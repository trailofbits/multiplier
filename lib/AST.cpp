// Copyright (c) 2022-present, Trail of Bits, Inc.
// All rights reserved.
//
// This source code is licensed in accordance with the terms specified in
// the LICENSE file found in the root directory of this source tree.

// Auto-generated file; do not modify!

#include <multiplier/AST.h>
#include <cassert>

#include "Attr.h"
#include "Decl.h"
#include "File.h"
#include "Fragment.h"
#include "Macro.h"
#include "Pseudo.h"
#include "Stmt.h"
#include "Type.h"

namespace mx {
const char *EnumeratorName(DeclKind e) {
  switch (e) {
    case DeclKind::ACCESS_SPEC: return "ACCESS_SPEC";
    case DeclKind::BINDING: return "BINDING";
    case DeclKind::BLOCK: return "BLOCK";
    case DeclKind::BUILTIN_TEMPLATE: return "BUILTIN_TEMPLATE";
    case DeclKind::CXX_CONSTRUCTOR: return "CXX_CONSTRUCTOR";
    case DeclKind::CXX_CONVERSION: return "CXX_CONVERSION";
    case DeclKind::CXX_DEDUCTION_GUIDE: return "CXX_DEDUCTION_GUIDE";
    case DeclKind::CXX_DESTRUCTOR: return "CXX_DESTRUCTOR";
    case DeclKind::CXX_METHOD: return "CXX_METHOD";
    case DeclKind::CXX_RECORD: return "CXX_RECORD";
    case DeclKind::CAPTURED: return "CAPTURED";
    case DeclKind::CLASS_SCOPE_FUNCTION_SPECIALIZATION: return "CLASS_SCOPE_FUNCTION_SPECIALIZATION";
    case DeclKind::CLASS_TEMPLATE: return "CLASS_TEMPLATE";
    case DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION: return "CLASS_TEMPLATE_PARTIAL_SPECIALIZATION";
    case DeclKind::CLASS_TEMPLATE_SPECIALIZATION: return "CLASS_TEMPLATE_SPECIALIZATION";
    case DeclKind::CONCEPT: return "CONCEPT";
    case DeclKind::CONSTRUCTOR_USING_SHADOW: return "CONSTRUCTOR_USING_SHADOW";
    case DeclKind::DECOMPOSITION: return "DECOMPOSITION";
    case DeclKind::EMPTY: return "EMPTY";
    case DeclKind::ENUM_CONSTANT: return "ENUM_CONSTANT";
    case DeclKind::ENUM: return "ENUM";
    case DeclKind::EXPORT: return "EXPORT";
    case DeclKind::EXTERN_C_CONTEXT: return "EXTERN_C_CONTEXT";
    case DeclKind::FIELD: return "FIELD";
    case DeclKind::FILE_SCOPE_ASM: return "FILE_SCOPE_ASM";
    case DeclKind::FRIEND: return "FRIEND";
    case DeclKind::FRIEND_TEMPLATE: return "FRIEND_TEMPLATE";
    case DeclKind::FUNCTION: return "FUNCTION";
    case DeclKind::FUNCTION_TEMPLATE: return "FUNCTION_TEMPLATE";
    case DeclKind::IMPLICIT_PARAM: return "IMPLICIT_PARAM";
    case DeclKind::IMPORT: return "IMPORT";
    case DeclKind::INDIRECT_FIELD: return "INDIRECT_FIELD";
    case DeclKind::LABEL: return "LABEL";
    case DeclKind::LIFETIME_EXTENDED_TEMPORARY: return "LIFETIME_EXTENDED_TEMPORARY";
    case DeclKind::LINKAGE_SPEC: return "LINKAGE_SPEC";
    case DeclKind::MS_GUID: return "MS_GUID";
    case DeclKind::MS_PROPERTY: return "MS_PROPERTY";
    case DeclKind::NAMESPACE_ALIAS: return "NAMESPACE_ALIAS";
    case DeclKind::NAMESPACE: return "NAMESPACE";
    case DeclKind::NON_TYPE_TEMPLATE_PARM: return "NON_TYPE_TEMPLATE_PARM";
    case DeclKind::OMP_ALLOCATE: return "OMP_ALLOCATE";
    case DeclKind::OMP_CAPTURED_EXPR: return "OMP_CAPTURED_EXPR";
    case DeclKind::OMP_DECLARE_MAPPER: return "OMP_DECLARE_MAPPER";
    case DeclKind::OMP_DECLARE_REDUCTION: return "OMP_DECLARE_REDUCTION";
    case DeclKind::OMP_REQUIRES: return "OMP_REQUIRES";
    case DeclKind::OMP_THREAD_PRIVATE: return "OMP_THREAD_PRIVATE";
    case DeclKind::OBJ_C_AT_DEFS_FIELD: return "OBJ_C_AT_DEFS_FIELD";
    case DeclKind::OBJ_C_CATEGORY: return "OBJ_C_CATEGORY";
    case DeclKind::OBJ_C_CATEGORY_IMPL: return "OBJ_C_CATEGORY_IMPL";
    case DeclKind::OBJ_C_COMPATIBLE_ALIAS: return "OBJ_C_COMPATIBLE_ALIAS";
    case DeclKind::OBJ_C_IMPLEMENTATION: return "OBJ_C_IMPLEMENTATION";
    case DeclKind::OBJ_C_INTERFACE: return "OBJ_C_INTERFACE";
    case DeclKind::OBJ_C_IVAR: return "OBJ_C_IVAR";
    case DeclKind::OBJ_C_METHOD: return "OBJ_C_METHOD";
    case DeclKind::OBJ_C_PROPERTY: return "OBJ_C_PROPERTY";
    case DeclKind::OBJ_C_PROPERTY_IMPL: return "OBJ_C_PROPERTY_IMPL";
    case DeclKind::OBJ_C_PROTOCOL: return "OBJ_C_PROTOCOL";
    case DeclKind::OBJ_C_TYPE_PARAM: return "OBJ_C_TYPE_PARAM";
    case DeclKind::PARM_VAR: return "PARM_VAR";
    case DeclKind::PRAGMA_COMMENT: return "PRAGMA_COMMENT";
    case DeclKind::PRAGMA_DETECT_MISMATCH: return "PRAGMA_DETECT_MISMATCH";
    case DeclKind::RECORD: return "RECORD";
    case DeclKind::REQUIRES_EXPR_BODY: return "REQUIRES_EXPR_BODY";
    case DeclKind::STATIC_ASSERT: return "STATIC_ASSERT";
    case DeclKind::TEMPLATE_PARAM_OBJECT: return "TEMPLATE_PARAM_OBJECT";
    case DeclKind::TEMPLATE_TEMPLATE_PARM: return "TEMPLATE_TEMPLATE_PARM";
    case DeclKind::TEMPLATE_TYPE_PARM: return "TEMPLATE_TYPE_PARM";
    case DeclKind::TRANSLATION_UNIT: return "TRANSLATION_UNIT";
    case DeclKind::TYPE_ALIAS: return "TYPE_ALIAS";
    case DeclKind::TYPE_ALIAS_TEMPLATE: return "TYPE_ALIAS_TEMPLATE";
    case DeclKind::TYPEDEF: return "TYPEDEF";
    case DeclKind::UNNAMED_GLOBAL_CONSTANT: return "UNNAMED_GLOBAL_CONSTANT";
    case DeclKind::UNRESOLVED_USING_IF_EXISTS: return "UNRESOLVED_USING_IF_EXISTS";
    case DeclKind::UNRESOLVED_USING_TYPENAME: return "UNRESOLVED_USING_TYPENAME";
    case DeclKind::UNRESOLVED_USING_VALUE: return "UNRESOLVED_USING_VALUE";
    case DeclKind::USING: return "USING";
    case DeclKind::USING_DIRECTIVE: return "USING_DIRECTIVE";
    case DeclKind::USING_ENUM: return "USING_ENUM";
    case DeclKind::USING_PACK: return "USING_PACK";
    case DeclKind::USING_SHADOW: return "USING_SHADOW";
    case DeclKind::VAR: return "VAR";
    case DeclKind::VAR_TEMPLATE: return "VAR_TEMPLATE";
    case DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION: return "VAR_TEMPLATE_PARTIAL_SPECIALIZATION";
    case DeclKind::VAR_TEMPLATE_SPECIALIZATION: return "VAR_TEMPLATE_SPECIALIZATION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AttrKind e) {
  switch (e) {
    case AttrKind::A_ARCH64_SVE_PCS: return "A_ARCH64_SVE_PCS";
    case AttrKind::A_ARCH64_VECTOR_PCS: return "A_ARCH64_VECTOR_PCS";
    case AttrKind::AMDGPU_FLAT_WORK_GROUP_SIZE: return "AMDGPU_FLAT_WORK_GROUP_SIZE";
    case AttrKind::AMDGPU_KERNEL_CALL: return "AMDGPU_KERNEL_CALL";
    case AttrKind::AMDGPU_NUM_SGPR: return "AMDGPU_NUM_SGPR";
    case AttrKind::AMDGPU_NUM_VGPR: return "AMDGPU_NUM_VGPR";
    case AttrKind::AMDGPU_WAVES_PER_EU: return "AMDGPU_WAVES_PER_EU";
    case AttrKind::ARM_INTERRUPT: return "ARM_INTERRUPT";
    case AttrKind::AVR_INTERRUPT: return "AVR_INTERRUPT";
    case AttrKind::AVR_SIGNAL: return "AVR_SIGNAL";
    case AttrKind::ABI_TAG: return "ABI_TAG";
    case AttrKind::ACQUIRE_CAPABILITY: return "ACQUIRE_CAPABILITY";
    case AttrKind::ACQUIRE_HANDLE: return "ACQUIRE_HANDLE";
    case AttrKind::ACQUIRED_AFTER: return "ACQUIRED_AFTER";
    case AttrKind::ACQUIRED_BEFORE: return "ACQUIRED_BEFORE";
    case AttrKind::ADDRESS_SPACE: return "ADDRESS_SPACE";
    case AttrKind::ALIAS: return "ALIAS";
    case AttrKind::ALIGN_MAC68K: return "ALIGN_MAC68K";
    case AttrKind::ALIGN_NATURAL: return "ALIGN_NATURAL";
    case AttrKind::ALIGN_VALUE: return "ALIGN_VALUE";
    case AttrKind::ALIGNED: return "ALIGNED";
    case AttrKind::ALLOC_ALIGN: return "ALLOC_ALIGN";
    case AttrKind::ALLOC_SIZE: return "ALLOC_SIZE";
    case AttrKind::ALWAYS_DESTROY: return "ALWAYS_DESTROY";
    case AttrKind::ALWAYS_INLINE: return "ALWAYS_INLINE";
    case AttrKind::ANALYZER_NO_RETURN: return "ANALYZER_NO_RETURN";
    case AttrKind::ANNOTATE: return "ANNOTATE";
    case AttrKind::ANNOTATE_TYPE: return "ANNOTATE_TYPE";
    case AttrKind::ANY_X86_INTERRUPT: return "ANY_X86_INTERRUPT";
    case AttrKind::ANY_X86_NO_CALLER_SAVED_REGISTERS: return "ANY_X86_NO_CALLER_SAVED_REGISTERS";
    case AttrKind::ANY_X86_NO_CF_CHECK: return "ANY_X86_NO_CF_CHECK";
    case AttrKind::ARC_WEAKREF_UNAVAILABLE: return "ARC_WEAKREF_UNAVAILABLE";
    case AttrKind::ARGUMENT_WITH_TYPE_TAG: return "ARGUMENT_WITH_TYPE_TAG";
    case AttrKind::ARM_BUILTIN_ALIAS: return "ARM_BUILTIN_ALIAS";
    case AttrKind::ARM_MVE_STRICT_POLYMORPHISM: return "ARM_MVE_STRICT_POLYMORPHISM";
    case AttrKind::ARTIFICIAL: return "ARTIFICIAL";
    case AttrKind::ASM_LABEL: return "ASM_LABEL";
    case AttrKind::ASSERT_CAPABILITY: return "ASSERT_CAPABILITY";
    case AttrKind::ASSERT_EXCLUSIVE_LOCK: return "ASSERT_EXCLUSIVE_LOCK";
    case AttrKind::ASSERT_SHARED_LOCK: return "ASSERT_SHARED_LOCK";
    case AttrKind::ASSUME_ALIGNED: return "ASSUME_ALIGNED";
    case AttrKind::ASSUMPTION: return "ASSUMPTION";
    case AttrKind::AVAILABILITY: return "AVAILABILITY";
    case AttrKind::BPF_PRESERVE_ACCESS_INDEX: return "BPF_PRESERVE_ACCESS_INDEX";
    case AttrKind::BTF_DECL_TAG: return "BTF_DECL_TAG";
    case AttrKind::BTF_TYPE_TAG: return "BTF_TYPE_TAG";
    case AttrKind::BLOCKS: return "BLOCKS";
    case AttrKind::BUILTIN_ALIAS: return "BUILTIN_ALIAS";
    case AttrKind::BUILTIN: return "BUILTIN";
    case AttrKind::C11_NO_RETURN: return "C11_NO_RETURN";
    case AttrKind::C_DECL: return "C_DECL";
    case AttrKind::CF_AUDITED_TRANSFER: return "CF_AUDITED_TRANSFER";
    case AttrKind::CF_CONSUMED: return "CF_CONSUMED";
    case AttrKind::CF_GUARD: return "CF_GUARD";
    case AttrKind::CFI_CANONICAL_JUMP_TABLE: return "CFI_CANONICAL_JUMP_TABLE";
    case AttrKind::CF_RETURNS_NOT_RETAINED: return "CF_RETURNS_NOT_RETAINED";
    case AttrKind::CF_RETURNS_RETAINED: return "CF_RETURNS_RETAINED";
    case AttrKind::CF_UNKNOWN_TRANSFER: return "CF_UNKNOWN_TRANSFER";
    case AttrKind::CPU_DISPATCH: return "CPU_DISPATCH";
    case AttrKind::CPU_SPECIFIC: return "CPU_SPECIFIC";
    case AttrKind::CUDA_CONSTANT: return "CUDA_CONSTANT";
    case AttrKind::CUDA_DEVICE: return "CUDA_DEVICE";
    case AttrKind::CUDA_DEVICE_BUILTIN_SURFACE_TYPE: return "CUDA_DEVICE_BUILTIN_SURFACE_TYPE";
    case AttrKind::CUDA_DEVICE_BUILTIN_TEXTURE_TYPE: return "CUDA_DEVICE_BUILTIN_TEXTURE_TYPE";
    case AttrKind::CUDA_GLOBAL: return "CUDA_GLOBAL";
    case AttrKind::CUDA_HOST: return "CUDA_HOST";
    case AttrKind::CUDA_INVALID_TARGET: return "CUDA_INVALID_TARGET";
    case AttrKind::CUDA_LAUNCH_BOUNDS: return "CUDA_LAUNCH_BOUNDS";
    case AttrKind::CUDA_SHARED: return "CUDA_SHARED";
    case AttrKind::CXX11_NO_RETURN: return "CXX11_NO_RETURN";
    case AttrKind::CALLABLE_WHEN: return "CALLABLE_WHEN";
    case AttrKind::CALLBACK: return "CALLBACK";
    case AttrKind::CALLED_ONCE: return "CALLED_ONCE";
    case AttrKind::CAPABILITY: return "CAPABILITY";
    case AttrKind::CAPTURED_RECORD: return "CAPTURED_RECORD";
    case AttrKind::CARRIES_DEPENDENCY: return "CARRIES_DEPENDENCY";
    case AttrKind::CLEANUP: return "CLEANUP";
    case AttrKind::CMSE_NS_CALL: return "CMSE_NS_CALL";
    case AttrKind::CMSE_NS_ENTRY: return "CMSE_NS_ENTRY";
    case AttrKind::CODE_SEG: return "CODE_SEG";
    case AttrKind::COLD: return "COLD";
    case AttrKind::COMMON: return "COMMON";
    case AttrKind::CONST: return "CONST";
    case AttrKind::CONST_INIT: return "CONST_INIT";
    case AttrKind::CONSTRUCTOR: return "CONSTRUCTOR";
    case AttrKind::CONSUMABLE: return "CONSUMABLE";
    case AttrKind::CONSUMABLE_AUTO_CAST: return "CONSUMABLE_AUTO_CAST";
    case AttrKind::CONSUMABLE_SET_ON_READ: return "CONSUMABLE_SET_ON_READ";
    case AttrKind::CONVERGENT: return "CONVERGENT";
    case AttrKind::DLL_EXPORT: return "DLL_EXPORT";
    case AttrKind::DLL_EXPORT_STATIC_LOCAL: return "DLL_EXPORT_STATIC_LOCAL";
    case AttrKind::DLL_IMPORT: return "DLL_IMPORT";
    case AttrKind::DLL_IMPORT_STATIC_LOCAL: return "DLL_IMPORT_STATIC_LOCAL";
    case AttrKind::DEPRECATED: return "DEPRECATED";
    case AttrKind::DESTRUCTOR: return "DESTRUCTOR";
    case AttrKind::DIAGNOSE_AS_BUILTIN: return "DIAGNOSE_AS_BUILTIN";
    case AttrKind::DIAGNOSE_IF: return "DIAGNOSE_IF";
    case AttrKind::DISABLE_SANITIZER_INSTRUMENTATION: return "DISABLE_SANITIZER_INSTRUMENTATION";
    case AttrKind::DISABLE_TAIL_CALLS: return "DISABLE_TAIL_CALLS";
    case AttrKind::EMPTY_BASES: return "EMPTY_BASES";
    case AttrKind::ENABLE_IF: return "ENABLE_IF";
    case AttrKind::ENFORCE_TCB: return "ENFORCE_TCB";
    case AttrKind::ENFORCE_TCB_LEAF: return "ENFORCE_TCB_LEAF";
    case AttrKind::ENUM_EXTENSIBILITY: return "ENUM_EXTENSIBILITY";
    case AttrKind::ERROR: return "ERROR";
    case AttrKind::EXCLUDE_FROM_EXPLICIT_INSTANTIATION: return "EXCLUDE_FROM_EXPLICIT_INSTANTIATION";
    case AttrKind::EXCLUSIVE_TRYLOCK_FUNCTION: return "EXCLUSIVE_TRYLOCK_FUNCTION";
    case AttrKind::EXTERNAL_SOURCE_SYMBOL: return "EXTERNAL_SOURCE_SYMBOL";
    case AttrKind::FALL_THROUGH: return "FALL_THROUGH";
    case AttrKind::FAST_CALL: return "FAST_CALL";
    case AttrKind::FINAL: return "FINAL";
    case AttrKind::FLAG_ENUM: return "FLAG_ENUM";
    case AttrKind::FLATTEN: return "FLATTEN";
    case AttrKind::FORMAT_ARG: return "FORMAT_ARG";
    case AttrKind::FORMAT: return "FORMAT";
    case AttrKind::FUNCTION_RETURN_THUNKS: return "FUNCTION_RETURN_THUNKS";
    case AttrKind::GNU_INLINE: return "GNU_INLINE";
    case AttrKind::GUARDED_BY: return "GUARDED_BY";
    case AttrKind::GUARDED_VAR: return "GUARDED_VAR";
    case AttrKind::HIP_MANAGED: return "HIP_MANAGED";
    case AttrKind::HLSL_NUM_THREADS: return "HLSL_NUM_THREADS";
    case AttrKind::HLSLSV__GROUP_INDEX: return "HLSLSV__GROUP_INDEX";
    case AttrKind::HLSL_SHADER: return "HLSL_SHADER";
    case AttrKind::HOT: return "HOT";
    case AttrKind::IB_ACTION: return "IB_ACTION";
    case AttrKind::IB_OUTLET: return "IB_OUTLET";
    case AttrKind::IB_OUTLET_COLLECTION: return "IB_OUTLET_COLLECTION";
    case AttrKind::I_FUNC: return "I_FUNC";
    case AttrKind::INIT_PRIORITY: return "INIT_PRIORITY";
    case AttrKind::INIT_SEG: return "INIT_SEG";
    case AttrKind::INTEL_OCL_BICC: return "INTEL_OCL_BICC";
    case AttrKind::INTERNAL_LINKAGE: return "INTERNAL_LINKAGE";
    case AttrKind::LTO_VISIBILITY_PUBLIC: return "LTO_VISIBILITY_PUBLIC";
    case AttrKind::LAYOUT_VERSION: return "LAYOUT_VERSION";
    case AttrKind::LEAF: return "LEAF";
    case AttrKind::LIFETIME_BOUND: return "LIFETIME_BOUND";
    case AttrKind::LIKELY: return "LIKELY";
    case AttrKind::LOADER_UNINITIALIZED: return "LOADER_UNINITIALIZED";
    case AttrKind::LOCK_RETURNED: return "LOCK_RETURNED";
    case AttrKind::LOCKS_EXCLUDED: return "LOCKS_EXCLUDED";
    case AttrKind::LOOP_HINT: return "LOOP_HINT";
    case AttrKind::M68K_INTERRUPT: return "M68K_INTERRUPT";
    case AttrKind::MIG_SERVER_ROUTINE_: return "MIG_SERVER_ROUTINE_";
    case AttrKind::MSABI: return "MSABI";
    case AttrKind::MS_ALLOCATOR: return "MS_ALLOCATOR";
    case AttrKind::MS_INHERITANCE: return "MS_INHERITANCE";
    case AttrKind::MS_NO_V_TABLE: return "MS_NO_V_TABLE";
    case AttrKind::MSP430_INTERRUPT: return "MSP430_INTERRUPT";
    case AttrKind::MS_STRUCT: return "MS_STRUCT";
    case AttrKind::MS_VTOR_DISP: return "MS_VTOR_DISP";
    case AttrKind::MAX_FIELD_ALIGNMENT: return "MAX_FIELD_ALIGNMENT";
    case AttrKind::MAY_ALIAS: return "MAY_ALIAS";
    case AttrKind::MICRO_MIPS: return "MICRO_MIPS";
    case AttrKind::MIN_SIZE: return "MIN_SIZE";
    case AttrKind::MIN_VECTOR_WIDTH: return "MIN_VECTOR_WIDTH";
    case AttrKind::MIPS16: return "MIPS16";
    case AttrKind::MIPS_INTERRUPT: return "MIPS_INTERRUPT";
    case AttrKind::MIPS_LONG_CALL: return "MIPS_LONG_CALL";
    case AttrKind::MIPS_SHORT_CALL: return "MIPS_SHORT_CALL";
    case AttrKind::MODE: return "MODE";
    case AttrKind::MUST_TAIL: return "MUST_TAIL";
    case AttrKind::NS_CONSUMED: return "NS_CONSUMED";
    case AttrKind::NS_CONSUMES_SELF: return "NS_CONSUMES_SELF";
    case AttrKind::NS_ERROR_DOMAIN: return "NS_ERROR_DOMAIN";
    case AttrKind::NS_RETURNS_AUTORELEASED: return "NS_RETURNS_AUTORELEASED";
    case AttrKind::NS_RETURNS_NOT_RETAINED: return "NS_RETURNS_NOT_RETAINED";
    case AttrKind::NS_RETURNS_RETAINED: return "NS_RETURNS_RETAINED";
    case AttrKind::NAKED: return "NAKED";
    case AttrKind::NO_ALIAS: return "NO_ALIAS";
    case AttrKind::NO_BUILTIN: return "NO_BUILTIN";
    case AttrKind::NO_COMMON: return "NO_COMMON";
    case AttrKind::NO_DEBUG: return "NO_DEBUG";
    case AttrKind::NO_DEREF: return "NO_DEREF";
    case AttrKind::NO_DESTROY: return "NO_DESTROY";
    case AttrKind::NO_DUPLICATE: return "NO_DUPLICATE";
    case AttrKind::NO_ESCAPE: return "NO_ESCAPE";
    case AttrKind::NO_INLINE: return "NO_INLINE";
    case AttrKind::NO_INSTRUMENT_FUNCTION: return "NO_INSTRUMENT_FUNCTION";
    case AttrKind::NO_MERGE: return "NO_MERGE";
    case AttrKind::NO_MICRO_MIPS: return "NO_MICRO_MIPS";
    case AttrKind::NO_MIPS16: return "NO_MIPS16";
    case AttrKind::NO_PROFILE_FUNCTION: return "NO_PROFILE_FUNCTION";
    case AttrKind::NO_RANDOMIZE_LAYOUT: return "NO_RANDOMIZE_LAYOUT";
    case AttrKind::NO_RETURN: return "NO_RETURN";
    case AttrKind::NO_SANITIZE: return "NO_SANITIZE";
    case AttrKind::NO_SPECULATIVE_LOAD_HARDENING: return "NO_SPECULATIVE_LOAD_HARDENING";
    case AttrKind::NO_SPLIT_STACK: return "NO_SPLIT_STACK";
    case AttrKind::NO_STACK_PROTECTOR: return "NO_STACK_PROTECTOR";
    case AttrKind::NO_THREAD_SAFETY_ANALYSIS: return "NO_THREAD_SAFETY_ANALYSIS";
    case AttrKind::NO_THROW: return "NO_THROW";
    case AttrKind::NO_UNIQUE_ADDRESS: return "NO_UNIQUE_ADDRESS";
    case AttrKind::NON_NULL: return "NON_NULL";
    case AttrKind::NOT_TAIL_CALLED: return "NOT_TAIL_CALLED";
    case AttrKind::OMP_ALLOCATE_DECL: return "OMP_ALLOCATE_DECL";
    case AttrKind::OMP_CAPTURE_KIND: return "OMP_CAPTURE_KIND";
    case AttrKind::OMP_CAPTURE_NO_INIT: return "OMP_CAPTURE_NO_INIT";
    case AttrKind::OMP_DECLARE_SIMD_DECL: return "OMP_DECLARE_SIMD_DECL";
    case AttrKind::OMP_DECLARE_TARGET_DECL: return "OMP_DECLARE_TARGET_DECL";
    case AttrKind::OMP_DECLARE_VARIANT: return "OMP_DECLARE_VARIANT";
    case AttrKind::OMP_REFERENCED_VAR: return "OMP_REFERENCED_VAR";
    case AttrKind::OMP_THREAD_PRIVATE_DECL: return "OMP_THREAD_PRIVATE_DECL";
    case AttrKind::OS_CONSUMED: return "OS_CONSUMED";
    case AttrKind::OS_CONSUMES_THIS: return "OS_CONSUMES_THIS";
    case AttrKind::OS_RETURNS_NOT_RETAINED: return "OS_RETURNS_NOT_RETAINED";
    case AttrKind::OS_RETURNS_RETAINED: return "OS_RETURNS_RETAINED";
    case AttrKind::OS_RETURNS_RETAINED_ON_NON_ZERO: return "OS_RETURNS_RETAINED_ON_NON_ZERO";
    case AttrKind::OS_RETURNS_RETAINED_ON_ZERO: return "OS_RETURNS_RETAINED_ON_ZERO";
    case AttrKind::OBJ_C_BOXABLE: return "OBJ_C_BOXABLE";
    case AttrKind::OBJ_C_BRIDGE: return "OBJ_C_BRIDGE";
    case AttrKind::OBJ_C_BRIDGE_MUTABLE: return "OBJ_C_BRIDGE_MUTABLE";
    case AttrKind::OBJ_C_BRIDGE_RELATED: return "OBJ_C_BRIDGE_RELATED";
    case AttrKind::OBJ_C_CLASS_STUB: return "OBJ_C_CLASS_STUB";
    case AttrKind::OBJ_C_DESIGNATED_INITIALIZER: return "OBJ_C_DESIGNATED_INITIALIZER";
    case AttrKind::OBJ_C_DIRECT: return "OBJ_C_DIRECT";
    case AttrKind::OBJ_C_DIRECT_MEMBERS: return "OBJ_C_DIRECT_MEMBERS";
    case AttrKind::OBJ_C_EXCEPTION: return "OBJ_C_EXCEPTION";
    case AttrKind::OBJ_C_EXPLICIT_PROTOCOL_IMPL: return "OBJ_C_EXPLICIT_PROTOCOL_IMPL";
    case AttrKind::OBJ_C_EXTERNALLY_RETAINED: return "OBJ_C_EXTERNALLY_RETAINED";
    case AttrKind::OBJ_CGC: return "OBJ_CGC";
    case AttrKind::OBJ_C_INDEPENDENT_CLASS: return "OBJ_C_INDEPENDENT_CLASS";
    case AttrKind::OBJ_C_INERT_UNSAFE_UNRETAINED: return "OBJ_C_INERT_UNSAFE_UNRETAINED";
    case AttrKind::OBJ_C_KIND_OF: return "OBJ_C_KIND_OF";
    case AttrKind::OBJ_C_METHOD_FAMILY: return "OBJ_C_METHOD_FAMILY";
    case AttrKind::OBJ_CNS_OBJECT: return "OBJ_CNS_OBJECT";
    case AttrKind::OBJ_C_NON_LAZY_CLASS: return "OBJ_C_NON_LAZY_CLASS";
    case AttrKind::OBJ_C_NON_RUNTIME_PROTOCOL: return "OBJ_C_NON_RUNTIME_PROTOCOL";
    case AttrKind::OBJ_C_OWNERSHIP: return "OBJ_C_OWNERSHIP";
    case AttrKind::OBJ_C_PRECISE_LIFETIME: return "OBJ_C_PRECISE_LIFETIME";
    case AttrKind::OBJ_C_REQUIRES_PROPERTY_DEFS: return "OBJ_C_REQUIRES_PROPERTY_DEFS";
    case AttrKind::OBJ_C_REQUIRES_SUPER: return "OBJ_C_REQUIRES_SUPER";
    case AttrKind::OBJ_C_RETURNS_INNER_POINTER: return "OBJ_C_RETURNS_INNER_POINTER";
    case AttrKind::OBJ_C_ROOT_CLASS: return "OBJ_C_ROOT_CLASS";
    case AttrKind::OBJ_C_RUNTIME_NAME: return "OBJ_C_RUNTIME_NAME";
    case AttrKind::OBJ_C_RUNTIME_VISIBLE: return "OBJ_C_RUNTIME_VISIBLE";
    case AttrKind::OBJ_C_SUBCLASSING_RESTRICTED: return "OBJ_C_SUBCLASSING_RESTRICTED";
    case AttrKind::OPEN_CL_ACCESS: return "OPEN_CL_ACCESS";
    case AttrKind::OPEN_CL_CONSTANT_ADDRESS_SPACE: return "OPEN_CL_CONSTANT_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_GENERIC_ADDRESS_SPACE: return "OPEN_CL_GENERIC_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_GLOBAL_ADDRESS_SPACE: return "OPEN_CL_GLOBAL_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE: return "OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE: return "OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE: return "OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE";
    case AttrKind::OPEN_CL_KERNEL: return "OPEN_CL_KERNEL";
    case AttrKind::OPEN_CL_LOCAL_ADDRESS_SPACE: return "OPEN_CL_LOCAL_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_PRIVATE_ADDRESS_SPACE: return "OPEN_CL_PRIVATE_ADDRESS_SPACE";
    case AttrKind::OPEN_CL_UNROLL_HINT: return "OPEN_CL_UNROLL_HINT";
    case AttrKind::OPTIMIZE_NONE: return "OPTIMIZE_NONE";
    case AttrKind::OVERLOADABLE: return "OVERLOADABLE";
    case AttrKind::OVERRIDE: return "OVERRIDE";
    case AttrKind::OWNER: return "OWNER";
    case AttrKind::OWNERSHIP: return "OWNERSHIP";
    case AttrKind::PACKED: return "PACKED";
    case AttrKind::PARAM_TYPESTATE: return "PARAM_TYPESTATE";
    case AttrKind::PASCAL: return "PASCAL";
    case AttrKind::PASS_OBJECT_SIZE: return "PASS_OBJECT_SIZE";
    case AttrKind::PATCHABLE_FUNCTION_ENTRY: return "PATCHABLE_FUNCTION_ENTRY";
    case AttrKind::PCS: return "PCS";
    case AttrKind::POINTER: return "POINTER";
    case AttrKind::PRAGMA_CLANG_BSS_SECTION: return "PRAGMA_CLANG_BSS_SECTION";
    case AttrKind::PRAGMA_CLANG_DATA_SECTION: return "PRAGMA_CLANG_DATA_SECTION";
    case AttrKind::PRAGMA_CLANG_RELRO_SECTION: return "PRAGMA_CLANG_RELRO_SECTION";
    case AttrKind::PRAGMA_CLANG_RODATA_SECTION: return "PRAGMA_CLANG_RODATA_SECTION";
    case AttrKind::PRAGMA_CLANG_TEXT_SECTION: return "PRAGMA_CLANG_TEXT_SECTION";
    case AttrKind::PREFERRED_NAME: return "PREFERRED_NAME";
    case AttrKind::PRESERVE_ALL: return "PRESERVE_ALL";
    case AttrKind::PRESERVE_MOST: return "PRESERVE_MOST";
    case AttrKind::PT_GUARDED_BY: return "PT_GUARDED_BY";
    case AttrKind::PT_GUARDED_VAR: return "PT_GUARDED_VAR";
    case AttrKind::PTR32: return "PTR32";
    case AttrKind::PTR64: return "PTR64";
    case AttrKind::PURE: return "PURE";
    case AttrKind::RISCV_INTERRUPT: return "RISCV_INTERRUPT";
    case AttrKind::RANDOMIZE_LAYOUT: return "RANDOMIZE_LAYOUT";
    case AttrKind::REG_CALL: return "REG_CALL";
    case AttrKind::REINITIALIZES: return "REINITIALIZES";
    case AttrKind::RELEASE_CAPABILITY: return "RELEASE_CAPABILITY";
    case AttrKind::RELEASE_HANDLE: return "RELEASE_HANDLE";
    case AttrKind::RENDER_SCRIPT_KERNEL: return "RENDER_SCRIPT_KERNEL";
    case AttrKind::REQD_WORK_GROUP_SIZE: return "REQD_WORK_GROUP_SIZE";
    case AttrKind::REQUIRES_CAPABILITY: return "REQUIRES_CAPABILITY";
    case AttrKind::RESTRICT: return "RESTRICT";
    case AttrKind::RETAIN: return "RETAIN";
    case AttrKind::RETURN_TYPESTATE: return "RETURN_TYPESTATE";
    case AttrKind::RETURNS_NON_NULL: return "RETURNS_NON_NULL";
    case AttrKind::RETURNS_TWICE: return "RETURNS_TWICE";
    case AttrKind::S_PTR: return "S_PTR";
    case AttrKind::SYCL_KERNEL: return "SYCL_KERNEL";
    case AttrKind::SYCL_SPECIAL_CLASS: return "SYCL_SPECIAL_CLASS";
    case AttrKind::SCOPED_LOCKABLE: return "SCOPED_LOCKABLE";
    case AttrKind::SECTION: return "SECTION";
    case AttrKind::SELECT_ANY: return "SELECT_ANY";
    case AttrKind::SENTINEL: return "SENTINEL";
    case AttrKind::SET_TYPESTATE: return "SET_TYPESTATE";
    case AttrKind::SHARED_TRYLOCK_FUNCTION: return "SHARED_TRYLOCK_FUNCTION";
    case AttrKind::SPECULATIVE_LOAD_HARDENING: return "SPECULATIVE_LOAD_HARDENING";
    case AttrKind::STANDALONE_DEBUG: return "STANDALONE_DEBUG";
    case AttrKind::STD_CALL: return "STD_CALL";
    case AttrKind::STRICT_FP: return "STRICT_FP";
    case AttrKind::SUPPRESS: return "SUPPRESS";
    case AttrKind::SWIFT_ASYNC: return "SWIFT_ASYNC";
    case AttrKind::SWIFT_ASYNC_CALL: return "SWIFT_ASYNC_CALL";
    case AttrKind::SWIFT_ASYNC_CONTEXT: return "SWIFT_ASYNC_CONTEXT";
    case AttrKind::SWIFT_ASYNC_ERROR: return "SWIFT_ASYNC_ERROR";
    case AttrKind::SWIFT_ASYNC_NAME: return "SWIFT_ASYNC_NAME";
    case AttrKind::SWIFT_ATTR: return "SWIFT_ATTR";
    case AttrKind::SWIFT_BRIDGE: return "SWIFT_BRIDGE";
    case AttrKind::SWIFT_BRIDGED_TYPEDEF: return "SWIFT_BRIDGED_TYPEDEF";
    case AttrKind::SWIFT_CALL: return "SWIFT_CALL";
    case AttrKind::SWIFT_CONTEXT: return "SWIFT_CONTEXT";
    case AttrKind::SWIFT_ERROR: return "SWIFT_ERROR";
    case AttrKind::SWIFT_ERROR_RESULT: return "SWIFT_ERROR_RESULT";
    case AttrKind::SWIFT_INDIRECT_RESULT: return "SWIFT_INDIRECT_RESULT";
    case AttrKind::SWIFT_NAME: return "SWIFT_NAME";
    case AttrKind::SWIFT_NEW_TYPE: return "SWIFT_NEW_TYPE";
    case AttrKind::SWIFT_OBJ_C_MEMBERS: return "SWIFT_OBJ_C_MEMBERS";
    case AttrKind::SWIFT_PRIVATE: return "SWIFT_PRIVATE";
    case AttrKind::SYS_VABI: return "SYS_VABI";
    case AttrKind::TLS_MODEL: return "TLS_MODEL";
    case AttrKind::TARGET: return "TARGET";
    case AttrKind::TARGET_CLONES: return "TARGET_CLONES";
    case AttrKind::TEST_TYPESTATE: return "TEST_TYPESTATE";
    case AttrKind::THIS_CALL: return "THIS_CALL";
    case AttrKind::THREAD: return "THREAD";
    case AttrKind::TRANSPARENT_UNION: return "TRANSPARENT_UNION";
    case AttrKind::TRIVIAL_ABI: return "TRIVIAL_ABI";
    case AttrKind::TRY_ACQUIRE_CAPABILITY: return "TRY_ACQUIRE_CAPABILITY";
    case AttrKind::TYPE_NON_NULL: return "TYPE_NON_NULL";
    case AttrKind::TYPE_NULL_UNSPECIFIED: return "TYPE_NULL_UNSPECIFIED";
    case AttrKind::TYPE_NULLABLE: return "TYPE_NULLABLE";
    case AttrKind::TYPE_NULLABLE_RESULT: return "TYPE_NULLABLE_RESULT";
    case AttrKind::TYPE_TAG_FOR_DATATYPE: return "TYPE_TAG_FOR_DATATYPE";
    case AttrKind::TYPE_VISIBILITY: return "TYPE_VISIBILITY";
    case AttrKind::U_PTR: return "U_PTR";
    case AttrKind::UNAVAILABLE: return "UNAVAILABLE";
    case AttrKind::UNINITIALIZED: return "UNINITIALIZED";
    case AttrKind::UNLIKELY: return "UNLIKELY";
    case AttrKind::UNUSED: return "UNUSED";
    case AttrKind::USE_HANDLE: return "USE_HANDLE";
    case AttrKind::USED: return "USED";
    case AttrKind::USING_IF_EXISTS: return "USING_IF_EXISTS";
    case AttrKind::UUID: return "UUID";
    case AttrKind::VEC_RETURN: return "VEC_RETURN";
    case AttrKind::VEC_TYPE_HINT: return "VEC_TYPE_HINT";
    case AttrKind::VECTOR_CALL: return "VECTOR_CALL";
    case AttrKind::VISIBILITY: return "VISIBILITY";
    case AttrKind::WARN_UNUSED: return "WARN_UNUSED";
    case AttrKind::WARN_UNUSED_RESULT: return "WARN_UNUSED_RESULT";
    case AttrKind::WEAK: return "WEAK";
    case AttrKind::WEAK_IMPORT: return "WEAK_IMPORT";
    case AttrKind::WEAK_REF: return "WEAK_REF";
    case AttrKind::WEB_ASSEMBLY_EXPORT_NAME: return "WEB_ASSEMBLY_EXPORT_NAME";
    case AttrKind::WEB_ASSEMBLY_IMPORT_MODULE: return "WEB_ASSEMBLY_IMPORT_MODULE";
    case AttrKind::WEB_ASSEMBLY_IMPORT_NAME: return "WEB_ASSEMBLY_IMPORT_NAME";
    case AttrKind::WORK_GROUP_SIZE_HINT: return "WORK_GROUP_SIZE_HINT";
    case AttrKind::X86_FORCE_ALIGN_ARG_POINTER: return "X86_FORCE_ALIGN_ARG_POINTER";
    case AttrKind::X_RAY_INSTRUMENT: return "X_RAY_INSTRUMENT";
    case AttrKind::X_RAY_LOG_ARGS: return "X_RAY_LOG_ARGS";
    case AttrKind::ZERO_CALL_USED_REGS: return "ZERO_CALL_USED_REGS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AArch64SVEPcsAttrSpelling e) {
  switch (e) {
    case AArch64SVEPcsAttrSpelling::GNU_AARCH64_SVE_PCS: return "GNU_AARCH64_SVE_PCS";
    case AArch64SVEPcsAttrSpelling::CXX11_CLANG_AARCH64_SVE_PCS: return "CXX11_CLANG_AARCH64_SVE_PCS";
    case AArch64SVEPcsAttrSpelling::C2X_CLANG_AARCH64_SVE_PCS: return "C2X_CLANG_AARCH64_SVE_PCS";
    case AArch64SVEPcsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AArch64VectorPcsAttrSpelling e) {
  switch (e) {
    case AArch64VectorPcsAttrSpelling::GNU_AARCH64_VECTOR_PCS: return "GNU_AARCH64_VECTOR_PCS";
    case AArch64VectorPcsAttrSpelling::CXX11_CLANG_AARCH64_VECTOR_PCS: return "CXX11_CLANG_AARCH64_VECTOR_PCS";
    case AArch64VectorPcsAttrSpelling::C2X_CLANG_AARCH64_VECTOR_PCS: return "C2X_CLANG_AARCH64_VECTOR_PCS";
    case AArch64VectorPcsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AMDGPUFlatWorkGroupSizeAttrSpelling e) {
  switch (e) {
    case AMDGPUFlatWorkGroupSizeAttrSpelling::GNU_AMDGPU_FLAT_WORK_GROUP_SIZE: return "GNU_AMDGPU_FLAT_WORK_GROUP_SIZE";
    case AMDGPUFlatWorkGroupSizeAttrSpelling::CXX11_CLANG_AMDGPU_FLAT_WORK_GROUP_SIZE: return "CXX11_CLANG_AMDGPU_FLAT_WORK_GROUP_SIZE";
    case AMDGPUFlatWorkGroupSizeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AMDGPUKernelCallAttrSpelling e) {
  switch (e) {
    case AMDGPUKernelCallAttrSpelling::GNU_AMDGPU_KERNEL: return "GNU_AMDGPU_KERNEL";
    case AMDGPUKernelCallAttrSpelling::CXX11_CLANG_AMDGPU_KERNEL: return "CXX11_CLANG_AMDGPU_KERNEL";
    case AMDGPUKernelCallAttrSpelling::C2X_CLANG_AMDGPU_KERNEL: return "C2X_CLANG_AMDGPU_KERNEL";
    case AMDGPUKernelCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AMDGPUNumSGPRAttrSpelling e) {
  switch (e) {
    case AMDGPUNumSGPRAttrSpelling::GNU_AMDGPU_NUM_SGPR: return "GNU_AMDGPU_NUM_SGPR";
    case AMDGPUNumSGPRAttrSpelling::CXX11_CLANG_AMDGPU_NUM_SGPR: return "CXX11_CLANG_AMDGPU_NUM_SGPR";
    case AMDGPUNumSGPRAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AMDGPUNumVGPRAttrSpelling e) {
  switch (e) {
    case AMDGPUNumVGPRAttrSpelling::GNU_AMDGPU_NUM_VGPR: return "GNU_AMDGPU_NUM_VGPR";
    case AMDGPUNumVGPRAttrSpelling::CXX11_CLANG_AMDGPU_NUM_VGPR: return "CXX11_CLANG_AMDGPU_NUM_VGPR";
    case AMDGPUNumVGPRAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AMDGPUWavesPerEUAttrSpelling e) {
  switch (e) {
    case AMDGPUWavesPerEUAttrSpelling::GNU_AMDGPU_WAVES_PER_EU: return "GNU_AMDGPU_WAVES_PER_EU";
    case AMDGPUWavesPerEUAttrSpelling::CXX11_CLANG_AMDGPU_WAVES_PER_EU: return "CXX11_CLANG_AMDGPU_WAVES_PER_EU";
    case AMDGPUWavesPerEUAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ARMInterruptAttrInterruptType e) {
  switch (e) {
    case ARMInterruptAttrInterruptType::IRQ: return "IRQ";
    case ARMInterruptAttrInterruptType::FIQ: return "FIQ";
    case ARMInterruptAttrInterruptType::SWI: return "SWI";
    case ARMInterruptAttrInterruptType::ABORT: return "ABORT";
    case ARMInterruptAttrInterruptType::UNDEF: return "UNDEF";
    case ARMInterruptAttrInterruptType::GENERIC: return "GENERIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ARMInterruptAttrSpelling e) {
  switch (e) {
    case ARMInterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case ARMInterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case ARMInterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case ARMInterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AVRInterruptAttrSpelling e) {
  switch (e) {
    case AVRInterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case AVRInterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case AVRInterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case AVRInterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AVRSignalAttrSpelling e) {
  switch (e) {
    case AVRSignalAttrSpelling::GNU_SIGNAL: return "GNU_SIGNAL";
    case AVRSignalAttrSpelling::CXX11_GNU_SIGNAL: return "CXX11_GNU_SIGNAL";
    case AVRSignalAttrSpelling::C2X_GNU_SIGNAL: return "C2X_GNU_SIGNAL";
    case AVRSignalAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AbiTagAttrSpelling e) {
  switch (e) {
    case AbiTagAttrSpelling::GNU_ABI_TAG: return "GNU_ABI_TAG";
    case AbiTagAttrSpelling::CXX11_GNU_ABI_TAG: return "CXX11_GNU_ABI_TAG";
    case AbiTagAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AcquireCapabilityAttrSpelling e) {
  switch (e) {
    case AcquireCapabilityAttrSpelling::GNU_ACQUIRE_CAPABILITY: return "GNU_ACQUIRE_CAPABILITY";
    case AcquireCapabilityAttrSpelling::CXX11_CLANG_ACQUIRE_CAPABILITY: return "CXX11_CLANG_ACQUIRE_CAPABILITY";
    case AcquireCapabilityAttrSpelling::GNU_ACQUIRE_SHARED_CAPABILITY: return "GNU_ACQUIRE_SHARED_CAPABILITY";
    case AcquireCapabilityAttrSpelling::CXX11_CLANG_ACQUIRE_SHARED_CAPABILITY: return "CXX11_CLANG_ACQUIRE_SHARED_CAPABILITY";
    case AcquireCapabilityAttrSpelling::GNU_EXCLUSIVE_LOCK_FUNCTION: return "GNU_EXCLUSIVE_LOCK_FUNCTION";
    case AcquireCapabilityAttrSpelling::GNU_SHARED_LOCK_FUNCTION: return "GNU_SHARED_LOCK_FUNCTION";
    case AcquireCapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AcquireHandleAttrSpelling e) {
  switch (e) {
    case AcquireHandleAttrSpelling::GNU_ACQUIRE_HANDLE: return "GNU_ACQUIRE_HANDLE";
    case AcquireHandleAttrSpelling::CXX11_CLANG_ACQUIRE_HANDLE: return "CXX11_CLANG_ACQUIRE_HANDLE";
    case AcquireHandleAttrSpelling::C2X_CLANG_ACQUIRE_HANDLE: return "C2X_CLANG_ACQUIRE_HANDLE";
    case AcquireHandleAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AddressSpaceAttrSpelling e) {
  switch (e) {
    case AddressSpaceAttrSpelling::GNU_ADDRESS_SPACE: return "GNU_ADDRESS_SPACE";
    case AddressSpaceAttrSpelling::CXX11_CLANG_ADDRESS_SPACE: return "CXX11_CLANG_ADDRESS_SPACE";
    case AddressSpaceAttrSpelling::C2X_CLANG_ADDRESS_SPACE: return "C2X_CLANG_ADDRESS_SPACE";
    case AddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AliasAttrSpelling e) {
  switch (e) {
    case AliasAttrSpelling::GNU_ALIAS: return "GNU_ALIAS";
    case AliasAttrSpelling::CXX11_GNU_ALIAS: return "CXX11_GNU_ALIAS";
    case AliasAttrSpelling::C2X_GNU_ALIAS: return "C2X_GNU_ALIAS";
    case AliasAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AlignedAttrSpelling e) {
  switch (e) {
    case AlignedAttrSpelling::GNU_ALIGNED: return "GNU_ALIGNED";
    case AlignedAttrSpelling::CXX11_GNU_ALIGNED: return "CXX11_GNU_ALIGNED";
    case AlignedAttrSpelling::C2X_GNU_ALIGNED: return "C2X_GNU_ALIGNED";
    case AlignedAttrSpelling::DECLSPEC_ALIGN: return "DECLSPEC_ALIGN";
    case AlignedAttrSpelling::KEYWORD_ALIGNAS: return "KEYWORD_ALIGNAS";
    case AlignedAttrSpelling::KEYWORD__ALIGNAS: return "KEYWORD__ALIGNAS";
    case AlignedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AllocAlignAttrSpelling e) {
  switch (e) {
    case AllocAlignAttrSpelling::GNU_ALLOC_ALIGN: return "GNU_ALLOC_ALIGN";
    case AllocAlignAttrSpelling::CXX11_GNU_ALLOC_ALIGN: return "CXX11_GNU_ALLOC_ALIGN";
    case AllocAlignAttrSpelling::C2X_GNU_ALLOC_ALIGN: return "C2X_GNU_ALLOC_ALIGN";
    case AllocAlignAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AllocSizeAttrSpelling e) {
  switch (e) {
    case AllocSizeAttrSpelling::GNU_ALLOC_SIZE: return "GNU_ALLOC_SIZE";
    case AllocSizeAttrSpelling::CXX11_GNU_ALLOC_SIZE: return "CXX11_GNU_ALLOC_SIZE";
    case AllocSizeAttrSpelling::C2X_GNU_ALLOC_SIZE: return "C2X_GNU_ALLOC_SIZE";
    case AllocSizeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AlwaysDestroyAttrSpelling e) {
  switch (e) {
    case AlwaysDestroyAttrSpelling::GNU_ALWAYS_DESTROY: return "GNU_ALWAYS_DESTROY";
    case AlwaysDestroyAttrSpelling::CXX11_CLANG_ALWAYS_DESTROY: return "CXX11_CLANG_ALWAYS_DESTROY";
    case AlwaysDestroyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AlwaysInlineAttrSpelling e) {
  switch (e) {
    case AlwaysInlineAttrSpelling::GNU_ALWAYS_INLINE: return "GNU_ALWAYS_INLINE";
    case AlwaysInlineAttrSpelling::CXX11_GNU_ALWAYS_INLINE: return "CXX11_GNU_ALWAYS_INLINE";
    case AlwaysInlineAttrSpelling::C2X_GNU_ALWAYS_INLINE: return "C2X_GNU_ALWAYS_INLINE";
    case AlwaysInlineAttrSpelling::CXX11_CLANG_ALWAYS_INLINE: return "CXX11_CLANG_ALWAYS_INLINE";
    case AlwaysInlineAttrSpelling::C2X_CLANG_ALWAYS_INLINE: return "C2X_CLANG_ALWAYS_INLINE";
    case AlwaysInlineAttrSpelling::KEYWORD_FORCEINLINE: return "KEYWORD_FORCEINLINE";
    case AlwaysInlineAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AnnotateAttrSpelling e) {
  switch (e) {
    case AnnotateAttrSpelling::GNU_ANNOTATE: return "GNU_ANNOTATE";
    case AnnotateAttrSpelling::CXX11_CLANG_ANNOTATE: return "CXX11_CLANG_ANNOTATE";
    case AnnotateAttrSpelling::C2X_CLANG_ANNOTATE: return "C2X_CLANG_ANNOTATE";
    case AnnotateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AnnotateTypeAttrSpelling e) {
  switch (e) {
    case AnnotateTypeAttrSpelling::CXX11_CLANG_ANNOTATE_TYPE: return "CXX11_CLANG_ANNOTATE_TYPE";
    case AnnotateTypeAttrSpelling::C2X_CLANG_ANNOTATE_TYPE: return "C2X_CLANG_ANNOTATE_TYPE";
    case AnnotateTypeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AnyX86InterruptAttrSpelling e) {
  switch (e) {
    case AnyX86InterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case AnyX86InterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case AnyX86InterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case AnyX86InterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AnyX86NoCallerSavedRegistersAttrSpelling e) {
  switch (e) {
    case AnyX86NoCallerSavedRegistersAttrSpelling::GNU_NO_CALLER_SAVED_REGISTERS: return "GNU_NO_CALLER_SAVED_REGISTERS";
    case AnyX86NoCallerSavedRegistersAttrSpelling::CXX11_GNU_NO_CALLER_SAVED_REGISTERS: return "CXX11_GNU_NO_CALLER_SAVED_REGISTERS";
    case AnyX86NoCallerSavedRegistersAttrSpelling::C2X_GNU_NO_CALLER_SAVED_REGISTERS: return "C2X_GNU_NO_CALLER_SAVED_REGISTERS";
    case AnyX86NoCallerSavedRegistersAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AnyX86NoCfCheckAttrSpelling e) {
  switch (e) {
    case AnyX86NoCfCheckAttrSpelling::GNU_NOCF_CHECK: return "GNU_NOCF_CHECK";
    case AnyX86NoCfCheckAttrSpelling::CXX11_GNU_NOCF_CHECK: return "CXX11_GNU_NOCF_CHECK";
    case AnyX86NoCfCheckAttrSpelling::C2X_GNU_NOCF_CHECK: return "C2X_GNU_NOCF_CHECK";
    case AnyX86NoCfCheckAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArcWeakrefUnavailableAttrSpelling e) {
  switch (e) {
    case ArcWeakrefUnavailableAttrSpelling::GNU_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE: return "GNU_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE";
    case ArcWeakrefUnavailableAttrSpelling::CXX11_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE: return "CXX11_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE";
    case ArcWeakrefUnavailableAttrSpelling::C2X_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE: return "C2X_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE";
    case ArcWeakrefUnavailableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArgumentWithTypeTagAttrSpelling e) {
  switch (e) {
    case ArgumentWithTypeTagAttrSpelling::GNU_ARGUMENT_WITH_TYPE_TAG: return "GNU_ARGUMENT_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::CXX11_CLANG_ARGUMENT_WITH_TYPE_TAG: return "CXX11_CLANG_ARGUMENT_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::C2X_CLANG_ARGUMENT_WITH_TYPE_TAG: return "C2X_CLANG_ARGUMENT_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::GNU_POINTER_WITH_TYPE_TAG: return "GNU_POINTER_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::CXX11_CLANG_POINTER_WITH_TYPE_TAG: return "CXX11_CLANG_POINTER_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::C2X_CLANG_POINTER_WITH_TYPE_TAG: return "C2X_CLANG_POINTER_WITH_TYPE_TAG";
    case ArgumentWithTypeTagAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArmBuiltinAliasAttrSpelling e) {
  switch (e) {
    case ArmBuiltinAliasAttrSpelling::GNU_CLANG_ARM_BUILTIN_ALIAS: return "GNU_CLANG_ARM_BUILTIN_ALIAS";
    case ArmBuiltinAliasAttrSpelling::CXX11_CLANG_CLANG_ARM_BUILTIN_ALIAS: return "CXX11_CLANG_CLANG_ARM_BUILTIN_ALIAS";
    case ArmBuiltinAliasAttrSpelling::C2X_CLANG_CLANG_ARM_BUILTIN_ALIAS: return "C2X_CLANG_CLANG_ARM_BUILTIN_ALIAS";
    case ArmBuiltinAliasAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArmMveStrictPolymorphismAttrSpelling e) {
  switch (e) {
    case ArmMveStrictPolymorphismAttrSpelling::GNU_CLANG_ARM_MVE_STRICT_POLYMORPHISM: return "GNU_CLANG_ARM_MVE_STRICT_POLYMORPHISM";
    case ArmMveStrictPolymorphismAttrSpelling::CXX11_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM: return "CXX11_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM";
    case ArmMveStrictPolymorphismAttrSpelling::C2X_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM: return "C2X_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM";
    case ArmMveStrictPolymorphismAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArrayTypeArraySizeModifier e) {
  switch (e) {
    case ArrayTypeArraySizeModifier::NORMAL: return "NORMAL";
    case ArrayTypeArraySizeModifier::STATIC: return "STATIC";
    case ArrayTypeArraySizeModifier::STAR: return "STAR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArtificialAttrSpelling e) {
  switch (e) {
    case ArtificialAttrSpelling::GNU_ARTIFICIAL: return "GNU_ARTIFICIAL";
    case ArtificialAttrSpelling::CXX11_GNU_ARTIFICIAL: return "CXX11_GNU_ARTIFICIAL";
    case ArtificialAttrSpelling::C2X_GNU_ARTIFICIAL: return "C2X_GNU_ARTIFICIAL";
    case ArtificialAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AsmLabelAttrSpelling e) {
  switch (e) {
    case AsmLabelAttrSpelling::KEYWORD_ASSEMBLY: return "KEYWORD_ASSEMBLY";
    case AsmLabelAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AssertCapabilityAttrSpelling e) {
  switch (e) {
    case AssertCapabilityAttrSpelling::GNU_ASSERT_CAPABILITY: return "GNU_ASSERT_CAPABILITY";
    case AssertCapabilityAttrSpelling::CXX11_CLANG_ASSERT_CAPABILITY: return "CXX11_CLANG_ASSERT_CAPABILITY";
    case AssertCapabilityAttrSpelling::GNU_ASSERT_SHARED_CAPABILITY: return "GNU_ASSERT_SHARED_CAPABILITY";
    case AssertCapabilityAttrSpelling::CXX11_CLANG_ASSERT_SHARED_CAPABILITY: return "CXX11_CLANG_ASSERT_SHARED_CAPABILITY";
    case AssertCapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AssumeAlignedAttrSpelling e) {
  switch (e) {
    case AssumeAlignedAttrSpelling::GNU_ASSUME_ALIGNED: return "GNU_ASSUME_ALIGNED";
    case AssumeAlignedAttrSpelling::CXX11_GNU_ASSUME_ALIGNED: return "CXX11_GNU_ASSUME_ALIGNED";
    case AssumeAlignedAttrSpelling::C2X_GNU_ASSUME_ALIGNED: return "C2X_GNU_ASSUME_ALIGNED";
    case AssumeAlignedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AssumptionAttrSpelling e) {
  switch (e) {
    case AssumptionAttrSpelling::GNU_ASSUME: return "GNU_ASSUME";
    case AssumptionAttrSpelling::CXX11_CLANG_ASSUME: return "CXX11_CLANG_ASSUME";
    case AssumptionAttrSpelling::C2X_CLANG_ASSUME: return "C2X_CLANG_ASSUME";
    case AssumptionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AtomicExprAtomicOp e) {
  switch (e) {
    case AtomicExprAtomicOp::C11_ATOMIC_INITIALIZER: return "C11_ATOMIC_INITIALIZER";
    case AtomicExprAtomicOp::C11_ATOMIC_LOAD: return "C11_ATOMIC_LOAD";
    case AtomicExprAtomicOp::C11_ATOMIC_STORE: return "C11_ATOMIC_STORE";
    case AtomicExprAtomicOp::C11_ATOMIC_EXCHANGE: return "C11_ATOMIC_EXCHANGE";
    case AtomicExprAtomicOp::C11_ATOMIC_COMPARE_EXCHANGE_STRONG: return "C11_ATOMIC_COMPARE_EXCHANGE_STRONG";
    case AtomicExprAtomicOp::C11_ATOMIC_COMPARE_EXCHANGE_WEAK: return "C11_ATOMIC_COMPARE_EXCHANGE_WEAK";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_ADD: return "C11_ATOMIC_FETCH_ADD";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_SUB: return "C11_ATOMIC_FETCH_SUB";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_AND: return "C11_ATOMIC_FETCH_AND";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_OR: return "C11_ATOMIC_FETCH_OR";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_XOR: return "C11_ATOMIC_FETCH_XOR";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_NAND: return "C11_ATOMIC_FETCH_NAND";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_MAX: return "C11_ATOMIC_FETCH_MAX";
    case AtomicExprAtomicOp::C11_ATOMIC_FETCH_MIN: return "C11_ATOMIC_FETCH_MIN";
    case AtomicExprAtomicOp::ATOMIC_LOAD: return "ATOMIC_LOAD";
    case AtomicExprAtomicOp::ATOMIC_LOAD_N: return "ATOMIC_LOAD_N";
    case AtomicExprAtomicOp::ATOMIC_STORE: return "ATOMIC_STORE";
    case AtomicExprAtomicOp::ATOMIC_STORE_N: return "ATOMIC_STORE_N";
    case AtomicExprAtomicOp::ATOMIC_EXCHANGE: return "ATOMIC_EXCHANGE";
    case AtomicExprAtomicOp::ATOMIC_EXCHANGE_N: return "ATOMIC_EXCHANGE_N";
    case AtomicExprAtomicOp::ATOMIC_COMPARE_EXCHANGE: return "ATOMIC_COMPARE_EXCHANGE";
    case AtomicExprAtomicOp::ATOMIC_COMPARE_EXCHANGE_N: return "ATOMIC_COMPARE_EXCHANGE_N";
    case AtomicExprAtomicOp::ATOMIC_FETCH_ADD: return "ATOMIC_FETCH_ADD";
    case AtomicExprAtomicOp::ATOMIC_FETCH_SUB: return "ATOMIC_FETCH_SUB";
    case AtomicExprAtomicOp::ATOMIC_FETCH_AND: return "ATOMIC_FETCH_AND";
    case AtomicExprAtomicOp::ATOMIC_FETCH_OR: return "ATOMIC_FETCH_OR";
    case AtomicExprAtomicOp::ATOMIC_FETCH_XOR: return "ATOMIC_FETCH_XOR";
    case AtomicExprAtomicOp::ATOMIC_FETCH_NAND: return "ATOMIC_FETCH_NAND";
    case AtomicExprAtomicOp::ATOMIC_ADD_FETCH: return "ATOMIC_ADD_FETCH";
    case AtomicExprAtomicOp::ATOMIC_SUB_FETCH: return "ATOMIC_SUB_FETCH";
    case AtomicExprAtomicOp::ATOMIC_AND_FETCH: return "ATOMIC_AND_FETCH";
    case AtomicExprAtomicOp::ATOMIC_OR_FETCH: return "ATOMIC_OR_FETCH";
    case AtomicExprAtomicOp::ATOMIC_XOR_FETCH: return "ATOMIC_XOR_FETCH";
    case AtomicExprAtomicOp::ATOMIC_MAX_FETCH: return "ATOMIC_MAX_FETCH";
    case AtomicExprAtomicOp::ATOMIC_MIN_FETCH: return "ATOMIC_MIN_FETCH";
    case AtomicExprAtomicOp::ATOMIC_NAND_FETCH: return "ATOMIC_NAND_FETCH";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_INITIALIZER: return "OPENCL_ATOMIC_INITIALIZER";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_LOAD: return "OPENCL_ATOMIC_LOAD";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_STORE: return "OPENCL_ATOMIC_STORE";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_EXCHANGE: return "OPENCL_ATOMIC_EXCHANGE";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_COMPARE_EXCHANGE_STRONG: return "OPENCL_ATOMIC_COMPARE_EXCHANGE_STRONG";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_COMPARE_EXCHANGE_WEAK: return "OPENCL_ATOMIC_COMPARE_EXCHANGE_WEAK";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_ADD: return "OPENCL_ATOMIC_FETCH_ADD";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_SUB: return "OPENCL_ATOMIC_FETCH_SUB";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_AND: return "OPENCL_ATOMIC_FETCH_AND";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_OR: return "OPENCL_ATOMIC_FETCH_OR";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_XOR: return "OPENCL_ATOMIC_FETCH_XOR";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_MIN: return "OPENCL_ATOMIC_FETCH_MIN";
    case AtomicExprAtomicOp::OPENCL_ATOMIC_FETCH_MAX: return "OPENCL_ATOMIC_FETCH_MAX";
    case AtomicExprAtomicOp::ATOMIC_FETCH_MIN: return "ATOMIC_FETCH_MIN";
    case AtomicExprAtomicOp::ATOMIC_FETCH_MAX: return "ATOMIC_FETCH_MAX";
    case AtomicExprAtomicOp::HIP_ATOMIC_LOAD: return "HIP_ATOMIC_LOAD";
    case AtomicExprAtomicOp::HIP_ATOMIC_STORE: return "HIP_ATOMIC_STORE";
    case AtomicExprAtomicOp::HIP_ATOMIC_COMPARE_EXCHANGE_WEAK: return "HIP_ATOMIC_COMPARE_EXCHANGE_WEAK";
    case AtomicExprAtomicOp::HIP_ATOMIC_COMPARE_EXCHANGE_STRONG: return "HIP_ATOMIC_COMPARE_EXCHANGE_STRONG";
    case AtomicExprAtomicOp::HIP_ATOMIC_EXCHANGE: return "HIP_ATOMIC_EXCHANGE";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_ADD: return "HIP_ATOMIC_FETCH_ADD";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_AND: return "HIP_ATOMIC_FETCH_AND";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_OR: return "HIP_ATOMIC_FETCH_OR";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_XOR: return "HIP_ATOMIC_FETCH_XOR";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_MIN: return "HIP_ATOMIC_FETCH_MIN";
    case AtomicExprAtomicOp::HIP_ATOMIC_FETCH_MAX: return "HIP_ATOMIC_FETCH_MAX";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AvailabilityAttrSpelling e) {
  switch (e) {
    case AvailabilityAttrSpelling::GNU_AVAILABILITY: return "GNU_AVAILABILITY";
    case AvailabilityAttrSpelling::CXX11_CLANG_AVAILABILITY: return "CXX11_CLANG_AVAILABILITY";
    case AvailabilityAttrSpelling::C2X_CLANG_AVAILABILITY: return "C2X_CLANG_AVAILABILITY";
    case AvailabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BPFPreserveAccessIndexAttrSpelling e) {
  switch (e) {
    case BPFPreserveAccessIndexAttrSpelling::GNU_PRESERVE_ACCESS_INDEX: return "GNU_PRESERVE_ACCESS_INDEX";
    case BPFPreserveAccessIndexAttrSpelling::CXX11_CLANG_PRESERVE_ACCESS_INDEX: return "CXX11_CLANG_PRESERVE_ACCESS_INDEX";
    case BPFPreserveAccessIndexAttrSpelling::C2X_CLANG_PRESERVE_ACCESS_INDEX: return "C2X_CLANG_PRESERVE_ACCESS_INDEX";
    case BPFPreserveAccessIndexAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BTFDeclTagAttrSpelling e) {
  switch (e) {
    case BTFDeclTagAttrSpelling::GNU_BTF_DECLARATION_TAG: return "GNU_BTF_DECLARATION_TAG";
    case BTFDeclTagAttrSpelling::CXX11_CLANG_BTF_DECLARATION_TAG: return "CXX11_CLANG_BTF_DECLARATION_TAG";
    case BTFDeclTagAttrSpelling::C2X_CLANG_BTF_DECLARATION_TAG: return "C2X_CLANG_BTF_DECLARATION_TAG";
    case BTFDeclTagAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BTFTypeTagAttrSpelling e) {
  switch (e) {
    case BTFTypeTagAttrSpelling::GNU_BTF_TYPE_TAG: return "GNU_BTF_TYPE_TAG";
    case BTFTypeTagAttrSpelling::CXX11_CLANG_BTF_TYPE_TAG: return "CXX11_CLANG_BTF_TYPE_TAG";
    case BTFTypeTagAttrSpelling::C2X_CLANG_BTF_TYPE_TAG: return "C2X_CLANG_BTF_TYPE_TAG";
    case BTFTypeTagAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BlocksAttrBlockType e) {
  switch (e) {
    case BlocksAttrBlockType::BY_REFERENCE: return "BY_REFERENCE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BlocksAttrSpelling e) {
  switch (e) {
    case BlocksAttrSpelling::GNU_BLOCKS: return "GNU_BLOCKS";
    case BlocksAttrSpelling::CXX11_CLANG_BLOCKS: return "CXX11_CLANG_BLOCKS";
    case BlocksAttrSpelling::C2X_CLANG_BLOCKS: return "C2X_CLANG_BLOCKS";
    case BlocksAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BuiltinAliasAttrSpelling e) {
  switch (e) {
    case BuiltinAliasAttrSpelling::CXX11_CLANG_BUILTIN_ALIAS: return "CXX11_CLANG_BUILTIN_ALIAS";
    case BuiltinAliasAttrSpelling::C2X_CLANG_BUILTIN_ALIAS: return "C2X_CLANG_BUILTIN_ALIAS";
    case BuiltinAliasAttrSpelling::GNU_CLANG_BUILTIN_ALIAS: return "GNU_CLANG_BUILTIN_ALIAS";
    case BuiltinAliasAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BuiltinTypeKind e) {
  switch (e) {
    case BuiltinTypeKind::OCL_IMAGE_1D_RO: return "OCL_IMAGE_1D_RO";
    case BuiltinTypeKind::OCL_IMAGE_1D_ARRAY_RO: return "OCL_IMAGE_1D_ARRAY_RO";
    case BuiltinTypeKind::OCL_IMAGE_1D_BUFFER_RO: return "OCL_IMAGE_1D_BUFFER_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_RO: return "OCL_IMAGE_2D_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_RO: return "OCL_IMAGE_2D_ARRAY_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_DEPTH_RO: return "OCL_IMAGE_2D_DEPTH_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_DEPTH_RO: return "OCL_IMAGE_2D_ARRAY_DEPTH_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAARO: return "OCL_IMAGE_2D_MSAARO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAARO: return "OCL_IMAGE_2D_ARRAY_MSAARO";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAA_DEPTH_RO: return "OCL_IMAGE_2D_MSAA_DEPTH_RO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RO: return "OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RO";
    case BuiltinTypeKind::OCL_IMAGE_3D_RO: return "OCL_IMAGE_3D_RO";
    case BuiltinTypeKind::OCL_IMAGE_1D_WO: return "OCL_IMAGE_1D_WO";
    case BuiltinTypeKind::OCL_IMAGE_1D_ARRAY_WO: return "OCL_IMAGE_1D_ARRAY_WO";
    case BuiltinTypeKind::OCL_IMAGE_1D_BUFFER_WO: return "OCL_IMAGE_1D_BUFFER_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_WO: return "OCL_IMAGE_2D_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_WO: return "OCL_IMAGE_2D_ARRAY_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_DEPTH_WO: return "OCL_IMAGE_2D_DEPTH_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_DEPTH_WO: return "OCL_IMAGE_2D_ARRAY_DEPTH_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAAWO: return "OCL_IMAGE_2D_MSAAWO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAAWO: return "OCL_IMAGE_2D_ARRAY_MSAAWO";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAA_DEPTH_WO: return "OCL_IMAGE_2D_MSAA_DEPTH_WO";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_WO: return "OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_WO";
    case BuiltinTypeKind::OCL_IMAGE_3D_WO: return "OCL_IMAGE_3D_WO";
    case BuiltinTypeKind::OCL_IMAGE_1D_RW: return "OCL_IMAGE_1D_RW";
    case BuiltinTypeKind::OCL_IMAGE_1D_ARRAY_RW: return "OCL_IMAGE_1D_ARRAY_RW";
    case BuiltinTypeKind::OCL_IMAGE_1D_BUFFER_RW: return "OCL_IMAGE_1D_BUFFER_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_RW: return "OCL_IMAGE_2D_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_RW: return "OCL_IMAGE_2D_ARRAY_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_DEPTH_RW: return "OCL_IMAGE_2D_DEPTH_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_DEPTH_RW: return "OCL_IMAGE_2D_ARRAY_DEPTH_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAARW: return "OCL_IMAGE_2D_MSAARW";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAARW: return "OCL_IMAGE_2D_ARRAY_MSAARW";
    case BuiltinTypeKind::OCL_IMAGE_2D_MSAA_DEPTH_RW: return "OCL_IMAGE_2D_MSAA_DEPTH_RW";
    case BuiltinTypeKind::OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RW: return "OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RW";
    case BuiltinTypeKind::OCL_IMAGE_3D_RW: return "OCL_IMAGE_3D_RW";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_MCE_PAYLOAD: return "OCL_INTEL_SUBGROUP_AVC_MCE_PAYLOAD";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_PAYLOAD: return "OCL_INTEL_SUBGROUP_AVC_IME_PAYLOAD";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_REF_PAYLOAD: return "OCL_INTEL_SUBGROUP_AVC_REF_PAYLOAD";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_SIC_PAYLOAD: return "OCL_INTEL_SUBGROUP_AVC_SIC_PAYLOAD";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_MCE_RESULT: return "OCL_INTEL_SUBGROUP_AVC_MCE_RESULT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_RESULT: return "OCL_INTEL_SUBGROUP_AVC_IME_RESULT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_REF_RESULT: return "OCL_INTEL_SUBGROUP_AVC_REF_RESULT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_SIC_RESULT: return "OCL_INTEL_SUBGROUP_AVC_SIC_RESULT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_RESULT_SINGLE_REFERENCE_STREAMOUT: return "OCL_INTEL_SUBGROUP_AVC_IME_RESULT_SINGLE_REFERENCE_STREAMOUT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_RESULT_DUAL_REFERENCE_STREAMOUT: return "OCL_INTEL_SUBGROUP_AVC_IME_RESULT_DUAL_REFERENCE_STREAMOUT";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_SINGLE_REFERENCE_STREAMIN: return "OCL_INTEL_SUBGROUP_AVC_IME_SINGLE_REFERENCE_STREAMIN";
    case BuiltinTypeKind::OCL_INTEL_SUBGROUP_AVC_IME_DUAL_REFERENCE_STREAMIN: return "OCL_INTEL_SUBGROUP_AVC_IME_DUAL_REFERENCE_STREAMIN";
    case BuiltinTypeKind::SVE_INT8: return "SVE_INT8";
    case BuiltinTypeKind::SVE_INT16: return "SVE_INT16";
    case BuiltinTypeKind::SVE_INT32: return "SVE_INT32";
    case BuiltinTypeKind::SVE_INT64: return "SVE_INT64";
    case BuiltinTypeKind::SVE_UINT8: return "SVE_UINT8";
    case BuiltinTypeKind::SVE_UINT16: return "SVE_UINT16";
    case BuiltinTypeKind::SVE_UINT32: return "SVE_UINT32";
    case BuiltinTypeKind::SVE_UINT64: return "SVE_UINT64";
    case BuiltinTypeKind::SVE_FLOAT16: return "SVE_FLOAT16";
    case BuiltinTypeKind::SVE_FLOAT32: return "SVE_FLOAT32";
    case BuiltinTypeKind::SVE_FLOAT64: return "SVE_FLOAT64";
    case BuiltinTypeKind::SVE_B_FLOAT16: return "SVE_B_FLOAT16";
    case BuiltinTypeKind::SVE_INT8X2: return "SVE_INT8X2";
    case BuiltinTypeKind::SVE_INT16X2: return "SVE_INT16X2";
    case BuiltinTypeKind::SVE_INT32X2: return "SVE_INT32X2";
    case BuiltinTypeKind::SVE_INT64X2: return "SVE_INT64X2";
    case BuiltinTypeKind::SVE_UINT8X2: return "SVE_UINT8X2";
    case BuiltinTypeKind::SVE_UINT16X2: return "SVE_UINT16X2";
    case BuiltinTypeKind::SVE_UINT32X2: return "SVE_UINT32X2";
    case BuiltinTypeKind::SVE_UINT64X2: return "SVE_UINT64X2";
    case BuiltinTypeKind::SVE_FLOAT16X2: return "SVE_FLOAT16X2";
    case BuiltinTypeKind::SVE_FLOAT32X2: return "SVE_FLOAT32X2";
    case BuiltinTypeKind::SVE_FLOAT64X2: return "SVE_FLOAT64X2";
    case BuiltinTypeKind::SVE_B_FLOAT16X2: return "SVE_B_FLOAT16X2";
    case BuiltinTypeKind::SVE_INT8X3: return "SVE_INT8X3";
    case BuiltinTypeKind::SVE_INT16X3: return "SVE_INT16X3";
    case BuiltinTypeKind::SVE_INT32X3: return "SVE_INT32X3";
    case BuiltinTypeKind::SVE_INT64X3: return "SVE_INT64X3";
    case BuiltinTypeKind::SVE_UINT8X3: return "SVE_UINT8X3";
    case BuiltinTypeKind::SVE_UINT16X3: return "SVE_UINT16X3";
    case BuiltinTypeKind::SVE_UINT32X3: return "SVE_UINT32X3";
    case BuiltinTypeKind::SVE_UINT64X3: return "SVE_UINT64X3";
    case BuiltinTypeKind::SVE_FLOAT16X3: return "SVE_FLOAT16X3";
    case BuiltinTypeKind::SVE_FLOAT32X3: return "SVE_FLOAT32X3";
    case BuiltinTypeKind::SVE_FLOAT64X3: return "SVE_FLOAT64X3";
    case BuiltinTypeKind::SVE_B_FLOAT16X3: return "SVE_B_FLOAT16X3";
    case BuiltinTypeKind::SVE_INT8X4: return "SVE_INT8X4";
    case BuiltinTypeKind::SVE_INT16X4: return "SVE_INT16X4";
    case BuiltinTypeKind::SVE_INT32X4: return "SVE_INT32X4";
    case BuiltinTypeKind::SVE_INT64X4: return "SVE_INT64X4";
    case BuiltinTypeKind::SVE_UINT8X4: return "SVE_UINT8X4";
    case BuiltinTypeKind::SVE_UINT16X4: return "SVE_UINT16X4";
    case BuiltinTypeKind::SVE_UINT32X4: return "SVE_UINT32X4";
    case BuiltinTypeKind::SVE_UINT64X4: return "SVE_UINT64X4";
    case BuiltinTypeKind::SVE_FLOAT16X4: return "SVE_FLOAT16X4";
    case BuiltinTypeKind::SVE_FLOAT32X4: return "SVE_FLOAT32X4";
    case BuiltinTypeKind::SVE_FLOAT64X4: return "SVE_FLOAT64X4";
    case BuiltinTypeKind::SVE_B_FLOAT16X4: return "SVE_B_FLOAT16X4";
    case BuiltinTypeKind::SVE_BOOLEAN: return "SVE_BOOLEAN";
    case BuiltinTypeKind::VECTOR_QUAD: return "VECTOR_QUAD";
    case BuiltinTypeKind::VECTOR_PAIR: return "VECTOR_PAIR";
    case BuiltinTypeKind::RVV_INT8MF8: return "RVV_INT8MF8";
    case BuiltinTypeKind::RVV_INT8MF4: return "RVV_INT8MF4";
    case BuiltinTypeKind::RVV_INT8MF2: return "RVV_INT8MF2";
    case BuiltinTypeKind::RVV_INT8M1: return "RVV_INT8M1";
    case BuiltinTypeKind::RVV_INT8M2: return "RVV_INT8M2";
    case BuiltinTypeKind::RVV_INT8M4: return "RVV_INT8M4";
    case BuiltinTypeKind::RVV_INT8M8: return "RVV_INT8M8";
    case BuiltinTypeKind::RVV_UINT8MF8: return "RVV_UINT8MF8";
    case BuiltinTypeKind::RVV_UINT8MF4: return "RVV_UINT8MF4";
    case BuiltinTypeKind::RVV_UINT8MF2: return "RVV_UINT8MF2";
    case BuiltinTypeKind::RVV_UINT8M1: return "RVV_UINT8M1";
    case BuiltinTypeKind::RVV_UINT8M2: return "RVV_UINT8M2";
    case BuiltinTypeKind::RVV_UINT8M4: return "RVV_UINT8M4";
    case BuiltinTypeKind::RVV_UINT8M8: return "RVV_UINT8M8";
    case BuiltinTypeKind::RVV_INT16MF4: return "RVV_INT16MF4";
    case BuiltinTypeKind::RVV_INT16MF2: return "RVV_INT16MF2";
    case BuiltinTypeKind::RVV_INT16M1: return "RVV_INT16M1";
    case BuiltinTypeKind::RVV_INT16M2: return "RVV_INT16M2";
    case BuiltinTypeKind::RVV_INT16M4: return "RVV_INT16M4";
    case BuiltinTypeKind::RVV_INT16M8: return "RVV_INT16M8";
    case BuiltinTypeKind::RVV_UINT16MF4: return "RVV_UINT16MF4";
    case BuiltinTypeKind::RVV_UINT16MF2: return "RVV_UINT16MF2";
    case BuiltinTypeKind::RVV_UINT16M1: return "RVV_UINT16M1";
    case BuiltinTypeKind::RVV_UINT16M2: return "RVV_UINT16M2";
    case BuiltinTypeKind::RVV_UINT16M4: return "RVV_UINT16M4";
    case BuiltinTypeKind::RVV_UINT16M8: return "RVV_UINT16M8";
    case BuiltinTypeKind::RVV_INT32MF2: return "RVV_INT32MF2";
    case BuiltinTypeKind::RVV_INT32M1: return "RVV_INT32M1";
    case BuiltinTypeKind::RVV_INT32M2: return "RVV_INT32M2";
    case BuiltinTypeKind::RVV_INT32M4: return "RVV_INT32M4";
    case BuiltinTypeKind::RVV_INT32M8: return "RVV_INT32M8";
    case BuiltinTypeKind::RVV_UINT32MF2: return "RVV_UINT32MF2";
    case BuiltinTypeKind::RVV_UINT32M1: return "RVV_UINT32M1";
    case BuiltinTypeKind::RVV_UINT32M2: return "RVV_UINT32M2";
    case BuiltinTypeKind::RVV_UINT32M4: return "RVV_UINT32M4";
    case BuiltinTypeKind::RVV_UINT32M8: return "RVV_UINT32M8";
    case BuiltinTypeKind::RVV_INT64M1: return "RVV_INT64M1";
    case BuiltinTypeKind::RVV_INT64M2: return "RVV_INT64M2";
    case BuiltinTypeKind::RVV_INT64M4: return "RVV_INT64M4";
    case BuiltinTypeKind::RVV_INT64M8: return "RVV_INT64M8";
    case BuiltinTypeKind::RVV_UINT64M1: return "RVV_UINT64M1";
    case BuiltinTypeKind::RVV_UINT64M2: return "RVV_UINT64M2";
    case BuiltinTypeKind::RVV_UINT64M4: return "RVV_UINT64M4";
    case BuiltinTypeKind::RVV_UINT64M8: return "RVV_UINT64M8";
    case BuiltinTypeKind::RVV_FLOAT16MF4: return "RVV_FLOAT16MF4";
    case BuiltinTypeKind::RVV_FLOAT16MF2: return "RVV_FLOAT16MF2";
    case BuiltinTypeKind::RVV_FLOAT16M1: return "RVV_FLOAT16M1";
    case BuiltinTypeKind::RVV_FLOAT16M2: return "RVV_FLOAT16M2";
    case BuiltinTypeKind::RVV_FLOAT16M4: return "RVV_FLOAT16M4";
    case BuiltinTypeKind::RVV_FLOAT16M8: return "RVV_FLOAT16M8";
    case BuiltinTypeKind::RVV_FLOAT32MF2: return "RVV_FLOAT32MF2";
    case BuiltinTypeKind::RVV_FLOAT32M1: return "RVV_FLOAT32M1";
    case BuiltinTypeKind::RVV_FLOAT32M2: return "RVV_FLOAT32M2";
    case BuiltinTypeKind::RVV_FLOAT32M4: return "RVV_FLOAT32M4";
    case BuiltinTypeKind::RVV_FLOAT32M8: return "RVV_FLOAT32M8";
    case BuiltinTypeKind::RVV_FLOAT64M1: return "RVV_FLOAT64M1";
    case BuiltinTypeKind::RVV_FLOAT64M2: return "RVV_FLOAT64M2";
    case BuiltinTypeKind::RVV_FLOAT64M4: return "RVV_FLOAT64M4";
    case BuiltinTypeKind::RVV_FLOAT64M8: return "RVV_FLOAT64M8";
    case BuiltinTypeKind::RVV_BOOL1: return "RVV_BOOL1";
    case BuiltinTypeKind::RVV_BOOL2: return "RVV_BOOL2";
    case BuiltinTypeKind::RVV_BOOL4: return "RVV_BOOL4";
    case BuiltinTypeKind::RVV_BOOL8: return "RVV_BOOL8";
    case BuiltinTypeKind::RVV_BOOL16: return "RVV_BOOL16";
    case BuiltinTypeKind::RVV_BOOL32: return "RVV_BOOL32";
    case BuiltinTypeKind::RVV_BOOL64: return "RVV_BOOL64";
    case BuiltinTypeKind::VOID: return "VOID";
    case BuiltinTypeKind::BOOLEAN: return "BOOLEAN";
    case BuiltinTypeKind::CHARACTER_U: return "CHARACTER_U";
    case BuiltinTypeKind::U_CHAR: return "U_CHAR";
    case BuiltinTypeKind::W_CHAR_U: return "W_CHAR_U";
    case BuiltinTypeKind::CHAR8: return "CHAR8";
    case BuiltinTypeKind::CHAR16: return "CHAR16";
    case BuiltinTypeKind::CHAR32: return "CHAR32";
    case BuiltinTypeKind::U_SHORT: return "U_SHORT";
    case BuiltinTypeKind::U_INT: return "U_INT";
    case BuiltinTypeKind::U_LONG: return "U_LONG";
    case BuiltinTypeKind::U_LONG_LONG: return "U_LONG_LONG";
    case BuiltinTypeKind::U_INT128: return "U_INT128";
    case BuiltinTypeKind::CHARACTER_S: return "CHARACTER_S";
    case BuiltinTypeKind::S_CHAR: return "S_CHAR";
    case BuiltinTypeKind::W_CHAR_S: return "W_CHAR_S";
    case BuiltinTypeKind::SHORT: return "SHORT";
    case BuiltinTypeKind::INT: return "INT";
    case BuiltinTypeKind::LONG: return "LONG";
    case BuiltinTypeKind::LONG_LONG: return "LONG_LONG";
    case BuiltinTypeKind::INT128: return "INT128";
    case BuiltinTypeKind::SHORT_ACCUM: return "SHORT_ACCUM";
    case BuiltinTypeKind::ACCUM: return "ACCUM";
    case BuiltinTypeKind::LONG_ACCUM: return "LONG_ACCUM";
    case BuiltinTypeKind::U_SHORT_ACCUM: return "U_SHORT_ACCUM";
    case BuiltinTypeKind::U_ACCUM: return "U_ACCUM";
    case BuiltinTypeKind::U_LONG_ACCUM: return "U_LONG_ACCUM";
    case BuiltinTypeKind::SHORT_FRACT: return "SHORT_FRACT";
    case BuiltinTypeKind::FRACT: return "FRACT";
    case BuiltinTypeKind::LONG_FRACT: return "LONG_FRACT";
    case BuiltinTypeKind::U_SHORT_FRACT: return "U_SHORT_FRACT";
    case BuiltinTypeKind::U_FRACT: return "U_FRACT";
    case BuiltinTypeKind::U_LONG_FRACT: return "U_LONG_FRACT";
    case BuiltinTypeKind::SAT_SHORT_ACCUM: return "SAT_SHORT_ACCUM";
    case BuiltinTypeKind::SAT_ACCUM: return "SAT_ACCUM";
    case BuiltinTypeKind::SAT_LONG_ACCUM: return "SAT_LONG_ACCUM";
    case BuiltinTypeKind::SAT_U_SHORT_ACCUM: return "SAT_U_SHORT_ACCUM";
    case BuiltinTypeKind::SAT_U_ACCUM: return "SAT_U_ACCUM";
    case BuiltinTypeKind::SAT_U_LONG_ACCUM: return "SAT_U_LONG_ACCUM";
    case BuiltinTypeKind::SAT_SHORT_FRACT: return "SAT_SHORT_FRACT";
    case BuiltinTypeKind::SAT_FRACT: return "SAT_FRACT";
    case BuiltinTypeKind::SAT_LONG_FRACT: return "SAT_LONG_FRACT";
    case BuiltinTypeKind::SAT_U_SHORT_FRACT: return "SAT_U_SHORT_FRACT";
    case BuiltinTypeKind::SAT_U_FRACT: return "SAT_U_FRACT";
    case BuiltinTypeKind::SAT_U_LONG_FRACT: return "SAT_U_LONG_FRACT";
    case BuiltinTypeKind::HALF: return "HALF";
    case BuiltinTypeKind::FLOAT: return "FLOAT";
    case BuiltinTypeKind::DOUBLE: return "DOUBLE";
    case BuiltinTypeKind::LONG_DOUBLE: return "LONG_DOUBLE";
    case BuiltinTypeKind::FLOAT16: return "FLOAT16";
    case BuiltinTypeKind::B_FLOAT16: return "B_FLOAT16";
    case BuiltinTypeKind::FLOAT128: return "FLOAT128";
    case BuiltinTypeKind::IBM128: return "IBM128";
    case BuiltinTypeKind::NULL_POINTER: return "NULL_POINTER";
    case BuiltinTypeKind::OBJ_C_ID: return "OBJ_C_ID";
    case BuiltinTypeKind::OBJ_C_CLASS: return "OBJ_C_CLASS";
    case BuiltinTypeKind::OBJ_C_SEL: return "OBJ_C_SEL";
    case BuiltinTypeKind::OCL_SAMPLER: return "OCL_SAMPLER";
    case BuiltinTypeKind::OCL_EVENT: return "OCL_EVENT";
    case BuiltinTypeKind::OCL_CLK_EVENT: return "OCL_CLK_EVENT";
    case BuiltinTypeKind::OCL_QUEUE: return "OCL_QUEUE";
    case BuiltinTypeKind::OCL_RESERVE_ID: return "OCL_RESERVE_ID";
    case BuiltinTypeKind::DEPENDENT: return "DEPENDENT";
    case BuiltinTypeKind::OVERLOAD: return "OVERLOAD";
    case BuiltinTypeKind::BOUND_MEMBER: return "BOUND_MEMBER";
    case BuiltinTypeKind::PSEUDO_OBJECT: return "PSEUDO_OBJECT";
    case BuiltinTypeKind::UNKNOWN_ANY: return "UNKNOWN_ANY";
    case BuiltinTypeKind::BUILTIN_FN: return "BUILTIN_FN";
    case BuiltinTypeKind::ARC_UNBRIDGED_CAST: return "ARC_UNBRIDGED_CAST";
    case BuiltinTypeKind::INCOMPLETE_MATRIX_INDEX: return "INCOMPLETE_MATRIX_INDEX";
    case BuiltinTypeKind::OMP_ARRAY_SECTION: return "OMP_ARRAY_SECTION";
    case BuiltinTypeKind::OMP_ARRAY_SHAPING: return "OMP_ARRAY_SHAPING";
    case BuiltinTypeKind::OMP_ITERATOR: return "OMP_ITERATOR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CDeclAttrSpelling e) {
  switch (e) {
    case CDeclAttrSpelling::GNU_CDECL: return "GNU_CDECL";
    case CDeclAttrSpelling::CXX11_GNU_CDECL: return "CXX11_GNU_CDECL";
    case CDeclAttrSpelling::C2X_GNU_CDECL: return "C2X_GNU_CDECL";
    case CDeclAttrSpelling::KEYWORD_CDECL: return "KEYWORD_CDECL";
    case CDeclAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFAuditedTransferAttrSpelling e) {
  switch (e) {
    case CFAuditedTransferAttrSpelling::GNU_CF_AUDITED_TRANSFER: return "GNU_CF_AUDITED_TRANSFER";
    case CFAuditedTransferAttrSpelling::CXX11_CLANG_CF_AUDITED_TRANSFER: return "CXX11_CLANG_CF_AUDITED_TRANSFER";
    case CFAuditedTransferAttrSpelling::C2X_CLANG_CF_AUDITED_TRANSFER: return "C2X_CLANG_CF_AUDITED_TRANSFER";
    case CFAuditedTransferAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFConsumedAttrSpelling e) {
  switch (e) {
    case CFConsumedAttrSpelling::GNU_CF_CONSUMED: return "GNU_CF_CONSUMED";
    case CFConsumedAttrSpelling::CXX11_CLANG_CF_CONSUMED: return "CXX11_CLANG_CF_CONSUMED";
    case CFConsumedAttrSpelling::C2X_CLANG_CF_CONSUMED: return "C2X_CLANG_CF_CONSUMED";
    case CFConsumedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFGuardAttrGuardArg e) {
  switch (e) {
    case CFGuardAttrGuardArg::NOCF: return "NOCF";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFICanonicalJumpTableAttrSpelling e) {
  switch (e) {
    case CFICanonicalJumpTableAttrSpelling::GNU_CFI_CANONICAL_JUMP_TABLE: return "GNU_CFI_CANONICAL_JUMP_TABLE";
    case CFICanonicalJumpTableAttrSpelling::CXX11_CLANG_CFI_CANONICAL_JUMP_TABLE: return "CXX11_CLANG_CFI_CANONICAL_JUMP_TABLE";
    case CFICanonicalJumpTableAttrSpelling::C2X_CLANG_CFI_CANONICAL_JUMP_TABLE: return "C2X_CLANG_CFI_CANONICAL_JUMP_TABLE";
    case CFICanonicalJumpTableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFReturnsNotRetainedAttrSpelling e) {
  switch (e) {
    case CFReturnsNotRetainedAttrSpelling::GNU_CF_RETURNS_NOT_RETAINED: return "GNU_CF_RETURNS_NOT_RETAINED";
    case CFReturnsNotRetainedAttrSpelling::CXX11_CLANG_CF_RETURNS_NOT_RETAINED: return "CXX11_CLANG_CF_RETURNS_NOT_RETAINED";
    case CFReturnsNotRetainedAttrSpelling::C2X_CLANG_CF_RETURNS_NOT_RETAINED: return "C2X_CLANG_CF_RETURNS_NOT_RETAINED";
    case CFReturnsNotRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFReturnsRetainedAttrSpelling e) {
  switch (e) {
    case CFReturnsRetainedAttrSpelling::GNU_CF_RETURNS_RETAINED: return "GNU_CF_RETURNS_RETAINED";
    case CFReturnsRetainedAttrSpelling::CXX11_CLANG_CF_RETURNS_RETAINED: return "CXX11_CLANG_CF_RETURNS_RETAINED";
    case CFReturnsRetainedAttrSpelling::C2X_CLANG_CF_RETURNS_RETAINED: return "C2X_CLANG_CF_RETURNS_RETAINED";
    case CFReturnsRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CFUnknownTransferAttrSpelling e) {
  switch (e) {
    case CFUnknownTransferAttrSpelling::GNU_CF_UNKNOWN_TRANSFER: return "GNU_CF_UNKNOWN_TRANSFER";
    case CFUnknownTransferAttrSpelling::CXX11_CLANG_CF_UNKNOWN_TRANSFER: return "CXX11_CLANG_CF_UNKNOWN_TRANSFER";
    case CFUnknownTransferAttrSpelling::C2X_CLANG_CF_UNKNOWN_TRANSFER: return "C2X_CLANG_CF_UNKNOWN_TRANSFER";
    case CFUnknownTransferAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CPUDispatchAttrSpelling e) {
  switch (e) {
    case CPUDispatchAttrSpelling::GNU_CPU_DISPATCH: return "GNU_CPU_DISPATCH";
    case CPUDispatchAttrSpelling::CXX11_CLANG_CPU_DISPATCH: return "CXX11_CLANG_CPU_DISPATCH";
    case CPUDispatchAttrSpelling::C2X_CLANG_CPU_DISPATCH: return "C2X_CLANG_CPU_DISPATCH";
    case CPUDispatchAttrSpelling::DECLSPEC_CPU_DISPATCH: return "DECLSPEC_CPU_DISPATCH";
    case CPUDispatchAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CPUSpecificAttrSpelling e) {
  switch (e) {
    case CPUSpecificAttrSpelling::GNU_CPU_SPECIFIC: return "GNU_CPU_SPECIFIC";
    case CPUSpecificAttrSpelling::CXX11_CLANG_CPU_SPECIFIC: return "CXX11_CLANG_CPU_SPECIFIC";
    case CPUSpecificAttrSpelling::C2X_CLANG_CPU_SPECIFIC: return "C2X_CLANG_CPU_SPECIFIC";
    case CPUSpecificAttrSpelling::DECLSPEC_CPU_SPECIFIC: return "DECLSPEC_CPU_SPECIFIC";
    case CPUSpecificAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDAConstantAttrSpelling e) {
  switch (e) {
    case CUDAConstantAttrSpelling::GNU_CONSTANT: return "GNU_CONSTANT";
    case CUDAConstantAttrSpelling::DECLSPEC_CONSTANT: return "DECLSPEC_CONSTANT";
    case CUDAConstantAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDADeviceAttrSpelling e) {
  switch (e) {
    case CUDADeviceAttrSpelling::GNU_DEVICE: return "GNU_DEVICE";
    case CUDADeviceAttrSpelling::DECLSPEC_DEVICE: return "DECLSPEC_DEVICE";
    case CUDADeviceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDADeviceBuiltinSurfaceTypeAttrSpelling e) {
  switch (e) {
    case CUDADeviceBuiltinSurfaceTypeAttrSpelling::GNU_DEVICE_BUILTIN_SURFACE_TYPE: return "GNU_DEVICE_BUILTIN_SURFACE_TYPE";
    case CUDADeviceBuiltinSurfaceTypeAttrSpelling::DECLSPEC_DEVICE_BUILTIN_SURFACE_TYPE: return "DECLSPEC_DEVICE_BUILTIN_SURFACE_TYPE";
    case CUDADeviceBuiltinSurfaceTypeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDADeviceBuiltinTextureTypeAttrSpelling e) {
  switch (e) {
    case CUDADeviceBuiltinTextureTypeAttrSpelling::GNU_DEVICE_BUILTIN_TEXTURE_TYPE: return "GNU_DEVICE_BUILTIN_TEXTURE_TYPE";
    case CUDADeviceBuiltinTextureTypeAttrSpelling::DECLSPEC_DEVICE_BUILTIN_TEXTURE_TYPE: return "DECLSPEC_DEVICE_BUILTIN_TEXTURE_TYPE";
    case CUDADeviceBuiltinTextureTypeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDAGlobalAttrSpelling e) {
  switch (e) {
    case CUDAGlobalAttrSpelling::GNU_GLOBAL: return "GNU_GLOBAL";
    case CUDAGlobalAttrSpelling::DECLSPEC_GLOBAL: return "DECLSPEC_GLOBAL";
    case CUDAGlobalAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDAHostAttrSpelling e) {
  switch (e) {
    case CUDAHostAttrSpelling::GNU_HOST: return "GNU_HOST";
    case CUDAHostAttrSpelling::DECLSPEC_HOST: return "DECLSPEC_HOST";
    case CUDAHostAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDALaunchBoundsAttrSpelling e) {
  switch (e) {
    case CUDALaunchBoundsAttrSpelling::GNU_LAUNCH_BOUNDS: return "GNU_LAUNCH_BOUNDS";
    case CUDALaunchBoundsAttrSpelling::DECLSPEC_LAUNCH_BOUNDS: return "DECLSPEC_LAUNCH_BOUNDS";
    case CUDALaunchBoundsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CUDASharedAttrSpelling e) {
  switch (e) {
    case CUDASharedAttrSpelling::GNU_SHARED: return "GNU_SHARED";
    case CUDASharedAttrSpelling::DECLSPEC_SHARED: return "DECLSPEC_SHARED";
    case CUDASharedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CXX11NoReturnAttrSpelling e) {
  switch (e) {
    case CXX11NoReturnAttrSpelling::CXX11_NORETURN: return "CXX11_NORETURN";
    case CXX11NoReturnAttrSpelling::C2XNORETURN: return "C2XNORETURN";
    case CXX11NoReturnAttrSpelling::C2X_NORETURN: return "C2X_NORETURN";
    case CXX11NoReturnAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CXXConstructExprConstructionKind e) {
  switch (e) {
    case CXXConstructExprConstructionKind::COMPLETE: return "COMPLETE";
    case CXXConstructExprConstructionKind::NON_VIRTUAL_BASE: return "NON_VIRTUAL_BASE";
    case CXXConstructExprConstructionKind::VIRTUAL_BASE: return "VIRTUAL_BASE";
    case CXXConstructExprConstructionKind::DELEGATING: return "DELEGATING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CXXNewExprInitializationStyle e) {
  switch (e) {
    case CXXNewExprInitializationStyle::NO_INITIALIZER: return "NO_INITIALIZER";
    case CXXNewExprInitializationStyle::CALL_INITIALIZER: return "CALL_INITIALIZER";
    case CXXNewExprInitializationStyle::LIST_INITIALIZER: return "LIST_INITIALIZER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CXXRecordDeclLambdaDependencyKind e) {
  switch (e) {
    case CXXRecordDeclLambdaDependencyKind::UNKNOWN: return "UNKNOWN";
    case CXXRecordDeclLambdaDependencyKind::ALWAYS_DEPENDENT: return "ALWAYS_DEPENDENT";
    case CXXRecordDeclLambdaDependencyKind::NEVER_DEPENDENT: return "NEVER_DEPENDENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CallExprADLCallKind e) {
  switch (e) {
    case CallExprADLCallKind::NOT_ADL: return "NOT_ADL";
    case CallExprADLCallKind::USES_ADL: return "USES_ADL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CallableWhenAttrConsumedState e) {
  switch (e) {
    case CallableWhenAttrConsumedState::UNKNOWN: return "UNKNOWN";
    case CallableWhenAttrConsumedState::CONSUMED: return "CONSUMED";
    case CallableWhenAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CallableWhenAttrSpelling e) {
  switch (e) {
    case CallableWhenAttrSpelling::GNU_CALLABLE_WHEN: return "GNU_CALLABLE_WHEN";
    case CallableWhenAttrSpelling::CXX11_CLANG_CALLABLE_WHEN: return "CXX11_CLANG_CALLABLE_WHEN";
    case CallableWhenAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CallbackAttrSpelling e) {
  switch (e) {
    case CallbackAttrSpelling::GNU_CALLBACK: return "GNU_CALLBACK";
    case CallbackAttrSpelling::CXX11_CLANG_CALLBACK: return "CXX11_CLANG_CALLBACK";
    case CallbackAttrSpelling::C2X_CLANG_CALLBACK: return "C2X_CLANG_CALLBACK";
    case CallbackAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CalledOnceAttrSpelling e) {
  switch (e) {
    case CalledOnceAttrSpelling::GNU_CALLED_ONCE: return "GNU_CALLED_ONCE";
    case CalledOnceAttrSpelling::CXX11_CLANG_CALLED_ONCE: return "CXX11_CLANG_CALLED_ONCE";
    case CalledOnceAttrSpelling::C2X_CLANG_CALLED_ONCE: return "C2X_CLANG_CALLED_ONCE";
    case CalledOnceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CapabilityAttrSpelling e) {
  switch (e) {
    case CapabilityAttrSpelling::GNU_CAPABILITY: return "GNU_CAPABILITY";
    case CapabilityAttrSpelling::CXX11_CLANG_CAPABILITY: return "CXX11_CLANG_CAPABILITY";
    case CapabilityAttrSpelling::GNU_SHARED_CAPABILITY: return "GNU_SHARED_CAPABILITY";
    case CapabilityAttrSpelling::CXX11_CLANG_SHARED_CAPABILITY: return "CXX11_CLANG_SHARED_CAPABILITY";
    case CapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CapturedStmtVariableCaptureKind e) {
  switch (e) {
    case CapturedStmtVariableCaptureKind::THIS: return "THIS";
    case CapturedStmtVariableCaptureKind::BY_REFERENCE: return "BY_REFERENCE";
    case CapturedStmtVariableCaptureKind::BY_COPY: return "BY_COPY";
    case CapturedStmtVariableCaptureKind::VLA_TYPE: return "VLA_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CarriesDependencyAttrSpelling e) {
  switch (e) {
    case CarriesDependencyAttrSpelling::GNU_CARRIES_DEPENDENCY: return "GNU_CARRIES_DEPENDENCY";
    case CarriesDependencyAttrSpelling::CXX11_CARRIES_DEPENDENCY: return "CXX11_CARRIES_DEPENDENCY";
    case CarriesDependencyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CharacterLiteralCharacterKind e) {
  switch (e) {
    case CharacterLiteralCharacterKind::ASCII: return "ASCII";
    case CharacterLiteralCharacterKind::WIDE: return "WIDE";
    case CharacterLiteralCharacterKind::UTF8: return "UTF8";
    case CharacterLiteralCharacterKind::UTF16: return "UTF16";
    case CharacterLiteralCharacterKind::UTF32: return "UTF32";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CleanupAttrSpelling e) {
  switch (e) {
    case CleanupAttrSpelling::GNU_CLEANUP: return "GNU_CLEANUP";
    case CleanupAttrSpelling::CXX11_GNU_CLEANUP: return "CXX11_GNU_CLEANUP";
    case CleanupAttrSpelling::C2X_GNU_CLEANUP: return "C2X_GNU_CLEANUP";
    case CleanupAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ColdAttrSpelling e) {
  switch (e) {
    case ColdAttrSpelling::GNU_COLD: return "GNU_COLD";
    case ColdAttrSpelling::CXX11_GNU_COLD: return "CXX11_GNU_COLD";
    case ColdAttrSpelling::C2X_GNU_COLD: return "C2X_GNU_COLD";
    case ColdAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CommonAttrSpelling e) {
  switch (e) {
    case CommonAttrSpelling::GNU_COMMON: return "GNU_COMMON";
    case CommonAttrSpelling::CXX11_GNU_COMMON: return "CXX11_GNU_COMMON";
    case CommonAttrSpelling::C2X_GNU_COMMON: return "C2X_GNU_COMMON";
    case CommonAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConstAttrSpelling e) {
  switch (e) {
    case ConstAttrSpelling::GNU_CONST: return "GNU_CONST";
    case ConstAttrSpelling::CXX11_GNU_CONST: return "CXX11_GNU_CONST";
    case ConstAttrSpelling::C2X_GNU_CONST: return "C2X_GNU_CONST";
    case ConstAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConstInitAttrSpelling e) {
  switch (e) {
    case ConstInitAttrSpelling::KEYWORD_CONSTINIT: return "KEYWORD_CONSTINIT";
    case ConstInitAttrSpelling::GNU_REQUIRE_CONSTANT_INITIALIZATION: return "GNU_REQUIRE_CONSTANT_INITIALIZATION";
    case ConstInitAttrSpelling::CXX11_CLANG_REQUIRE_CONSTANT_INITIALIZATION: return "CXX11_CLANG_REQUIRE_CONSTANT_INITIALIZATION";
    case ConstInitAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConstantExprResultStorageKind e) {
  switch (e) {
    case ConstantExprResultStorageKind::NONE: return "NONE";
    case ConstantExprResultStorageKind::INT64: return "INT64";
    case ConstantExprResultStorageKind::AP_VALUE: return "AP_VALUE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConstructorAttrSpelling e) {
  switch (e) {
    case ConstructorAttrSpelling::GNU_CONSTRUCTOR: return "GNU_CONSTRUCTOR";
    case ConstructorAttrSpelling::CXX11_GNU_CONSTRUCTOR: return "CXX11_GNU_CONSTRUCTOR";
    case ConstructorAttrSpelling::C2X_GNU_CONSTRUCTOR: return "C2X_GNU_CONSTRUCTOR";
    case ConstructorAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConsumableAttrConsumedState e) {
  switch (e) {
    case ConsumableAttrConsumedState::UNKNOWN: return "UNKNOWN";
    case ConsumableAttrConsumedState::CONSUMED: return "CONSUMED";
    case ConsumableAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConsumableAttrSpelling e) {
  switch (e) {
    case ConsumableAttrSpelling::GNU_CONSUMABLE: return "GNU_CONSUMABLE";
    case ConsumableAttrSpelling::CXX11_CLANG_CONSUMABLE: return "CXX11_CLANG_CONSUMABLE";
    case ConsumableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConsumableAutoCastAttrSpelling e) {
  switch (e) {
    case ConsumableAutoCastAttrSpelling::GNU_CONSUMABLE_AUTO_CAST_STATE: return "GNU_CONSUMABLE_AUTO_CAST_STATE";
    case ConsumableAutoCastAttrSpelling::CXX11_CLANG_CONSUMABLE_AUTO_CAST_STATE: return "CXX11_CLANG_CONSUMABLE_AUTO_CAST_STATE";
    case ConsumableAutoCastAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConsumableSetOnReadAttrSpelling e) {
  switch (e) {
    case ConsumableSetOnReadAttrSpelling::GNU_CONSUMABLE_STATE_ON_READ: return "GNU_CONSUMABLE_STATE_ON_READ";
    case ConsumableSetOnReadAttrSpelling::CXX11_CLANG_CONSUMABLE_STATE_ON_READ: return "CXX11_CLANG_CONSUMABLE_STATE_ON_READ";
    case ConsumableSetOnReadAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConvergentAttrSpelling e) {
  switch (e) {
    case ConvergentAttrSpelling::GNU_CONVERGENT: return "GNU_CONVERGENT";
    case ConvergentAttrSpelling::CXX11_CLANG_CONVERGENT: return "CXX11_CLANG_CONVERGENT";
    case ConvergentAttrSpelling::C2X_CLANG_CONVERGENT: return "C2X_CLANG_CONVERGENT";
    case ConvergentAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DLLExportAttrSpelling e) {
  switch (e) {
    case DLLExportAttrSpelling::DECLSPEC_DLLEXPORT: return "DECLSPEC_DLLEXPORT";
    case DLLExportAttrSpelling::GNU_DLLEXPORT: return "GNU_DLLEXPORT";
    case DLLExportAttrSpelling::CXX11_GNU_DLLEXPORT: return "CXX11_GNU_DLLEXPORT";
    case DLLExportAttrSpelling::C2X_GNU_DLLEXPORT: return "C2X_GNU_DLLEXPORT";
    case DLLExportAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DLLImportAttrSpelling e) {
  switch (e) {
    case DLLImportAttrSpelling::DECLSPEC_DLLIMPORT: return "DECLSPEC_DLLIMPORT";
    case DLLImportAttrSpelling::GNU_DLLIMPORT: return "GNU_DLLIMPORT";
    case DLLImportAttrSpelling::CXX11_GNU_DLLIMPORT: return "CXX11_GNU_DLLIMPORT";
    case DLLImportAttrSpelling::C2X_GNU_DLLIMPORT: return "C2X_GNU_DLLIMPORT";
    case DLLImportAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeclFriendObjectKind e) {
  switch (e) {
    case DeclFriendObjectKind::NONE: return "NONE";
    case DeclFriendObjectKind::DECLARED: return "DECLARED";
    case DeclFriendObjectKind::UNDECLARED: return "UNDECLARED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeclIdentifierNamespace e) {
  switch (e) {
    case DeclIdentifierNamespace::LABEL: return "LABEL";
    case DeclIdentifierNamespace::TAG: return "TAG";
    case DeclIdentifierNamespace::TYPE: return "TYPE";
    case DeclIdentifierNamespace::MEMBER: return "MEMBER";
    case DeclIdentifierNamespace::NAMESPACE: return "NAMESPACE";
    case DeclIdentifierNamespace::ORDINARY: return "ORDINARY";
    case DeclIdentifierNamespace::OBJ_C_PROTOCOL: return "OBJ_C_PROTOCOL";
    case DeclIdentifierNamespace::ORDINARY_FRIEND: return "ORDINARY_FRIEND";
    case DeclIdentifierNamespace::TAG_FRIEND: return "TAG_FRIEND";
    case DeclIdentifierNamespace::USING: return "USING";
    case DeclIdentifierNamespace::NON_MEMBER_OPERATOR: return "NON_MEMBER_OPERATOR";
    case DeclIdentifierNamespace::LOCAL_EXTERN: return "LOCAL_EXTERN";
    case DeclIdentifierNamespace::OMP_REDUCTION: return "OMP_REDUCTION";
    case DeclIdentifierNamespace::OMP_MAPPER: return "OMP_MAPPER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeclModuleOwnershipKind e) {
  switch (e) {
    case DeclModuleOwnershipKind::UNOWNED: return "UNOWNED";
    case DeclModuleOwnershipKind::VISIBLE: return "VISIBLE";
    case DeclModuleOwnershipKind::VISIBLE_WHEN_IMPORTED: return "VISIBLE_WHEN_IMPORTED";
    case DeclModuleOwnershipKind::REACHABLE_WHEN_IMPORTED: return "REACHABLE_WHEN_IMPORTED";
    case DeclModuleOwnershipKind::MODULE_PRIVATE: return "MODULE_PRIVATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeclObjCDeclQualifier e) {
  switch (e) {
    case DeclObjCDeclQualifier::NONE: return "NONE";
    case DeclObjCDeclQualifier::IN: return "IN";
    case DeclObjCDeclQualifier::INOUT: return "INOUT";
    case DeclObjCDeclQualifier::OUT: return "OUT";
    case DeclObjCDeclQualifier::BYCOPY: return "BYCOPY";
    case DeclObjCDeclQualifier::BYREF: return "BYREF";
    case DeclObjCDeclQualifier::ONEWAY: return "ONEWAY";
    case DeclObjCDeclQualifier::CS_NULLABILITY: return "CS_NULLABILITY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeprecatedAttrSpelling e) {
  switch (e) {
    case DeprecatedAttrSpelling::GNU_DEPRECATED: return "GNU_DEPRECATED";
    case DeprecatedAttrSpelling::CXX11_GNU_DEPRECATED: return "CXX11_GNU_DEPRECATED";
    case DeprecatedAttrSpelling::C2X_GNU_DEPRECATED: return "C2X_GNU_DEPRECATED";
    case DeprecatedAttrSpelling::DECLSPEC_DEPRECATED: return "DECLSPEC_DEPRECATED";
    case DeprecatedAttrSpelling::CXX11_DEPRECATED: return "CXX11_DEPRECATED";
    case DeprecatedAttrSpelling::C2X_DEPRECATED: return "C2X_DEPRECATED";
    case DeprecatedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DestructorAttrSpelling e) {
  switch (e) {
    case DestructorAttrSpelling::GNU_DESTRUCTOR: return "GNU_DESTRUCTOR";
    case DestructorAttrSpelling::CXX11_GNU_DESTRUCTOR: return "CXX11_GNU_DESTRUCTOR";
    case DestructorAttrSpelling::C2X_GNU_DESTRUCTOR: return "C2X_GNU_DESTRUCTOR";
    case DestructorAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DiagnoseAsBuiltinAttrSpelling e) {
  switch (e) {
    case DiagnoseAsBuiltinAttrSpelling::GNU_DIAGNOSE_AS_BUILTIN: return "GNU_DIAGNOSE_AS_BUILTIN";
    case DiagnoseAsBuiltinAttrSpelling::CXX11_CLANG_DIAGNOSE_AS_BUILTIN: return "CXX11_CLANG_DIAGNOSE_AS_BUILTIN";
    case DiagnoseAsBuiltinAttrSpelling::C2X_CLANG_DIAGNOSE_AS_BUILTIN: return "C2X_CLANG_DIAGNOSE_AS_BUILTIN";
    case DiagnoseAsBuiltinAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DiagnoseIfAttrDiagnosticType e) {
  switch (e) {
    case DiagnoseIfAttrDiagnosticType::ERROR: return "ERROR";
    case DiagnoseIfAttrDiagnosticType::WARNING: return "WARNING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DisableSanitizerInstrumentationAttrSpelling e) {
  switch (e) {
    case DisableSanitizerInstrumentationAttrSpelling::GNU_DISABLE_SANITIZER_INSTRUMENTATION: return "GNU_DISABLE_SANITIZER_INSTRUMENTATION";
    case DisableSanitizerInstrumentationAttrSpelling::CXX11_CLANG_DISABLE_SANITIZER_INSTRUMENTATION: return "CXX11_CLANG_DISABLE_SANITIZER_INSTRUMENTATION";
    case DisableSanitizerInstrumentationAttrSpelling::C2X_CLANG_DISABLE_SANITIZER_INSTRUMENTATION: return "C2X_CLANG_DISABLE_SANITIZER_INSTRUMENTATION";
    case DisableSanitizerInstrumentationAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DisableTailCallsAttrSpelling e) {
  switch (e) {
    case DisableTailCallsAttrSpelling::GNU_DISABLE_TAIL_CALLS: return "GNU_DISABLE_TAIL_CALLS";
    case DisableTailCallsAttrSpelling::CXX11_CLANG_DISABLE_TAIL_CALLS: return "CXX11_CLANG_DISABLE_TAIL_CALLS";
    case DisableTailCallsAttrSpelling::C2X_CLANG_DISABLE_TAIL_CALLS: return "C2X_CLANG_DISABLE_TAIL_CALLS";
    case DisableTailCallsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EnforceTCBAttrSpelling e) {
  switch (e) {
    case EnforceTCBAttrSpelling::GNU_ENFORCE_TCB: return "GNU_ENFORCE_TCB";
    case EnforceTCBAttrSpelling::CXX11_CLANG_ENFORCE_TCB: return "CXX11_CLANG_ENFORCE_TCB";
    case EnforceTCBAttrSpelling::C2X_CLANG_ENFORCE_TCB: return "C2X_CLANG_ENFORCE_TCB";
    case EnforceTCBAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EnforceTCBLeafAttrSpelling e) {
  switch (e) {
    case EnforceTCBLeafAttrSpelling::GNU_ENFORCE_TCB_LEAF: return "GNU_ENFORCE_TCB_LEAF";
    case EnforceTCBLeafAttrSpelling::CXX11_CLANG_ENFORCE_TCB_LEAF: return "CXX11_CLANG_ENFORCE_TCB_LEAF";
    case EnforceTCBLeafAttrSpelling::C2X_CLANG_ENFORCE_TCB_LEAF: return "C2X_CLANG_ENFORCE_TCB_LEAF";
    case EnforceTCBLeafAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EnumExtensibilityAttrKind e) {
  switch (e) {
    case EnumExtensibilityAttrKind::CLOSED: return "CLOSED";
    case EnumExtensibilityAttrKind::OPEN: return "OPEN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EnumExtensibilityAttrSpelling e) {
  switch (e) {
    case EnumExtensibilityAttrSpelling::GNU_ENUM_EXTENSIBILITY: return "GNU_ENUM_EXTENSIBILITY";
    case EnumExtensibilityAttrSpelling::CXX11_CLANG_ENUM_EXTENSIBILITY: return "CXX11_CLANG_ENUM_EXTENSIBILITY";
    case EnumExtensibilityAttrSpelling::C2X_CLANG_ENUM_EXTENSIBILITY: return "C2X_CLANG_ENUM_EXTENSIBILITY";
    case EnumExtensibilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ErrorAttrSpelling e) {
  switch (e) {
    case ErrorAttrSpelling::GNU_ERROR: return "GNU_ERROR";
    case ErrorAttrSpelling::CXX11_GNU_ERROR: return "CXX11_GNU_ERROR";
    case ErrorAttrSpelling::C2X_GNU_ERROR: return "C2X_GNU_ERROR";
    case ErrorAttrSpelling::GNU_WARNING: return "GNU_WARNING";
    case ErrorAttrSpelling::CXX11_GNU_WARNING: return "CXX11_GNU_WARNING";
    case ErrorAttrSpelling::C2X_GNU_WARNING: return "C2X_GNU_WARNING";
    case ErrorAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExcludeFromExplicitInstantiationAttrSpelling e) {
  switch (e) {
    case ExcludeFromExplicitInstantiationAttrSpelling::GNU_EXCLUDE_FROM_EXPLICIT_INSTANTIATION: return "GNU_EXCLUDE_FROM_EXPLICIT_INSTANTIATION";
    case ExcludeFromExplicitInstantiationAttrSpelling::CXX11_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION: return "CXX11_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION";
    case ExcludeFromExplicitInstantiationAttrSpelling::C2X_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION: return "C2X_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION";
    case ExcludeFromExplicitInstantiationAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprConstantExprKind e) {
  switch (e) {
    case ExprConstantExprKind::NORMAL: return "NORMAL";
    case ExprConstantExprKind::NON_CLASS_TEMPLATE_ARGUMENT: return "NON_CLASS_TEMPLATE_ARGUMENT";
    case ExprConstantExprKind::CLASS_TEMPLATE_ARGUMENT: return "CLASS_TEMPLATE_ARGUMENT";
    case ExprConstantExprKind::IMMEDIATE_INVOCATION: return "IMMEDIATE_INVOCATION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprLValueClassification e) {
  switch (e) {
    case ExprLValueClassification::VALID: return "VALID";
    case ExprLValueClassification::NOT_OBJECT_TYPE: return "NOT_OBJECT_TYPE";
    case ExprLValueClassification::INCOMPLETE_VOID_TYPE: return "INCOMPLETE_VOID_TYPE";
    case ExprLValueClassification::DUPLICATE_VECTOR_COMPONENTS: return "DUPLICATE_VECTOR_COMPONENTS";
    case ExprLValueClassification::INVALID_EXPRESSION: return "INVALID_EXPRESSION";
    case ExprLValueClassification::INVALID_MESSAGE_EXPRESSION: return "INVALID_MESSAGE_EXPRESSION";
    case ExprLValueClassification::MEMBER_FUNCTION: return "MEMBER_FUNCTION";
    case ExprLValueClassification::SUB_OBJ_C_PROPERTY_SETTING: return "SUB_OBJ_C_PROPERTY_SETTING";
    case ExprLValueClassification::CLASS_TEMPORARY: return "CLASS_TEMPORARY";
    case ExprLValueClassification::ARRAY_TEMPORARY: return "ARRAY_TEMPORARY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprNullPointerConstantKind e) {
  switch (e) {
    case ExprNullPointerConstantKind::NOT_NULL: return "NOT_NULL";
    case ExprNullPointerConstantKind::ZERO_EXPRESSION: return "ZERO_EXPRESSION";
    case ExprNullPointerConstantKind::ZERO_LITERAL: return "ZERO_LITERAL";
    case ExprNullPointerConstantKind::CXX11_NULLPTR: return "CXX11_NULLPTR";
    case ExprNullPointerConstantKind::GNU_NULL: return "GNU_NULL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprNullPointerConstantValueDependence e) {
  switch (e) {
    case ExprNullPointerConstantValueDependence::NEVER_VALUE_DEPENDENT: return "NEVER_VALUE_DEPENDENT";
    case ExprNullPointerConstantValueDependence::VALUE_DEPENDENT_IS_NULL: return "VALUE_DEPENDENT_IS_NULL";
    case ExprNullPointerConstantValueDependence::VALUE_DEPENDENT_IS_NOT_NULL: return "VALUE_DEPENDENT_IS_NOT_NULL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprSideEffectsKind e) {
  switch (e) {
    case ExprSideEffectsKind::NO_SIDE_EFFECTS: return "NO_SIDE_EFFECTS";
    case ExprSideEffectsKind::ALLOW_UNDEFINED_BEHAVIOR: return "ALLOW_UNDEFINED_BEHAVIOR";
    case ExprSideEffectsKind::ALLOW_SIDE_EFFECTS: return "ALLOW_SIDE_EFFECTS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprisModifiableLvalueResult e) {
  switch (e) {
    case ExprisModifiableLvalueResult::VALID: return "VALID";
    case ExprisModifiableLvalueResult::NOT_OBJECT_TYPE: return "NOT_OBJECT_TYPE";
    case ExprisModifiableLvalueResult::INCOMPLETE_VOID_TYPE: return "INCOMPLETE_VOID_TYPE";
    case ExprisModifiableLvalueResult::DUPLICATE_VECTOR_COMPONENTS: return "DUPLICATE_VECTOR_COMPONENTS";
    case ExprisModifiableLvalueResult::INVALID_EXPRESSION: return "INVALID_EXPRESSION";
    case ExprisModifiableLvalueResult::L_VALUE_CAST: return "L_VALUE_CAST";
    case ExprisModifiableLvalueResult::INCOMPLETE_TYPE: return "INCOMPLETE_TYPE";
    case ExprisModifiableLvalueResult::CONST_QUALIFIED: return "CONST_QUALIFIED";
    case ExprisModifiableLvalueResult::CONST_QUALIFIED_FIELD: return "CONST_QUALIFIED_FIELD";
    case ExprisModifiableLvalueResult::CONST_ADDRESS_SPACE: return "CONST_ADDRESS_SPACE";
    case ExprisModifiableLvalueResult::ARRAY_TYPE: return "ARRAY_TYPE";
    case ExprisModifiableLvalueResult::NO_SETTER_PROPERTY: return "NO_SETTER_PROPERTY";
    case ExprisModifiableLvalueResult::MEMBER_FUNCTION: return "MEMBER_FUNCTION";
    case ExprisModifiableLvalueResult::SUB_OBJ_C_PROPERTY_SETTING: return "SUB_OBJ_C_PROPERTY_SETTING";
    case ExprisModifiableLvalueResult::INVALID_MESSAGE_EXPRESSION: return "INVALID_MESSAGE_EXPRESSION";
    case ExprisModifiableLvalueResult::CLASS_TEMPORARY: return "CLASS_TEMPORARY";
    case ExprisModifiableLvalueResult::ARRAY_TEMPORARY: return "ARRAY_TEMPORARY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExternalSourceSymbolAttrSpelling e) {
  switch (e) {
    case ExternalSourceSymbolAttrSpelling::GNU_EXTERNAL_SOURCE_SYMBOL: return "GNU_EXTERNAL_SOURCE_SYMBOL";
    case ExternalSourceSymbolAttrSpelling::CXX11_CLANG_EXTERNAL_SOURCE_SYMBOL: return "CXX11_CLANG_EXTERNAL_SOURCE_SYMBOL";
    case ExternalSourceSymbolAttrSpelling::C2X_CLANG_EXTERNAL_SOURCE_SYMBOL: return "C2X_CLANG_EXTERNAL_SOURCE_SYMBOL";
    case ExternalSourceSymbolAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FallThroughAttrSpelling e) {
  switch (e) {
    case FallThroughAttrSpelling::CXX11_FALLTHROUGH: return "CXX11_FALLTHROUGH";
    case FallThroughAttrSpelling::C2X_FALLTHROUGH: return "C2X_FALLTHROUGH";
    case FallThroughAttrSpelling::CXX11_CLANG_FALLTHROUGH: return "CXX11_CLANG_FALLTHROUGH";
    case FallThroughAttrSpelling::GNU_FALLTHROUGH: return "GNU_FALLTHROUGH";
    case FallThroughAttrSpelling::CXX11_GNU_FALLTHROUGH: return "CXX11_GNU_FALLTHROUGH";
    case FallThroughAttrSpelling::C2X_GNU_FALLTHROUGH: return "C2X_GNU_FALLTHROUGH";
    case FallThroughAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FastCallAttrSpelling e) {
  switch (e) {
    case FastCallAttrSpelling::GNU_FASTCALL: return "GNU_FASTCALL";
    case FastCallAttrSpelling::CXX11_GNU_FASTCALL: return "CXX11_GNU_FASTCALL";
    case FastCallAttrSpelling::C2X_GNU_FASTCALL: return "C2X_GNU_FASTCALL";
    case FastCallAttrSpelling::KEYWORD_FASTCALL: return "KEYWORD_FASTCALL";
    case FastCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FinalAttrSpelling e) {
  switch (e) {
    case FinalAttrSpelling::KEYWORD_FINAL: return "KEYWORD_FINAL";
    case FinalAttrSpelling::KEYWORD_SEALED: return "KEYWORD_SEALED";
    case FinalAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FlagEnumAttrSpelling e) {
  switch (e) {
    case FlagEnumAttrSpelling::GNU_FLAG_ENUM: return "GNU_FLAG_ENUM";
    case FlagEnumAttrSpelling::CXX11_CLANG_FLAG_ENUM: return "CXX11_CLANG_FLAG_ENUM";
    case FlagEnumAttrSpelling::C2X_CLANG_FLAG_ENUM: return "C2X_CLANG_FLAG_ENUM";
    case FlagEnumAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FlattenAttrSpelling e) {
  switch (e) {
    case FlattenAttrSpelling::GNU_FLATTEN: return "GNU_FLATTEN";
    case FlattenAttrSpelling::CXX11_GNU_FLATTEN: return "CXX11_GNU_FLATTEN";
    case FlattenAttrSpelling::C2X_GNU_FLATTEN: return "C2X_GNU_FLATTEN";
    case FlattenAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FormatArgAttrSpelling e) {
  switch (e) {
    case FormatArgAttrSpelling::GNU_FORMAT_ARGUMENT: return "GNU_FORMAT_ARGUMENT";
    case FormatArgAttrSpelling::CXX11_GNU_FORMAT_ARGUMENT: return "CXX11_GNU_FORMAT_ARGUMENT";
    case FormatArgAttrSpelling::C2X_GNU_FORMAT_ARGUMENT: return "C2X_GNU_FORMAT_ARGUMENT";
    case FormatArgAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FormatAttrSpelling e) {
  switch (e) {
    case FormatAttrSpelling::GNU_FORMAT: return "GNU_FORMAT";
    case FormatAttrSpelling::CXX11_GNU_FORMAT: return "CXX11_GNU_FORMAT";
    case FormatAttrSpelling::C2X_GNU_FORMAT: return "C2X_GNU_FORMAT";
    case FormatAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FunctionDeclTemplatedKind e) {
  switch (e) {
    case FunctionDeclTemplatedKind::NON_TEMPLATE: return "NON_TEMPLATE";
    case FunctionDeclTemplatedKind::FUNCTION_TEMPLATE: return "FUNCTION_TEMPLATE";
    case FunctionDeclTemplatedKind::MEMBER_SPECIALIZATION: return "MEMBER_SPECIALIZATION";
    case FunctionDeclTemplatedKind::FUNCTION_TEMPLATE_SPECIALIZATION: return "FUNCTION_TEMPLATE_SPECIALIZATION";
    case FunctionDeclTemplatedKind::DEPENDENT_FUNCTION_TEMPLATE_SPECIALIZATION: return "DEPENDENT_FUNCTION_TEMPLATE_SPECIALIZATION";
    case FunctionDeclTemplatedKind::DEPENDENT_NON_TEMPLATE: return "DEPENDENT_NON_TEMPLATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FunctionReturnThunksAttrKind e) {
  switch (e) {
    case FunctionReturnThunksAttrKind::KEEP: return "KEEP";
    case FunctionReturnThunksAttrKind::EXTERN: return "EXTERN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FunctionReturnThunksAttrSpelling e) {
  switch (e) {
    case FunctionReturnThunksAttrSpelling::GNU_FUNCTION_RETURN: return "GNU_FUNCTION_RETURN";
    case FunctionReturnThunksAttrSpelling::CXX11_GNU_FUNCTION_RETURN: return "CXX11_GNU_FUNCTION_RETURN";
    case FunctionReturnThunksAttrSpelling::C2X_GNU_FUNCTION_RETURN: return "C2X_GNU_FUNCTION_RETURN";
    case FunctionReturnThunksAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GNUInlineAttrSpelling e) {
  switch (e) {
    case GNUInlineAttrSpelling::GNU_GNU_INLINE: return "GNU_GNU_INLINE";
    case GNUInlineAttrSpelling::CXX11_GNU_GNU_INLINE: return "CXX11_GNU_GNU_INLINE";
    case GNUInlineAttrSpelling::C2X_GNU_GNU_INLINE: return "C2X_GNU_GNU_INLINE";
    case GNUInlineAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GuardedVarAttrSpelling e) {
  switch (e) {
    case GuardedVarAttrSpelling::GNU_GUARDED_VARIABLE: return "GNU_GUARDED_VARIABLE";
    case GuardedVarAttrSpelling::CXX11_CLANG_GUARDED_VARIABLE: return "CXX11_CLANG_GUARDED_VARIABLE";
    case GuardedVarAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(HIPManagedAttrSpelling e) {
  switch (e) {
    case HIPManagedAttrSpelling::GNU_MANAGED: return "GNU_MANAGED";
    case HIPManagedAttrSpelling::DECLSPEC_MANAGED: return "DECLSPEC_MANAGED";
    case HIPManagedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(HLSLShaderAttrShaderType e) {
  switch (e) {
    case HLSLShaderAttrShaderType::PIXEL: return "PIXEL";
    case HLSLShaderAttrShaderType::VERTEX: return "VERTEX";
    case HLSLShaderAttrShaderType::GEOMETRY: return "GEOMETRY";
    case HLSLShaderAttrShaderType::HULL: return "HULL";
    case HLSLShaderAttrShaderType::DOMAIN_: return "DOMAIN_";
    case HLSLShaderAttrShaderType::COMPUTE: return "COMPUTE";
    case HLSLShaderAttrShaderType::RAY_GENERATION: return "RAY_GENERATION";
    case HLSLShaderAttrShaderType::INTERSECTION: return "INTERSECTION";
    case HLSLShaderAttrShaderType::ANY_HIT: return "ANY_HIT";
    case HLSLShaderAttrShaderType::CLOSEST_HIT: return "CLOSEST_HIT";
    case HLSLShaderAttrShaderType::MISS: return "MISS";
    case HLSLShaderAttrShaderType::CALLABLE: return "CALLABLE";
    case HLSLShaderAttrShaderType::MESH: return "MESH";
    case HLSLShaderAttrShaderType::AMPLIFICATION: return "AMPLIFICATION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(HotAttrSpelling e) {
  switch (e) {
    case HotAttrSpelling::GNU_HOT: return "GNU_HOT";
    case HotAttrSpelling::CXX11_GNU_HOT: return "CXX11_GNU_HOT";
    case HotAttrSpelling::C2X_GNU_HOT: return "C2X_GNU_HOT";
    case HotAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IBActionAttrSpelling e) {
  switch (e) {
    case IBActionAttrSpelling::GNU_IBACTION: return "GNU_IBACTION";
    case IBActionAttrSpelling::CXX11_CLANG_IBACTION: return "CXX11_CLANG_IBACTION";
    case IBActionAttrSpelling::C2X_CLANG_IBACTION: return "C2X_CLANG_IBACTION";
    case IBActionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IBOutletAttrSpelling e) {
  switch (e) {
    case IBOutletAttrSpelling::GNU_IBOUTLET: return "GNU_IBOUTLET";
    case IBOutletAttrSpelling::CXX11_CLANG_IBOUTLET: return "CXX11_CLANG_IBOUTLET";
    case IBOutletAttrSpelling::C2X_CLANG_IBOUTLET: return "C2X_CLANG_IBOUTLET";
    case IBOutletAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IBOutletCollectionAttrSpelling e) {
  switch (e) {
    case IBOutletCollectionAttrSpelling::GNU_IBOUTLETCOLLECTION: return "GNU_IBOUTLETCOLLECTION";
    case IBOutletCollectionAttrSpelling::CXX11_CLANG_IBOUTLETCOLLECTION: return "CXX11_CLANG_IBOUTLETCOLLECTION";
    case IBOutletCollectionAttrSpelling::C2X_CLANG_IBOUTLETCOLLECTION: return "C2X_CLANG_IBOUTLETCOLLECTION";
    case IBOutletCollectionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IFuncAttrSpelling e) {
  switch (e) {
    case IFuncAttrSpelling::GNU_IFUNC: return "GNU_IFUNC";
    case IFuncAttrSpelling::CXX11_GNU_IFUNC: return "CXX11_GNU_IFUNC";
    case IFuncAttrSpelling::C2X_GNU_IFUNC: return "C2X_GNU_IFUNC";
    case IFuncAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ImplicitCastExprOnStack e) {
  switch (e) {
    case ImplicitCastExprOnStack::ON_STACK: return "ON_STACK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ImplicitParamDeclImplicitParamKind e) {
  switch (e) {
    case ImplicitParamDeclImplicitParamKind::OBJ_C_SELF: return "OBJ_C_SELF";
    case ImplicitParamDeclImplicitParamKind::OBJ_C_CMD: return "OBJ_C_CMD";
    case ImplicitParamDeclImplicitParamKind::CXX_THIS: return "CXX_THIS";
    case ImplicitParamDeclImplicitParamKind::CXXVTT: return "CXXVTT";
    case ImplicitParamDeclImplicitParamKind::CAPTURED_CONTEXT: return "CAPTURED_CONTEXT";
    case ImplicitParamDeclImplicitParamKind::THREAD_PRIVATE_VARIABLE: return "THREAD_PRIVATE_VARIABLE";
    case ImplicitParamDeclImplicitParamKind::OTHER: return "OTHER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InitPriorityAttrSpelling e) {
  switch (e) {
    case InitPriorityAttrSpelling::GNU_INITIALIZER_PRIORITY: return "GNU_INITIALIZER_PRIORITY";
    case InitPriorityAttrSpelling::CXX11_GNU_INITIALIZER_PRIORITY: return "CXX11_GNU_INITIALIZER_PRIORITY";
    case InitPriorityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IntelOclBiccAttrSpelling e) {
  switch (e) {
    case IntelOclBiccAttrSpelling::GNU_INTEL_OCL_BICC: return "GNU_INTEL_OCL_BICC";
    case IntelOclBiccAttrSpelling::CXX11_CLANG_INTEL_OCL_BICC: return "CXX11_CLANG_INTEL_OCL_BICC";
    case IntelOclBiccAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InternalLinkageAttrSpelling e) {
  switch (e) {
    case InternalLinkageAttrSpelling::GNU_INTERNAL_LINKAGE: return "GNU_INTERNAL_LINKAGE";
    case InternalLinkageAttrSpelling::CXX11_CLANG_INTERNAL_LINKAGE: return "CXX11_CLANG_INTERNAL_LINKAGE";
    case InternalLinkageAttrSpelling::C2X_CLANG_INTERNAL_LINKAGE: return "C2X_CLANG_INTERNAL_LINKAGE";
    case InternalLinkageAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LTOVisibilityPublicAttrSpelling e) {
  switch (e) {
    case LTOVisibilityPublicAttrSpelling::GNU_LTO_VISIBILITY_PUBLIC: return "GNU_LTO_VISIBILITY_PUBLIC";
    case LTOVisibilityPublicAttrSpelling::CXX11_CLANG_LTO_VISIBILITY_PUBLIC: return "CXX11_CLANG_LTO_VISIBILITY_PUBLIC";
    case LTOVisibilityPublicAttrSpelling::C2X_CLANG_LTO_VISIBILITY_PUBLIC: return "C2X_CLANG_LTO_VISIBILITY_PUBLIC";
    case LTOVisibilityPublicAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LeafAttrSpelling e) {
  switch (e) {
    case LeafAttrSpelling::GNU_LEAF: return "GNU_LEAF";
    case LeafAttrSpelling::CXX11_GNU_LEAF: return "CXX11_GNU_LEAF";
    case LeafAttrSpelling::C2X_GNU_LEAF: return "C2X_GNU_LEAF";
    case LeafAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LifetimeBoundAttrSpelling e) {
  switch (e) {
    case LifetimeBoundAttrSpelling::GNU_LIFETIMEBOUND: return "GNU_LIFETIMEBOUND";
    case LifetimeBoundAttrSpelling::CXX11_CLANG_LIFETIMEBOUND: return "CXX11_CLANG_LIFETIMEBOUND";
    case LifetimeBoundAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LikelyAttrSpelling e) {
  switch (e) {
    case LikelyAttrSpelling::CXX11_LIKELY: return "CXX11_LIKELY";
    case LikelyAttrSpelling::C2X_CLANG_LIKELY: return "C2X_CLANG_LIKELY";
    case LikelyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LinkageSpecDeclLanguageIDs e) {
  switch (e) {
    case LinkageSpecDeclLanguageIDs::C: return "C";
    case LinkageSpecDeclLanguageIDs::CXX: return "CXX";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LoaderUninitializedAttrSpelling e) {
  switch (e) {
    case LoaderUninitializedAttrSpelling::GNU_LOADER_UNINITIALIZED: return "GNU_LOADER_UNINITIALIZED";
    case LoaderUninitializedAttrSpelling::CXX11_CLANG_LOADER_UNINITIALIZED: return "CXX11_CLANG_LOADER_UNINITIALIZED";
    case LoaderUninitializedAttrSpelling::C2X_CLANG_LOADER_UNINITIALIZED: return "C2X_CLANG_LOADER_UNINITIALIZED";
    case LoaderUninitializedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LoopHintAttrLoopHintState e) {
  switch (e) {
    case LoopHintAttrLoopHintState::ENABLE: return "ENABLE";
    case LoopHintAttrLoopHintState::DISABLE: return "DISABLE";
    case LoopHintAttrLoopHintState::NUMERIC: return "NUMERIC";
    case LoopHintAttrLoopHintState::FIXED_WIDTH: return "FIXED_WIDTH";
    case LoopHintAttrLoopHintState::SCALABLE_WIDTH: return "SCALABLE_WIDTH";
    case LoopHintAttrLoopHintState::ASSUME_SAFETY: return "ASSUME_SAFETY";
    case LoopHintAttrLoopHintState::FULL: return "FULL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LoopHintAttrOptionType e) {
  switch (e) {
    case LoopHintAttrOptionType::VECTORIZE: return "VECTORIZE";
    case LoopHintAttrOptionType::VECTORIZE_WIDTH: return "VECTORIZE_WIDTH";
    case LoopHintAttrOptionType::INTERLEAVE: return "INTERLEAVE";
    case LoopHintAttrOptionType::INTERLEAVE_COUNT: return "INTERLEAVE_COUNT";
    case LoopHintAttrOptionType::UNROLL: return "UNROLL";
    case LoopHintAttrOptionType::UNROLL_COUNT: return "UNROLL_COUNT";
    case LoopHintAttrOptionType::UNROLL_AND_JAM: return "UNROLL_AND_JAM";
    case LoopHintAttrOptionType::UNROLL_AND_JAM_COUNT: return "UNROLL_AND_JAM_COUNT";
    case LoopHintAttrOptionType::PIPELINE_DISABLED: return "PIPELINE_DISABLED";
    case LoopHintAttrOptionType::PIPELINE_INITIATION_INTERVAL: return "PIPELINE_INITIATION_INTERVAL";
    case LoopHintAttrOptionType::DISTRIBUTE: return "DISTRIBUTE";
    case LoopHintAttrOptionType::VECTORIZE_PREDICATE: return "VECTORIZE_PREDICATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LoopHintAttrSpelling e) {
  switch (e) {
    case LoopHintAttrSpelling::PRAGMA_CLANG_LOOP: return "PRAGMA_CLANG_LOOP";
    case LoopHintAttrSpelling::PRAGMA_UNROLL: return "PRAGMA_UNROLL";
    case LoopHintAttrSpelling::PRAGMA_NOUNROLL: return "PRAGMA_NOUNROLL";
    case LoopHintAttrSpelling::PRAGMA_UNROLL_AND_JAM: return "PRAGMA_UNROLL_AND_JAM";
    case LoopHintAttrSpelling::PRAGMA_NOUNROLL_AND_JAM: return "PRAGMA_NOUNROLL_AND_JAM";
    case LoopHintAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MIGServerRoutineAttrSpelling e) {
  switch (e) {
    case MIGServerRoutineAttrSpelling::GNU_MIG_SERVER_ROUTINE: return "GNU_MIG_SERVER_ROUTINE";
    case MIGServerRoutineAttrSpelling::CXX11_CLANG_MIG_SERVER_ROUTINE: return "CXX11_CLANG_MIG_SERVER_ROUTINE";
    case MIGServerRoutineAttrSpelling::C2X_CLANG_MIG_SERVER_ROUTINE: return "C2X_CLANG_MIG_SERVER_ROUTINE";
    case MIGServerRoutineAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSABIAttrSpelling e) {
  switch (e) {
    case MSABIAttrSpelling::GNU_MS_ABI: return "GNU_MS_ABI";
    case MSABIAttrSpelling::CXX11_GNU_MS_ABI: return "CXX11_GNU_MS_ABI";
    case MSABIAttrSpelling::C2X_GNU_MS_ABI: return "C2X_GNU_MS_ABI";
    case MSABIAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSInheritanceAttrSpelling e) {
  switch (e) {
    case MSInheritanceAttrSpelling::KEYWORD_SINGLE_INHERITANCE: return "KEYWORD_SINGLE_INHERITANCE";
    case MSInheritanceAttrSpelling::KEYWORD_MULTIPLE_INHERITANCE: return "KEYWORD_MULTIPLE_INHERITANCE";
    case MSInheritanceAttrSpelling::KEYWORD_VIRTUAL_INHERITANCE: return "KEYWORD_VIRTUAL_INHERITANCE";
    case MSInheritanceAttrSpelling::KEYWORD_UNSPECIFIED_INHERITANCE: return "KEYWORD_UNSPECIFIED_INHERITANCE";
    case MSInheritanceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSP430InterruptAttrSpelling e) {
  switch (e) {
    case MSP430InterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case MSP430InterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case MSP430InterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case MSP430InterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSStructAttrSpelling e) {
  switch (e) {
    case MSStructAttrSpelling::GNU_MS_STRUCT: return "GNU_MS_STRUCT";
    case MSStructAttrSpelling::CXX11_GNU_MS_STRUCT: return "CXX11_GNU_MS_STRUCT";
    case MSStructAttrSpelling::C2X_GNU_MS_STRUCT: return "C2X_GNU_MS_STRUCT";
    case MSStructAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MayAliasAttrSpelling e) {
  switch (e) {
    case MayAliasAttrSpelling::GNU_MAY_ALIAS: return "GNU_MAY_ALIAS";
    case MayAliasAttrSpelling::CXX11_GNU_MAY_ALIAS: return "CXX11_GNU_MAY_ALIAS";
    case MayAliasAttrSpelling::C2X_GNU_MAY_ALIAS: return "C2X_GNU_MAY_ALIAS";
    case MayAliasAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MicroMipsAttrSpelling e) {
  switch (e) {
    case MicroMipsAttrSpelling::GNU_MICROMIPS: return "GNU_MICROMIPS";
    case MicroMipsAttrSpelling::CXX11_GNU_MICROMIPS: return "CXX11_GNU_MICROMIPS";
    case MicroMipsAttrSpelling::C2X_GNU_MICROMIPS: return "C2X_GNU_MICROMIPS";
    case MicroMipsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MinSizeAttrSpelling e) {
  switch (e) {
    case MinSizeAttrSpelling::GNU_MINSIZE: return "GNU_MINSIZE";
    case MinSizeAttrSpelling::CXX11_CLANG_MINSIZE: return "CXX11_CLANG_MINSIZE";
    case MinSizeAttrSpelling::C2X_CLANG_MINSIZE: return "C2X_CLANG_MINSIZE";
    case MinSizeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MinVectorWidthAttrSpelling e) {
  switch (e) {
    case MinVectorWidthAttrSpelling::GNU_MIN_VECTOR_WIDTH: return "GNU_MIN_VECTOR_WIDTH";
    case MinVectorWidthAttrSpelling::CXX11_CLANG_MIN_VECTOR_WIDTH: return "CXX11_CLANG_MIN_VECTOR_WIDTH";
    case MinVectorWidthAttrSpelling::C2X_CLANG_MIN_VECTOR_WIDTH: return "C2X_CLANG_MIN_VECTOR_WIDTH";
    case MinVectorWidthAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Mips16AttrSpelling e) {
  switch (e) {
    case Mips16AttrSpelling::GNU_MIPS16: return "GNU_MIPS16";
    case Mips16AttrSpelling::CXX11_GNU_MIPS16: return "CXX11_GNU_MIPS16";
    case Mips16AttrSpelling::C2X_GNU_MIPS16: return "C2X_GNU_MIPS16";
    case Mips16AttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MipsInterruptAttrInterruptType e) {
  switch (e) {
    case MipsInterruptAttrInterruptType::SW0: return "SW0";
    case MipsInterruptAttrInterruptType::SW1: return "SW1";
    case MipsInterruptAttrInterruptType::HW0: return "HW0";
    case MipsInterruptAttrInterruptType::HW1: return "HW1";
    case MipsInterruptAttrInterruptType::HW2: return "HW2";
    case MipsInterruptAttrInterruptType::HW3: return "HW3";
    case MipsInterruptAttrInterruptType::HW4: return "HW4";
    case MipsInterruptAttrInterruptType::HW5: return "HW5";
    case MipsInterruptAttrInterruptType::EIC: return "EIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MipsInterruptAttrSpelling e) {
  switch (e) {
    case MipsInterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case MipsInterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case MipsInterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case MipsInterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MipsLongCallAttrSpelling e) {
  switch (e) {
    case MipsLongCallAttrSpelling::GNU_LONG_CALL: return "GNU_LONG_CALL";
    case MipsLongCallAttrSpelling::CXX11_GNU_LONG_CALL: return "CXX11_GNU_LONG_CALL";
    case MipsLongCallAttrSpelling::C2X_GNU_LONG_CALL: return "C2X_GNU_LONG_CALL";
    case MipsLongCallAttrSpelling::GNU_FAR: return "GNU_FAR";
    case MipsLongCallAttrSpelling::CXX11_GNU_FAR: return "CXX11_GNU_FAR";
    case MipsLongCallAttrSpelling::C2X_GNU_FAR: return "C2X_GNU_FAR";
    case MipsLongCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MipsShortCallAttrSpelling e) {
  switch (e) {
    case MipsShortCallAttrSpelling::GNU_SHORT_CALL: return "GNU_SHORT_CALL";
    case MipsShortCallAttrSpelling::CXX11_GNU_SHORT_CALL: return "CXX11_GNU_SHORT_CALL";
    case MipsShortCallAttrSpelling::C2X_GNU_SHORT_CALL: return "C2X_GNU_SHORT_CALL";
    case MipsShortCallAttrSpelling::GNU_NEAR: return "GNU_NEAR";
    case MipsShortCallAttrSpelling::CXX11_GNU_NEAR: return "CXX11_GNU_NEAR";
    case MipsShortCallAttrSpelling::C2X_GNU_NEAR: return "C2X_GNU_NEAR";
    case MipsShortCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ModeAttrSpelling e) {
  switch (e) {
    case ModeAttrSpelling::GNU_MODE: return "GNU_MODE";
    case ModeAttrSpelling::CXX11_GNU_MODE: return "CXX11_GNU_MODE";
    case ModeAttrSpelling::C2X_GNU_MODE: return "C2X_GNU_MODE";
    case ModeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MustTailAttrSpelling e) {
  switch (e) {
    case MustTailAttrSpelling::GNU_MUSTTAIL: return "GNU_MUSTTAIL";
    case MustTailAttrSpelling::CXX11_CLANG_MUSTTAIL: return "CXX11_CLANG_MUSTTAIL";
    case MustTailAttrSpelling::C2X_CLANG_MUSTTAIL: return "C2X_CLANG_MUSTTAIL";
    case MustTailAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NSConsumedAttrSpelling e) {
  switch (e) {
    case NSConsumedAttrSpelling::GNU_NS_CONSUMED: return "GNU_NS_CONSUMED";
    case NSConsumedAttrSpelling::CXX11_CLANG_NS_CONSUMED: return "CXX11_CLANG_NS_CONSUMED";
    case NSConsumedAttrSpelling::C2X_CLANG_NS_CONSUMED: return "C2X_CLANG_NS_CONSUMED";
    case NSConsumedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NSConsumesSelfAttrSpelling e) {
  switch (e) {
    case NSConsumesSelfAttrSpelling::GNU_NS_CONSUMES_SELF: return "GNU_NS_CONSUMES_SELF";
    case NSConsumesSelfAttrSpelling::CXX11_CLANG_NS_CONSUMES_SELF: return "CXX11_CLANG_NS_CONSUMES_SELF";
    case NSConsumesSelfAttrSpelling::C2X_CLANG_NS_CONSUMES_SELF: return "C2X_CLANG_NS_CONSUMES_SELF";
    case NSConsumesSelfAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NSReturnsAutoreleasedAttrSpelling e) {
  switch (e) {
    case NSReturnsAutoreleasedAttrSpelling::GNU_NS_RETURNS_AUTORELEASED: return "GNU_NS_RETURNS_AUTORELEASED";
    case NSReturnsAutoreleasedAttrSpelling::CXX11_CLANG_NS_RETURNS_AUTORELEASED: return "CXX11_CLANG_NS_RETURNS_AUTORELEASED";
    case NSReturnsAutoreleasedAttrSpelling::C2X_CLANG_NS_RETURNS_AUTORELEASED: return "C2X_CLANG_NS_RETURNS_AUTORELEASED";
    case NSReturnsAutoreleasedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NSReturnsNotRetainedAttrSpelling e) {
  switch (e) {
    case NSReturnsNotRetainedAttrSpelling::GNU_NS_RETURNS_NOT_RETAINED: return "GNU_NS_RETURNS_NOT_RETAINED";
    case NSReturnsNotRetainedAttrSpelling::CXX11_CLANG_NS_RETURNS_NOT_RETAINED: return "CXX11_CLANG_NS_RETURNS_NOT_RETAINED";
    case NSReturnsNotRetainedAttrSpelling::C2X_CLANG_NS_RETURNS_NOT_RETAINED: return "C2X_CLANG_NS_RETURNS_NOT_RETAINED";
    case NSReturnsNotRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NSReturnsRetainedAttrSpelling e) {
  switch (e) {
    case NSReturnsRetainedAttrSpelling::GNU_NS_RETURNS_RETAINED: return "GNU_NS_RETURNS_RETAINED";
    case NSReturnsRetainedAttrSpelling::CXX11_CLANG_NS_RETURNS_RETAINED: return "CXX11_CLANG_NS_RETURNS_RETAINED";
    case NSReturnsRetainedAttrSpelling::C2X_CLANG_NS_RETURNS_RETAINED: return "C2X_CLANG_NS_RETURNS_RETAINED";
    case NSReturnsRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NakedAttrSpelling e) {
  switch (e) {
    case NakedAttrSpelling::GNU_NAKED: return "GNU_NAKED";
    case NakedAttrSpelling::CXX11_GNU_NAKED: return "CXX11_GNU_NAKED";
    case NakedAttrSpelling::C2X_GNU_NAKED: return "C2X_GNU_NAKED";
    case NakedAttrSpelling::DECLSPEC_NAKED: return "DECLSPEC_NAKED";
    case NakedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NamedDeclExplicitVisibilityKind e) {
  switch (e) {
    case NamedDeclExplicitVisibilityKind::VISIBILITY_FOR_TYPE: return "VISIBILITY_FOR_TYPE";
    case NamedDeclExplicitVisibilityKind::VISIBILITY_FOR_VALUE: return "VISIBILITY_FOR_VALUE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoBuiltinAttrSpelling e) {
  switch (e) {
    case NoBuiltinAttrSpelling::GNU_NO_BUILTIN: return "GNU_NO_BUILTIN";
    case NoBuiltinAttrSpelling::CXX11_CLANG_NO_BUILTIN: return "CXX11_CLANG_NO_BUILTIN";
    case NoBuiltinAttrSpelling::C2X_CLANG_NO_BUILTIN: return "C2X_CLANG_NO_BUILTIN";
    case NoBuiltinAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoCommonAttrSpelling e) {
  switch (e) {
    case NoCommonAttrSpelling::GNU_NOCOMMON: return "GNU_NOCOMMON";
    case NoCommonAttrSpelling::CXX11_GNU_NOCOMMON: return "CXX11_GNU_NOCOMMON";
    case NoCommonAttrSpelling::C2X_GNU_NOCOMMON: return "C2X_GNU_NOCOMMON";
    case NoCommonAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoDebugAttrSpelling e) {
  switch (e) {
    case NoDebugAttrSpelling::GNU_NODEBUG: return "GNU_NODEBUG";
    case NoDebugAttrSpelling::CXX11_GNU_NODEBUG: return "CXX11_GNU_NODEBUG";
    case NoDebugAttrSpelling::C2X_GNU_NODEBUG: return "C2X_GNU_NODEBUG";
    case NoDebugAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoDerefAttrSpelling e) {
  switch (e) {
    case NoDerefAttrSpelling::GNU_NODEREF: return "GNU_NODEREF";
    case NoDerefAttrSpelling::CXX11_CLANG_NODEREF: return "CXX11_CLANG_NODEREF";
    case NoDerefAttrSpelling::C2X_CLANG_NODEREF: return "C2X_CLANG_NODEREF";
    case NoDerefAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoDestroyAttrSpelling e) {
  switch (e) {
    case NoDestroyAttrSpelling::GNU_NO_DESTROY: return "GNU_NO_DESTROY";
    case NoDestroyAttrSpelling::CXX11_CLANG_NO_DESTROY: return "CXX11_CLANG_NO_DESTROY";
    case NoDestroyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoDuplicateAttrSpelling e) {
  switch (e) {
    case NoDuplicateAttrSpelling::GNU_NODUPLICATE: return "GNU_NODUPLICATE";
    case NoDuplicateAttrSpelling::CXX11_CLANG_NODUPLICATE: return "CXX11_CLANG_NODUPLICATE";
    case NoDuplicateAttrSpelling::C2X_CLANG_NODUPLICATE: return "C2X_CLANG_NODUPLICATE";
    case NoDuplicateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoEscapeAttrSpelling e) {
  switch (e) {
    case NoEscapeAttrSpelling::GNU_NOESCAPE: return "GNU_NOESCAPE";
    case NoEscapeAttrSpelling::CXX11_CLANG_NOESCAPE: return "CXX11_CLANG_NOESCAPE";
    case NoEscapeAttrSpelling::C2X_CLANG_NOESCAPE: return "C2X_CLANG_NOESCAPE";
    case NoEscapeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoInlineAttrSpelling e) {
  switch (e) {
    case NoInlineAttrSpelling::KEYWORD_NOINLINE: return "KEYWORD_NOINLINE";
    case NoInlineAttrSpelling::GNU_NOINLINE: return "GNU_NOINLINE";
    case NoInlineAttrSpelling::CXX11_GNU_NOINLINE: return "CXX11_GNU_NOINLINE";
    case NoInlineAttrSpelling::C2X_GNU_NOINLINE: return "C2X_GNU_NOINLINE";
    case NoInlineAttrSpelling::CXX11_CLANG_NOINLINE: return "CXX11_CLANG_NOINLINE";
    case NoInlineAttrSpelling::C2X_CLANG_NOINLINE: return "C2X_CLANG_NOINLINE";
    case NoInlineAttrSpelling::DECLSPEC_NOINLINE: return "DECLSPEC_NOINLINE";
    case NoInlineAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoInstrumentFunctionAttrSpelling e) {
  switch (e) {
    case NoInstrumentFunctionAttrSpelling::GNU_NO_INSTRUMENT_FUNCTION: return "GNU_NO_INSTRUMENT_FUNCTION";
    case NoInstrumentFunctionAttrSpelling::CXX11_GNU_NO_INSTRUMENT_FUNCTION: return "CXX11_GNU_NO_INSTRUMENT_FUNCTION";
    case NoInstrumentFunctionAttrSpelling::C2X_GNU_NO_INSTRUMENT_FUNCTION: return "C2X_GNU_NO_INSTRUMENT_FUNCTION";
    case NoInstrumentFunctionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoMergeAttrSpelling e) {
  switch (e) {
    case NoMergeAttrSpelling::GNU_NOMERGE: return "GNU_NOMERGE";
    case NoMergeAttrSpelling::CXX11_CLANG_NOMERGE: return "CXX11_CLANG_NOMERGE";
    case NoMergeAttrSpelling::C2X_CLANG_NOMERGE: return "C2X_CLANG_NOMERGE";
    case NoMergeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoMicroMipsAttrSpelling e) {
  switch (e) {
    case NoMicroMipsAttrSpelling::GNU_NOMICROMIPS: return "GNU_NOMICROMIPS";
    case NoMicroMipsAttrSpelling::CXX11_GNU_NOMICROMIPS: return "CXX11_GNU_NOMICROMIPS";
    case NoMicroMipsAttrSpelling::C2X_GNU_NOMICROMIPS: return "C2X_GNU_NOMICROMIPS";
    case NoMicroMipsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoMips16AttrSpelling e) {
  switch (e) {
    case NoMips16AttrSpelling::GNU_NOMIPS16: return "GNU_NOMIPS16";
    case NoMips16AttrSpelling::CXX11_GNU_NOMIPS16: return "CXX11_GNU_NOMIPS16";
    case NoMips16AttrSpelling::C2X_GNU_NOMIPS16: return "C2X_GNU_NOMIPS16";
    case NoMips16AttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoProfileFunctionAttrSpelling e) {
  switch (e) {
    case NoProfileFunctionAttrSpelling::GNU_NO_PROFILE_INSTRUMENT_FUNCTION: return "GNU_NO_PROFILE_INSTRUMENT_FUNCTION";
    case NoProfileFunctionAttrSpelling::CXX11_GNU_NO_PROFILE_INSTRUMENT_FUNCTION: return "CXX11_GNU_NO_PROFILE_INSTRUMENT_FUNCTION";
    case NoProfileFunctionAttrSpelling::C2X_GNU_NO_PROFILE_INSTRUMENT_FUNCTION: return "C2X_GNU_NO_PROFILE_INSTRUMENT_FUNCTION";
    case NoProfileFunctionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoRandomizeLayoutAttrSpelling e) {
  switch (e) {
    case NoRandomizeLayoutAttrSpelling::GNU_NO_RANDOMIZE_LAYOUT: return "GNU_NO_RANDOMIZE_LAYOUT";
    case NoRandomizeLayoutAttrSpelling::CXX11_GNU_NO_RANDOMIZE_LAYOUT: return "CXX11_GNU_NO_RANDOMIZE_LAYOUT";
    case NoRandomizeLayoutAttrSpelling::C2X_GNU_NO_RANDOMIZE_LAYOUT: return "C2X_GNU_NO_RANDOMIZE_LAYOUT";
    case NoRandomizeLayoutAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoReturnAttrSpelling e) {
  switch (e) {
    case NoReturnAttrSpelling::GNU_NORETURN: return "GNU_NORETURN";
    case NoReturnAttrSpelling::CXX11_GNU_NORETURN: return "CXX11_GNU_NORETURN";
    case NoReturnAttrSpelling::C2X_GNU_NORETURN: return "C2X_GNU_NORETURN";
    case NoReturnAttrSpelling::DECLSPEC_NORETURN: return "DECLSPEC_NORETURN";
    case NoReturnAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoSanitizeAttrSpelling e) {
  switch (e) {
    case NoSanitizeAttrSpelling::GNU_NO_SANITIZE: return "GNU_NO_SANITIZE";
    case NoSanitizeAttrSpelling::CXX11_CLANG_NO_SANITIZE: return "CXX11_CLANG_NO_SANITIZE";
    case NoSanitizeAttrSpelling::C2X_CLANG_NO_SANITIZE: return "C2X_CLANG_NO_SANITIZE";
    case NoSanitizeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoSpeculativeLoadHardeningAttrSpelling e) {
  switch (e) {
    case NoSpeculativeLoadHardeningAttrSpelling::GNU_NO_SPECULATIVE_LOAD_HARDENING: return "GNU_NO_SPECULATIVE_LOAD_HARDENING";
    case NoSpeculativeLoadHardeningAttrSpelling::CXX11_CLANG_NO_SPECULATIVE_LOAD_HARDENING: return "CXX11_CLANG_NO_SPECULATIVE_LOAD_HARDENING";
    case NoSpeculativeLoadHardeningAttrSpelling::C2X_CLANG_NO_SPECULATIVE_LOAD_HARDENING: return "C2X_CLANG_NO_SPECULATIVE_LOAD_HARDENING";
    case NoSpeculativeLoadHardeningAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoSplitStackAttrSpelling e) {
  switch (e) {
    case NoSplitStackAttrSpelling::GNU_NO_SPLIT_STACK: return "GNU_NO_SPLIT_STACK";
    case NoSplitStackAttrSpelling::CXX11_GNU_NO_SPLIT_STACK: return "CXX11_GNU_NO_SPLIT_STACK";
    case NoSplitStackAttrSpelling::C2X_GNU_NO_SPLIT_STACK: return "C2X_GNU_NO_SPLIT_STACK";
    case NoSplitStackAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoStackProtectorAttrSpelling e) {
  switch (e) {
    case NoStackProtectorAttrSpelling::GNU_NO_STACK_PROTECTOR: return "GNU_NO_STACK_PROTECTOR";
    case NoStackProtectorAttrSpelling::CXX11_CLANG_NO_STACK_PROTECTOR: return "CXX11_CLANG_NO_STACK_PROTECTOR";
    case NoStackProtectorAttrSpelling::C2X_CLANG_NO_STACK_PROTECTOR: return "C2X_CLANG_NO_STACK_PROTECTOR";
    case NoStackProtectorAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoThreadSafetyAnalysisAttrSpelling e) {
  switch (e) {
    case NoThreadSafetyAnalysisAttrSpelling::GNU_NO_THREAD_SAFETY_ANALYSIS: return "GNU_NO_THREAD_SAFETY_ANALYSIS";
    case NoThreadSafetyAnalysisAttrSpelling::CXX11_CLANG_NO_THREAD_SAFETY_ANALYSIS: return "CXX11_CLANG_NO_THREAD_SAFETY_ANALYSIS";
    case NoThreadSafetyAnalysisAttrSpelling::C2X_CLANG_NO_THREAD_SAFETY_ANALYSIS: return "C2X_CLANG_NO_THREAD_SAFETY_ANALYSIS";
    case NoThreadSafetyAnalysisAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NoThrowAttrSpelling e) {
  switch (e) {
    case NoThrowAttrSpelling::GNU_NOTHROW: return "GNU_NOTHROW";
    case NoThrowAttrSpelling::CXX11_GNU_NOTHROW: return "CXX11_GNU_NOTHROW";
    case NoThrowAttrSpelling::C2X_GNU_NOTHROW: return "C2X_GNU_NOTHROW";
    case NoThrowAttrSpelling::DECLSPEC_NOTHROW: return "DECLSPEC_NOTHROW";
    case NoThrowAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NonNullAttrSpelling e) {
  switch (e) {
    case NonNullAttrSpelling::GNU_NONNULL: return "GNU_NONNULL";
    case NonNullAttrSpelling::CXX11_GNU_NONNULL: return "CXX11_GNU_NONNULL";
    case NonNullAttrSpelling::C2X_GNU_NONNULL: return "C2X_GNU_NONNULL";
    case NonNullAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NotTailCalledAttrSpelling e) {
  switch (e) {
    case NotTailCalledAttrSpelling::GNU_NOT_TAIL_CALLED: return "GNU_NOT_TAIL_CALLED";
    case NotTailCalledAttrSpelling::CXX11_CLANG_NOT_TAIL_CALLED: return "CXX11_CLANG_NOT_TAIL_CALLED";
    case NotTailCalledAttrSpelling::C2X_CLANG_NOT_TAIL_CALLED: return "C2X_CLANG_NOT_TAIL_CALLED";
    case NotTailCalledAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPAllocateDeclAttrAllocatorTypeTy e) {
  switch (e) {
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_NULL_MEMORY_ALLOC: return "OMP_NULL_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_DEFAULT_MEMORY_ALLOC: return "OMP_DEFAULT_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_LARGE_CAP_MEMORY_ALLOC: return "OMP_LARGE_CAP_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_CONST_MEMORY_ALLOC: return "OMP_CONST_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_HIGH_BW_MEMORY_ALLOC: return "OMP_HIGH_BW_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_LOW_LAT_MEMORY_ALLOC: return "OMP_LOW_LAT_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMPC_GROUP_MEMORY_ALLOC: return "OMPC_GROUP_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMPP_TEAM_MEMORY_ALLOC: return "OMPP_TEAM_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_THREAD_MEMORY_ALLOC: return "OMP_THREAD_MEMORY_ALLOC";
    case OMPAllocateDeclAttrAllocatorTypeTy::OMP_USER_DEFINED_MEMORY_ALLOC: return "OMP_USER_DEFINED_MEMORY_ALLOC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPDeclareReductionDeclInitKind e) {
  switch (e) {
    case OMPDeclareReductionDeclInitKind::CALL_INITIALIZER: return "CALL_INITIALIZER";
    case OMPDeclareReductionDeclInitKind::DIRECT_INITIALIZER: return "DIRECT_INITIALIZER";
    case OMPDeclareReductionDeclInitKind::COPY_INITIALIZER: return "COPY_INITIALIZER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPDeclareSimdDeclAttrBranchStateTy e) {
  switch (e) {
    case OMPDeclareSimdDeclAttrBranchStateTy::UNDEFINED: return "UNDEFINED";
    case OMPDeclareSimdDeclAttrBranchStateTy::INBRANCH: return "INBRANCH";
    case OMPDeclareSimdDeclAttrBranchStateTy::NOTINBRANCH: return "NOTINBRANCH";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPDeclareTargetDeclAttrDevTypeTy e) {
  switch (e) {
    case OMPDeclareTargetDeclAttrDevTypeTy::HOST: return "HOST";
    case OMPDeclareTargetDeclAttrDevTypeTy::NO_HOST: return "NO_HOST";
    case OMPDeclareTargetDeclAttrDevTypeTy::ANY: return "ANY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPDeclareTargetDeclAttrMapTypeTy e) {
  switch (e) {
    case OMPDeclareTargetDeclAttrMapTypeTy::TO: return "TO";
    case OMPDeclareTargetDeclAttrMapTypeTy::LINK: return "LINK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OMPDeclareVariantAttrInteropType e) {
  switch (e) {
    case OMPDeclareVariantAttrInteropType::TARGET: return "TARGET";
    case OMPDeclareVariantAttrInteropType::TARGET_SYNC: return "TARGET_SYNC";
    case OMPDeclareVariantAttrInteropType::TARGET_TARGET_SYNC: return "TARGET_TARGET_SYNC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSConsumedAttrSpelling e) {
  switch (e) {
    case OSConsumedAttrSpelling::GNU_OS_CONSUMED: return "GNU_OS_CONSUMED";
    case OSConsumedAttrSpelling::CXX11_CLANG_OS_CONSUMED: return "CXX11_CLANG_OS_CONSUMED";
    case OSConsumedAttrSpelling::C2X_CLANG_OS_CONSUMED: return "C2X_CLANG_OS_CONSUMED";
    case OSConsumedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSConsumesThisAttrSpelling e) {
  switch (e) {
    case OSConsumesThisAttrSpelling::GNU_OS_CONSUMES_THIS: return "GNU_OS_CONSUMES_THIS";
    case OSConsumesThisAttrSpelling::CXX11_CLANG_OS_CONSUMES_THIS: return "CXX11_CLANG_OS_CONSUMES_THIS";
    case OSConsumesThisAttrSpelling::C2X_CLANG_OS_CONSUMES_THIS: return "C2X_CLANG_OS_CONSUMES_THIS";
    case OSConsumesThisAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSReturnsNotRetainedAttrSpelling e) {
  switch (e) {
    case OSReturnsNotRetainedAttrSpelling::GNU_OS_RETURNS_NOT_RETAINED: return "GNU_OS_RETURNS_NOT_RETAINED";
    case OSReturnsNotRetainedAttrSpelling::CXX11_CLANG_OS_RETURNS_NOT_RETAINED: return "CXX11_CLANG_OS_RETURNS_NOT_RETAINED";
    case OSReturnsNotRetainedAttrSpelling::C2X_CLANG_OS_RETURNS_NOT_RETAINED: return "C2X_CLANG_OS_RETURNS_NOT_RETAINED";
    case OSReturnsNotRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSReturnsRetainedAttrSpelling e) {
  switch (e) {
    case OSReturnsRetainedAttrSpelling::GNU_OS_RETURNS_RETAINED: return "GNU_OS_RETURNS_RETAINED";
    case OSReturnsRetainedAttrSpelling::CXX11_CLANG_OS_RETURNS_RETAINED: return "CXX11_CLANG_OS_RETURNS_RETAINED";
    case OSReturnsRetainedAttrSpelling::C2X_CLANG_OS_RETURNS_RETAINED: return "C2X_CLANG_OS_RETURNS_RETAINED";
    case OSReturnsRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSReturnsRetainedOnNonZeroAttrSpelling e) {
  switch (e) {
    case OSReturnsRetainedOnNonZeroAttrSpelling::GNU_OS_RETURNS_RETAINED_ON_NON_ZERO: return "GNU_OS_RETURNS_RETAINED_ON_NON_ZERO";
    case OSReturnsRetainedOnNonZeroAttrSpelling::CXX11_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO: return "CXX11_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO";
    case OSReturnsRetainedOnNonZeroAttrSpelling::C2X_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO: return "C2X_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO";
    case OSReturnsRetainedOnNonZeroAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OSReturnsRetainedOnZeroAttrSpelling e) {
  switch (e) {
    case OSReturnsRetainedOnZeroAttrSpelling::GNU_OS_RETURNS_RETAINED_ON_ZERO: return "GNU_OS_RETURNS_RETAINED_ON_ZERO";
    case OSReturnsRetainedOnZeroAttrSpelling::CXX11_CLANG_OS_RETURNS_RETAINED_ON_ZERO: return "CXX11_CLANG_OS_RETURNS_RETAINED_ON_ZERO";
    case OSReturnsRetainedOnZeroAttrSpelling::C2X_CLANG_OS_RETURNS_RETAINED_ON_ZERO: return "C2X_CLANG_OS_RETURNS_RETAINED_ON_ZERO";
    case OSReturnsRetainedOnZeroAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCBoxableAttrSpelling e) {
  switch (e) {
    case ObjCBoxableAttrSpelling::GNU_OBJC_BOXABLE: return "GNU_OBJC_BOXABLE";
    case ObjCBoxableAttrSpelling::CXX11_CLANG_OBJC_BOXABLE: return "CXX11_CLANG_OBJC_BOXABLE";
    case ObjCBoxableAttrSpelling::C2X_CLANG_OBJC_BOXABLE: return "C2X_CLANG_OBJC_BOXABLE";
    case ObjCBoxableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCBridgeAttrSpelling e) {
  switch (e) {
    case ObjCBridgeAttrSpelling::GNU_OBJC_BRIDGE: return "GNU_OBJC_BRIDGE";
    case ObjCBridgeAttrSpelling::CXX11_CLANG_OBJC_BRIDGE: return "CXX11_CLANG_OBJC_BRIDGE";
    case ObjCBridgeAttrSpelling::C2X_CLANG_OBJC_BRIDGE: return "C2X_CLANG_OBJC_BRIDGE";
    case ObjCBridgeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCBridgeMutableAttrSpelling e) {
  switch (e) {
    case ObjCBridgeMutableAttrSpelling::GNU_OBJC_BRIDGE_MUTABLE: return "GNU_OBJC_BRIDGE_MUTABLE";
    case ObjCBridgeMutableAttrSpelling::CXX11_CLANG_OBJC_BRIDGE_MUTABLE: return "CXX11_CLANG_OBJC_BRIDGE_MUTABLE";
    case ObjCBridgeMutableAttrSpelling::C2X_CLANG_OBJC_BRIDGE_MUTABLE: return "C2X_CLANG_OBJC_BRIDGE_MUTABLE";
    case ObjCBridgeMutableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCBridgeRelatedAttrSpelling e) {
  switch (e) {
    case ObjCBridgeRelatedAttrSpelling::GNU_OBJC_BRIDGE_RELATED: return "GNU_OBJC_BRIDGE_RELATED";
    case ObjCBridgeRelatedAttrSpelling::CXX11_CLANG_OBJC_BRIDGE_RELATED: return "CXX11_CLANG_OBJC_BRIDGE_RELATED";
    case ObjCBridgeRelatedAttrSpelling::C2X_CLANG_OBJC_BRIDGE_RELATED: return "C2X_CLANG_OBJC_BRIDGE_RELATED";
    case ObjCBridgeRelatedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCClassStubAttrSpelling e) {
  switch (e) {
    case ObjCClassStubAttrSpelling::GNU_OBJC_CLASS_STUB: return "GNU_OBJC_CLASS_STUB";
    case ObjCClassStubAttrSpelling::CXX11_CLANG_OBJC_CLASS_STUB: return "CXX11_CLANG_OBJC_CLASS_STUB";
    case ObjCClassStubAttrSpelling::C2X_CLANG_OBJC_CLASS_STUB: return "C2X_CLANG_OBJC_CLASS_STUB";
    case ObjCClassStubAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCDesignatedInitializerAttrSpelling e) {
  switch (e) {
    case ObjCDesignatedInitializerAttrSpelling::GNU_OBJC_DESIGNATED_INITIALIZER: return "GNU_OBJC_DESIGNATED_INITIALIZER";
    case ObjCDesignatedInitializerAttrSpelling::CXX11_CLANG_OBJC_DESIGNATED_INITIALIZER: return "CXX11_CLANG_OBJC_DESIGNATED_INITIALIZER";
    case ObjCDesignatedInitializerAttrSpelling::C2X_CLANG_OBJC_DESIGNATED_INITIALIZER: return "C2X_CLANG_OBJC_DESIGNATED_INITIALIZER";
    case ObjCDesignatedInitializerAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCDirectAttrSpelling e) {
  switch (e) {
    case ObjCDirectAttrSpelling::GNU_OBJC_DIRECT: return "GNU_OBJC_DIRECT";
    case ObjCDirectAttrSpelling::CXX11_CLANG_OBJC_DIRECT: return "CXX11_CLANG_OBJC_DIRECT";
    case ObjCDirectAttrSpelling::C2X_CLANG_OBJC_DIRECT: return "C2X_CLANG_OBJC_DIRECT";
    case ObjCDirectAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCDirectMembersAttrSpelling e) {
  switch (e) {
    case ObjCDirectMembersAttrSpelling::GNU_OBJC_DIRECT_MEMBERS: return "GNU_OBJC_DIRECT_MEMBERS";
    case ObjCDirectMembersAttrSpelling::CXX11_CLANG_OBJC_DIRECT_MEMBERS: return "CXX11_CLANG_OBJC_DIRECT_MEMBERS";
    case ObjCDirectMembersAttrSpelling::C2X_CLANG_OBJC_DIRECT_MEMBERS: return "C2X_CLANG_OBJC_DIRECT_MEMBERS";
    case ObjCDirectMembersAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCExceptionAttrSpelling e) {
  switch (e) {
    case ObjCExceptionAttrSpelling::GNU_OBJC_EXCEPTION: return "GNU_OBJC_EXCEPTION";
    case ObjCExceptionAttrSpelling::CXX11_CLANG_OBJC_EXCEPTION: return "CXX11_CLANG_OBJC_EXCEPTION";
    case ObjCExceptionAttrSpelling::C2X_CLANG_OBJC_EXCEPTION: return "C2X_CLANG_OBJC_EXCEPTION";
    case ObjCExceptionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCExplicitProtocolImplAttrSpelling e) {
  switch (e) {
    case ObjCExplicitProtocolImplAttrSpelling::GNU_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION: return "GNU_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION";
    case ObjCExplicitProtocolImplAttrSpelling::CXX11_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION: return "CXX11_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION";
    case ObjCExplicitProtocolImplAttrSpelling::C2X_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION: return "C2X_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION";
    case ObjCExplicitProtocolImplAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCExternallyRetainedAttrSpelling e) {
  switch (e) {
    case ObjCExternallyRetainedAttrSpelling::GNU_OBJC_EXTERNALLY_RETAINED: return "GNU_OBJC_EXTERNALLY_RETAINED";
    case ObjCExternallyRetainedAttrSpelling::CXX11_CLANG_OBJC_EXTERNALLY_RETAINED: return "CXX11_CLANG_OBJC_EXTERNALLY_RETAINED";
    case ObjCExternallyRetainedAttrSpelling::C2X_CLANG_OBJC_EXTERNALLY_RETAINED: return "C2X_CLANG_OBJC_EXTERNALLY_RETAINED";
    case ObjCExternallyRetainedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCGCAttrSpelling e) {
  switch (e) {
    case ObjCGCAttrSpelling::GNU_OBJC_GC: return "GNU_OBJC_GC";
    case ObjCGCAttrSpelling::CXX11_CLANG_OBJC_GC: return "CXX11_CLANG_OBJC_GC";
    case ObjCGCAttrSpelling::C2X_CLANG_OBJC_GC: return "C2X_CLANG_OBJC_GC";
    case ObjCGCAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCIndependentClassAttrSpelling e) {
  switch (e) {
    case ObjCIndependentClassAttrSpelling::GNU_OBJC_INDEPENDENT_CLASS: return "GNU_OBJC_INDEPENDENT_CLASS";
    case ObjCIndependentClassAttrSpelling::CXX11_CLANG_OBJC_INDEPENDENT_CLASS: return "CXX11_CLANG_OBJC_INDEPENDENT_CLASS";
    case ObjCIndependentClassAttrSpelling::C2X_CLANG_OBJC_INDEPENDENT_CLASS: return "C2X_CLANG_OBJC_INDEPENDENT_CLASS";
    case ObjCIndependentClassAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCIvarDeclAccessControl e) {
  switch (e) {
    case ObjCIvarDeclAccessControl::NONE: return "NONE";
    case ObjCIvarDeclAccessControl::PRIVATE: return "PRIVATE";
    case ObjCIvarDeclAccessControl::PROTECTED: return "PROTECTED";
    case ObjCIvarDeclAccessControl::PUBLIC: return "PUBLIC";
    case ObjCIvarDeclAccessControl::PACKAGE: return "PACKAGE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCMessageExprReceiverKind e) {
  switch (e) {
    case ObjCMessageExprReceiverKind::CLASS: return "CLASS";
    case ObjCMessageExprReceiverKind::INSTANCE: return "INSTANCE";
    case ObjCMessageExprReceiverKind::SUPER_CLASS: return "SUPER_CLASS";
    case ObjCMessageExprReceiverKind::SUPER_INSTANCE: return "SUPER_INSTANCE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCMethodDeclImplementationControl e) {
  switch (e) {
    case ObjCMethodDeclImplementationControl::NONE: return "NONE";
    case ObjCMethodDeclImplementationControl::REQUIRED: return "REQUIRED";
    case ObjCMethodDeclImplementationControl::OPTIONAL: return "OPTIONAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCMethodFamilyAttrFamilyKind e) {
  switch (e) {
    case ObjCMethodFamilyAttrFamilyKind::NONE: return "NONE";
    case ObjCMethodFamilyAttrFamilyKind::ALLOC: return "ALLOC";
    case ObjCMethodFamilyAttrFamilyKind::COPY: return "COPY";
    case ObjCMethodFamilyAttrFamilyKind::INITIALIZER: return "INITIALIZER";
    case ObjCMethodFamilyAttrFamilyKind::MUTABLE_COPY: return "MUTABLE_COPY";
    case ObjCMethodFamilyAttrFamilyKind::NEW: return "NEW";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCMethodFamilyAttrSpelling e) {
  switch (e) {
    case ObjCMethodFamilyAttrSpelling::GNU_OBJC_METHOD_FAMILY: return "GNU_OBJC_METHOD_FAMILY";
    case ObjCMethodFamilyAttrSpelling::CXX11_CLANG_OBJC_METHOD_FAMILY: return "CXX11_CLANG_OBJC_METHOD_FAMILY";
    case ObjCMethodFamilyAttrSpelling::C2X_CLANG_OBJC_METHOD_FAMILY: return "C2X_CLANG_OBJC_METHOD_FAMILY";
    case ObjCMethodFamilyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCNSObjectAttrSpelling e) {
  switch (e) {
    case ObjCNSObjectAttrSpelling::GNUNS_OBJECT: return "GNUNS_OBJECT";
    case ObjCNSObjectAttrSpelling::CXX11_CLANG_NS_OBJECT: return "CXX11_CLANG_NS_OBJECT";
    case ObjCNSObjectAttrSpelling::C2X_CLANG_NS_OBJECT: return "C2X_CLANG_NS_OBJECT";
    case ObjCNSObjectAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCNonLazyClassAttrSpelling e) {
  switch (e) {
    case ObjCNonLazyClassAttrSpelling::GNU_OBJC_NONLAZY_CLASS: return "GNU_OBJC_NONLAZY_CLASS";
    case ObjCNonLazyClassAttrSpelling::CXX11_CLANG_OBJC_NONLAZY_CLASS: return "CXX11_CLANG_OBJC_NONLAZY_CLASS";
    case ObjCNonLazyClassAttrSpelling::C2X_CLANG_OBJC_NONLAZY_CLASS: return "C2X_CLANG_OBJC_NONLAZY_CLASS";
    case ObjCNonLazyClassAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCNonRuntimeProtocolAttrSpelling e) {
  switch (e) {
    case ObjCNonRuntimeProtocolAttrSpelling::GNU_OBJC_NON_RUNTIME_PROTOCOL: return "GNU_OBJC_NON_RUNTIME_PROTOCOL";
    case ObjCNonRuntimeProtocolAttrSpelling::CXX11_CLANG_OBJC_NON_RUNTIME_PROTOCOL: return "CXX11_CLANG_OBJC_NON_RUNTIME_PROTOCOL";
    case ObjCNonRuntimeProtocolAttrSpelling::C2X_CLANG_OBJC_NON_RUNTIME_PROTOCOL: return "C2X_CLANG_OBJC_NON_RUNTIME_PROTOCOL";
    case ObjCNonRuntimeProtocolAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCOwnershipAttrSpelling e) {
  switch (e) {
    case ObjCOwnershipAttrSpelling::GNU_OBJC_OWNERSHIP: return "GNU_OBJC_OWNERSHIP";
    case ObjCOwnershipAttrSpelling::CXX11_CLANG_OBJC_OWNERSHIP: return "CXX11_CLANG_OBJC_OWNERSHIP";
    case ObjCOwnershipAttrSpelling::C2X_CLANG_OBJC_OWNERSHIP: return "C2X_CLANG_OBJC_OWNERSHIP";
    case ObjCOwnershipAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCPreciseLifetimeAttrSpelling e) {
  switch (e) {
    case ObjCPreciseLifetimeAttrSpelling::GNU_OBJC_PRECISE_LIFETIME: return "GNU_OBJC_PRECISE_LIFETIME";
    case ObjCPreciseLifetimeAttrSpelling::CXX11_CLANG_OBJC_PRECISE_LIFETIME: return "CXX11_CLANG_OBJC_PRECISE_LIFETIME";
    case ObjCPreciseLifetimeAttrSpelling::C2X_CLANG_OBJC_PRECISE_LIFETIME: return "C2X_CLANG_OBJC_PRECISE_LIFETIME";
    case ObjCPreciseLifetimeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCPropertyDeclPropertyControl e) {
  switch (e) {
    case ObjCPropertyDeclPropertyControl::NONE: return "NONE";
    case ObjCPropertyDeclPropertyControl::REQUIRED: return "REQUIRED";
    case ObjCPropertyDeclPropertyControl::OPTIONAL: return "OPTIONAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCPropertyDeclSetterKind e) {
  switch (e) {
    case ObjCPropertyDeclSetterKind::ASSIGN: return "ASSIGN";
    case ObjCPropertyDeclSetterKind::RETAIN: return "RETAIN";
    case ObjCPropertyDeclSetterKind::COPY: return "COPY";
    case ObjCPropertyDeclSetterKind::WEAK: return "WEAK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCPropertyImplDeclKind e) {
  switch (e) {
    case ObjCPropertyImplDeclKind::SYNTHESIZE: return "SYNTHESIZE";
    case ObjCPropertyImplDeclKind::DYNAMIC: return "DYNAMIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCRequiresPropertyDefsAttrSpelling e) {
  switch (e) {
    case ObjCRequiresPropertyDefsAttrSpelling::GNU_OBJC_REQUIRES_PROPERTY_DEFINITIONS: return "GNU_OBJC_REQUIRES_PROPERTY_DEFINITIONS";
    case ObjCRequiresPropertyDefsAttrSpelling::CXX11_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS: return "CXX11_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS";
    case ObjCRequiresPropertyDefsAttrSpelling::C2X_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS: return "C2X_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS";
    case ObjCRequiresPropertyDefsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCRequiresSuperAttrSpelling e) {
  switch (e) {
    case ObjCRequiresSuperAttrSpelling::GNU_OBJC_REQUIRES_SUPER: return "GNU_OBJC_REQUIRES_SUPER";
    case ObjCRequiresSuperAttrSpelling::CXX11_CLANG_OBJC_REQUIRES_SUPER: return "CXX11_CLANG_OBJC_REQUIRES_SUPER";
    case ObjCRequiresSuperAttrSpelling::C2X_CLANG_OBJC_REQUIRES_SUPER: return "C2X_CLANG_OBJC_REQUIRES_SUPER";
    case ObjCRequiresSuperAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCReturnsInnerPointerAttrSpelling e) {
  switch (e) {
    case ObjCReturnsInnerPointerAttrSpelling::GNU_OBJC_RETURNS_INNER_POINTER: return "GNU_OBJC_RETURNS_INNER_POINTER";
    case ObjCReturnsInnerPointerAttrSpelling::CXX11_CLANG_OBJC_RETURNS_INNER_POINTER: return "CXX11_CLANG_OBJC_RETURNS_INNER_POINTER";
    case ObjCReturnsInnerPointerAttrSpelling::C2X_CLANG_OBJC_RETURNS_INNER_POINTER: return "C2X_CLANG_OBJC_RETURNS_INNER_POINTER";
    case ObjCReturnsInnerPointerAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCRootClassAttrSpelling e) {
  switch (e) {
    case ObjCRootClassAttrSpelling::GNU_OBJC_ROOT_CLASS: return "GNU_OBJC_ROOT_CLASS";
    case ObjCRootClassAttrSpelling::CXX11_CLANG_OBJC_ROOT_CLASS: return "CXX11_CLANG_OBJC_ROOT_CLASS";
    case ObjCRootClassAttrSpelling::C2X_CLANG_OBJC_ROOT_CLASS: return "C2X_CLANG_OBJC_ROOT_CLASS";
    case ObjCRootClassAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCRuntimeNameAttrSpelling e) {
  switch (e) {
    case ObjCRuntimeNameAttrSpelling::GNU_OBJC_RUNTIME_NAME: return "GNU_OBJC_RUNTIME_NAME";
    case ObjCRuntimeNameAttrSpelling::CXX11_CLANG_OBJC_RUNTIME_NAME: return "CXX11_CLANG_OBJC_RUNTIME_NAME";
    case ObjCRuntimeNameAttrSpelling::C2X_CLANG_OBJC_RUNTIME_NAME: return "C2X_CLANG_OBJC_RUNTIME_NAME";
    case ObjCRuntimeNameAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCRuntimeVisibleAttrSpelling e) {
  switch (e) {
    case ObjCRuntimeVisibleAttrSpelling::GNU_OBJC_RUNTIME_VISIBLE: return "GNU_OBJC_RUNTIME_VISIBLE";
    case ObjCRuntimeVisibleAttrSpelling::CXX11_CLANG_OBJC_RUNTIME_VISIBLE: return "CXX11_CLANG_OBJC_RUNTIME_VISIBLE";
    case ObjCRuntimeVisibleAttrSpelling::C2X_CLANG_OBJC_RUNTIME_VISIBLE: return "C2X_CLANG_OBJC_RUNTIME_VISIBLE";
    case ObjCRuntimeVisibleAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCSubclassingRestrictedAttrSpelling e) {
  switch (e) {
    case ObjCSubclassingRestrictedAttrSpelling::GNU_OBJC_SUBCLASSING_RESTRICTED: return "GNU_OBJC_SUBCLASSING_RESTRICTED";
    case ObjCSubclassingRestrictedAttrSpelling::CXX11_CLANG_OBJC_SUBCLASSING_RESTRICTED: return "CXX11_CLANG_OBJC_SUBCLASSING_RESTRICTED";
    case ObjCSubclassingRestrictedAttrSpelling::C2X_CLANG_OBJC_SUBCLASSING_RESTRICTED: return "C2X_CLANG_OBJC_SUBCLASSING_RESTRICTED";
    case ObjCSubclassingRestrictedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLAccessAttrSpelling e) {
  switch (e) {
    case OpenCLAccessAttrSpelling::KEYWORD_READ_ONLY: return "KEYWORD_READ_ONLY";
    case OpenCLAccessAttrSpelling::KEYWORD_WRITE_ONLY: return "KEYWORD_WRITE_ONLY";
    case OpenCLAccessAttrSpelling::KEYWORD_READ_WRITE: return "KEYWORD_READ_WRITE";
    case OpenCLAccessAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLConstantAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLConstantAddressSpaceAttrSpelling::KEYWORD_CONSTANT: return "KEYWORD_CONSTANT";
    case OpenCLConstantAddressSpaceAttrSpelling::GNU_OPENCL_CONSTANT: return "GNU_OPENCL_CONSTANT";
    case OpenCLConstantAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_CONSTANT: return "CXX11_CLANG_OPENCL_CONSTANT";
    case OpenCLConstantAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_CONSTANT: return "C2X_CLANG_OPENCL_CONSTANT";
    case OpenCLConstantAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLGenericAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLGenericAddressSpaceAttrSpelling::KEYWORD_GENERIC: return "KEYWORD_GENERIC";
    case OpenCLGenericAddressSpaceAttrSpelling::GNU_OPENCL_GENERIC: return "GNU_OPENCL_GENERIC";
    case OpenCLGenericAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_GENERIC: return "CXX11_CLANG_OPENCL_GENERIC";
    case OpenCLGenericAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_GENERIC: return "C2X_CLANG_OPENCL_GENERIC";
    case OpenCLGenericAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLGlobalAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLGlobalAddressSpaceAttrSpelling::KEYWORD_GLOBAL: return "KEYWORD_GLOBAL";
    case OpenCLGlobalAddressSpaceAttrSpelling::GNU_OPENCL_GLOBAL: return "GNU_OPENCL_GLOBAL";
    case OpenCLGlobalAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_GLOBAL: return "CXX11_CLANG_OPENCL_GLOBAL";
    case OpenCLGlobalAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_GLOBAL: return "C2X_CLANG_OPENCL_GLOBAL";
    case OpenCLGlobalAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLGlobalDeviceAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLGlobalDeviceAddressSpaceAttrSpelling::GNU_OPENCL_GLOBAL_DEVICE: return "GNU_OPENCL_GLOBAL_DEVICE";
    case OpenCLGlobalDeviceAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_GLOBAL_DEVICE: return "CXX11_CLANG_OPENCL_GLOBAL_DEVICE";
    case OpenCLGlobalDeviceAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_GLOBAL_DEVICE: return "C2X_CLANG_OPENCL_GLOBAL_DEVICE";
    case OpenCLGlobalDeviceAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLGlobalHostAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLGlobalHostAddressSpaceAttrSpelling::GNU_OPENCL_GLOBAL_HOST: return "GNU_OPENCL_GLOBAL_HOST";
    case OpenCLGlobalHostAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_GLOBAL_HOST: return "CXX11_CLANG_OPENCL_GLOBAL_HOST";
    case OpenCLGlobalHostAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_GLOBAL_HOST: return "C2X_CLANG_OPENCL_GLOBAL_HOST";
    case OpenCLGlobalHostAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLKernelAttrSpelling e) {
  switch (e) {
    case OpenCLKernelAttrSpelling::KEYWORD_KERNEL: return "KEYWORD_KERNEL";
    case OpenCLKernelAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLLocalAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLLocalAddressSpaceAttrSpelling::KEYWORD_LOCAL: return "KEYWORD_LOCAL";
    case OpenCLLocalAddressSpaceAttrSpelling::GNU_OPENCL_LOCAL: return "GNU_OPENCL_LOCAL";
    case OpenCLLocalAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_LOCAL: return "CXX11_CLANG_OPENCL_LOCAL";
    case OpenCLLocalAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_LOCAL: return "C2X_CLANG_OPENCL_LOCAL";
    case OpenCLLocalAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenCLPrivateAddressSpaceAttrSpelling e) {
  switch (e) {
    case OpenCLPrivateAddressSpaceAttrSpelling::KEYWORD_PRIVATE: return "KEYWORD_PRIVATE";
    case OpenCLPrivateAddressSpaceAttrSpelling::GNU_OPENCL_PRIVATE: return "GNU_OPENCL_PRIVATE";
    case OpenCLPrivateAddressSpaceAttrSpelling::CXX11_CLANG_OPENCL_PRIVATE: return "CXX11_CLANG_OPENCL_PRIVATE";
    case OpenCLPrivateAddressSpaceAttrSpelling::C2X_CLANG_OPENCL_PRIVATE: return "C2X_CLANG_OPENCL_PRIVATE";
    case OpenCLPrivateAddressSpaceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OptimizeNoneAttrSpelling e) {
  switch (e) {
    case OptimizeNoneAttrSpelling::GNU_OPTNONE: return "GNU_OPTNONE";
    case OptimizeNoneAttrSpelling::CXX11_CLANG_OPTNONE: return "CXX11_CLANG_OPTNONE";
    case OptimizeNoneAttrSpelling::C2X_CLANG_OPTNONE: return "C2X_CLANG_OPTNONE";
    case OptimizeNoneAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OverloadableAttrSpelling e) {
  switch (e) {
    case OverloadableAttrSpelling::GNU_OVERLOADABLE: return "GNU_OVERLOADABLE";
    case OverloadableAttrSpelling::CXX11_CLANG_OVERLOADABLE: return "CXX11_CLANG_OVERLOADABLE";
    case OverloadableAttrSpelling::C2X_CLANG_OVERLOADABLE: return "C2X_CLANG_OVERLOADABLE";
    case OverloadableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OwnershipAttrOwnershipKind e) {
  switch (e) {
    case OwnershipAttrOwnershipKind::HOLDS: return "HOLDS";
    case OwnershipAttrOwnershipKind::RETURNS: return "RETURNS";
    case OwnershipAttrOwnershipKind::TAKES: return "TAKES";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OwnershipAttrSpelling e) {
  switch (e) {
    case OwnershipAttrSpelling::GNU_OWNERSHIP_HOLDS: return "GNU_OWNERSHIP_HOLDS";
    case OwnershipAttrSpelling::CXX11_CLANG_OWNERSHIP_HOLDS: return "CXX11_CLANG_OWNERSHIP_HOLDS";
    case OwnershipAttrSpelling::C2X_CLANG_OWNERSHIP_HOLDS: return "C2X_CLANG_OWNERSHIP_HOLDS";
    case OwnershipAttrSpelling::GNU_OWNERSHIP_RETURNS: return "GNU_OWNERSHIP_RETURNS";
    case OwnershipAttrSpelling::CXX11_CLANG_OWNERSHIP_RETURNS: return "CXX11_CLANG_OWNERSHIP_RETURNS";
    case OwnershipAttrSpelling::C2X_CLANG_OWNERSHIP_RETURNS: return "C2X_CLANG_OWNERSHIP_RETURNS";
    case OwnershipAttrSpelling::GNU_OWNERSHIP_TAKES: return "GNU_OWNERSHIP_TAKES";
    case OwnershipAttrSpelling::CXX11_CLANG_OWNERSHIP_TAKES: return "CXX11_CLANG_OWNERSHIP_TAKES";
    case OwnershipAttrSpelling::C2X_CLANG_OWNERSHIP_TAKES: return "C2X_CLANG_OWNERSHIP_TAKES";
    case OwnershipAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PackedAttrSpelling e) {
  switch (e) {
    case PackedAttrSpelling::GNU_PACKED: return "GNU_PACKED";
    case PackedAttrSpelling::CXX11_GNU_PACKED: return "CXX11_GNU_PACKED";
    case PackedAttrSpelling::C2X_GNU_PACKED: return "C2X_GNU_PACKED";
    case PackedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ParamTypestateAttrConsumedState e) {
  switch (e) {
    case ParamTypestateAttrConsumedState::UNKNOWN: return "UNKNOWN";
    case ParamTypestateAttrConsumedState::CONSUMED: return "CONSUMED";
    case ParamTypestateAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ParamTypestateAttrSpelling e) {
  switch (e) {
    case ParamTypestateAttrSpelling::GNU_PARAMETER_TYPESTATE: return "GNU_PARAMETER_TYPESTATE";
    case ParamTypestateAttrSpelling::CXX11_CLANG_PARAMETER_TYPESTATE: return "CXX11_CLANG_PARAMETER_TYPESTATE";
    case ParamTypestateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PascalAttrSpelling e) {
  switch (e) {
    case PascalAttrSpelling::GNU_PASCAL: return "GNU_PASCAL";
    case PascalAttrSpelling::CXX11_CLANG_PASCAL: return "CXX11_CLANG_PASCAL";
    case PascalAttrSpelling::C2X_CLANG_PASCAL: return "C2X_CLANG_PASCAL";
    case PascalAttrSpelling::KEYWORD_PASCAL: return "KEYWORD_PASCAL";
    case PascalAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PassObjectSizeAttrSpelling e) {
  switch (e) {
    case PassObjectSizeAttrSpelling::GNU_PASS_OBJECT_SIZE: return "GNU_PASS_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::CXX11_CLANG_PASS_OBJECT_SIZE: return "CXX11_CLANG_PASS_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::C2X_CLANG_PASS_OBJECT_SIZE: return "C2X_CLANG_PASS_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::GNU_PASS_DYNAMIC_OBJECT_SIZE: return "GNU_PASS_DYNAMIC_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::CXX11_CLANG_PASS_DYNAMIC_OBJECT_SIZE: return "CXX11_CLANG_PASS_DYNAMIC_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::C2X_CLANG_PASS_DYNAMIC_OBJECT_SIZE: return "C2X_CLANG_PASS_DYNAMIC_OBJECT_SIZE";
    case PassObjectSizeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PatchableFunctionEntryAttrSpelling e) {
  switch (e) {
    case PatchableFunctionEntryAttrSpelling::GNU_PATCHABLE_FUNCTION_ENTRY: return "GNU_PATCHABLE_FUNCTION_ENTRY";
    case PatchableFunctionEntryAttrSpelling::CXX11_GNU_PATCHABLE_FUNCTION_ENTRY: return "CXX11_GNU_PATCHABLE_FUNCTION_ENTRY";
    case PatchableFunctionEntryAttrSpelling::C2X_GNU_PATCHABLE_FUNCTION_ENTRY: return "C2X_GNU_PATCHABLE_FUNCTION_ENTRY";
    case PatchableFunctionEntryAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PcsAttrPCSType e) {
  switch (e) {
    case PcsAttrPCSType::AAPCS: return "AAPCS";
    case PcsAttrPCSType::VFP: return "VFP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PcsAttrSpelling e) {
  switch (e) {
    case PcsAttrSpelling::GNU_PCS: return "GNU_PCS";
    case PcsAttrSpelling::CXX11_GNU_PCS: return "CXX11_GNU_PCS";
    case PcsAttrSpelling::C2X_GNU_PCS: return "C2X_GNU_PCS";
    case PcsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PredefinedExprIdentKind e) {
  switch (e) {
    case PredefinedExprIdentKind::FUNC: return "FUNC";
    case PredefinedExprIdentKind::FUNCTION: return "FUNCTION";
    case PredefinedExprIdentKind::L_FUNCTION: return "L_FUNCTION";
    case PredefinedExprIdentKind::FUNC_D_NAME: return "FUNC_D_NAME";
    case PredefinedExprIdentKind::FUNC_SIG: return "FUNC_SIG";
    case PredefinedExprIdentKind::L_FUNC_SIG: return "L_FUNC_SIG";
    case PredefinedExprIdentKind::PRETTY_FUNCTION: return "PRETTY_FUNCTION";
    case PredefinedExprIdentKind::PRETTY_FUNCTION_NO_VIRTUAL: return "PRETTY_FUNCTION_NO_VIRTUAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PreferredNameAttrSpelling e) {
  switch (e) {
    case PreferredNameAttrSpelling::GNU_PREFERRED_NAME: return "GNU_PREFERRED_NAME";
    case PreferredNameAttrSpelling::CXX11_CLANG_PREFERRED_NAME: return "CXX11_CLANG_PREFERRED_NAME";
    case PreferredNameAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PreserveAllAttrSpelling e) {
  switch (e) {
    case PreserveAllAttrSpelling::GNU_PRESERVE_ALL: return "GNU_PRESERVE_ALL";
    case PreserveAllAttrSpelling::CXX11_CLANG_PRESERVE_ALL: return "CXX11_CLANG_PRESERVE_ALL";
    case PreserveAllAttrSpelling::C2X_CLANG_PRESERVE_ALL: return "C2X_CLANG_PRESERVE_ALL";
    case PreserveAllAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PreserveMostAttrSpelling e) {
  switch (e) {
    case PreserveMostAttrSpelling::GNU_PRESERVE_MOST: return "GNU_PRESERVE_MOST";
    case PreserveMostAttrSpelling::CXX11_CLANG_PRESERVE_MOST: return "CXX11_CLANG_PRESERVE_MOST";
    case PreserveMostAttrSpelling::C2X_CLANG_PRESERVE_MOST: return "C2X_CLANG_PRESERVE_MOST";
    case PreserveMostAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PtGuardedVarAttrSpelling e) {
  switch (e) {
    case PtGuardedVarAttrSpelling::GNU_PT_GUARDED_VARIABLE: return "GNU_PT_GUARDED_VARIABLE";
    case PtGuardedVarAttrSpelling::CXX11_CLANG_PT_GUARDED_VARIABLE: return "CXX11_CLANG_PT_GUARDED_VARIABLE";
    case PtGuardedVarAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PureAttrSpelling e) {
  switch (e) {
    case PureAttrSpelling::GNU_PURE: return "GNU_PURE";
    case PureAttrSpelling::CXX11_GNU_PURE: return "CXX11_GNU_PURE";
    case PureAttrSpelling::C2X_GNU_PURE: return "C2X_GNU_PURE";
    case PureAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(QualTypeDestructionKind e) {
  switch (e) {
    case QualTypeDestructionKind::NONE: return "NONE";
    case QualTypeDestructionKind::CXX_DESTRUCTOR: return "CXX_DESTRUCTOR";
    case QualTypeDestructionKind::OBJC_STRONG_LIFETIME: return "OBJC_STRONG_LIFETIME";
    case QualTypeDestructionKind::OBJC_WEAK_LIFETIME: return "OBJC_WEAK_LIFETIME";
    case QualTypeDestructionKind::NONTRIVIAL_C_STRUCT: return "NONTRIVIAL_C_STRUCT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(QualTypePrimitiveCopyKind e) {
  switch (e) {
    case QualTypePrimitiveCopyKind::TRIVIAL: return "TRIVIAL";
    case QualTypePrimitiveCopyKind::VOLATILE_TRIVIAL: return "VOLATILE_TRIVIAL";
    case QualTypePrimitiveCopyKind::ARC_STRONG: return "ARC_STRONG";
    case QualTypePrimitiveCopyKind::ARC_WEAK: return "ARC_WEAK";
    case QualTypePrimitiveCopyKind::STRUCT: return "STRUCT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(QualTypePrimitiveDefaultInitializeKind e) {
  switch (e) {
    case QualTypePrimitiveDefaultInitializeKind::TRIVIAL: return "TRIVIAL";
    case QualTypePrimitiveDefaultInitializeKind::ARC_STRONG: return "ARC_STRONG";
    case QualTypePrimitiveDefaultInitializeKind::ARC_WEAK: return "ARC_WEAK";
    case QualTypePrimitiveDefaultInitializeKind::STRUCT: return "STRUCT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RISCVInterruptAttrInterruptType e) {
  switch (e) {
    case RISCVInterruptAttrInterruptType::USER: return "USER";
    case RISCVInterruptAttrInterruptType::SUPERVISOR: return "SUPERVISOR";
    case RISCVInterruptAttrInterruptType::MACHINE: return "MACHINE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RISCVInterruptAttrSpelling e) {
  switch (e) {
    case RISCVInterruptAttrSpelling::GNU_INTERRUPT: return "GNU_INTERRUPT";
    case RISCVInterruptAttrSpelling::CXX11_GNU_INTERRUPT: return "CXX11_GNU_INTERRUPT";
    case RISCVInterruptAttrSpelling::C2X_GNU_INTERRUPT: return "C2X_GNU_INTERRUPT";
    case RISCVInterruptAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RandomizeLayoutAttrSpelling e) {
  switch (e) {
    case RandomizeLayoutAttrSpelling::GNU_RANDOMIZE_LAYOUT: return "GNU_RANDOMIZE_LAYOUT";
    case RandomizeLayoutAttrSpelling::CXX11_GNU_RANDOMIZE_LAYOUT: return "CXX11_GNU_RANDOMIZE_LAYOUT";
    case RandomizeLayoutAttrSpelling::C2X_GNU_RANDOMIZE_LAYOUT: return "C2X_GNU_RANDOMIZE_LAYOUT";
    case RandomizeLayoutAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RecordDeclArgPassingKind e) {
  switch (e) {
    case RecordDeclArgPassingKind::CAN_PASS_IN_REGS: return "CAN_PASS_IN_REGS";
    case RecordDeclArgPassingKind::CANNOT_PASS_IN_REGS: return "CANNOT_PASS_IN_REGS";
    case RecordDeclArgPassingKind::CAN_NEVER_PASS_IN_REGS: return "CAN_NEVER_PASS_IN_REGS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RegCallAttrSpelling e) {
  switch (e) {
    case RegCallAttrSpelling::GNU_REGCALL: return "GNU_REGCALL";
    case RegCallAttrSpelling::CXX11_GNU_REGCALL: return "CXX11_GNU_REGCALL";
    case RegCallAttrSpelling::C2X_GNU_REGCALL: return "C2X_GNU_REGCALL";
    case RegCallAttrSpelling::KEYWORD_REGCALL: return "KEYWORD_REGCALL";
    case RegCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReinitializesAttrSpelling e) {
  switch (e) {
    case ReinitializesAttrSpelling::GNU_REINITIALIZES: return "GNU_REINITIALIZES";
    case ReinitializesAttrSpelling::CXX11_CLANG_REINITIALIZES: return "CXX11_CLANG_REINITIALIZES";
    case ReinitializesAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReleaseCapabilityAttrSpelling e) {
  switch (e) {
    case ReleaseCapabilityAttrSpelling::GNU_RELEASE_CAPABILITY: return "GNU_RELEASE_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::CXX11_CLANG_RELEASE_CAPABILITY: return "CXX11_CLANG_RELEASE_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::GNU_RELEASE_SHARED_CAPABILITY: return "GNU_RELEASE_SHARED_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::CXX11_CLANG_RELEASE_SHARED_CAPABILITY: return "CXX11_CLANG_RELEASE_SHARED_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::GNU_RELEASE_GENERIC_CAPABILITY: return "GNU_RELEASE_GENERIC_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::CXX11_CLANG_RELEASE_GENERIC_CAPABILITY: return "CXX11_CLANG_RELEASE_GENERIC_CAPABILITY";
    case ReleaseCapabilityAttrSpelling::GNU_UNLOCK_FUNCTION: return "GNU_UNLOCK_FUNCTION";
    case ReleaseCapabilityAttrSpelling::CXX11_CLANG_UNLOCK_FUNCTION: return "CXX11_CLANG_UNLOCK_FUNCTION";
    case ReleaseCapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReleaseHandleAttrSpelling e) {
  switch (e) {
    case ReleaseHandleAttrSpelling::GNU_RELEASE_HANDLE: return "GNU_RELEASE_HANDLE";
    case ReleaseHandleAttrSpelling::CXX11_CLANG_RELEASE_HANDLE: return "CXX11_CLANG_RELEASE_HANDLE";
    case ReleaseHandleAttrSpelling::C2X_CLANG_RELEASE_HANDLE: return "C2X_CLANG_RELEASE_HANDLE";
    case ReleaseHandleAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RequiresCapabilityAttrSpelling e) {
  switch (e) {
    case RequiresCapabilityAttrSpelling::GNU_REQUIRES_CAPABILITY: return "GNU_REQUIRES_CAPABILITY";
    case RequiresCapabilityAttrSpelling::CXX11_CLANG_REQUIRES_CAPABILITY: return "CXX11_CLANG_REQUIRES_CAPABILITY";
    case RequiresCapabilityAttrSpelling::GNU_EXCLUSIVE_LOCKS_REQUIRED: return "GNU_EXCLUSIVE_LOCKS_REQUIRED";
    case RequiresCapabilityAttrSpelling::CXX11_CLANG_EXCLUSIVE_LOCKS_REQUIRED: return "CXX11_CLANG_EXCLUSIVE_LOCKS_REQUIRED";
    case RequiresCapabilityAttrSpelling::GNU_REQUIRES_SHARED_CAPABILITY: return "GNU_REQUIRES_SHARED_CAPABILITY";
    case RequiresCapabilityAttrSpelling::CXX11_CLANG_REQUIRES_SHARED_CAPABILITY: return "CXX11_CLANG_REQUIRES_SHARED_CAPABILITY";
    case RequiresCapabilityAttrSpelling::GNU_SHARED_LOCKS_REQUIRED: return "GNU_SHARED_LOCKS_REQUIRED";
    case RequiresCapabilityAttrSpelling::CXX11_CLANG_SHARED_LOCKS_REQUIRED: return "CXX11_CLANG_SHARED_LOCKS_REQUIRED";
    case RequiresCapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RestrictAttrSpelling e) {
  switch (e) {
    case RestrictAttrSpelling::DECLSPEC_RESTRICT: return "DECLSPEC_RESTRICT";
    case RestrictAttrSpelling::GNU_MALLOC: return "GNU_MALLOC";
    case RestrictAttrSpelling::CXX11_GNU_MALLOC: return "CXX11_GNU_MALLOC";
    case RestrictAttrSpelling::C2X_GNU_MALLOC: return "C2X_GNU_MALLOC";
    case RestrictAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RetainAttrSpelling e) {
  switch (e) {
    case RetainAttrSpelling::GNU_RETAIN: return "GNU_RETAIN";
    case RetainAttrSpelling::CXX11_GNU_RETAIN: return "CXX11_GNU_RETAIN";
    case RetainAttrSpelling::C2X_GNU_RETAIN: return "C2X_GNU_RETAIN";
    case RetainAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReturnTypestateAttrConsumedState e) {
  switch (e) {
    case ReturnTypestateAttrConsumedState::UNKNOWN: return "UNKNOWN";
    case ReturnTypestateAttrConsumedState::CONSUMED: return "CONSUMED";
    case ReturnTypestateAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReturnTypestateAttrSpelling e) {
  switch (e) {
    case ReturnTypestateAttrSpelling::GNU_RETURN_TYPESTATE: return "GNU_RETURN_TYPESTATE";
    case ReturnTypestateAttrSpelling::CXX11_CLANG_RETURN_TYPESTATE: return "CXX11_CLANG_RETURN_TYPESTATE";
    case ReturnTypestateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReturnsNonNullAttrSpelling e) {
  switch (e) {
    case ReturnsNonNullAttrSpelling::GNU_RETURNS_NONNULL: return "GNU_RETURNS_NONNULL";
    case ReturnsNonNullAttrSpelling::CXX11_GNU_RETURNS_NONNULL: return "CXX11_GNU_RETURNS_NONNULL";
    case ReturnsNonNullAttrSpelling::C2X_GNU_RETURNS_NONNULL: return "C2X_GNU_RETURNS_NONNULL";
    case ReturnsNonNullAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReturnsTwiceAttrSpelling e) {
  switch (e) {
    case ReturnsTwiceAttrSpelling::GNU_RETURNS_TWICE: return "GNU_RETURNS_TWICE";
    case ReturnsTwiceAttrSpelling::CXX11_GNU_RETURNS_TWICE: return "CXX11_GNU_RETURNS_TWICE";
    case ReturnsTwiceAttrSpelling::C2X_GNU_RETURNS_TWICE: return "C2X_GNU_RETURNS_TWICE";
    case ReturnsTwiceAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SYCLKernelAttrSpelling e) {
  switch (e) {
    case SYCLKernelAttrSpelling::GNU_SYCL_KERNEL: return "GNU_SYCL_KERNEL";
    case SYCLKernelAttrSpelling::CXX11_CLANG_SYCL_KERNEL: return "CXX11_CLANG_SYCL_KERNEL";
    case SYCLKernelAttrSpelling::C2X_CLANG_SYCL_KERNEL: return "C2X_CLANG_SYCL_KERNEL";
    case SYCLKernelAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SYCLSpecialClassAttrSpelling e) {
  switch (e) {
    case SYCLSpecialClassAttrSpelling::GNU_SYCL_SPECIAL_CLASS: return "GNU_SYCL_SPECIAL_CLASS";
    case SYCLSpecialClassAttrSpelling::CXX11_CLANG_SYCL_SPECIAL_CLASS: return "CXX11_CLANG_SYCL_SPECIAL_CLASS";
    case SYCLSpecialClassAttrSpelling::C2X_CLANG_SYCL_SPECIAL_CLASS: return "C2X_CLANG_SYCL_SPECIAL_CLASS";
    case SYCLSpecialClassAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ScopedLockableAttrSpelling e) {
  switch (e) {
    case ScopedLockableAttrSpelling::GNU_SCOPED_LOCKABLE: return "GNU_SCOPED_LOCKABLE";
    case ScopedLockableAttrSpelling::CXX11_CLANG_SCOPED_LOCKABLE: return "CXX11_CLANG_SCOPED_LOCKABLE";
    case ScopedLockableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SectionAttrSpelling e) {
  switch (e) {
    case SectionAttrSpelling::GNU_SECTION: return "GNU_SECTION";
    case SectionAttrSpelling::CXX11_GNU_SECTION: return "CXX11_GNU_SECTION";
    case SectionAttrSpelling::C2X_GNU_SECTION: return "C2X_GNU_SECTION";
    case SectionAttrSpelling::DECLSPEC_ALLOCATE: return "DECLSPEC_ALLOCATE";
    case SectionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SelectAnyAttrSpelling e) {
  switch (e) {
    case SelectAnyAttrSpelling::DECLSPEC_SELECTANY: return "DECLSPEC_SELECTANY";
    case SelectAnyAttrSpelling::GNU_SELECTANY: return "GNU_SELECTANY";
    case SelectAnyAttrSpelling::CXX11_GNU_SELECTANY: return "CXX11_GNU_SELECTANY";
    case SelectAnyAttrSpelling::C2X_GNU_SELECTANY: return "C2X_GNU_SELECTANY";
    case SelectAnyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SentinelAttrSpelling e) {
  switch (e) {
    case SentinelAttrSpelling::GNU_SENTINEL: return "GNU_SENTINEL";
    case SentinelAttrSpelling::CXX11_GNU_SENTINEL: return "CXX11_GNU_SENTINEL";
    case SentinelAttrSpelling::C2X_GNU_SENTINEL: return "C2X_GNU_SENTINEL";
    case SentinelAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SetTypestateAttrConsumedState e) {
  switch (e) {
    case SetTypestateAttrConsumedState::UNKNOWN: return "UNKNOWN";
    case SetTypestateAttrConsumedState::CONSUMED: return "CONSUMED";
    case SetTypestateAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SetTypestateAttrSpelling e) {
  switch (e) {
    case SetTypestateAttrSpelling::GNU_TYPESTATE: return "GNU_TYPESTATE";
    case SetTypestateAttrSpelling::CXX11_CLANG_TYPESTATE: return "CXX11_CLANG_TYPESTATE";
    case SetTypestateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SourceLocExprIdentKind e) {
  switch (e) {
    case SourceLocExprIdentKind::FUNCTION: return "FUNCTION";
    case SourceLocExprIdentKind::FILE: return "FILE";
    case SourceLocExprIdentKind::LINE: return "LINE";
    case SourceLocExprIdentKind::COLUMN: return "COLUMN";
    case SourceLocExprIdentKind::SOURCE_TOKEN_STRUCT: return "SOURCE_TOKEN_STRUCT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SpeculativeLoadHardeningAttrSpelling e) {
  switch (e) {
    case SpeculativeLoadHardeningAttrSpelling::GNU_SPECULATIVE_LOAD_HARDENING: return "GNU_SPECULATIVE_LOAD_HARDENING";
    case SpeculativeLoadHardeningAttrSpelling::CXX11_CLANG_SPECULATIVE_LOAD_HARDENING: return "CXX11_CLANG_SPECULATIVE_LOAD_HARDENING";
    case SpeculativeLoadHardeningAttrSpelling::C2X_CLANG_SPECULATIVE_LOAD_HARDENING: return "C2X_CLANG_SPECULATIVE_LOAD_HARDENING";
    case SpeculativeLoadHardeningAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StandaloneDebugAttrSpelling e) {
  switch (e) {
    case StandaloneDebugAttrSpelling::GNU_STANDALONE_DEBUG: return "GNU_STANDALONE_DEBUG";
    case StandaloneDebugAttrSpelling::CXX11_CLANG_STANDALONE_DEBUG: return "CXX11_CLANG_STANDALONE_DEBUG";
    case StandaloneDebugAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StdCallAttrSpelling e) {
  switch (e) {
    case StdCallAttrSpelling::GNU_STDCALL: return "GNU_STDCALL";
    case StdCallAttrSpelling::CXX11_GNU_STDCALL: return "CXX11_GNU_STDCALL";
    case StdCallAttrSpelling::C2X_GNU_STDCALL: return "C2X_GNU_STDCALL";
    case StdCallAttrSpelling::KEYWORD_STDCALL: return "KEYWORD_STDCALL";
    case StdCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StmtLikelihood e) {
  switch (e) {
    case StmtLikelihood::UNLIKELY: return "UNLIKELY";
    case StmtLikelihood::NONE: return "NONE";
    case StmtLikelihood::LIKELY: return "LIKELY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StmtKind e) {
  switch (e) {
    case StmtKind::GCC_ASM_STMT: return "GCC_ASM_STMT";
    case StmtKind::MS_ASM_STMT: return "MS_ASM_STMT";
    case StmtKind::BREAK_STMT: return "BREAK_STMT";
    case StmtKind::CXX_CATCH_STMT: return "CXX_CATCH_STMT";
    case StmtKind::CXX_FOR_RANGE_STMT: return "CXX_FOR_RANGE_STMT";
    case StmtKind::CXX_TRY_STMT: return "CXX_TRY_STMT";
    case StmtKind::CAPTURED_STMT: return "CAPTURED_STMT";
    case StmtKind::COMPOUND_STMT: return "COMPOUND_STMT";
    case StmtKind::CONTINUE_STMT: return "CONTINUE_STMT";
    case StmtKind::CORETURN_STMT: return "CORETURN_STMT";
    case StmtKind::COROUTINE_BODY_STMT: return "COROUTINE_BODY_STMT";
    case StmtKind::DECL_STMT: return "DECL_STMT";
    case StmtKind::DO_STMT: return "DO_STMT";
    case StmtKind::FOR_STMT: return "FOR_STMT";
    case StmtKind::GOTO_STMT: return "GOTO_STMT";
    case StmtKind::IF_STMT: return "IF_STMT";
    case StmtKind::INDIRECT_GOTO_STMT: return "INDIRECT_GOTO_STMT";
    case StmtKind::MS_DEPENDENT_EXISTS_STMT: return "MS_DEPENDENT_EXISTS_STMT";
    case StmtKind::NULL_STMT: return "NULL_STMT";
    case StmtKind::OMP_CANONICAL_LOOP: return "OMP_CANONICAL_LOOP";
    case StmtKind::OMP_ATOMIC_DIRECTIVE: return "OMP_ATOMIC_DIRECTIVE";
    case StmtKind::OMP_BARRIER_DIRECTIVE: return "OMP_BARRIER_DIRECTIVE";
    case StmtKind::OMP_CANCEL_DIRECTIVE: return "OMP_CANCEL_DIRECTIVE";
    case StmtKind::OMP_CANCELLATION_POINT_DIRECTIVE: return "OMP_CANCELLATION_POINT_DIRECTIVE";
    case StmtKind::OMP_CRITICAL_DIRECTIVE: return "OMP_CRITICAL_DIRECTIVE";
    case StmtKind::OMP_DEPOBJ_DIRECTIVE: return "OMP_DEPOBJ_DIRECTIVE";
    case StmtKind::OMP_DISPATCH_DIRECTIVE: return "OMP_DISPATCH_DIRECTIVE";
    case StmtKind::OMP_FLUSH_DIRECTIVE: return "OMP_FLUSH_DIRECTIVE";
    case StmtKind::OMP_INTEROP_DIRECTIVE: return "OMP_INTEROP_DIRECTIVE";
    case StmtKind::OMP_DISTRIBUTE_DIRECTIVE: return "OMP_DISTRIBUTE_DIRECTIVE";
    case StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: return "OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE";
    case StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: return "OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE: return "OMP_DISTRIBUTE_SIMD_DIRECTIVE";
    case StmtKind::OMP_FOR_DIRECTIVE: return "OMP_FOR_DIRECTIVE";
    case StmtKind::OMP_FOR_SIMD_DIRECTIVE: return "OMP_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_GENERIC_LOOP_DIRECTIVE: return "OMP_GENERIC_LOOP_DIRECTIVE";
    case StmtKind::OMP_MASKED_TASK_LOOP_DIRECTIVE: return "OMP_MASKED_TASK_LOOP_DIRECTIVE";
    case StmtKind::OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE: return "OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE";
    case StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE: return "OMP_MASTER_TASK_LOOP_DIRECTIVE";
    case StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE: return "OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_FOR_DIRECTIVE: return "OMP_PARALLEL_FOR_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE: return "OMP_PARALLEL_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE: return "OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE: return "OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE: return "OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE: return "OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE: return "OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE";
    case StmtKind::OMP_SIMD_DIRECTIVE: return "OMP_SIMD_DIRECTIVE";
    case StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE: return "OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE: return "OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE";
    case StmtKind::OMP_TARGET_SIMD_DIRECTIVE: return "OMP_TARGET_SIMD_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE: return "OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: return "OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: return "OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: return "OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE: return "OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE";
    case StmtKind::OMP_TASK_LOOP_DIRECTIVE: return "OMP_TASK_LOOP_DIRECTIVE";
    case StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE: return "OMP_TASK_LOOP_SIMD_DIRECTIVE";
    case StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE: return "OMP_TEAMS_DISTRIBUTE_DIRECTIVE";
    case StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: return "OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE";
    case StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: return "OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE";
    case StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: return "OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE";
    case StmtKind::OMP_TEAMS_GENERIC_LOOP_DIRECTIVE: return "OMP_TEAMS_GENERIC_LOOP_DIRECTIVE";
    case StmtKind::OMP_TILE_DIRECTIVE: return "OMP_TILE_DIRECTIVE";
    case StmtKind::OMP_UNROLL_DIRECTIVE: return "OMP_UNROLL_DIRECTIVE";
    case StmtKind::OMP_MASKED_DIRECTIVE: return "OMP_MASKED_DIRECTIVE";
    case StmtKind::OMP_MASTER_DIRECTIVE: return "OMP_MASTER_DIRECTIVE";
    case StmtKind::OMP_META_DIRECTIVE: return "OMP_META_DIRECTIVE";
    case StmtKind::OMP_ORDERED_DIRECTIVE: return "OMP_ORDERED_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_DIRECTIVE: return "OMP_PARALLEL_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASKED_DIRECTIVE: return "OMP_PARALLEL_MASKED_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_MASTER_DIRECTIVE: return "OMP_PARALLEL_MASTER_DIRECTIVE";
    case StmtKind::OMP_PARALLEL_SECTIONS_DIRECTIVE: return "OMP_PARALLEL_SECTIONS_DIRECTIVE";
    case StmtKind::OMP_SCAN_DIRECTIVE: return "OMP_SCAN_DIRECTIVE";
    case StmtKind::OMP_SECTION_DIRECTIVE: return "OMP_SECTION_DIRECTIVE";
    case StmtKind::OMP_SECTIONS_DIRECTIVE: return "OMP_SECTIONS_DIRECTIVE";
    case StmtKind::OMP_SINGLE_DIRECTIVE: return "OMP_SINGLE_DIRECTIVE";
    case StmtKind::OMP_TARGET_DATA_DIRECTIVE: return "OMP_TARGET_DATA_DIRECTIVE";
    case StmtKind::OMP_TARGET_DIRECTIVE: return "OMP_TARGET_DIRECTIVE";
    case StmtKind::OMP_TARGET_ENTER_DATA_DIRECTIVE: return "OMP_TARGET_ENTER_DATA_DIRECTIVE";
    case StmtKind::OMP_TARGET_EXIT_DATA_DIRECTIVE: return "OMP_TARGET_EXIT_DATA_DIRECTIVE";
    case StmtKind::OMP_TARGET_PARALLEL_DIRECTIVE: return "OMP_TARGET_PARALLEL_DIRECTIVE";
    case StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE: return "OMP_TARGET_PARALLEL_FOR_DIRECTIVE";
    case StmtKind::OMP_TARGET_TEAMS_DIRECTIVE: return "OMP_TARGET_TEAMS_DIRECTIVE";
    case StmtKind::OMP_TARGET_UPDATE_DIRECTIVE: return "OMP_TARGET_UPDATE_DIRECTIVE";
    case StmtKind::OMP_TASK_DIRECTIVE: return "OMP_TASK_DIRECTIVE";
    case StmtKind::OMP_TASKGROUP_DIRECTIVE: return "OMP_TASKGROUP_DIRECTIVE";
    case StmtKind::OMP_TASKWAIT_DIRECTIVE: return "OMP_TASKWAIT_DIRECTIVE";
    case StmtKind::OMP_TASKYIELD_DIRECTIVE: return "OMP_TASKYIELD_DIRECTIVE";
    case StmtKind::OMP_TEAMS_DIRECTIVE: return "OMP_TEAMS_DIRECTIVE";
    case StmtKind::OBJ_C_AT_CATCH_STMT: return "OBJ_C_AT_CATCH_STMT";
    case StmtKind::OBJ_C_AT_FINALLY_STMT: return "OBJ_C_AT_FINALLY_STMT";
    case StmtKind::OBJ_C_AT_SYNCHRONIZED_STMT: return "OBJ_C_AT_SYNCHRONIZED_STMT";
    case StmtKind::OBJ_C_AT_THROW_STMT: return "OBJ_C_AT_THROW_STMT";
    case StmtKind::OBJ_C_AT_TRY_STMT: return "OBJ_C_AT_TRY_STMT";
    case StmtKind::OBJ_C_AUTORELEASE_POOL_STMT: return "OBJ_C_AUTORELEASE_POOL_STMT";
    case StmtKind::OBJ_C_FOR_COLLECTION_STMT: return "OBJ_C_FOR_COLLECTION_STMT";
    case StmtKind::RETURN_STMT: return "RETURN_STMT";
    case StmtKind::SEH_EXCEPT_STMT: return "SEH_EXCEPT_STMT";
    case StmtKind::SEH_FINALLY_STMT: return "SEH_FINALLY_STMT";
    case StmtKind::SEH_LEAVE_STMT: return "SEH_LEAVE_STMT";
    case StmtKind::SEH_TRY_STMT: return "SEH_TRY_STMT";
    case StmtKind::CASE_STMT: return "CASE_STMT";
    case StmtKind::DEFAULT_STMT: return "DEFAULT_STMT";
    case StmtKind::SWITCH_STMT: return "SWITCH_STMT";
    case StmtKind::ATTRIBUTED_STMT: return "ATTRIBUTED_STMT";
    case StmtKind::BINARY_CONDITIONAL_OPERATOR: return "BINARY_CONDITIONAL_OPERATOR";
    case StmtKind::CONDITIONAL_OPERATOR: return "CONDITIONAL_OPERATOR";
    case StmtKind::ADDR_LABEL_EXPR: return "ADDR_LABEL_EXPR";
    case StmtKind::ARRAY_INIT_INDEX_EXPR: return "ARRAY_INIT_INDEX_EXPR";
    case StmtKind::ARRAY_INIT_LOOP_EXPR: return "ARRAY_INIT_LOOP_EXPR";
    case StmtKind::ARRAY_SUBSCRIPT_EXPR: return "ARRAY_SUBSCRIPT_EXPR";
    case StmtKind::ARRAY_TYPE_TRAIT_EXPR: return "ARRAY_TYPE_TRAIT_EXPR";
    case StmtKind::AS_TYPE_EXPR: return "AS_TYPE_EXPR";
    case StmtKind::ATOMIC_EXPR: return "ATOMIC_EXPR";
    case StmtKind::BINARY_OPERATOR: return "BINARY_OPERATOR";
    case StmtKind::COMPOUND_ASSIGN_OPERATOR: return "COMPOUND_ASSIGN_OPERATOR";
    case StmtKind::BLOCK_EXPR: return "BLOCK_EXPR";
    case StmtKind::CXX_BIND_TEMPORARY_EXPR: return "CXX_BIND_TEMPORARY_EXPR";
    case StmtKind::CXX_BOOL_LITERAL_EXPR: return "CXX_BOOL_LITERAL_EXPR";
    case StmtKind::CXX_CONSTRUCT_EXPR: return "CXX_CONSTRUCT_EXPR";
    case StmtKind::CXX_TEMPORARY_OBJECT_EXPR: return "CXX_TEMPORARY_OBJECT_EXPR";
    case StmtKind::CXX_DEFAULT_ARG_EXPR: return "CXX_DEFAULT_ARG_EXPR";
    case StmtKind::CXX_DEFAULT_INIT_EXPR: return "CXX_DEFAULT_INIT_EXPR";
    case StmtKind::CXX_DELETE_EXPR: return "CXX_DELETE_EXPR";
    case StmtKind::CXX_DEPENDENT_SCOPE_MEMBER_EXPR: return "CXX_DEPENDENT_SCOPE_MEMBER_EXPR";
    case StmtKind::CXX_FOLD_EXPR: return "CXX_FOLD_EXPR";
    case StmtKind::CXX_INHERITED_CTOR_INIT_EXPR: return "CXX_INHERITED_CTOR_INIT_EXPR";
    case StmtKind::CXX_NEW_EXPR: return "CXX_NEW_EXPR";
    case StmtKind::CXX_NOEXCEPT_EXPR: return "CXX_NOEXCEPT_EXPR";
    case StmtKind::CXX_NULL_PTR_LITERAL_EXPR: return "CXX_NULL_PTR_LITERAL_EXPR";
    case StmtKind::CXX_PSEUDO_DESTRUCTOR_EXPR: return "CXX_PSEUDO_DESTRUCTOR_EXPR";
    case StmtKind::CXX_REWRITTEN_BINARY_OPERATOR: return "CXX_REWRITTEN_BINARY_OPERATOR";
    case StmtKind::CXX_SCALAR_VALUE_INIT_EXPR: return "CXX_SCALAR_VALUE_INIT_EXPR";
    case StmtKind::CXX_STD_INITIALIZER_LIST_EXPR: return "CXX_STD_INITIALIZER_LIST_EXPR";
    case StmtKind::CXX_THIS_EXPR: return "CXX_THIS_EXPR";
    case StmtKind::CXX_THROW_EXPR: return "CXX_THROW_EXPR";
    case StmtKind::CXX_TYPEID_EXPR: return "CXX_TYPEID_EXPR";
    case StmtKind::CXX_UNRESOLVED_CONSTRUCT_EXPR: return "CXX_UNRESOLVED_CONSTRUCT_EXPR";
    case StmtKind::CXX_UUIDOF_EXPR: return "CXX_UUIDOF_EXPR";
    case StmtKind::CALL_EXPR: return "CALL_EXPR";
    case StmtKind::CUDA_KERNEL_CALL_EXPR: return "CUDA_KERNEL_CALL_EXPR";
    case StmtKind::CXX_MEMBER_CALL_EXPR: return "CXX_MEMBER_CALL_EXPR";
    case StmtKind::CXX_OPERATOR_CALL_EXPR: return "CXX_OPERATOR_CALL_EXPR";
    case StmtKind::USER_DEFINED_LITERAL: return "USER_DEFINED_LITERAL";
    case StmtKind::BUILTIN_BIT_CAST_EXPR: return "BUILTIN_BIT_CAST_EXPR";
    case StmtKind::C_STYLE_CAST_EXPR: return "C_STYLE_CAST_EXPR";
    case StmtKind::CXX_FUNCTIONAL_CAST_EXPR: return "CXX_FUNCTIONAL_CAST_EXPR";
    case StmtKind::CXX_ADDRSPACE_CAST_EXPR: return "CXX_ADDRSPACE_CAST_EXPR";
    case StmtKind::CXX_CONST_CAST_EXPR: return "CXX_CONST_CAST_EXPR";
    case StmtKind::CXX_DYNAMIC_CAST_EXPR: return "CXX_DYNAMIC_CAST_EXPR";
    case StmtKind::CXX_REINTERPRET_CAST_EXPR: return "CXX_REINTERPRET_CAST_EXPR";
    case StmtKind::CXX_STATIC_CAST_EXPR: return "CXX_STATIC_CAST_EXPR";
    case StmtKind::OBJ_C_BRIDGED_CAST_EXPR: return "OBJ_C_BRIDGED_CAST_EXPR";
    case StmtKind::IMPLICIT_CAST_EXPR: return "IMPLICIT_CAST_EXPR";
    case StmtKind::CHARACTER_LITERAL: return "CHARACTER_LITERAL";
    case StmtKind::CHOOSE_EXPR: return "CHOOSE_EXPR";
    case StmtKind::COMPOUND_LITERAL_EXPR: return "COMPOUND_LITERAL_EXPR";
    case StmtKind::CONCEPT_SPECIALIZATION_EXPR: return "CONCEPT_SPECIALIZATION_EXPR";
    case StmtKind::CONVERT_VECTOR_EXPR: return "CONVERT_VECTOR_EXPR";
    case StmtKind::COAWAIT_EXPR: return "COAWAIT_EXPR";
    case StmtKind::COYIELD_EXPR: return "COYIELD_EXPR";
    case StmtKind::DECL_REF_EXPR: return "DECL_REF_EXPR";
    case StmtKind::DEPENDENT_COAWAIT_EXPR: return "DEPENDENT_COAWAIT_EXPR";
    case StmtKind::DEPENDENT_SCOPE_DECL_REF_EXPR: return "DEPENDENT_SCOPE_DECL_REF_EXPR";
    case StmtKind::DESIGNATED_INIT_EXPR: return "DESIGNATED_INIT_EXPR";
    case StmtKind::DESIGNATED_INIT_UPDATE_EXPR: return "DESIGNATED_INIT_UPDATE_EXPR";
    case StmtKind::EXPRESSION_TRAIT_EXPR: return "EXPRESSION_TRAIT_EXPR";
    case StmtKind::EXT_VECTOR_ELEMENT_EXPR: return "EXT_VECTOR_ELEMENT_EXPR";
    case StmtKind::FIXED_POINT_LITERAL: return "FIXED_POINT_LITERAL";
    case StmtKind::FLOATING_LITERAL: return "FLOATING_LITERAL";
    case StmtKind::CONSTANT_EXPR: return "CONSTANT_EXPR";
    case StmtKind::EXPR_WITH_CLEANUPS: return "EXPR_WITH_CLEANUPS";
    case StmtKind::FUNCTION_PARM_PACK_EXPR: return "FUNCTION_PARM_PACK_EXPR";
    case StmtKind::GNU_NULL_EXPR: return "GNU_NULL_EXPR";
    case StmtKind::GENERIC_SELECTION_EXPR: return "GENERIC_SELECTION_EXPR";
    case StmtKind::IMAGINARY_LITERAL: return "IMAGINARY_LITERAL";
    case StmtKind::IMPLICIT_VALUE_INIT_EXPR: return "IMPLICIT_VALUE_INIT_EXPR";
    case StmtKind::INIT_LIST_EXPR: return "INIT_LIST_EXPR";
    case StmtKind::INTEGER_LITERAL: return "INTEGER_LITERAL";
    case StmtKind::LAMBDA_EXPR: return "LAMBDA_EXPR";
    case StmtKind::MS_PROPERTY_REF_EXPR: return "MS_PROPERTY_REF_EXPR";
    case StmtKind::MS_PROPERTY_SUBSCRIPT_EXPR: return "MS_PROPERTY_SUBSCRIPT_EXPR";
    case StmtKind::MATERIALIZE_TEMPORARY_EXPR: return "MATERIALIZE_TEMPORARY_EXPR";
    case StmtKind::MATRIX_SUBSCRIPT_EXPR: return "MATRIX_SUBSCRIPT_EXPR";
    case StmtKind::MEMBER_EXPR: return "MEMBER_EXPR";
    case StmtKind::NO_INIT_EXPR: return "NO_INIT_EXPR";
    case StmtKind::OMP_ARRAY_SECTION_EXPR: return "OMP_ARRAY_SECTION_EXPR";
    case StmtKind::OMP_ARRAY_SHAPING_EXPR: return "OMP_ARRAY_SHAPING_EXPR";
    case StmtKind::OMP_ITERATOR_EXPR: return "OMP_ITERATOR_EXPR";
    case StmtKind::OBJ_C_ARRAY_LITERAL: return "OBJ_C_ARRAY_LITERAL";
    case StmtKind::OBJ_C_AVAILABILITY_CHECK_EXPR: return "OBJ_C_AVAILABILITY_CHECK_EXPR";
    case StmtKind::OBJ_C_BOOL_LITERAL_EXPR: return "OBJ_C_BOOL_LITERAL_EXPR";
    case StmtKind::OBJ_C_BOXED_EXPR: return "OBJ_C_BOXED_EXPR";
    case StmtKind::OBJ_C_DICTIONARY_LITERAL: return "OBJ_C_DICTIONARY_LITERAL";
    case StmtKind::OBJ_C_ENCODE_EXPR: return "OBJ_C_ENCODE_EXPR";
    case StmtKind::OBJ_C_INDIRECT_COPY_RESTORE_EXPR: return "OBJ_C_INDIRECT_COPY_RESTORE_EXPR";
    case StmtKind::OBJ_C_ISA_EXPR: return "OBJ_C_ISA_EXPR";
    case StmtKind::OBJ_C_IVAR_REF_EXPR: return "OBJ_C_IVAR_REF_EXPR";
    case StmtKind::OBJ_C_MESSAGE_EXPR: return "OBJ_C_MESSAGE_EXPR";
    case StmtKind::OBJ_C_PROPERTY_REF_EXPR: return "OBJ_C_PROPERTY_REF_EXPR";
    case StmtKind::OBJ_C_PROTOCOL_EXPR: return "OBJ_C_PROTOCOL_EXPR";
    case StmtKind::OBJ_C_SELECTOR_EXPR: return "OBJ_C_SELECTOR_EXPR";
    case StmtKind::OBJ_C_STRING_LITERAL: return "OBJ_C_STRING_LITERAL";
    case StmtKind::OBJ_C_SUBSCRIPT_REF_EXPR: return "OBJ_C_SUBSCRIPT_REF_EXPR";
    case StmtKind::OFFSET_OF_EXPR: return "OFFSET_OF_EXPR";
    case StmtKind::OPAQUE_VALUE_EXPR: return "OPAQUE_VALUE_EXPR";
    case StmtKind::UNRESOLVED_LOOKUP_EXPR: return "UNRESOLVED_LOOKUP_EXPR";
    case StmtKind::UNRESOLVED_MEMBER_EXPR: return "UNRESOLVED_MEMBER_EXPR";
    case StmtKind::PACK_EXPANSION_EXPR: return "PACK_EXPANSION_EXPR";
    case StmtKind::PAREN_EXPR: return "PAREN_EXPR";
    case StmtKind::PAREN_LIST_EXPR: return "PAREN_LIST_EXPR";
    case StmtKind::PREDEFINED_EXPR: return "PREDEFINED_EXPR";
    case StmtKind::PSEUDO_OBJECT_EXPR: return "PSEUDO_OBJECT_EXPR";
    case StmtKind::RECOVERY_EXPR: return "RECOVERY_EXPR";
    case StmtKind::REQUIRES_EXPR: return "REQUIRES_EXPR";
    case StmtKind::SYCL_UNIQUE_STABLE_NAME_EXPR: return "SYCL_UNIQUE_STABLE_NAME_EXPR";
    case StmtKind::SHUFFLE_VECTOR_EXPR: return "SHUFFLE_VECTOR_EXPR";
    case StmtKind::SIZE_OF_PACK_EXPR: return "SIZE_OF_PACK_EXPR";
    case StmtKind::SOURCE_LOC_EXPR: return "SOURCE_LOC_EXPR";
    case StmtKind::STMT_EXPR: return "STMT_EXPR";
    case StmtKind::STRING_LITERAL: return "STRING_LITERAL";
    case StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_EXPR: return "SUBST_NON_TYPE_TEMPLATE_PARM_EXPR";
    case StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR: return "SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR";
    case StmtKind::TYPE_TRAIT_EXPR: return "TYPE_TRAIT_EXPR";
    case StmtKind::TYPO_EXPR: return "TYPO_EXPR";
    case StmtKind::UNARY_EXPR_OR_TYPE_TRAIT_EXPR: return "UNARY_EXPR_OR_TYPE_TRAIT_EXPR";
    case StmtKind::UNARY_OPERATOR: return "UNARY_OPERATOR";
    case StmtKind::VA_ARG_EXPR: return "VA_ARG_EXPR";
    case StmtKind::LABEL_STMT: return "LABEL_STMT";
    case StmtKind::WHILE_STMT: return "WHILE_STMT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StringLiteralStringKind e) {
  switch (e) {
    case StringLiteralStringKind::ORDINARY: return "ORDINARY";
    case StringLiteralStringKind::WIDE: return "WIDE";
    case StringLiteralStringKind::UTF8: return "UTF8";
    case StringLiteralStringKind::UTF16: return "UTF16";
    case StringLiteralStringKind::UTF32: return "UTF32";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncAttrKind e) {
  switch (e) {
    case SwiftAsyncAttrKind::NONE: return "NONE";
    case SwiftAsyncAttrKind::SWIFT_PRIVATE: return "SWIFT_PRIVATE";
    case SwiftAsyncAttrKind::NOT_SWIFT_PRIVATE: return "NOT_SWIFT_PRIVATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncAttrSpelling e) {
  switch (e) {
    case SwiftAsyncAttrSpelling::GNU_SWIFT_ASYNC: return "GNU_SWIFT_ASYNC";
    case SwiftAsyncAttrSpelling::CXX11_CLANG_SWIFT_ASYNC: return "CXX11_CLANG_SWIFT_ASYNC";
    case SwiftAsyncAttrSpelling::C2X_CLANG_SWIFT_ASYNC: return "C2X_CLANG_SWIFT_ASYNC";
    case SwiftAsyncAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncCallAttrSpelling e) {
  switch (e) {
    case SwiftAsyncCallAttrSpelling::GNU_SWIFTASYNCCALL: return "GNU_SWIFTASYNCCALL";
    case SwiftAsyncCallAttrSpelling::CXX11_CLANG_SWIFTASYNCCALL: return "CXX11_CLANG_SWIFTASYNCCALL";
    case SwiftAsyncCallAttrSpelling::C2X_CLANG_SWIFTASYNCCALL: return "C2X_CLANG_SWIFTASYNCCALL";
    case SwiftAsyncCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncContextAttrSpelling e) {
  switch (e) {
    case SwiftAsyncContextAttrSpelling::GNU_SWIFT_ASYNC_CONTEXT: return "GNU_SWIFT_ASYNC_CONTEXT";
    case SwiftAsyncContextAttrSpelling::CXX11_CLANG_SWIFT_ASYNC_CONTEXT: return "CXX11_CLANG_SWIFT_ASYNC_CONTEXT";
    case SwiftAsyncContextAttrSpelling::C2X_CLANG_SWIFT_ASYNC_CONTEXT: return "C2X_CLANG_SWIFT_ASYNC_CONTEXT";
    case SwiftAsyncContextAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncErrorAttrConventionKind e) {
  switch (e) {
    case SwiftAsyncErrorAttrConventionKind::NONE: return "NONE";
    case SwiftAsyncErrorAttrConventionKind::NON_NULL_ERROR: return "NON_NULL_ERROR";
    case SwiftAsyncErrorAttrConventionKind::ZERO_ARGUMENT: return "ZERO_ARGUMENT";
    case SwiftAsyncErrorAttrConventionKind::NON_ZERO_ARGUMENT: return "NON_ZERO_ARGUMENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncErrorAttrSpelling e) {
  switch (e) {
    case SwiftAsyncErrorAttrSpelling::GNU_SWIFT_ASYNC_ERROR: return "GNU_SWIFT_ASYNC_ERROR";
    case SwiftAsyncErrorAttrSpelling::CXX11_CLANG_SWIFT_ASYNC_ERROR: return "CXX11_CLANG_SWIFT_ASYNC_ERROR";
    case SwiftAsyncErrorAttrSpelling::C2X_CLANG_SWIFT_ASYNC_ERROR: return "C2X_CLANG_SWIFT_ASYNC_ERROR";
    case SwiftAsyncErrorAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftCallAttrSpelling e) {
  switch (e) {
    case SwiftCallAttrSpelling::GNU_SWIFTCALL: return "GNU_SWIFTCALL";
    case SwiftCallAttrSpelling::CXX11_CLANG_SWIFTCALL: return "CXX11_CLANG_SWIFTCALL";
    case SwiftCallAttrSpelling::C2X_CLANG_SWIFTCALL: return "C2X_CLANG_SWIFTCALL";
    case SwiftCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftContextAttrSpelling e) {
  switch (e) {
    case SwiftContextAttrSpelling::GNU_SWIFT_CONTEXT: return "GNU_SWIFT_CONTEXT";
    case SwiftContextAttrSpelling::CXX11_CLANG_SWIFT_CONTEXT: return "CXX11_CLANG_SWIFT_CONTEXT";
    case SwiftContextAttrSpelling::C2X_CLANG_SWIFT_CONTEXT: return "C2X_CLANG_SWIFT_CONTEXT";
    case SwiftContextAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftErrorAttrConventionKind e) {
  switch (e) {
    case SwiftErrorAttrConventionKind::NONE: return "NONE";
    case SwiftErrorAttrConventionKind::NON_NULL_ERROR: return "NON_NULL_ERROR";
    case SwiftErrorAttrConventionKind::NULL_RESULT: return "NULL_RESULT";
    case SwiftErrorAttrConventionKind::ZERO_RESULT: return "ZERO_RESULT";
    case SwiftErrorAttrConventionKind::NON_ZERO_RESULT: return "NON_ZERO_RESULT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftErrorResultAttrSpelling e) {
  switch (e) {
    case SwiftErrorResultAttrSpelling::GNU_SWIFT_ERROR_RESULT: return "GNU_SWIFT_ERROR_RESULT";
    case SwiftErrorResultAttrSpelling::CXX11_CLANG_SWIFT_ERROR_RESULT: return "CXX11_CLANG_SWIFT_ERROR_RESULT";
    case SwiftErrorResultAttrSpelling::C2X_CLANG_SWIFT_ERROR_RESULT: return "C2X_CLANG_SWIFT_ERROR_RESULT";
    case SwiftErrorResultAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftIndirectResultAttrSpelling e) {
  switch (e) {
    case SwiftIndirectResultAttrSpelling::GNU_SWIFT_INDIRECT_RESULT: return "GNU_SWIFT_INDIRECT_RESULT";
    case SwiftIndirectResultAttrSpelling::CXX11_CLANG_SWIFT_INDIRECT_RESULT: return "CXX11_CLANG_SWIFT_INDIRECT_RESULT";
    case SwiftIndirectResultAttrSpelling::C2X_CLANG_SWIFT_INDIRECT_RESULT: return "C2X_CLANG_SWIFT_INDIRECT_RESULT";
    case SwiftIndirectResultAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftNewTypeAttrNewtypeKind e) {
  switch (e) {
    case SwiftNewTypeAttrNewtypeKind::STRUCT: return "STRUCT";
    case SwiftNewTypeAttrNewtypeKind::ENUM: return "ENUM";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftNewTypeAttrSpelling e) {
  switch (e) {
    case SwiftNewTypeAttrSpelling::GNU_SWIFT_NEWTYPE: return "GNU_SWIFT_NEWTYPE";
    case SwiftNewTypeAttrSpelling::GNU_SWIFT_WRAPPER: return "GNU_SWIFT_WRAPPER";
    case SwiftNewTypeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SysVABIAttrSpelling e) {
  switch (e) {
    case SysVABIAttrSpelling::GNU_SYSV_ABI: return "GNU_SYSV_ABI";
    case SysVABIAttrSpelling::CXX11_GNU_SYSV_ABI: return "CXX11_GNU_SYSV_ABI";
    case SysVABIAttrSpelling::C2X_GNU_SYSV_ABI: return "C2X_GNU_SYSV_ABI";
    case SysVABIAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TLSModelAttrSpelling e) {
  switch (e) {
    case TLSModelAttrSpelling::GNU_TLS_MODEL: return "GNU_TLS_MODEL";
    case TLSModelAttrSpelling::CXX11_GNU_TLS_MODEL: return "CXX11_GNU_TLS_MODEL";
    case TLSModelAttrSpelling::C2X_GNU_TLS_MODEL: return "C2X_GNU_TLS_MODEL";
    case TLSModelAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TargetAttrSpelling e) {
  switch (e) {
    case TargetAttrSpelling::GNU_TARGET: return "GNU_TARGET";
    case TargetAttrSpelling::CXX11_GNU_TARGET: return "CXX11_GNU_TARGET";
    case TargetAttrSpelling::C2X_GNU_TARGET: return "C2X_GNU_TARGET";
    case TargetAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TargetClonesAttrSpelling e) {
  switch (e) {
    case TargetClonesAttrSpelling::GNU_TARGET_CLONES: return "GNU_TARGET_CLONES";
    case TargetClonesAttrSpelling::CXX11_GNU_TARGET_CLONES: return "CXX11_GNU_TARGET_CLONES";
    case TargetClonesAttrSpelling::C2X_GNU_TARGET_CLONES: return "C2X_GNU_TARGET_CLONES";
    case TargetClonesAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TemplateArgumentKind e) {
  switch (e) {
    case TemplateArgumentKind::EMPTY: return "EMPTY";
    case TemplateArgumentKind::TYPE: return "TYPE";
    case TemplateArgumentKind::DECLARATION: return "DECLARATION";
    case TemplateArgumentKind::NULL_POINTER: return "NULL_POINTER";
    case TemplateArgumentKind::INTEGRAL: return "INTEGRAL";
    case TemplateArgumentKind::TEMPLATE: return "TEMPLATE";
    case TemplateArgumentKind::TEMPLATE_EXPANSION: return "TEMPLATE_EXPANSION";
    case TemplateArgumentKind::EXPRESSION: return "EXPRESSION";
    case TemplateArgumentKind::PACK: return "PACK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TestTypestateAttrConsumedState e) {
  switch (e) {
    case TestTypestateAttrConsumedState::CONSUMED: return "CONSUMED";
    case TestTypestateAttrConsumedState::UNCONSUMED: return "UNCONSUMED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TestTypestateAttrSpelling e) {
  switch (e) {
    case TestTypestateAttrSpelling::GNU_TEST_TYPESTATE: return "GNU_TEST_TYPESTATE";
    case TestTypestateAttrSpelling::CXX11_CLANG_TEST_TYPESTATE: return "CXX11_CLANG_TEST_TYPESTATE";
    case TestTypestateAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ThisCallAttrSpelling e) {
  switch (e) {
    case ThisCallAttrSpelling::GNU_THISCALL: return "GNU_THISCALL";
    case ThisCallAttrSpelling::CXX11_GNU_THISCALL: return "CXX11_GNU_THISCALL";
    case ThisCallAttrSpelling::C2X_GNU_THISCALL: return "C2X_GNU_THISCALL";
    case ThisCallAttrSpelling::KEYWORD_THISCALL: return "KEYWORD_THISCALL";
    case ThisCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TransparentUnionAttrSpelling e) {
  switch (e) {
    case TransparentUnionAttrSpelling::GNU_TRANSPARENT_UNION: return "GNU_TRANSPARENT_UNION";
    case TransparentUnionAttrSpelling::CXX11_GNU_TRANSPARENT_UNION: return "CXX11_GNU_TRANSPARENT_UNION";
    case TransparentUnionAttrSpelling::C2X_GNU_TRANSPARENT_UNION: return "C2X_GNU_TRANSPARENT_UNION";
    case TransparentUnionAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TrivialABIAttrSpelling e) {
  switch (e) {
    case TrivialABIAttrSpelling::GNU_TRIVIAL_ABI: return "GNU_TRIVIAL_ABI";
    case TrivialABIAttrSpelling::CXX11_CLANG_TRIVIAL_ABI: return "CXX11_CLANG_TRIVIAL_ABI";
    case TrivialABIAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TryAcquireCapabilityAttrSpelling e) {
  switch (e) {
    case TryAcquireCapabilityAttrSpelling::GNU_TRY_ACQUIRE_CAPABILITY: return "GNU_TRY_ACQUIRE_CAPABILITY";
    case TryAcquireCapabilityAttrSpelling::CXX11_CLANG_TRY_ACQUIRE_CAPABILITY: return "CXX11_CLANG_TRY_ACQUIRE_CAPABILITY";
    case TryAcquireCapabilityAttrSpelling::GNU_TRY_ACQUIRE_SHARED_CAPABILITY: return "GNU_TRY_ACQUIRE_SHARED_CAPABILITY";
    case TryAcquireCapabilityAttrSpelling::CXX11_CLANG_TRY_ACQUIRE_SHARED_CAPABILITY: return "CXX11_CLANG_TRY_ACQUIRE_SHARED_CAPABILITY";
    case TryAcquireCapabilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeScalarTypeKind e) {
  switch (e) {
    case TypeScalarTypeKind::C_POINTER: return "C_POINTER";
    case TypeScalarTypeKind::BLOCK_POINTER: return "BLOCK_POINTER";
    case TypeScalarTypeKind::OBJ_C_OBJECT_POINTER: return "OBJ_C_OBJECT_POINTER";
    case TypeScalarTypeKind::MEMBER_POINTER: return "MEMBER_POINTER";
    case TypeScalarTypeKind::BOOLEAN: return "BOOLEAN";
    case TypeScalarTypeKind::INTEGRAL: return "INTEGRAL";
    case TypeScalarTypeKind::FLOATING: return "FLOATING";
    case TypeScalarTypeKind::INTEGRAL_COMPLEX: return "INTEGRAL_COMPLEX";
    case TypeScalarTypeKind::FLOATING_COMPLEX: return "FLOATING_COMPLEX";
    case TypeScalarTypeKind::FIXED_POINT: return "FIXED_POINT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeKind e) {
  switch (e) {
    case TypeKind::ADJUSTED: return "ADJUSTED";
    case TypeKind::DECAYED: return "DECAYED";
    case TypeKind::CONSTANT_ARRAY: return "CONSTANT_ARRAY";
    case TypeKind::DEPENDENT_SIZED_ARRAY: return "DEPENDENT_SIZED_ARRAY";
    case TypeKind::INCOMPLETE_ARRAY: return "INCOMPLETE_ARRAY";
    case TypeKind::VARIABLE_ARRAY: return "VARIABLE_ARRAY";
    case TypeKind::ATOMIC: return "ATOMIC";
    case TypeKind::ATTRIBUTED: return "ATTRIBUTED";
    case TypeKind::BTF_TAG_ATTRIBUTED: return "BTF_TAG_ATTRIBUTED";
    case TypeKind::BIT_INT: return "BIT_INT";
    case TypeKind::BLOCK_POINTER: return "BLOCK_POINTER";
    case TypeKind::BUILTIN: return "BUILTIN";
    case TypeKind::COMPLEX: return "COMPLEX";
    case TypeKind::DECLTYPE: return "DECLTYPE";
    case TypeKind::AUTO: return "AUTO";
    case TypeKind::DEDUCED_TEMPLATE_SPECIALIZATION: return "DEDUCED_TEMPLATE_SPECIALIZATION";
    case TypeKind::DEPENDENT_ADDRESS_SPACE: return "DEPENDENT_ADDRESS_SPACE";
    case TypeKind::DEPENDENT_BIT_INT: return "DEPENDENT_BIT_INT";
    case TypeKind::DEPENDENT_NAME: return "DEPENDENT_NAME";
    case TypeKind::DEPENDENT_SIZED_EXT_VECTOR: return "DEPENDENT_SIZED_EXT_VECTOR";
    case TypeKind::DEPENDENT_TEMPLATE_SPECIALIZATION: return "DEPENDENT_TEMPLATE_SPECIALIZATION";
    case TypeKind::DEPENDENT_VECTOR: return "DEPENDENT_VECTOR";
    case TypeKind::ELABORATED: return "ELABORATED";
    case TypeKind::FUNCTION_NO_PROTO: return "FUNCTION_NO_PROTO";
    case TypeKind::FUNCTION_PROTO: return "FUNCTION_PROTO";
    case TypeKind::INJECTED_CLASS_NAME: return "INJECTED_CLASS_NAME";
    case TypeKind::MACRO_QUALIFIED: return "MACRO_QUALIFIED";
    case TypeKind::CONSTANT_MATRIX: return "CONSTANT_MATRIX";
    case TypeKind::DEPENDENT_SIZED_MATRIX: return "DEPENDENT_SIZED_MATRIX";
    case TypeKind::MEMBER_POINTER: return "MEMBER_POINTER";
    case TypeKind::OBJ_C_OBJECT_POINTER: return "OBJ_C_OBJECT_POINTER";
    case TypeKind::OBJ_C_OBJECT: return "OBJ_C_OBJECT";
    case TypeKind::OBJ_C_INTERFACE: return "OBJ_C_INTERFACE";
    case TypeKind::OBJ_C_TYPE_PARAM: return "OBJ_C_TYPE_PARAM";
    case TypeKind::PACK_EXPANSION: return "PACK_EXPANSION";
    case TypeKind::PAREN: return "PAREN";
    case TypeKind::PIPE: return "PIPE";
    case TypeKind::POINTER: return "POINTER";
    case TypeKind::L_VALUE_REFERENCE: return "L_VALUE_REFERENCE";
    case TypeKind::R_VALUE_REFERENCE: return "R_VALUE_REFERENCE";
    case TypeKind::SUBST_TEMPLATE_TYPE_PARM_PACK: return "SUBST_TEMPLATE_TYPE_PARM_PACK";
    case TypeKind::SUBST_TEMPLATE_TYPE_PARM: return "SUBST_TEMPLATE_TYPE_PARM";
    case TypeKind::ENUM: return "ENUM";
    case TypeKind::RECORD: return "RECORD";
    case TypeKind::TEMPLATE_SPECIALIZATION: return "TEMPLATE_SPECIALIZATION";
    case TypeKind::TEMPLATE_TYPE_PARM: return "TEMPLATE_TYPE_PARM";
    case TypeKind::TYPE_OF_EXPR: return "TYPE_OF_EXPR";
    case TypeKind::TYPE_OF: return "TYPE_OF";
    case TypeKind::TYPEDEF: return "TYPEDEF";
    case TypeKind::UNARY_TRANSFORM: return "UNARY_TRANSFORM";
    case TypeKind::UNRESOLVED_USING: return "UNRESOLVED_USING";
    case TypeKind::USING: return "USING";
    case TypeKind::VECTOR: return "VECTOR";
    case TypeKind::EXT_VECTOR: return "EXT_VECTOR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeTagForDatatypeAttrSpelling e) {
  switch (e) {
    case TypeTagForDatatypeAttrSpelling::GNU_TYPE_TAG_FOR_DATATYPE: return "GNU_TYPE_TAG_FOR_DATATYPE";
    case TypeTagForDatatypeAttrSpelling::CXX11_CLANG_TYPE_TAG_FOR_DATATYPE: return "CXX11_CLANG_TYPE_TAG_FOR_DATATYPE";
    case TypeTagForDatatypeAttrSpelling::C2X_CLANG_TYPE_TAG_FOR_DATATYPE: return "C2X_CLANG_TYPE_TAG_FOR_DATATYPE";
    case TypeTagForDatatypeAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeVisibilityAttrSpelling e) {
  switch (e) {
    case TypeVisibilityAttrSpelling::GNU_TYPE_VISIBILITY: return "GNU_TYPE_VISIBILITY";
    case TypeVisibilityAttrSpelling::CXX11_CLANG_TYPE_VISIBILITY: return "CXX11_CLANG_TYPE_VISIBILITY";
    case TypeVisibilityAttrSpelling::C2X_CLANG_TYPE_VISIBILITY: return "C2X_CLANG_TYPE_VISIBILITY";
    case TypeVisibilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeVisibilityAttrVisibilityType e) {
  switch (e) {
    case TypeVisibilityAttrVisibilityType::DEFAULT: return "DEFAULT";
    case TypeVisibilityAttrVisibilityType::HIDDEN: return "HIDDEN";
    case TypeVisibilityAttrVisibilityType::PROTECTED: return "PROTECTED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnaryTransformTypeUTTKind e) {
  switch (e) {
    case UnaryTransformTypeUTTKind::ENUM_UNDERLYING_TYPE: return "ENUM_UNDERLYING_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnavailableAttrImplicitReason e) {
  switch (e) {
    case UnavailableAttrImplicitReason::NONE: return "NONE";
    case UnavailableAttrImplicitReason::ARC_FORBIDDEN_TYPE: return "ARC_FORBIDDEN_TYPE";
    case UnavailableAttrImplicitReason::FORBIDDEN_WEAK: return "FORBIDDEN_WEAK";
    case UnavailableAttrImplicitReason::ARC_FORBIDDEN_CONVERSION: return "ARC_FORBIDDEN_CONVERSION";
    case UnavailableAttrImplicitReason::ARC_INIT_RETURNS_UNRELATED: return "ARC_INIT_RETURNS_UNRELATED";
    case UnavailableAttrImplicitReason::ARC_FIELD_WITH_OWNERSHIP: return "ARC_FIELD_WITH_OWNERSHIP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnavailableAttrSpelling e) {
  switch (e) {
    case UnavailableAttrSpelling::GNU_UNAVAILABLE: return "GNU_UNAVAILABLE";
    case UnavailableAttrSpelling::CXX11_CLANG_UNAVAILABLE: return "CXX11_CLANG_UNAVAILABLE";
    case UnavailableAttrSpelling::C2X_CLANG_UNAVAILABLE: return "C2X_CLANG_UNAVAILABLE";
    case UnavailableAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UninitializedAttrSpelling e) {
  switch (e) {
    case UninitializedAttrSpelling::GNU_UNINITIALIZED: return "GNU_UNINITIALIZED";
    case UninitializedAttrSpelling::CXX11_CLANG_UNINITIALIZED: return "CXX11_CLANG_UNINITIALIZED";
    case UninitializedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnlikelyAttrSpelling e) {
  switch (e) {
    case UnlikelyAttrSpelling::CXX11_UNLIKELY: return "CXX11_UNLIKELY";
    case UnlikelyAttrSpelling::C2X_CLANG_UNLIKELY: return "C2X_CLANG_UNLIKELY";
    case UnlikelyAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnusedAttrSpelling e) {
  switch (e) {
    case UnusedAttrSpelling::CXX11_MAYBE_UNUSED: return "CXX11_MAYBE_UNUSED";
    case UnusedAttrSpelling::GNU_UNUSED: return "GNU_UNUSED";
    case UnusedAttrSpelling::CXX11_GNU_UNUSED: return "CXX11_GNU_UNUSED";
    case UnusedAttrSpelling::C2X_GNU_UNUSED: return "C2X_GNU_UNUSED";
    case UnusedAttrSpelling::C2X_MAYBE_UNUSED: return "C2X_MAYBE_UNUSED";
    case UnusedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UseHandleAttrSpelling e) {
  switch (e) {
    case UseHandleAttrSpelling::GNU_USE_HANDLE: return "GNU_USE_HANDLE";
    case UseHandleAttrSpelling::CXX11_CLANG_USE_HANDLE: return "CXX11_CLANG_USE_HANDLE";
    case UseHandleAttrSpelling::C2X_CLANG_USE_HANDLE: return "C2X_CLANG_USE_HANDLE";
    case UseHandleAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UsedAttrSpelling e) {
  switch (e) {
    case UsedAttrSpelling::GNU_USED: return "GNU_USED";
    case UsedAttrSpelling::CXX11_GNU_USED: return "CXX11_GNU_USED";
    case UsedAttrSpelling::C2X_GNU_USED: return "C2X_GNU_USED";
    case UsedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UserDefinedLiteralLiteralOperatorKind e) {
  switch (e) {
    case UserDefinedLiteralLiteralOperatorKind::RAW: return "RAW";
    case UserDefinedLiteralLiteralOperatorKind::TEMPLATE: return "TEMPLATE";
    case UserDefinedLiteralLiteralOperatorKind::INTEGER: return "INTEGER";
    case UserDefinedLiteralLiteralOperatorKind::FLOATING: return "FLOATING";
    case UserDefinedLiteralLiteralOperatorKind::STRING: return "STRING";
    case UserDefinedLiteralLiteralOperatorKind::CHARACTER: return "CHARACTER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UsingIfExistsAttrSpelling e) {
  switch (e) {
    case UsingIfExistsAttrSpelling::GNU_USING_IF_EXISTS: return "GNU_USING_IF_EXISTS";
    case UsingIfExistsAttrSpelling::CXX11_CLANG_USING_IF_EXISTS: return "CXX11_CLANG_USING_IF_EXISTS";
    case UsingIfExistsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UuidAttrSpelling e) {
  switch (e) {
    case UuidAttrSpelling::DECLSPEC_UUID: return "DECLSPEC_UUID";
    case UuidAttrSpelling::MICROSOFT_UUID: return "MICROSOFT_UUID";
    case UuidAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VarDeclDefinitionKind e) {
  switch (e) {
    case VarDeclDefinitionKind::DECLARATION_ONLY: return "DECLARATION_ONLY";
    case VarDeclDefinitionKind::TENTATIVE_DEFINITION: return "TENTATIVE_DEFINITION";
    case VarDeclDefinitionKind::DEFINITION: return "DEFINITION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VarDeclInitializationStyle e) {
  switch (e) {
    case VarDeclInitializationStyle::C_INIT: return "C_INIT";
    case VarDeclInitializationStyle::CALL_INITIALIZER: return "CALL_INITIALIZER";
    case VarDeclInitializationStyle::LIST_INITIALIZER: return "LIST_INITIALIZER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VarDeclTLSKind e) {
  switch (e) {
    case VarDeclTLSKind::NONE: return "NONE";
    case VarDeclTLSKind::STATIC: return "STATIC";
    case VarDeclTLSKind::DYNAMIC: return "DYNAMIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VecReturnAttrSpelling e) {
  switch (e) {
    case VecReturnAttrSpelling::GNU_VECRETURN: return "GNU_VECRETURN";
    case VecReturnAttrSpelling::CXX11_CLANG_VECRETURN: return "CXX11_CLANG_VECRETURN";
    case VecReturnAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VectorCallAttrSpelling e) {
  switch (e) {
    case VectorCallAttrSpelling::GNU_VECTORCALL: return "GNU_VECTORCALL";
    case VectorCallAttrSpelling::CXX11_CLANG_VECTORCALL: return "CXX11_CLANG_VECTORCALL";
    case VectorCallAttrSpelling::C2X_CLANG_VECTORCALL: return "C2X_CLANG_VECTORCALL";
    case VectorCallAttrSpelling::KEYWORD_VECTORCALL: return "KEYWORD_VECTORCALL";
    case VectorCallAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VectorTypeVectorKind e) {
  switch (e) {
    case VectorTypeVectorKind::GENERIC_VECTOR: return "GENERIC_VECTOR";
    case VectorTypeVectorKind::ALTI_VEC_VECTOR: return "ALTI_VEC_VECTOR";
    case VectorTypeVectorKind::ALTI_VEC_PIXEL: return "ALTI_VEC_PIXEL";
    case VectorTypeVectorKind::ALTI_VEC_BOOLEAN: return "ALTI_VEC_BOOLEAN";
    case VectorTypeVectorKind::NEON_VECTOR: return "NEON_VECTOR";
    case VectorTypeVectorKind::NEON_POLY_VECTOR: return "NEON_POLY_VECTOR";
    case VectorTypeVectorKind::SVE_FIXED_LENGTH_DATA_VECTOR: return "SVE_FIXED_LENGTH_DATA_VECTOR";
    case VectorTypeVectorKind::SVE_FIXED_LENGTH_PREDICATE_VECTOR: return "SVE_FIXED_LENGTH_PREDICATE_VECTOR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VisibilityAttrSpelling e) {
  switch (e) {
    case VisibilityAttrSpelling::GNU_VISIBILITY: return "GNU_VISIBILITY";
    case VisibilityAttrSpelling::CXX11_GNU_VISIBILITY: return "CXX11_GNU_VISIBILITY";
    case VisibilityAttrSpelling::C2X_GNU_VISIBILITY: return "C2X_GNU_VISIBILITY";
    case VisibilityAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VisibilityAttrVisibilityType e) {
  switch (e) {
    case VisibilityAttrVisibilityType::DEFAULT: return "DEFAULT";
    case VisibilityAttrVisibilityType::HIDDEN: return "HIDDEN";
    case VisibilityAttrVisibilityType::PROTECTED: return "PROTECTED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WarnUnusedAttrSpelling e) {
  switch (e) {
    case WarnUnusedAttrSpelling::GNU_WARN_UNUSED: return "GNU_WARN_UNUSED";
    case WarnUnusedAttrSpelling::CXX11_GNU_WARN_UNUSED: return "CXX11_GNU_WARN_UNUSED";
    case WarnUnusedAttrSpelling::C2X_GNU_WARN_UNUSED: return "C2X_GNU_WARN_UNUSED";
    case WarnUnusedAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WarnUnusedResultAttrSpelling e) {
  switch (e) {
    case WarnUnusedResultAttrSpelling::CXX11_NODISCARD: return "CXX11_NODISCARD";
    case WarnUnusedResultAttrSpelling::C2X_NODISCARD: return "C2X_NODISCARD";
    case WarnUnusedResultAttrSpelling::CXX11_CLANG_WARN_UNUSED_RESULT: return "CXX11_CLANG_WARN_UNUSED_RESULT";
    case WarnUnusedResultAttrSpelling::GNU_WARN_UNUSED_RESULT: return "GNU_WARN_UNUSED_RESULT";
    case WarnUnusedResultAttrSpelling::CXX11_GNU_WARN_UNUSED_RESULT: return "CXX11_GNU_WARN_UNUSED_RESULT";
    case WarnUnusedResultAttrSpelling::C2X_GNU_WARN_UNUSED_RESULT: return "C2X_GNU_WARN_UNUSED_RESULT";
    case WarnUnusedResultAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WeakAttrSpelling e) {
  switch (e) {
    case WeakAttrSpelling::GNU_WEAK: return "GNU_WEAK";
    case WeakAttrSpelling::CXX11_GNU_WEAK: return "CXX11_GNU_WEAK";
    case WeakAttrSpelling::C2X_GNU_WEAK: return "C2X_GNU_WEAK";
    case WeakAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WeakImportAttrSpelling e) {
  switch (e) {
    case WeakImportAttrSpelling::GNU_WEAK_IMPORT: return "GNU_WEAK_IMPORT";
    case WeakImportAttrSpelling::CXX11_CLANG_WEAK_IMPORT: return "CXX11_CLANG_WEAK_IMPORT";
    case WeakImportAttrSpelling::C2X_CLANG_WEAK_IMPORT: return "C2X_CLANG_WEAK_IMPORT";
    case WeakImportAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WeakRefAttrSpelling e) {
  switch (e) {
    case WeakRefAttrSpelling::GNU_WEAKREF: return "GNU_WEAKREF";
    case WeakRefAttrSpelling::CXX11_GNU_WEAKREF: return "CXX11_GNU_WEAKREF";
    case WeakRefAttrSpelling::C2X_GNU_WEAKREF: return "C2X_GNU_WEAKREF";
    case WeakRefAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WebAssemblyExportNameAttrSpelling e) {
  switch (e) {
    case WebAssemblyExportNameAttrSpelling::GNU_EXPORT_NAME: return "GNU_EXPORT_NAME";
    case WebAssemblyExportNameAttrSpelling::CXX11_CLANG_EXPORT_NAME: return "CXX11_CLANG_EXPORT_NAME";
    case WebAssemblyExportNameAttrSpelling::C2X_CLANG_EXPORT_NAME: return "C2X_CLANG_EXPORT_NAME";
    case WebAssemblyExportNameAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WebAssemblyImportModuleAttrSpelling e) {
  switch (e) {
    case WebAssemblyImportModuleAttrSpelling::GNU_IMPORT_MODULE: return "GNU_IMPORT_MODULE";
    case WebAssemblyImportModuleAttrSpelling::CXX11_CLANG_IMPORT_MODULE: return "CXX11_CLANG_IMPORT_MODULE";
    case WebAssemblyImportModuleAttrSpelling::C2X_CLANG_IMPORT_MODULE: return "C2X_CLANG_IMPORT_MODULE";
    case WebAssemblyImportModuleAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(WebAssemblyImportNameAttrSpelling e) {
  switch (e) {
    case WebAssemblyImportNameAttrSpelling::GNU_IMPORT_NAME: return "GNU_IMPORT_NAME";
    case WebAssemblyImportNameAttrSpelling::CXX11_CLANG_IMPORT_NAME: return "CXX11_CLANG_IMPORT_NAME";
    case WebAssemblyImportNameAttrSpelling::C2X_CLANG_IMPORT_NAME: return "C2X_CLANG_IMPORT_NAME";
    case WebAssemblyImportNameAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(X86ForceAlignArgPointerAttrSpelling e) {
  switch (e) {
    case X86ForceAlignArgPointerAttrSpelling::GNU_FORCE_ALIGN_ARGUMENT_POINTER: return "GNU_FORCE_ALIGN_ARGUMENT_POINTER";
    case X86ForceAlignArgPointerAttrSpelling::CXX11_GNU_FORCE_ALIGN_ARGUMENT_POINTER: return "CXX11_GNU_FORCE_ALIGN_ARGUMENT_POINTER";
    case X86ForceAlignArgPointerAttrSpelling::C2X_GNU_FORCE_ALIGN_ARGUMENT_POINTER: return "C2X_GNU_FORCE_ALIGN_ARGUMENT_POINTER";
    case X86ForceAlignArgPointerAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(XRayInstrumentAttrSpelling e) {
  switch (e) {
    case XRayInstrumentAttrSpelling::GNU_XRAY_ALWAYS_INSTRUMENT: return "GNU_XRAY_ALWAYS_INSTRUMENT";
    case XRayInstrumentAttrSpelling::CXX11_CLANG_XRAY_ALWAYS_INSTRUMENT: return "CXX11_CLANG_XRAY_ALWAYS_INSTRUMENT";
    case XRayInstrumentAttrSpelling::C2X_CLANG_XRAY_ALWAYS_INSTRUMENT: return "C2X_CLANG_XRAY_ALWAYS_INSTRUMENT";
    case XRayInstrumentAttrSpelling::GNU_XRAY_NEVER_INSTRUMENT: return "GNU_XRAY_NEVER_INSTRUMENT";
    case XRayInstrumentAttrSpelling::CXX11_CLANG_XRAY_NEVER_INSTRUMENT: return "CXX11_CLANG_XRAY_NEVER_INSTRUMENT";
    case XRayInstrumentAttrSpelling::C2X_CLANG_XRAY_NEVER_INSTRUMENT: return "C2X_CLANG_XRAY_NEVER_INSTRUMENT";
    case XRayInstrumentAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(XRayLogArgsAttrSpelling e) {
  switch (e) {
    case XRayLogArgsAttrSpelling::GNU_XRAY_LOG_ARGUMENTS: return "GNU_XRAY_LOG_ARGUMENTS";
    case XRayLogArgsAttrSpelling::CXX11_CLANG_XRAY_LOG_ARGUMENTS: return "CXX11_CLANG_XRAY_LOG_ARGUMENTS";
    case XRayLogArgsAttrSpelling::C2X_CLANG_XRAY_LOG_ARGUMENTS: return "C2X_CLANG_XRAY_LOG_ARGUMENTS";
    case XRayLogArgsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ZeroCallUsedRegsAttrSpelling e) {
  switch (e) {
    case ZeroCallUsedRegsAttrSpelling::GNU_ZERO_CALL_USED_REGS: return "GNU_ZERO_CALL_USED_REGS";
    case ZeroCallUsedRegsAttrSpelling::CXX11_GNU_ZERO_CALL_USED_REGS: return "CXX11_GNU_ZERO_CALL_USED_REGS";
    case ZeroCallUsedRegsAttrSpelling::C2X_GNU_ZERO_CALL_USED_REGS: return "C2X_GNU_ZERO_CALL_USED_REGS";
    case ZeroCallUsedRegsAttrSpelling::SPELLING_NOT_CALCULATED: return "SPELLING_NOT_CALCULATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ZeroCallUsedRegsAttrZeroCallUsedRegsKind e) {
  switch (e) {
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::SKIP: return "SKIP";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::USED_GPR_ARG: return "USED_GPR_ARG";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::USED_GPR: return "USED_GPR";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::USED_ARGUMENT: return "USED_ARGUMENT";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::USED: return "USED";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::ALL_GPR_ARG: return "ALL_GPR_ARG";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::ALL_GPR: return "ALL_GPR";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::ALL_ARGUMENT: return "ALL_ARGUMENT";
    case ZeroCallUsedRegsAttrZeroCallUsedRegsKind::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ASTDumpOutputFormat e) {
  switch (e) {
    case ASTDumpOutputFormat::DEFAULT: return "DEFAULT";
    case ASTDumpOutputFormat::JSON: return "JSON";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AccessSpecifier e) {
  switch (e) {
    case AccessSpecifier::PUBLIC: return "PUBLIC";
    case AccessSpecifier::PROTECTED: return "PROTECTED";
    case AccessSpecifier::PRIVATE: return "PRIVATE";
    case AccessSpecifier::NONE: return "NONE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AddrSpaceMapMangling e) {
  switch (e) {
    case AddrSpaceMapMangling::TARGET: return "TARGET";
    case AddrSpaceMapMangling::ON: return "ON";
    case AddrSpaceMapMangling::OFF: return "OFF";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AlignRequirementKind e) {
  switch (e) {
    case AlignRequirementKind::NONE: return "NONE";
    case AlignRequirementKind::REQUIRED_BY_TYPEDEF: return "REQUIRED_BY_TYPEDEF";
    case AlignRequirementKind::REQUIRED_BY_RECORD: return "REQUIRED_BY_RECORD";
    case AlignRequirementKind::REQUIRED_BY_ENUM: return "REQUIRED_BY_ENUM";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AltivecSrcCompatKind e) {
  switch (e) {
    case AltivecSrcCompatKind::MIXED: return "MIXED";
    case AltivecSrcCompatKind::GCC: return "GCC";
    case AltivecSrcCompatKind::XL: return "XL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArgumentKind e) {
  switch (e) {
    case ArgumentKind::STD_STRING: return "STD_STRING";
    case ArgumentKind::C_STRING: return "C_STRING";
    case ArgumentKind::SINT: return "SINT";
    case ArgumentKind::UINT: return "UINT";
    case ArgumentKind::TOKENKIND: return "TOKENKIND";
    case ArgumentKind::IDENTIFIERINFO: return "IDENTIFIERINFO";
    case ArgumentKind::ADDRSPACE: return "ADDRSPACE";
    case ArgumentKind::QUALIFIED: return "QUALIFIED";
    case ArgumentKind::QUALTYPE: return "QUALTYPE";
    case ArgumentKind::DECLARATIONNAME: return "DECLARATIONNAME";
    case ArgumentKind::NAMEDDECL: return "NAMEDDECL";
    case ArgumentKind::NESTEDNAMESPEC: return "NESTEDNAMESPEC";
    case ArgumentKind::DECLCONTEXT: return "DECLCONTEXT";
    case ArgumentKind::QUALTYPE_PAIR: return "QUALTYPE_PAIR";
    case ArgumentKind::ATTRIBUTE: return "ATTRIBUTE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ArrayTypeTrait e) {
  switch (e) {
    case ArrayTypeTrait::ARRAY_RANK: return "ARRAY_RANK";
    case ArrayTypeTrait::ARRAY_EXTENT: return "ARRAY_EXTENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AtomicScopeModelKind e) {
  switch (e) {
    case AtomicScopeModelKind::NONE: return "NONE";
    case AtomicScopeModelKind::OPEN_CL: return "OPEN_CL";
    case AtomicScopeModelKind::HIP: return "HIP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AutoTypeKeyword e) {
  switch (e) {
    case AutoTypeKeyword::AUTO: return "AUTO";
    case AutoTypeKeyword::DECLTYPE_AUTO: return "DECLTYPE_AUTO";
    case AutoTypeKeyword::GNU_AUTO_TYPE: return "GNU_AUTO_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AvailabilityResult e) {
  switch (e) {
    case AvailabilityResult::AVAILABLE: return "AVAILABLE";
    case AvailabilityResult::NOT_YET_INTRODUCED: return "NOT_YET_INTRODUCED";
    case AvailabilityResult::DEPRECATED: return "DEPRECATED";
    case AvailabilityResult::UNAVAILABLE: return "UNAVAILABLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(BinaryOperatorKind e) {
  switch (e) {
    case BinaryOperatorKind::POINTER_MEMORY_D: return "POINTER_MEMORY_D";
    case BinaryOperatorKind::POINTER_MEMORY_I: return "POINTER_MEMORY_I";
    case BinaryOperatorKind::MUL: return "MUL";
    case BinaryOperatorKind::DIV: return "DIV";
    case BinaryOperatorKind::REM: return "REM";
    case BinaryOperatorKind::ADD: return "ADD";
    case BinaryOperatorKind::SUB: return "SUB";
    case BinaryOperatorKind::SHL: return "SHL";
    case BinaryOperatorKind::SHR: return "SHR";
    case BinaryOperatorKind::CMP: return "CMP";
    case BinaryOperatorKind::LT: return "LT";
    case BinaryOperatorKind::GT: return "GT";
    case BinaryOperatorKind::LE: return "LE";
    case BinaryOperatorKind::GE: return "GE";
    case BinaryOperatorKind::EQ: return "EQ";
    case BinaryOperatorKind::NE: return "NE";
    case BinaryOperatorKind::AND: return "AND";
    case BinaryOperatorKind::XOR: return "XOR";
    case BinaryOperatorKind::OR: return "OR";
    case BinaryOperatorKind::L_AND: return "L_AND";
    case BinaryOperatorKind::L_OR: return "L_OR";
    case BinaryOperatorKind::ASSIGN: return "ASSIGN";
    case BinaryOperatorKind::MUL_ASSIGN: return "MUL_ASSIGN";
    case BinaryOperatorKind::DIV_ASSIGN: return "DIV_ASSIGN";
    case BinaryOperatorKind::REM_ASSIGN: return "REM_ASSIGN";
    case BinaryOperatorKind::ADD_ASSIGN: return "ADD_ASSIGN";
    case BinaryOperatorKind::SUB_ASSIGN: return "SUB_ASSIGN";
    case BinaryOperatorKind::SHL_ASSIGN: return "SHL_ASSIGN";
    case BinaryOperatorKind::SHR_ASSIGN: return "SHR_ASSIGN";
    case BinaryOperatorKind::AND_ASSIGN: return "AND_ASSIGN";
    case BinaryOperatorKind::XOR_ASSIGN: return "XOR_ASSIGN";
    case BinaryOperatorKind::OR_ASSIGN: return "OR_ASSIGN";
    case BinaryOperatorKind::COMMA: return "COMMA";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Bits e) {
  switch (e) {
    case Bits::NONE: return "NONE";
    case Bits::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case Bits::INSTANTIATION: return "INSTANTIATION";
    case Bits::TYPE: return "TYPE";
    case Bits::VALUE: return "VALUE";
    case Bits::DEPENDENT: return "DEPENDENT";
    case Bits::ERROR: return "ERROR";
    case Bits::VARIABLY_MODIFIED: return "VARIABLY_MODIFIED";
    case Bits::SYNTACTIC: return "SYNTACTIC";
    case Bits::SEMANTIC: return "SEMANTIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CallingConv e) {
  switch (e) {
    case CallingConv::C: return "C";
    case CallingConv::X86_STD_CALL: return "X86_STD_CALL";
    case CallingConv::X86_FAST_CALL: return "X86_FAST_CALL";
    case CallingConv::X86_THIS_CALL: return "X86_THIS_CALL";
    case CallingConv::X86_VECTOR_CALL: return "X86_VECTOR_CALL";
    case CallingConv::X86_PASCAL: return "X86_PASCAL";
    case CallingConv::WIN64: return "WIN64";
    case CallingConv::X8664_SYS_V: return "X8664_SYS_V";
    case CallingConv::X86_REG_CALL: return "X86_REG_CALL";
    case CallingConv::AAPCS: return "AAPCS";
    case CallingConv::AAPCSVFP: return "AAPCSVFP";
    case CallingConv::INTEL_OCL_BICC: return "INTEL_OCL_BICC";
    case CallingConv::SPIR_FUNCTION: return "SPIR_FUNCTION";
    case CallingConv::OPEN_CL_KERNEL: return "OPEN_CL_KERNEL";
    case CallingConv::SWIFT: return "SWIFT";
    case CallingConv::SWIFT_ASYNC: return "SWIFT_ASYNC";
    case CallingConv::PRESERVE_MOST: return "PRESERVE_MOST";
    case CallingConv::PRESERVE_ALL: return "PRESERVE_ALL";
    case CallingConv::A_ARCH64_VECTOR_CALL: return "A_ARCH64_VECTOR_CALL";
    case CallingConv::A_ARCH64_SVEPCS: return "A_ARCH64_SVEPCS";
    case CallingConv::AMDGPU_KERNEL_CALL: return "AMDGPU_KERNEL_CALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CanThrowResult e) {
  switch (e) {
    case CanThrowResult::CANNOT: return "CANNOT";
    case CanThrowResult::DEPENDENT: return "DEPENDENT";
    case CanThrowResult::CAN: return "CAN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CapturedRegionKind e) {
  switch (e) {
    case CapturedRegionKind::DEFAULT: return "DEFAULT";
    case CapturedRegionKind::OBJ_C_AT_FINALLY: return "OBJ_C_AT_FINALLY";
    case CapturedRegionKind::OPEN_MP: return "OPEN_MP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CastKind e) {
  switch (e) {
    case CastKind::DEPENDENT: return "DEPENDENT";
    case CastKind::BIT_CAST: return "BIT_CAST";
    case CastKind::L_VALUE_BIT_CAST: return "L_VALUE_BIT_CAST";
    case CastKind::L_VALUE_TO_R_VALUE_BIT_CAST: return "L_VALUE_TO_R_VALUE_BIT_CAST";
    case CastKind::L_VALUE_TO_R_VALUE: return "L_VALUE_TO_R_VALUE";
    case CastKind::NO_OPERATION: return "NO_OPERATION";
    case CastKind::BASE_TO_DERIVED: return "BASE_TO_DERIVED";
    case CastKind::DERIVED_TO_BASE: return "DERIVED_TO_BASE";
    case CastKind::UNCHECKED_DERIVED_TO_BASE: return "UNCHECKED_DERIVED_TO_BASE";
    case CastKind::DYNAMIC: return "DYNAMIC";
    case CastKind::TO_UNION: return "TO_UNION";
    case CastKind::ARRAY_TO_POINTER_DECAY: return "ARRAY_TO_POINTER_DECAY";
    case CastKind::FUNCTION_TO_POINTER_DECAY: return "FUNCTION_TO_POINTER_DECAY";
    case CastKind::NULL_TO_POINTER: return "NULL_TO_POINTER";
    case CastKind::NULL_TO_MEMBER_POINTER: return "NULL_TO_MEMBER_POINTER";
    case CastKind::BASE_TO_DERIVED_MEMBER_POINTER: return "BASE_TO_DERIVED_MEMBER_POINTER";
    case CastKind::DERIVED_TO_BASE_MEMBER_POINTER: return "DERIVED_TO_BASE_MEMBER_POINTER";
    case CastKind::MEMBER_POINTER_TO_BOOLEAN: return "MEMBER_POINTER_TO_BOOLEAN";
    case CastKind::REINTERPRET_MEMBER_POINTER: return "REINTERPRET_MEMBER_POINTER";
    case CastKind::USER_DEFINED_CONVERSION: return "USER_DEFINED_CONVERSION";
    case CastKind::CONSTRUCTOR_CONVERSION: return "CONSTRUCTOR_CONVERSION";
    case CastKind::INTEGRAL_TO_POINTER: return "INTEGRAL_TO_POINTER";
    case CastKind::POINTER_TO_INTEGRAL: return "POINTER_TO_INTEGRAL";
    case CastKind::POINTER_TO_BOOLEAN: return "POINTER_TO_BOOLEAN";
    case CastKind::TO_VOID: return "TO_VOID";
    case CastKind::MATRIX_CAST: return "MATRIX_CAST";
    case CastKind::VECTOR_SPLAT: return "VECTOR_SPLAT";
    case CastKind::INTEGRAL_CAST: return "INTEGRAL_CAST";
    case CastKind::INTEGRAL_TO_BOOLEAN: return "INTEGRAL_TO_BOOLEAN";
    case CastKind::INTEGRAL_TO_FLOATING: return "INTEGRAL_TO_FLOATING";
    case CastKind::FLOATING_TO_FIXED_POINT: return "FLOATING_TO_FIXED_POINT";
    case CastKind::FIXED_POINT_TO_FLOATING: return "FIXED_POINT_TO_FLOATING";
    case CastKind::FIXED_POINT_CAST: return "FIXED_POINT_CAST";
    case CastKind::FIXED_POINT_TO_INTEGRAL: return "FIXED_POINT_TO_INTEGRAL";
    case CastKind::INTEGRAL_TO_FIXED_POINT: return "INTEGRAL_TO_FIXED_POINT";
    case CastKind::FIXED_POINT_TO_BOOLEAN: return "FIXED_POINT_TO_BOOLEAN";
    case CastKind::FLOATING_TO_INTEGRAL: return "FLOATING_TO_INTEGRAL";
    case CastKind::FLOATING_TO_BOOLEAN: return "FLOATING_TO_BOOLEAN";
    case CastKind::BOOLEAN_TO_SIGNED_INTEGRAL: return "BOOLEAN_TO_SIGNED_INTEGRAL";
    case CastKind::FLOATING_CAST: return "FLOATING_CAST";
    case CastKind::C_POINTER_TO_OBJ_C_POINTER_CAST: return "C_POINTER_TO_OBJ_C_POINTER_CAST";
    case CastKind::BLOCK_POINTER_TO_OBJ_C_POINTER_CAST: return "BLOCK_POINTER_TO_OBJ_C_POINTER_CAST";
    case CastKind::ANY_POINTER_TO_BLOCK_POINTER_CAST: return "ANY_POINTER_TO_BLOCK_POINTER_CAST";
    case CastKind::OBJ_C_OBJECT_L_VALUE_CAST: return "OBJ_C_OBJECT_L_VALUE_CAST";
    case CastKind::FLOATING_REAL_TO_COMPLEX: return "FLOATING_REAL_TO_COMPLEX";
    case CastKind::FLOATING_COMPLEX_TO_REAL: return "FLOATING_COMPLEX_TO_REAL";
    case CastKind::FLOATING_COMPLEX_TO_BOOLEAN: return "FLOATING_COMPLEX_TO_BOOLEAN";
    case CastKind::FLOATING_COMPLEX_CAST: return "FLOATING_COMPLEX_CAST";
    case CastKind::FLOATING_COMPLEX_TO_INTEGRAL_COMPLEX: return "FLOATING_COMPLEX_TO_INTEGRAL_COMPLEX";
    case CastKind::INTEGRAL_REAL_TO_COMPLEX: return "INTEGRAL_REAL_TO_COMPLEX";
    case CastKind::INTEGRAL_COMPLEX_TO_REAL: return "INTEGRAL_COMPLEX_TO_REAL";
    case CastKind::INTEGRAL_COMPLEX_TO_BOOLEAN: return "INTEGRAL_COMPLEX_TO_BOOLEAN";
    case CastKind::INTEGRAL_COMPLEX_CAST: return "INTEGRAL_COMPLEX_CAST";
    case CastKind::INTEGRAL_COMPLEX_TO_FLOATING_COMPLEX: return "INTEGRAL_COMPLEX_TO_FLOATING_COMPLEX";
    case CastKind::ARC_PRODUCE_OBJECT: return "ARC_PRODUCE_OBJECT";
    case CastKind::ARC_CONSUME_OBJECT: return "ARC_CONSUME_OBJECT";
    case CastKind::ARC_RECLAIM_RETURNED_OBJECT: return "ARC_RECLAIM_RETURNED_OBJECT";
    case CastKind::ARC_EXTEND_BLOCK_OBJECT: return "ARC_EXTEND_BLOCK_OBJECT";
    case CastKind::ATOMIC_TO_NON_ATOMIC: return "ATOMIC_TO_NON_ATOMIC";
    case CastKind::NON_ATOMIC_TO_ATOMIC: return "NON_ATOMIC_TO_ATOMIC";
    case CastKind::COPY_AND_AUTORELEASE_BLOCK_OBJECT: return "COPY_AND_AUTORELEASE_BLOCK_OBJECT";
    case CastKind::BUILTIN_FN_TO_FN_POINTER: return "BUILTIN_FN_TO_FN_POINTER";
    case CastKind::ZERO_TO_OCL_OPAQUE_TYPE: return "ZERO_TO_OCL_OPAQUE_TYPE";
    case CastKind::ADDRESS_SPACE_CONVERSION: return "ADDRESS_SPACE_CONVERSION";
    case CastKind::INT_TO_OCL_SAMPLER: return "INT_TO_OCL_SAMPLER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ClangABI e) {
  switch (e) {
    case ClangABI::VER38: return "VER38";
    case ClangABI::VER4: return "VER4";
    case ClangABI::VER6: return "VER6";
    case ClangABI::VER7: return "VER7";
    case ClangABI::VER9: return "VER9";
    case ClangABI::VER11: return "VER11";
    case ClangABI::VER12: return "VER12";
    case ClangABI::VER14: return "VER14";
    case ClangABI::LATEST: return "LATEST";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CommentKind e) {
  switch (e) {
    case CommentKind::INVALID: return "INVALID";
    case CommentKind::ORDINARY_BCPL: return "ORDINARY_BCPL";
    case CommentKind::ORDINARY_C: return "ORDINARY_C";
    case CommentKind::BCPL_SLASH: return "BCPL_SLASH";
    case CommentKind::BCPL_EXCL: return "BCPL_EXCL";
    case CommentKind::JAVA_DOC: return "JAVA_DOC";
    case CommentKind::QT: return "QT";
    case CommentKind::MERGED: return "MERGED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ComparisonCategoryResult e) {
  switch (e) {
    case ComparisonCategoryResult::EQUAL: return "EQUAL";
    case ComparisonCategoryResult::EQUIVALENT: return "EQUIVALENT";
    case ComparisonCategoryResult::LESS: return "LESS";
    case ComparisonCategoryResult::GREATER: return "GREATER";
    case ComparisonCategoryResult::UNORDERED: return "UNORDERED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ComparisonCategoryType e) {
  switch (e) {
    case ComparisonCategoryType::PARTIAL_ORDERING: return "PARTIAL_ORDERING";
    case ComparisonCategoryType::WEAK_ORDERING: return "WEAK_ORDERING";
    case ComparisonCategoryType::STRONG_ORDERING: return "STRONG_ORDERING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CompilingModuleKind e) {
  switch (e) {
    case CompilingModuleKind::NONE: return "NONE";
    case CompilingModuleKind::MODULE_MAP: return "MODULE_MAP";
    case CompilingModuleKind::HEADER_MODULE: return "HEADER_MODULE";
    case CompilingModuleKind::HEADER_UNIT: return "HEADER_UNIT";
    case CompilingModuleKind::MODULE_INTERFACE: return "MODULE_INTERFACE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ConstexprSpecKind e) {
  switch (e) {
    case ConstexprSpecKind::UNSPECIFIED: return "UNSPECIFIED";
    case ConstexprSpecKind::CONSTEXPR: return "CONSTEXPR";
    case ConstexprSpecKind::CONSTEVAL: return "CONSTEVAL";
    case ConstexprSpecKind::CONSTINIT: return "CONSTINIT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CoreFoundationABI e) {
  switch (e) {
    case CoreFoundationABI::UNSPECIFIED: return "UNSPECIFIED";
    case CoreFoundationABI::STANDALONE: return "STANDALONE";
    case CoreFoundationABI::OBJECTIVE_C: return "OBJECTIVE_C";
    case CoreFoundationABI::SWIFT: return "SWIFT";
    case CoreFoundationABI::SWIFT50: return "SWIFT50";
    case CoreFoundationABI::SWIFT42: return "SWIFT42";
    case CoreFoundationABI::SWIFT41: return "SWIFT41";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DataPositionTy e) {
  switch (e) {
    case DataPositionTy::POSX: return "POSX";
    case DataPositionTy::POSV: return "POSV";
    case DataPositionTy::POSE: return "POSE";
    case DataPositionTy::POS_UPDATE_EXPRESSION: return "POS_UPDATE_EXPRESSION";
    case DataPositionTy::POSD: return "POSD";
    case DataPositionTy::POS_CONDITION: return "POS_CONDITION";
    case DataPositionTy::POSR: return "POSR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DefaultArgKind e) {
  switch (e) {
    case DefaultArgKind::NONE: return "NONE";
    case DefaultArgKind::UNPARSED: return "UNPARSED";
    case DefaultArgKind::UNINSTANTIATED: return "UNINSTANTIATED";
    case DefaultArgKind::NORMAL: return "NORMAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DefaultCallingConvention e) {
  switch (e) {
    case DefaultCallingConvention::NONE: return "NONE";
    case DefaultCallingConvention::C_DECL: return "C_DECL";
    case DefaultCallingConvention::FAST_CALL: return "FAST_CALL";
    case DefaultCallingConvention::STD_CALL: return "STD_CALL";
    case DefaultCallingConvention::VECTOR_CALL: return "VECTOR_CALL";
    case DefaultCallingConvention::REG_CALL: return "REG_CALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DefaultVisiblityExportMapping e) {
  switch (e) {
    case DefaultVisiblityExportMapping::NONE: return "NONE";
    case DefaultVisiblityExportMapping::EXPLICIT: return "EXPLICIT";
    case DefaultVisiblityExportMapping::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DiagnosticLevelMask e) {
  switch (e) {
    case DiagnosticLevelMask::NONE: return "NONE";
    case DiagnosticLevelMask::NOTE: return "NOTE";
    case DiagnosticLevelMask::REMARK: return "REMARK";
    case DiagnosticLevelMask::WARNING: return "WARNING";
    case DiagnosticLevelMask::ERROR: return "ERROR";
    case DiagnosticLevelMask::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ElaboratedTypeKeyword e) {
  switch (e) {
    case ElaboratedTypeKeyword::STRUCT: return "STRUCT";
    case ElaboratedTypeKeyword::INTERFACE: return "INTERFACE";
    case ElaboratedTypeKeyword::UNION: return "UNION";
    case ElaboratedTypeKeyword::CLASS: return "CLASS";
    case ElaboratedTypeKeyword::ENUM: return "ENUM";
    case ElaboratedTypeKeyword::TYPENAME: return "TYPENAME";
    case ElaboratedTypeKeyword::NONE: return "NONE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EmbedBitcodeKind e) {
  switch (e) {
    case EmbedBitcodeKind::EMBED_OFF: return "EMBED_OFF";
    case EmbedBitcodeKind::EMBED_ALL: return "EMBED_ALL";
    case EmbedBitcodeKind::EMBED_BITCODE: return "EMBED_BITCODE";
    case EmbedBitcodeKind::EMBED_MARKER: return "EMBED_MARKER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(EscapeChar e) {
  switch (e) {
    case EscapeChar::SINGLE: return "SINGLE";
    case EscapeChar::DOUBLE: return "DOUBLE";
    case EscapeChar::SINGLE_AND_DOUBLE: return "SINGLE_AND_DOUBLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExceptionHandlingKind e) {
  switch (e) {
    case ExceptionHandlingKind::NONE: return "NONE";
    case ExceptionHandlingKind::SJ_LJ: return "SJ_LJ";
    case ExceptionHandlingKind::WIN_EH: return "WIN_EH";
    case ExceptionHandlingKind::DWARF_CFI: return "DWARF_CFI";
    case ExceptionHandlingKind::WASM: return "WASM";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExceptionSpecificationType e) {
  switch (e) {
    case ExceptionSpecificationType::NONE: return "NONE";
    case ExceptionSpecificationType::DYNAMIC_NONE: return "DYNAMIC_NONE";
    case ExceptionSpecificationType::DYNAMIC: return "DYNAMIC";
    case ExceptionSpecificationType::MS_ANY: return "MS_ANY";
    case ExceptionSpecificationType::NO_THROW: return "NO_THROW";
    case ExceptionSpecificationType::BASIC_NOEXCEPT: return "BASIC_NOEXCEPT";
    case ExceptionSpecificationType::DEPENDENT_NOEXCEPT: return "DEPENDENT_NOEXCEPT";
    case ExceptionSpecificationType::NOEXCEPT_FALSE: return "NOEXCEPT_FALSE";
    case ExceptionSpecificationType::NOEXCEPT_TRUE: return "NOEXCEPT_TRUE";
    case ExceptionSpecificationType::UNEVALUATED: return "UNEVALUATED";
    case ExceptionSpecificationType::UNINSTANTIATED: return "UNINSTANTIATED";
    case ExceptionSpecificationType::UNPARSED: return "UNPARSED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExplicitSpecKind e) {
  switch (e) {
    case ExplicitSpecKind::RESOLVED_FALSE: return "RESOLVED_FALSE";
    case ExplicitSpecKind::RESOLVED_TRUE: return "RESOLVED_TRUE";
    case ExplicitSpecKind::UNRESOLVED: return "UNRESOLVED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprDependence e) {
  switch (e) {
    case ExprDependence::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case ExprDependence::INSTANTIATION: return "INSTANTIATION";
    case ExprDependence::TYPE: return "TYPE";
    case ExprDependence::VALUE: return "VALUE";
    case ExprDependence::ERROR: return "ERROR";
    case ExprDependence::NONE: return "NONE";
    case ExprDependence::ALL: return "ALL";
    case ExprDependence::TYPE_VALUE: return "TYPE_VALUE";
    case ExprDependence::TYPE_INSTANTIATION: return "TYPE_INSTANTIATION";
    case ExprDependence::VALUE_INSTANTIATION: return "VALUE_INSTANTIATION";
    case ExprDependence::TYPE_VALUE_INSTANTIATION: return "TYPE_VALUE_INSTANTIATION";
    case ExprDependence::ERROR_DEPENDENT: return "ERROR_DEPENDENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprObjectKind e) {
  switch (e) {
    case ExprObjectKind::ORDINARY: return "ORDINARY";
    case ExprObjectKind::BIT_FIELD: return "BIT_FIELD";
    case ExprObjectKind::VECTOR_COMPONENT: return "VECTOR_COMPONENT";
    case ExprObjectKind::OBJ_C_PROPERTY: return "OBJ_C_PROPERTY";
    case ExprObjectKind::OBJ_C_SUBSCRIPT: return "OBJ_C_SUBSCRIPT";
    case ExprObjectKind::MATRIX_COMPONENT: return "MATRIX_COMPONENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprOffsets e) {
  switch (e) {
    case ExprOffsets::ALLOCATOR: return "ALLOCATOR";
    case ExprOffsets::ALLOCATOR_TRAITS: return "ALLOCATOR_TRAITS";
    case ExprOffsets::TOTAL: return "TOTAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExprValueKind e) {
  switch (e) {
    case ExprValueKind::PR_VALUE: return "PR_VALUE";
    case ExprValueKind::L_VALUE: return "L_VALUE";
    case ExprValueKind::X_VALUE: return "X_VALUE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExpressionTrait e) {
  switch (e) {
    case ExpressionTrait::IS_L_VALUE_EXPRESSION: return "IS_L_VALUE_EXPRESSION";
    case ExpressionTrait::IS_R_VALUE_EXPRESSION: return "IS_R_VALUE_EXPRESSION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExtKind e) {
  switch (e) {
    case ExtKind::ALWAYS: return "ALWAYS";
    case ExtKind::NEVER: return "NEVER";
    case ExtKind::REPLY_HAZY: return "REPLY_HAZY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ExtendArgsKind e) {
  switch (e) {
    case ExtendArgsKind::EXTEND_TO32: return "EXTEND_TO32";
    case ExtendArgsKind::EXTEND_TO64: return "EXTEND_TO64";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FPEvalMethodKind e) {
  switch (e) {
    case FPEvalMethodKind::FEM_INDETERMINABLE: return "FEM_INDETERMINABLE";
    case FPEvalMethodKind::FEM_SOURCE: return "FEM_SOURCE";
    case FPEvalMethodKind::FEM_DOUBLE: return "FEM_DOUBLE";
    case FPEvalMethodKind::FEM_EXTENDED: return "FEM_EXTENDED";
    case FPEvalMethodKind::FEM_UNSET_ON_COMMAND_LINE: return "FEM_UNSET_ON_COMMAND_LINE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FPExceptionModeKind e) {
  switch (e) {
    case FPExceptionModeKind::IGNORE: return "IGNORE";
    case FPExceptionModeKind::MAY_TRAP: return "MAY_TRAP";
    case FPExceptionModeKind::STRICT: return "STRICT";
    case FPExceptionModeKind::DEFAULT: return "DEFAULT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FPModeKind e) {
  switch (e) {
    case FPModeKind::OFF: return "OFF";
    case FPModeKind::ON: return "ON";
    case FPModeKind::FAST: return "FAST";
    case FPModeKind::FAST_HONOR_PRAGMAS: return "FAST_HONOR_PRAGMAS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FiniteLoopsKind e) {
  switch (e) {
    case FiniteLoopsKind::LANGUAGE: return "LANGUAGE";
    case FiniteLoopsKind::ALWAYS: return "ALWAYS";
    case FiniteLoopsKind::NEVER: return "NEVER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FramePointerKind e) {
  switch (e) {
    case FramePointerKind::NONE: return "NONE";
    case FramePointerKind::NON_LEAF: return "NON_LEAF";
    case FramePointerKind::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GC e) {
  switch (e) {
    case GC::GC_NONE: return "GC_NONE";
    case GC::WEAK: return "WEAK";
    case GC::STRONG: return "STRONG";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GCMode e) {
  switch (e) {
    case GCMode::NON_GC: return "NON_GC";
    case GCMode::GC_ONLY: return "GC_ONLY";
    case GCMode::HYBRID_GC: return "HYBRID_GC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GPUDefaultStreamKind e) {
  switch (e) {
    case GPUDefaultStreamKind::LEGACY: return "LEGACY";
    case GPUDefaultStreamKind::PER_THREAD: return "PER_THREAD";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GVALinkage e) {
  switch (e) {
    case GVALinkage::INTERNAL: return "INTERNAL";
    case GVALinkage::AVAILABLE_EXTERNALLY: return "AVAILABLE_EXTERNALLY";
    case GVALinkage::DISCARDABLE_ODR: return "DISCARDABLE_ODR";
    case GVALinkage::STRONG_EXTERNAL: return "STRONG_EXTERNAL";
    case GVALinkage::STRONG_ODR: return "STRONG_ODR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(GetBuiltinTypeError e) {
  switch (e) {
    case GetBuiltinTypeError::NONE: return "NONE";
    case GetBuiltinTypeError::MISSING_TYPE: return "MISSING_TYPE";
    case GetBuiltinTypeError::MISSING_STDIO: return "MISSING_STDIO";
    case GetBuiltinTypeError::MISSING: return "MISSING";
    case GetBuiltinTypeError::MISSING_UCONTEXT: return "MISSING_UCONTEXT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(HLSLLangStd e) {
  switch (e) {
    case HLSLLangStd::HLSL_UNSET: return "HLSL_UNSET";
    case HLSLLangStd::HLSL2015: return "HLSL2015";
    case HLSLLangStd::HLSL2016: return "HLSL2016";
    case HLSLLangStd::HLSL2017: return "HLSL2017";
    case HLSLLangStd::HLSL2018: return "HLSL2018";
    case HLSLLangStd::HLSL2021: return "HLSL2021";
    case HLSLLangStd::HLSL202X: return "HLSL202X";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ID e) {
  switch (e) {
    case ID::WORK_GROUP: return "WORK_GROUP";
    case ID::DEVICE: return "DEVICE";
    case ID::ALL_SVM_DEVICES: return "ALL_SVM_DEVICES";
    case ID::SUB_GROUP: return "SUB_GROUP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IdentifierInfoFlag e) {
  switch (e) {
    case IdentifierInfoFlag::ZERO_ARGUMENT: return "ZERO_ARGUMENT";
    case IdentifierInfoFlag::ONE_ARGUMENT: return "ONE_ARGUMENT";
    case IdentifierInfoFlag::MULTI_ARGUMENT: return "MULTI_ARGUMENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IfStatementKind e) {
  switch (e) {
    case IfStatementKind::ORDINARY: return "ORDINARY";
    case IfStatementKind::CONSTEXPR: return "CONSTEXPR";
    case IfStatementKind::CONSTEVAL_NON_NEGATED: return "CONSTEVAL_NON_NEGATED";
    case IfStatementKind::CONSTEVAL_NEGATED: return "CONSTEVAL_NEGATED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ImbueAttribute e) {
  switch (e) {
    case ImbueAttribute::NONE: return "NONE";
    case ImbueAttribute::ALWAYS: return "ALWAYS";
    case ImbueAttribute::NEVER: return "NEVER";
    case ImbueAttribute::ALWAYSARG1: return "ALWAYSARG1";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InClassInitStyle e) {
  switch (e) {
    case InClassInitStyle::NO_INITIALIZER: return "NO_INITIALIZER";
    case InClassInitStyle::COPY_INITIALIZER: return "COPY_INITIALIZER";
    case InClassInitStyle::LIST_INITIALIZER: return "LIST_INITIALIZER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InheritedDesignatedInitializersState e) {
  switch (e) {
    case InheritedDesignatedInitializersState::UNKNOWN: return "UNKNOWN";
    case InheritedDesignatedInitializersState::INHERITED: return "INHERITED";
    case InheritedDesignatedInitializersState::NOT_INHERITED: return "NOT_INHERITED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InitStorageKind e) {
  switch (e) {
    case InitStorageKind::NO_INITIALIZER: return "NO_INITIALIZER";
    case InitStorageKind::IN_CLASS_COPY_INITIALIZER: return "IN_CLASS_COPY_INITIALIZER";
    case InitStorageKind::IN_CLASS_LIST_INITIALIZER: return "IN_CLASS_LIST_INITIALIZER";
    case InitStorageKind::CAPTURED_VLA_TYPE: return "CAPTURED_VLA_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InlineAsmDialectKind e) {
  switch (e) {
    case InlineAsmDialectKind::IADATT: return "IADATT";
    case InlineAsmDialectKind::IAD_INTEL: return "IAD_INTEL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InlineVariableDefinitionKind e) {
  switch (e) {
    case InlineVariableDefinitionKind::NONE: return "NONE";
    case InlineVariableDefinitionKind::WEAK: return "WEAK";
    case InlineVariableDefinitionKind::WEAK_UNKNOWN: return "WEAK_UNKNOWN";
    case InlineVariableDefinitionKind::STRONG: return "STRONG";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(InliningMethod e) {
  switch (e) {
    case InliningMethod::NORMAL_INLINING: return "NORMAL_INLINING";
    case InliningMethod::ONLY_HINT_INLINING: return "ONLY_HINT_INLINING";
    case InliningMethod::ONLY_ALWAYS_INLINING: return "ONLY_ALWAYS_INLINING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Kinds e) {
  switch (e) {
    case Kinds::L_VALUE: return "L_VALUE";
    case Kinds::X_VALUE: return "X_VALUE";
    case Kinds::FUNCTION: return "FUNCTION";
    case Kinds::VOID: return "VOID";
    case Kinds::ADDRESSABLE_VOID: return "ADDRESSABLE_VOID";
    case Kinds::DUPLICATE_VECTOR_COMPONENTS: return "DUPLICATE_VECTOR_COMPONENTS";
    case Kinds::MEMBER_FUNCTION: return "MEMBER_FUNCTION";
    case Kinds::SUB_OBJ_C_PROPERTY_SETTING: return "SUB_OBJ_C_PROPERTY_SETTING";
    case Kinds::CLASS_TEMPORARY: return "CLASS_TEMPORARY";
    case Kinds::ARRAY_TEMPORARY: return "ARRAY_TEMPORARY";
    case Kinds::OBJ_C_MESSAGE_R_VALUE: return "OBJ_C_MESSAGE_R_VALUE";
    case Kinds::PR_VALUE: return "PR_VALUE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LambdaCaptureDefault e) {
  switch (e) {
    case LambdaCaptureDefault::NONE: return "NONE";
    case LambdaCaptureDefault::BY_COPY: return "BY_COPY";
    case LambdaCaptureDefault::BY_REFERENCE: return "BY_REFERENCE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LambdaCaptureKind e) {
  switch (e) {
    case LambdaCaptureKind::THIS: return "THIS";
    case LambdaCaptureKind::STAR_THIS: return "STAR_THIS";
    case LambdaCaptureKind::BY_COPY: return "BY_COPY";
    case LambdaCaptureKind::BY_REFERENCE: return "BY_REFERENCE";
    case LambdaCaptureKind::VLA_TYPE: return "VLA_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LangAS e) {
  switch (e) {
    case LangAS::DEFAULT: return "DEFAULT";
    case LangAS::OPENCL_GLOBAL: return "OPENCL_GLOBAL";
    case LangAS::OPENCL_LOCAL: return "OPENCL_LOCAL";
    case LangAS::OPENCL_CONSTANT: return "OPENCL_CONSTANT";
    case LangAS::OPENCL_PRIVATE: return "OPENCL_PRIVATE";
    case LangAS::OPENCL_GENERIC: return "OPENCL_GENERIC";
    case LangAS::OPENCL_GLOBAL_DEVICE: return "OPENCL_GLOBAL_DEVICE";
    case LangAS::OPENCL_GLOBAL_HOST: return "OPENCL_GLOBAL_HOST";
    case LangAS::CUDA_DEVICE: return "CUDA_DEVICE";
    case LangAS::CUDA_CONSTANT: return "CUDA_CONSTANT";
    case LangAS::CUDA_SHARED: return "CUDA_SHARED";
    case LangAS::SYCL_GLOBAL: return "SYCL_GLOBAL";
    case LangAS::SYCL_GLOBAL_DEVICE: return "SYCL_GLOBAL_DEVICE";
    case LangAS::SYCL_GLOBAL_HOST: return "SYCL_GLOBAL_HOST";
    case LangAS::SYCL_LOCAL: return "SYCL_LOCAL";
    case LangAS::SYCL_PRIVATE: return "SYCL_PRIVATE";
    case LangAS::PTR32_SPTR: return "PTR32_SPTR";
    case LangAS::PTR32_UPTR: return "PTR32_UPTR";
    case LangAS::PTR64: return "PTR64";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LangFeatures e) {
  switch (e) {
    case LangFeatures::LINE_COMMENT: return "LINE_COMMENT";
    case LangFeatures::C99: return "C99";
    case LangFeatures::C11: return "C11";
    case LangFeatures::C17: return "C17";
    case LangFeatures::C2X: return "C2X";
    case LangFeatures::C_PLUS_PLUS: return "C_PLUS_PLUS";
    case LangFeatures::C_PLUS_PLUS11: return "C_PLUS_PLUS11";
    case LangFeatures::C_PLUS_PLUS14: return "C_PLUS_PLUS14";
    case LangFeatures::C_PLUS_PLUS17: return "C_PLUS_PLUS17";
    case LangFeatures::C_PLUS_PLUS20: return "C_PLUS_PLUS20";
    case LangFeatures::C_PLUS_PLUS2B: return "C_PLUS_PLUS2B";
    case LangFeatures::DIGRAPHS: return "DIGRAPHS";
    case LangFeatures::GNU_MODE: return "GNU_MODE";
    case LangFeatures::HEX_FLOAT: return "HEX_FLOAT";
    case LangFeatures::OPEN_CL: return "OPEN_CL";
    case LangFeatures::HLSL: return "HLSL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Language e) {
  switch (e) {
    case Language::UNKNOWN: return "UNKNOWN";
    case Language::ASSEMBLY: return "ASSEMBLY";
    case Language::LLVMIR: return "LLVMIR";
    case Language::C: return "C";
    case Language::CXX: return "CXX";
    case Language::OBJ_C: return "OBJ_C";
    case Language::OBJ_CXX: return "OBJ_CXX";
    case Language::OPEN_CL: return "OPEN_CL";
    case Language::OPEN_CLCXX: return "OPEN_CLCXX";
    case Language::CUDA: return "CUDA";
    case Language::RENDER_SCRIPT: return "RENDER_SCRIPT";
    case Language::HIP: return "HIP";
    case Language::HLSL: return "HLSL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LanguageLinkage e) {
  switch (e) {
    case LanguageLinkage::C_LANGUAGE_LINKAGE: return "C_LANGUAGE_LINKAGE";
    case LanguageLinkage::CXX_LANGUAGE_LINKAGE: return "CXX_LANGUAGE_LINKAGE";
    case LanguageLinkage::NO_LANGUAGE_LINKAGE: return "NO_LANGUAGE_LINKAGE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(LaxVectorConversionKind e) {
  switch (e) {
    case LaxVectorConversionKind::NONE: return "NONE";
    case LaxVectorConversionKind::INTEGER: return "INTEGER";
    case LaxVectorConversionKind::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Level e) {
  switch (e) {
    case Level::IGNORED: return "IGNORED";
    case Level::NOTE: return "NOTE";
    case Level::REMARK: return "REMARK";
    case Level::WARNING: return "WARNING";
    case Level::ERROR: return "ERROR";
    case Level::FATAL: return "FATAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Linkage e) {
  switch (e) {
    case Linkage::NO_LINKAGE: return "NO_LINKAGE";
    case Linkage::INTERNAL_LINKAGE: return "INTERNAL_LINKAGE";
    case Linkage::UNIQUE_EXTERNAL_LINKAGE: return "UNIQUE_EXTERNAL_LINKAGE";
    case Linkage::VISIBLE_NO_LINKAGE: return "VISIBLE_NO_LINKAGE";
    case Linkage::MODULE_INTERNAL_LINKAGE: return "MODULE_INTERNAL_LINKAGE";
    case Linkage::MODULE_LINKAGE: return "MODULE_LINKAGE";
    case Linkage::EXTERNAL_LINKAGE: return "EXTERNAL_LINKAGE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSInheritanceModel e) {
  switch (e) {
    case MSInheritanceModel::SINGLE: return "SINGLE";
    case MSInheritanceModel::MULTIPLE: return "MULTIPLE";
    case MSInheritanceModel::VIRTUAL: return "VIRTUAL";
    case MSInheritanceModel::UNSPECIFIED: return "UNSPECIFIED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSVCMajorVersion e) {
  switch (e) {
    case MSVCMajorVersion::MSVC2010: return "MSVC2010";
    case MSVCMajorVersion::MSVC2012: return "MSVC2012";
    case MSVCMajorVersion::MSVC2013: return "MSVC2013";
    case MSVCMajorVersion::MSVC2015: return "MSVC2015";
    case MSVCMajorVersion::MSVC2017: return "MSVC2017";
    case MSVCMajorVersion::MSVC20175: return "MSVC20175";
    case MSVCMajorVersion::MSVC20177: return "MSVC20177";
    case MSVCMajorVersion::MSVC2019: return "MSVC2019";
    case MSVCMajorVersion::MSVC20195: return "MSVC20195";
    case MSVCMajorVersion::MSVC20198: return "MSVC20198";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MSVtorDispMode e) {
  switch (e) {
    case MSVtorDispMode::NEVER: return "NEVER";
    case MSVtorDispMode::FOR_VIRTUAL_BASE_OVERRIDE: return "FOR_VIRTUAL_BASE_OVERRIDE";
    case MSVtorDispMode::FOR_VF_TABLE: return "FOR_VF_TABLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MethodRefFlags e) {
  switch (e) {
    case MethodRefFlags::METHOD_REFERENCE_NONE: return "METHOD_REFERENCE_NONE";
    case MethodRefFlags::METHOD_REFERENCE_GETTER: return "METHOD_REFERENCE_GETTER";
    case MethodRefFlags::METHOD_REFERENCE_SETTER: return "METHOD_REFERENCE_SETTER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ModifiableType e) {
  switch (e) {
    case ModifiableType::UNTESTED: return "UNTESTED";
    case ModifiableType::MODIFIABLE: return "MODIFIABLE";
    case ModifiableType::R_VALUE: return "R_VALUE";
    case ModifiableType::FUNCTION: return "FUNCTION";
    case ModifiableType::L_VALUE_CAST: return "L_VALUE_CAST";
    case ModifiableType::NO_SETTER_PROPERTY: return "NO_SETTER_PROPERTY";
    case ModifiableType::CONST_QUALIFIED: return "CONST_QUALIFIED";
    case ModifiableType::CONST_QUALIFIED_FIELD: return "CONST_QUALIFIED_FIELD";
    case ModifiableType::CONST_ADDRESS_SPACE: return "CONST_ADDRESS_SPACE";
    case ModifiableType::ARRAY_TYPE: return "ARRAY_TYPE";
    case ModifiableType::INCOMPLETE_TYPE: return "INCOMPLETE_TYPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MultiVersionKind e) {
  switch (e) {
    case MultiVersionKind::NONE: return "NONE";
    case MultiVersionKind::TARGET: return "TARGET";
    case MultiVersionKind::CPU_SPECIFIC: return "CPU_SPECIFIC";
    case MultiVersionKind::CPU_DISPATCH: return "CPU_DISPATCH";
    case MultiVersionKind::TARGET_CLONES: return "TARGET_CLONES";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NameKind e) {
  switch (e) {
    case NameKind::TEMPLATE: return "TEMPLATE";
    case NameKind::OVERLOADED_TEMPLATE: return "OVERLOADED_TEMPLATE";
    case NameKind::ASSUMED_TEMPLATE: return "ASSUMED_TEMPLATE";
    case NameKind::QUALIFIED_TEMPLATE: return "QUALIFIED_TEMPLATE";
    case NameKind::DEPENDENT_TEMPLATE: return "DEPENDENT_TEMPLATE";
    case NameKind::SUBST_TEMPLATE_TEMPLATE_PARM: return "SUBST_TEMPLATE_TEMPLATE_PARM";
    case NameKind::SUBST_TEMPLATE_TEMPLATE_PARM_PACK: return "SUBST_TEMPLATE_TEMPLATE_PARM_PACK";
    case NameKind::USING_TEMPLATE: return "USING_TEMPLATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NeedExtraManglingDecl e) {
  switch (e) {
    case NeedExtraManglingDecl::NEED_EXTRA_MANGLING_DECLARATION: return "NEED_EXTRA_MANGLING_DECLARATION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NestedNameSpecifierDependence e) {
  switch (e) {
    case NestedNameSpecifierDependence::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case NestedNameSpecifierDependence::INSTANTIATION: return "INSTANTIATION";
    case NestedNameSpecifierDependence::DEPENDENT: return "DEPENDENT";
    case NestedNameSpecifierDependence::ERROR: return "ERROR";
    case NestedNameSpecifierDependence::NONE: return "NONE";
    case NestedNameSpecifierDependence::DEPENDENT_INSTANTIATION: return "DEPENDENT_INSTANTIATION";
    case NestedNameSpecifierDependence::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NonOdrUseReason e) {
  switch (e) {
    case NonOdrUseReason::NONE: return "NONE";
    case NonOdrUseReason::UNEVALUATED: return "UNEVALUATED";
    case NonOdrUseReason::CONSTANT: return "CONSTANT";
    case NonOdrUseReason::DISCARDED: return "DISCARDED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NonceObjCInterface e) {
  switch (e) {
    case NonceObjCInterface::OBJ_C_INTERFACE: return "OBJ_C_INTERFACE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(NullabilityKind e) {
  switch (e) {
    case NullabilityKind::NON_NULL: return "NON_NULL";
    case NullabilityKind::NULLABLE: return "NULLABLE";
    case NullabilityKind::UNSPECIFIED: return "UNSPECIFIED";
    case NullabilityKind::NULLABLE_RESULT: return "NULLABLE_RESULT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCBridgeCastKind e) {
  switch (e) {
    case ObjCBridgeCastKind::BRIDGE: return "BRIDGE";
    case ObjCBridgeCastKind::BRIDGE_TRANSFER: return "BRIDGE_TRANSFER";
    case ObjCBridgeCastKind::BRIDGE_RETAINED: return "BRIDGE_RETAINED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCDispatchMethodKind e) {
  switch (e) {
    case ObjCDispatchMethodKind::LEGACY: return "LEGACY";
    case ObjCDispatchMethodKind::NON_LEGACY: return "NON_LEGACY";
    case ObjCDispatchMethodKind::MIXED: return "MIXED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCInstanceTypeFamily e) {
  switch (e) {
    case ObjCInstanceTypeFamily::NONE: return "NONE";
    case ObjCInstanceTypeFamily::ARRAY: return "ARRAY";
    case ObjCInstanceTypeFamily::DICTIONARY: return "DICTIONARY";
    case ObjCInstanceTypeFamily::SINGLETON: return "SINGLETON";
    case ObjCInstanceTypeFamily::INITIALIZER: return "INITIALIZER";
    case ObjCInstanceTypeFamily::RETURNS_SELF: return "RETURNS_SELF";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCLifetime e) {
  switch (e) {
    case ObjCLifetime::NONE: return "NONE";
    case ObjCLifetime::EXPLICIT_NONE: return "EXPLICIT_NONE";
    case ObjCLifetime::STRONG: return "STRONG";
    case ObjCLifetime::WEAK: return "WEAK";
    case ObjCLifetime::AUTORELEASING: return "AUTORELEASING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCMethodFamily e) {
  switch (e) {
    case ObjCMethodFamily::NONE: return "NONE";
    case ObjCMethodFamily::ALLOC: return "ALLOC";
    case ObjCMethodFamily::COPY: return "COPY";
    case ObjCMethodFamily::INITIALIZER: return "INITIALIZER";
    case ObjCMethodFamily::MUTABLE_COPY: return "MUTABLE_COPY";
    case ObjCMethodFamily::NEW: return "NEW";
    case ObjCMethodFamily::AUTORELEASE: return "AUTORELEASE";
    case ObjCMethodFamily::DEALLOC: return "DEALLOC";
    case ObjCMethodFamily::FINALIZE: return "FINALIZE";
    case ObjCMethodFamily::RELEASE: return "RELEASE";
    case ObjCMethodFamily::RETAIN: return "RETAIN";
    case ObjCMethodFamily::RETAIN_COUNT: return "RETAIN_COUNT";
    case ObjCMethodFamily::SELF: return "SELF";
    case ObjCMethodFamily::INITIALIZE: return "INITIALIZE";
    case ObjCMethodFamily::PERFORM_SELECTOR: return "PERFORM_SELECTOR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCPropertyQueryKind e) {
  switch (e) {
    case ObjCPropertyQueryKind::QUERY_UNKNOWN: return "QUERY_UNKNOWN";
    case ObjCPropertyQueryKind::QUERY_INSTANCE: return "QUERY_INSTANCE";
    case ObjCPropertyQueryKind::QUERY_CLASS: return "QUERY_CLASS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCStringFormatFamily e) {
  switch (e) {
    case ObjCStringFormatFamily::NONE: return "NONE";
    case ObjCStringFormatFamily::NS_STRING: return "NS_STRING";
    case ObjCStringFormatFamily::CF_STRING: return "CF_STRING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCSubstitutionContext e) {
  switch (e) {
    case ObjCSubstitutionContext::ORDINARY: return "ORDINARY";
    case ObjCSubstitutionContext::RESULT: return "RESULT";
    case ObjCSubstitutionContext::PARAMETER: return "PARAMETER";
    case ObjCSubstitutionContext::PROPERTY: return "PROPERTY";
    case ObjCSubstitutionContext::SUPERCLASS: return "SUPERCLASS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ObjCTypeParamVariance e) {
  switch (e) {
    case ObjCTypeParamVariance::INVARIANT: return "INVARIANT";
    case ObjCTypeParamVariance::COVARIANT: return "COVARIANT";
    case ObjCTypeParamVariance::CONTRAVARIANT: return "CONTRAVARIANT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OnOffSwitch e) {
  switch (e) {
    case OnOffSwitch::ON: return "ON";
    case OnOffSwitch::OFF: return "OFF";
    case OnOffSwitch::DEFAULT: return "DEFAULT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OnStackType e) {
  switch (e) {
    case OnStackType::ON_STACK: return "ON_STACK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPAdjustArgsOpKind e) {
  switch (e) {
    case OpenMPAdjustArgsOpKind::ADJUSTARGS_NOTHING: return "ADJUSTARGS_NOTHING";
    case OpenMPAdjustArgsOpKind::ADJUSTARGS_NEED_DEVICE_POINTER: return "ADJUSTARGS_NEED_DEVICE_POINTER";
    case OpenMPAdjustArgsOpKind::ADJUSTARGS_UNKNOWN: return "ADJUSTARGS_UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPAtomicDefaultMemOrderClauseKind e) {
  switch (e) {
    case OpenMPAtomicDefaultMemOrderClauseKind::SEQ_CST: return "SEQ_CST";
    case OpenMPAtomicDefaultMemOrderClauseKind::ACQ_REL: return "ACQ_REL";
    case OpenMPAtomicDefaultMemOrderClauseKind::RELAXED: return "RELAXED";
    case OpenMPAtomicDefaultMemOrderClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPBindClauseKind e) {
  switch (e) {
    case OpenMPBindClauseKind::BIND_TEAMS: return "BIND_TEAMS";
    case OpenMPBindClauseKind::BIND_PARALLEL: return "BIND_PARALLEL";
    case OpenMPBindClauseKind::BIND_THREAD: return "BIND_THREAD";
    case OpenMPBindClauseKind::BIND_UNKNOWN: return "BIND_UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDefaultmapClauseKind e) {
  switch (e) {
    case OpenMPDefaultmapClauseKind::SCALAR: return "SCALAR";
    case OpenMPDefaultmapClauseKind::AGGREGATE: return "AGGREGATE";
    case OpenMPDefaultmapClauseKind::POINTER: return "POINTER";
    case OpenMPDefaultmapClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDefaultmapClauseModifier e) {
  switch (e) {
    case OpenMPDefaultmapClauseModifier::UNKNOWN: return "UNKNOWN";
    case OpenMPDefaultmapClauseModifier::ALLOC: return "ALLOC";
    case OpenMPDefaultmapClauseModifier::TO: return "TO";
    case OpenMPDefaultmapClauseModifier::FROM: return "FROM";
    case OpenMPDefaultmapClauseModifier::TOFROM: return "TOFROM";
    case OpenMPDefaultmapClauseModifier::NONE: return "NONE";
    case OpenMPDefaultmapClauseModifier::DEFAULT: return "DEFAULT";
    case OpenMPDefaultmapClauseModifier::PRESENT: return "PRESENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDependClauseKind e) {
  switch (e) {
    case OpenMPDependClauseKind::IN: return "IN";
    case OpenMPDependClauseKind::OUT: return "OUT";
    case OpenMPDependClauseKind::INOUT: return "INOUT";
    case OpenMPDependClauseKind::MUTEXINOUTSET: return "MUTEXINOUTSET";
    case OpenMPDependClauseKind::DEPOBJ: return "DEPOBJ";
    case OpenMPDependClauseKind::SOURCE: return "SOURCE";
    case OpenMPDependClauseKind::SINK: return "SINK";
    case OpenMPDependClauseKind::INOUTSET: return "INOUTSET";
    case OpenMPDependClauseKind::OUTALLMEMORY: return "OUTALLMEMORY";
    case OpenMPDependClauseKind::INOUTALLMEMORY: return "INOUTALLMEMORY";
    case OpenMPDependClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDeviceClauseModifier e) {
  switch (e) {
    case OpenMPDeviceClauseModifier::ANCESTOR: return "ANCESTOR";
    case OpenMPDeviceClauseModifier::DEVICE_NUM: return "DEVICE_NUM";
    case OpenMPDeviceClauseModifier::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDeviceType e) {
  switch (e) {
    case OpenMPDeviceType::HOST: return "HOST";
    case OpenMPDeviceType::NOHOST: return "NOHOST";
    case OpenMPDeviceType::ANY: return "ANY";
    case OpenMPDeviceType::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPDistScheduleClauseKind e) {
  switch (e) {
    case OpenMPDistScheduleClauseKind::STATIC: return "STATIC";
    case OpenMPDistScheduleClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPLastprivateModifier e) {
  switch (e) {
    case OpenMPLastprivateModifier::CONDITIONAL: return "CONDITIONAL";
    case OpenMPLastprivateModifier::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPLinearClauseKind e) {
  switch (e) {
    case OpenMPLinearClauseKind::VALUE: return "VALUE";
    case OpenMPLinearClauseKind::REFERENCE: return "REFERENCE";
    case OpenMPLinearClauseKind::UVAL: return "UVAL";
    case OpenMPLinearClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPMapClauseKind e) {
  switch (e) {
    case OpenMPMapClauseKind::ALLOC: return "ALLOC";
    case OpenMPMapClauseKind::TO: return "TO";
    case OpenMPMapClauseKind::FROM: return "FROM";
    case OpenMPMapClauseKind::TOFROM: return "TOFROM";
    case OpenMPMapClauseKind::DELETE: return "DELETE";
    case OpenMPMapClauseKind::RELEASE: return "RELEASE";
    case OpenMPMapClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPMapModifierKind e) {
  switch (e) {
    case OpenMPMapModifierKind::UNKNOWN: return "UNKNOWN";
    case OpenMPMapModifierKind::ALWAYS: return "ALWAYS";
    case OpenMPMapModifierKind::CLOSE: return "CLOSE";
    case OpenMPMapModifierKind::MAPPER: return "MAPPER";
    case OpenMPMapModifierKind::PRESENT: return "PRESENT";
    case OpenMPMapModifierKind::OMPX_HOLD: return "OMPX_HOLD";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPMotionModifierKind e) {
  switch (e) {
    case OpenMPMotionModifierKind::MOTIONMODIFIER_MAPPER: return "MOTIONMODIFIER_MAPPER";
    case OpenMPMotionModifierKind::MOTIONMODIFIER_PRESENT: return "MOTIONMODIFIER_PRESENT";
    case OpenMPMotionModifierKind::MOTIONMODIFIER_UNKNOWN: return "MOTIONMODIFIER_UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPOrderClauseKind e) {
  switch (e) {
    case OpenMPOrderClauseKind::CONCURRENT: return "CONCURRENT";
    case OpenMPOrderClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPReductionClauseModifier e) {
  switch (e) {
    case OpenMPReductionClauseModifier::DEFAULT: return "DEFAULT";
    case OpenMPReductionClauseModifier::INSCAN: return "INSCAN";
    case OpenMPReductionClauseModifier::TASK: return "TASK";
    case OpenMPReductionClauseModifier::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPScheduleClauseKind e) {
  switch (e) {
    case OpenMPScheduleClauseKind::STATIC: return "STATIC";
    case OpenMPScheduleClauseKind::DYNAMIC: return "DYNAMIC";
    case OpenMPScheduleClauseKind::GUIDED: return "GUIDED";
    case OpenMPScheduleClauseKind::AUTO: return "AUTO";
    case OpenMPScheduleClauseKind::RUNTIME: return "RUNTIME";
    case OpenMPScheduleClauseKind::UNKNOWN: return "UNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OpenMPScheduleClauseModifier e) {
  switch (e) {
    case OpenMPScheduleClauseModifier::UNKNOWN: return "UNKNOWN";
    case OpenMPScheduleClauseModifier::MONOTONIC: return "MONOTONIC";
    case OpenMPScheduleClauseModifier::NONMONOTONIC: return "NONMONOTONIC";
    case OpenMPScheduleClauseModifier::SIMD: return "SIMD";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OverloadedOperatorKind e) {
  switch (e) {
    case OverloadedOperatorKind::NONE: return "NONE";
    case OverloadedOperatorKind::NEW: return "NEW";
    case OverloadedOperatorKind::DELETE: return "DELETE";
    case OverloadedOperatorKind::ARRAY_NEW: return "ARRAY_NEW";
    case OverloadedOperatorKind::ARRAY_DELETE: return "ARRAY_DELETE";
    case OverloadedOperatorKind::PLUS: return "PLUS";
    case OverloadedOperatorKind::MINUS: return "MINUS";
    case OverloadedOperatorKind::STAR: return "STAR";
    case OverloadedOperatorKind::SLASH: return "SLASH";
    case OverloadedOperatorKind::PERCENT: return "PERCENT";
    case OverloadedOperatorKind::CARET: return "CARET";
    case OverloadedOperatorKind::AMP: return "AMP";
    case OverloadedOperatorKind::PIPE: return "PIPE";
    case OverloadedOperatorKind::TILDE: return "TILDE";
    case OverloadedOperatorKind::EXCLAIM: return "EXCLAIM";
    case OverloadedOperatorKind::EQUAL: return "EQUAL";
    case OverloadedOperatorKind::LESS: return "LESS";
    case OverloadedOperatorKind::GREATER: return "GREATER";
    case OverloadedOperatorKind::PLUS_EQUAL: return "PLUS_EQUAL";
    case OverloadedOperatorKind::MINUS_EQUAL: return "MINUS_EQUAL";
    case OverloadedOperatorKind::STAR_EQUAL: return "STAR_EQUAL";
    case OverloadedOperatorKind::SLASH_EQUAL: return "SLASH_EQUAL";
    case OverloadedOperatorKind::PERCENT_EQUAL: return "PERCENT_EQUAL";
    case OverloadedOperatorKind::CARET_EQUAL: return "CARET_EQUAL";
    case OverloadedOperatorKind::AMP_EQUAL: return "AMP_EQUAL";
    case OverloadedOperatorKind::PIPE_EQUAL: return "PIPE_EQUAL";
    case OverloadedOperatorKind::LESS_LESS: return "LESS_LESS";
    case OverloadedOperatorKind::GREATER_GREATER: return "GREATER_GREATER";
    case OverloadedOperatorKind::LESS_LESS_EQUAL: return "LESS_LESS_EQUAL";
    case OverloadedOperatorKind::GREATER_GREATER_EQUAL: return "GREATER_GREATER_EQUAL";
    case OverloadedOperatorKind::EQUAL_EQUAL: return "EQUAL_EQUAL";
    case OverloadedOperatorKind::EXCLAIM_EQUAL: return "EXCLAIM_EQUAL";
    case OverloadedOperatorKind::LESS_EQUAL: return "LESS_EQUAL";
    case OverloadedOperatorKind::GREATER_EQUAL: return "GREATER_EQUAL";
    case OverloadedOperatorKind::SPACESHIP: return "SPACESHIP";
    case OverloadedOperatorKind::AMP_AMP: return "AMP_AMP";
    case OverloadedOperatorKind::PIPE_PIPE: return "PIPE_PIPE";
    case OverloadedOperatorKind::PLUS_PLUS: return "PLUS_PLUS";
    case OverloadedOperatorKind::MINUS_MINUS: return "MINUS_MINUS";
    case OverloadedOperatorKind::COMMA: return "COMMA";
    case OverloadedOperatorKind::ARROW_STAR: return "ARROW_STAR";
    case OverloadedOperatorKind::ARROW: return "ARROW";
    case OverloadedOperatorKind::CALL: return "CALL";
    case OverloadedOperatorKind::SUBSCRIPT: return "SUBSCRIPT";
    case OverloadedOperatorKind::CONDITIONAL: return "CONDITIONAL";
    case OverloadedOperatorKind::COAWAIT: return "COAWAIT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(OverloadsShown e) {
  switch (e) {
    case OverloadsShown::ALL: return "ALL";
    case OverloadsShown::BEST: return "BEST";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ParameterABI e) {
  switch (e) {
    case ParameterABI::ORDINARY: return "ORDINARY";
    case ParameterABI::SWIFT_INDIRECT_RESULT: return "SWIFT_INDIRECT_RESULT";
    case ParameterABI::SWIFT_ERROR_RESULT: return "SWIFT_ERROR_RESULT";
    case ParameterABI::SWIFT_CONTEXT: return "SWIFT_CONTEXT";
    case ParameterABI::SWIFT_ASYNC_CONTEXT: return "SWIFT_ASYNC_CONTEXT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ParenLocsOffsets e) {
  switch (e) {
    case ParenLocsOffsets::L_PAREN_TOKEN: return "L_PAREN_TOKEN";
    case ParenLocsOffsets::R_PAREN_TOKEN: return "R_PAREN_TOKEN";
    case ParenLocsOffsets::TOTAL: return "TOTAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PragmaFloatControlKind e) {
  switch (e) {
    case PragmaFloatControlKind::UNKNOWN: return "UNKNOWN";
    case PragmaFloatControlKind::PRECISE: return "PRECISE";
    case PragmaFloatControlKind::NO_PRECISE: return "NO_PRECISE";
    case PragmaFloatControlKind::EXCEPT: return "EXCEPT";
    case PragmaFloatControlKind::NO_EXCEPT: return "NO_EXCEPT";
    case PragmaFloatControlKind::PUSH: return "PUSH";
    case PragmaFloatControlKind::POP: return "POP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PragmaMSCommentKind e) {
  switch (e) {
    case PragmaMSCommentKind::UNKNOWN: return "UNKNOWN";
    case PragmaMSCommentKind::LINKER: return "LINKER";
    case PragmaMSCommentKind::LIB: return "LIB";
    case PragmaMSCommentKind::COMPILER: return "COMPILER";
    case PragmaMSCommentKind::EXE_STRING: return "EXE_STRING";
    case PragmaMSCommentKind::USER: return "USER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PragmaMSPointersToMembersKind e) {
  switch (e) {
    case PragmaMSPointersToMembersKind::BEST_CASE: return "BEST_CASE";
    case PragmaMSPointersToMembersKind::FULL_GENERALITY_SINGLE_INHERITANCE: return "FULL_GENERALITY_SINGLE_INHERITANCE";
    case PragmaMSPointersToMembersKind::FULL_GENERALITY_MULTIPLE_INHERITANCE: return "FULL_GENERALITY_MULTIPLE_INHERITANCE";
    case PragmaMSPointersToMembersKind::FULL_GENERALITY_VIRTUAL_INHERITANCE: return "FULL_GENERALITY_VIRTUAL_INHERITANCE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PragmaMSStructKind e) {
  switch (e) {
    case PragmaMSStructKind::OFF: return "OFF";
    case PragmaMSStructKind::ON: return "ON";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PragmaSectionFlag e) {
  switch (e) {
    case PragmaSectionFlag::NONE: return "NONE";
    case PragmaSectionFlag::READ: return "READ";
    case PragmaSectionFlag::WRITE: return "WRITE";
    case PragmaSectionFlag::EXECUTE: return "EXECUTE";
    case PragmaSectionFlag::IMPLICIT: return "IMPLICIT";
    case PragmaSectionFlag::ZERO_INITIALIZER: return "ZERO_INITIALIZER";
    case PragmaSectionFlag::INVALID: return "INVALID";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ProfileInstrKind e) {
  switch (e) {
    case ProfileInstrKind::PROFILE_NONE: return "PROFILE_NONE";
    case ProfileInstrKind::PROFILE_CLANG_INSTR: return "PROFILE_CLANG_INSTR";
    case ProfileInstrKind::PROFILE_IR_INSTR: return "PROFILE_IR_INSTR";
    case ProfileInstrKind::PROFILE_CSIR_INSTR: return "PROFILE_CSIR_INSTR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Qualified e) {
  switch (e) {
    case Qualified::NONE: return "NONE";
    case Qualified::AS_WRITTEN: return "AS_WRITTEN";
    case Qualified::FULLY: return "FULLY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RangeExprOffset e) {
  switch (e) {
    case RangeExprOffset::BEGIN: return "BEGIN";
    case RangeExprOffset::END: return "END";
    case RangeExprOffset::STEP: return "STEP";
    case RangeExprOffset::TOTAL: return "TOTAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RangeLocOffset e) {
  switch (e) {
    case RangeLocOffset::ASSIGN_TOKEN: return "ASSIGN_TOKEN";
    case RangeLocOffset::SECOND_COLON_TOKEN: return "SECOND_COLON_TOKEN";
    case RangeLocOffset::TOTAL: return "TOTAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RefQualifierKind e) {
  switch (e) {
    case RefQualifierKind::NONE: return "NONE";
    case RefQualifierKind::L_VALUE: return "L_VALUE";
    case RefQualifierKind::R_VALUE: return "R_VALUE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(RemarkKind e) {
  switch (e) {
    case RemarkKind::MISSING: return "MISSING";
    case RemarkKind::ENABLED: return "ENABLED";
    case RemarkKind::ENABLED_EVERYTHING: return "ENABLED_EVERYTHING";
    case RemarkKind::DISABLED: return "DISABLED";
    case RemarkKind::DISABLED_EVERYTHING: return "DISABLED_EVERYTHING";
    case RemarkKind::WITH_PATTERN: return "WITH_PATTERN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ReservedIdentifierStatus e) {
  switch (e) {
    case ReservedIdentifierStatus::NOT_RESERVED: return "NOT_RESERVED";
    case ReservedIdentifierStatus::STARTS_WITH_UNDERSCORE_AT_GLOBAL_SCOPE: return "STARTS_WITH_UNDERSCORE_AT_GLOBAL_SCOPE";
    case ReservedIdentifierStatus::STARTS_WITH_UNDERSCORE_AND_IS_EXTERN_C: return "STARTS_WITH_UNDERSCORE_AND_IS_EXTERN_C";
    case ReservedIdentifierStatus::STARTS_WITH_DOUBLE_UNDERSCORE: return "STARTS_WITH_DOUBLE_UNDERSCORE";
    case ReservedIdentifierStatus::STARTS_WITH_UNDERSCORE_FOLLOWED_BY_CAPITAL_LETTER: return "STARTS_WITH_UNDERSCORE_FOLLOWED_BY_CAPITAL_LETTER";
    case ReservedIdentifierStatus::CONTAINS_DOUBLE_UNDERSCORE: return "CONTAINS_DOUBLE_UNDERSCORE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SFINAEResponse e) {
  switch (e) {
    case SFINAEResponse::SUBSTITUTION_FAILURE: return "SUBSTITUTION_FAILURE";
    case SFINAEResponse::SUPPRESS: return "SUPPRESS";
    case SFINAEResponse::REPORT: return "REPORT";
    case SFINAEResponse::ACCESS_CONTROL: return "ACCESS_CONTROL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SYCLMajorVersion e) {
  switch (e) {
    case SYCLMajorVersion::VERSION_NONE: return "VERSION_NONE";
    case SYCLMajorVersion::VERSION2017: return "VERSION2017";
    case SYCLMajorVersion::VERSION2020: return "VERSION2020";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SanitizerOrdinal e) {
  switch (e) {
    case SanitizerOrdinal::ADDRESS: return "ADDRESS";
    case SanitizerOrdinal::POINTER_COMPARE: return "POINTER_COMPARE";
    case SanitizerOrdinal::POINTER_SUBTRACT: return "POINTER_SUBTRACT";
    case SanitizerOrdinal::KERNEL_ADDRESS: return "KERNEL_ADDRESS";
    case SanitizerOrdinal::HW_ADDRESS: return "HW_ADDRESS";
    case SanitizerOrdinal::KERNEL_HW_ADDRESS: return "KERNEL_HW_ADDRESS";
    case SanitizerOrdinal::MEMTAG_STACK: return "MEMTAG_STACK";
    case SanitizerOrdinal::MEMTAG_HEAP: return "MEMTAG_HEAP";
    case SanitizerOrdinal::MEMTAG_GLOBALS: return "MEMTAG_GLOBALS";
    case SanitizerOrdinal::MEMORY_TAG_GROUP: return "MEMORY_TAG_GROUP";
    case SanitizerOrdinal::MEMORY: return "MEMORY";
    case SanitizerOrdinal::KERNEL_MEMORY: return "KERNEL_MEMORY";
    case SanitizerOrdinal::FUZZER: return "FUZZER";
    case SanitizerOrdinal::FUZZER_NO_LINK: return "FUZZER_NO_LINK";
    case SanitizerOrdinal::THREAD: return "THREAD";
    case SanitizerOrdinal::LEAK: return "LEAK";
    case SanitizerOrdinal::ALIGNMENT: return "ALIGNMENT";
    case SanitizerOrdinal::ARRAY_BOUNDS: return "ARRAY_BOUNDS";
    case SanitizerOrdinal::BOOLEAN: return "BOOLEAN";
    case SanitizerOrdinal::BUILTIN: return "BUILTIN";
    case SanitizerOrdinal::ENUM: return "ENUM";
    case SanitizerOrdinal::FLOAT_CAST_OVERFLOW: return "FLOAT_CAST_OVERFLOW";
    case SanitizerOrdinal::FLOAT_DIVIDE_BY_ZERO: return "FLOAT_DIVIDE_BY_ZERO";
    case SanitizerOrdinal::FUNCTION: return "FUNCTION";
    case SanitizerOrdinal::INTEGER_DIVIDE_BY_ZERO: return "INTEGER_DIVIDE_BY_ZERO";
    case SanitizerOrdinal::NONNULL_ATTRIBUTE: return "NONNULL_ATTRIBUTE";
    case SanitizerOrdinal::NULL_: return "NULL_";
    case SanitizerOrdinal::NULLABILITY_ARGUMENT: return "NULLABILITY_ARGUMENT";
    case SanitizerOrdinal::NULLABILITY_ASSIGN: return "NULLABILITY_ASSIGN";
    case SanitizerOrdinal::NULLABILITY_RETURN: return "NULLABILITY_RETURN";
    case SanitizerOrdinal::NULLABILITY_GROUP: return "NULLABILITY_GROUP";
    case SanitizerOrdinal::OBJECT_SIZE: return "OBJECT_SIZE";
    case SanitizerOrdinal::POINTER_OVERFLOW: return "POINTER_OVERFLOW";
    case SanitizerOrdinal::RETURN: return "RETURN";
    case SanitizerOrdinal::RETURNS_NONNULL_ATTRIBUTE: return "RETURNS_NONNULL_ATTRIBUTE";
    case SanitizerOrdinal::SHIFT_BASE: return "SHIFT_BASE";
    case SanitizerOrdinal::SHIFT_EXPONENT: return "SHIFT_EXPONENT";
    case SanitizerOrdinal::SHIFT_GROUP: return "SHIFT_GROUP";
    case SanitizerOrdinal::SIGNED_INTEGER_OVERFLOW: return "SIGNED_INTEGER_OVERFLOW";
    case SanitizerOrdinal::UNREACHABLE: return "UNREACHABLE";
    case SanitizerOrdinal::VLA_BOUND: return "VLA_BOUND";
    case SanitizerOrdinal::VPTR: return "VPTR";
    case SanitizerOrdinal::UNSIGNED_INTEGER_OVERFLOW: return "UNSIGNED_INTEGER_OVERFLOW";
    case SanitizerOrdinal::UNSIGNED_SHIFT_BASE: return "UNSIGNED_SHIFT_BASE";
    case SanitizerOrdinal::DATA_FLOW: return "DATA_FLOW";
    case SanitizerOrdinal::CFI_CAST_STRICT: return "CFI_CAST_STRICT";
    case SanitizerOrdinal::CFI_DERIVED_CAST: return "CFI_DERIVED_CAST";
    case SanitizerOrdinal::CFII_CALL: return "CFII_CALL";
    case SanitizerOrdinal::CFIMF_CALL: return "CFIMF_CALL";
    case SanitizerOrdinal::CFI_UNRELATED_CAST: return "CFI_UNRELATED_CAST";
    case SanitizerOrdinal::CFINV_CALL: return "CFINV_CALL";
    case SanitizerOrdinal::CFIV_CALL: return "CFIV_CALL";
    case SanitizerOrdinal::CFI_GROUP: return "CFI_GROUP";
    case SanitizerOrdinal::SAFE_STACK: return "SAFE_STACK";
    case SanitizerOrdinal::SHADOW_CALL_STACK: return "SHADOW_CALL_STACK";
    case SanitizerOrdinal::UNDEFINED_GROUP: return "UNDEFINED_GROUP";
    case SanitizerOrdinal::UNDEFINED_TRAP_GROUP: return "UNDEFINED_TRAP_GROUP";
    case SanitizerOrdinal::IMPLICIT_UNSIGNED_INTEGER_TRUNCATION: return "IMPLICIT_UNSIGNED_INTEGER_TRUNCATION";
    case SanitizerOrdinal::IMPLICIT_SIGNED_INTEGER_TRUNCATION: return "IMPLICIT_SIGNED_INTEGER_TRUNCATION";
    case SanitizerOrdinal::IMPLICIT_INTEGER_TRUNCATION_GROUP: return "IMPLICIT_INTEGER_TRUNCATION_GROUP";
    case SanitizerOrdinal::IMPLICIT_INTEGER_SIGN_CHANGE: return "IMPLICIT_INTEGER_SIGN_CHANGE";
    case SanitizerOrdinal::IMPLICIT_INTEGER_ARITHMETIC_VALUE_CHANGE_GROUP: return "IMPLICIT_INTEGER_ARITHMETIC_VALUE_CHANGE_GROUP";
    case SanitizerOrdinal::OBJ_C_CAST: return "OBJ_C_CAST";
    case SanitizerOrdinal::IMPLICIT_CONVERSION_GROUP: return "IMPLICIT_CONVERSION_GROUP";
    case SanitizerOrdinal::INTEGER_GROUP: return "INTEGER_GROUP";
    case SanitizerOrdinal::LOCAL_BOUNDS: return "LOCAL_BOUNDS";
    case SanitizerOrdinal::BOUNDS_GROUP: return "BOUNDS_GROUP";
    case SanitizerOrdinal::SCUDO: return "SCUDO";
    case SanitizerOrdinal::ALL_GROUP: return "ALL_GROUP";
    case SanitizerOrdinal::COUNT: return "COUNT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SelectorLocationsKind e) {
  switch (e) {
    case SelectorLocationsKind::NON_STANDARD: return "NON_STANDARD";
    case SelectorLocationsKind::STANDARD_NO_SPACE: return "STANDARD_NO_SPACE";
    case SelectorLocationsKind::STANDARD_WITH_SPACE: return "STANDARD_WITH_SPACE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ShaderStage e) {
  switch (e) {
    case ShaderStage::PIXEL: return "PIXEL";
    case ShaderStage::VERTEX: return "VERTEX";
    case ShaderStage::GEOMETRY: return "GEOMETRY";
    case ShaderStage::HULL: return "HULL";
    case ShaderStage::DOMAIN_: return "DOMAIN_";
    case ShaderStage::COMPUTE: return "COMPUTE";
    case ShaderStage::LIBRARY: return "LIBRARY";
    case ShaderStage::RAY_GENERATION: return "RAY_GENERATION";
    case ShaderStage::INTERSECTION: return "INTERSECTION";
    case ShaderStage::ANY_HIT: return "ANY_HIT";
    case ShaderStage::CLOSEST_HIT: return "CLOSEST_HIT";
    case ShaderStage::MISS: return "MISS";
    case ShaderStage::CALLABLE: return "CALLABLE";
    case ShaderStage::MESH: return "MESH";
    case ShaderStage::AMPLIFICATION: return "AMPLIFICATION";
    case ShaderStage::INVALID: return "INVALID";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SignReturnAddressKeyKind e) {
  switch (e) {
    case SignReturnAddressKeyKind::A_KEY: return "A_KEY";
    case SignReturnAddressKeyKind::B_KEY: return "B_KEY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SignReturnAddressScopeKind e) {
  switch (e) {
    case SignReturnAddressScopeKind::NONE: return "NONE";
    case SignReturnAddressScopeKind::NON_LEAF: return "NON_LEAF";
    case SignReturnAddressScopeKind::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SignedOverflowBehaviorTy e) {
  switch (e) {
    case SignedOverflowBehaviorTy::UNDEFINED: return "UNDEFINED";
    case SignedOverflowBehaviorTy::DEFINED: return "DEFINED";
    case SignedOverflowBehaviorTy::TRAPPING: return "TRAPPING";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SpecialMemberFlags e) {
  switch (e) {
    case SpecialMemberFlags::DEFAULT_CONSTRUCTOR: return "DEFAULT_CONSTRUCTOR";
    case SpecialMemberFlags::COPY_CONSTRUCTOR: return "COPY_CONSTRUCTOR";
    case SpecialMemberFlags::MOVE_CONSTRUCTOR: return "MOVE_CONSTRUCTOR";
    case SpecialMemberFlags::COPY_ASSIGNMENT: return "COPY_ASSIGNMENT";
    case SpecialMemberFlags::MOVE_ASSIGNMENT: return "MOVE_ASSIGNMENT";
    case SpecialMemberFlags::DESTRUCTOR: return "DESTRUCTOR";
    case SpecialMemberFlags::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SpecifierKind e) {
  switch (e) {
    case SpecifierKind::IDENTIFIER: return "IDENTIFIER";
    case SpecifierKind::NAMESPACE: return "NAMESPACE";
    case SpecifierKind::NAMESPACE_ALIAS: return "NAMESPACE_ALIAS";
    case SpecifierKind::TYPE_SPEC: return "TYPE_SPEC";
    case SpecifierKind::TYPE_SPEC_WITH_TEMPLATE: return "TYPE_SPEC_WITH_TEMPLATE";
    case SpecifierKind::GLOBAL: return "GLOBAL";
    case SpecifierKind::SUPER: return "SUPER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StackProtectorMode e) {
  switch (e) {
    case StackProtectorMode::OFF: return "OFF";
    case StackProtectorMode::ON: return "ON";
    case StackProtectorMode::STRONG: return "STRONG";
    case StackProtectorMode::REQ: return "REQ";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StorageClass e) {
  switch (e) {
    case StorageClass::NONE: return "NONE";
    case StorageClass::EXTERN: return "EXTERN";
    case StorageClass::STATIC: return "STATIC";
    case StorageClass::PRIVATE_EXTERN: return "PRIVATE_EXTERN";
    case StorageClass::AUTO: return "AUTO";
    case StorageClass::REGISTER: return "REGISTER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StorageDuration e) {
  switch (e) {
    case StorageDuration::FULL_EXPRESSION: return "FULL_EXPRESSION";
    case StorageDuration::AUTOMATIC: return "AUTOMATIC";
    case StorageDuration::THREAD: return "THREAD";
    case StorageDuration::STATIC: return "STATIC";
    case StorageDuration::DYNAMIC: return "DYNAMIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StoredNameKind e) {
  switch (e) {
    case StoredNameKind::STORED_IDENTIFIER: return "STORED_IDENTIFIER";
    case StoredNameKind::STORED_OBJ_C_ZERO_ARGUMENT_SELECTOR: return "STORED_OBJ_C_ZERO_ARGUMENT_SELECTOR";
    case StoredNameKind::STORED_OBJ_C_ONE_ARGUMENT_SELECTOR: return "STORED_OBJ_C_ONE_ARGUMENT_SELECTOR";
    case StoredNameKind::STORED_CXX_CONSTRUCTOR_NAME: return "STORED_CXX_CONSTRUCTOR_NAME";
    case StoredNameKind::STORED_CXX_DESTRUCTOR_NAME: return "STORED_CXX_DESTRUCTOR_NAME";
    case StoredNameKind::STORED_CXX_CONVERSION_FUNCTION_NAME: return "STORED_CXX_CONVERSION_FUNCTION_NAME";
    case StoredNameKind::STORED_CXX_OPERATOR_NAME: return "STORED_CXX_OPERATOR_NAME";
    case StoredNameKind::STORED_DECLARATION_NAME_EXTRA: return "STORED_DECLARATION_NAME_EXTRA";
    case StoredNameKind::UNCOMMON_NAME_KIND_OFFSET: return "UNCOMMON_NAME_KIND_OFFSET";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StoredSpecifierKind e) {
  switch (e) {
    case StoredSpecifierKind::STORED_IDENTIFIER: return "STORED_IDENTIFIER";
    case StoredSpecifierKind::STORED_DECLARATION: return "STORED_DECLARATION";
    case StoredSpecifierKind::STORED_TYPE_SPEC: return "STORED_TYPE_SPEC";
    case StoredSpecifierKind::STORED_TYPE_SPEC_WITH_TEMPLATE: return "STORED_TYPE_SPEC_WITH_TEMPLATE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(StructReturnConventionKind e) {
  switch (e) {
    case StructReturnConventionKind::DEFAULT: return "DEFAULT";
    case StructReturnConventionKind::ON_STACK: return "ON_STACK";
    case StructReturnConventionKind::IN_REGS: return "IN_REGS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SubExpr e) {
  switch (e) {
    case SubExpr::CALLEE: return "CALLEE";
    case SubExpr::LHS: return "LHS";
    case SubExpr::RHS: return "RHS";
    case SubExpr::COUNT: return "COUNT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SubStmt e) {
  switch (e) {
    case SubStmt::BODY: return "BODY";
    case SubStmt::PROMISE: return "PROMISE";
    case SubStmt::INITIALIZER_SUSPEND: return "INITIALIZER_SUSPEND";
    case SubStmt::FINAL_SUSPEND: return "FINAL_SUSPEND";
    case SubStmt::ON_EXCEPTION: return "ON_EXCEPTION";
    case SubStmt::ON_FALLTHROUGH: return "ON_FALLTHROUGH";
    case SubStmt::ALLOCATE: return "ALLOCATE";
    case SubStmt::DEALLOCATE: return "DEALLOCATE";
    case SubStmt::RETURN_VALUE: return "RETURN_VALUE";
    case SubStmt::RETURN_STATEMENT: return "RETURN_STATEMENT";
    case SubStmt::RETURN_STATEMENT_ON_ALLOC_FAILURE: return "RETURN_STATEMENT_ON_ALLOC_FAILURE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SwiftAsyncFramePointerKind e) {
  switch (e) {
    case SwiftAsyncFramePointerKind::AUTO: return "AUTO";
    case SwiftAsyncFramePointerKind::ALWAYS: return "ALWAYS";
    case SwiftAsyncFramePointerKind::NEVER: return "NEVER";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(SyncScope e) {
  switch (e) {
    case SyncScope::HIP_SINGLE_THREAD: return "HIP_SINGLE_THREAD";
    case SyncScope::HIP_WAVEFRONT: return "HIP_WAVEFRONT";
    case SyncScope::HIP_WORKGROUP: return "HIP_WORKGROUP";
    case SyncScope::HIP_AGENT: return "HIP_AGENT";
    case SyncScope::HIP_SYSTEM: return "HIP_SYSTEM";
    case SyncScope::OPEN_CL_WORK_GROUP: return "OPEN_CL_WORK_GROUP";
    case SyncScope::OPEN_CL_DEVICE: return "OPEN_CL_DEVICE";
    case SyncScope::OPEN_CL_ALL_SVM_DEVICES: return "OPEN_CL_ALL_SVM_DEVICES";
    case SyncScope::OPEN_CL_SUB_GROUP: return "OPEN_CL_SUB_GROUP";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Syntax e) {
  switch (e) {
    case Syntax::GNU: return "GNU";
    case Syntax::CXX11: return "CXX11";
    case Syntax::C2X: return "C2X";
    case Syntax::DECLSPEC: return "DECLSPEC";
    case Syntax::MICROSOFT: return "MICROSOFT";
    case Syntax::KEYWORD: return "KEYWORD";
    case Syntax::PRAGMA: return "PRAGMA";
    case Syntax::CONTEXT_SENSITIVE_KEYWORD: return "CONTEXT_SENSITIVE_KEYWORD";
    case Syntax::HLSL_SEMANTIC: return "HLSL_SEMANTIC";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TLSModel e) {
  switch (e) {
    case TLSModel::GENERAL_DYNAMIC_TLS_MODEL: return "GENERAL_DYNAMIC_TLS_MODEL";
    case TLSModel::LOCAL_DYNAMIC_TLS_MODEL: return "LOCAL_DYNAMIC_TLS_MODEL";
    case TLSModel::INITIAL_EXEC_TLS_MODEL: return "INITIAL_EXEC_TLS_MODEL";
    case TLSModel::LOCAL_EXEC_TLS_MODEL: return "LOCAL_EXEC_TLS_MODEL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TQ e) {
  switch (e) {
    case TQ::CONST: return "CONST";
    case TQ::RESTRICT: return "RESTRICT";
    case TQ::VOLATILE: return "VOLATILE";
    case TQ::CVR_MASK: return "CVR_MASK";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TagTypeKind e) {
  switch (e) {
    case TagTypeKind::STRUCT: return "STRUCT";
    case TagTypeKind::INTERFACE: return "INTERFACE";
    case TagTypeKind::UNION: return "UNION";
    case TagTypeKind::CLASS: return "CLASS";
    case TagTypeKind::ENUM: return "ENUM";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TailPaddingUseRules e) {
  switch (e) {
    case TailPaddingUseRules::ALWAYS_USE_TAIL_PADDING: return "ALWAYS_USE_TAIL_PADDING";
    case TailPaddingUseRules::USE_TAIL_PADDING_UNLESS_POD03: return "USE_TAIL_PADDING_UNLESS_POD03";
    case TailPaddingUseRules::USE_TAIL_PADDING_UNLESS_POD11: return "USE_TAIL_PADDING_UNLESS_POD11";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TemplateArgumentDependence e) {
  switch (e) {
    case TemplateArgumentDependence::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case TemplateArgumentDependence::INSTANTIATION: return "INSTANTIATION";
    case TemplateArgumentDependence::DEPENDENT: return "DEPENDENT";
    case TemplateArgumentDependence::ERROR: return "ERROR";
    case TemplateArgumentDependence::NONE: return "NONE";
    case TemplateArgumentDependence::DEPENDENT_INSTANTIATION: return "DEPENDENT_INSTANTIATION";
    case TemplateArgumentDependence::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TemplateNameDependence e) {
  switch (e) {
    case TemplateNameDependence::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case TemplateNameDependence::INSTANTIATION: return "INSTANTIATION";
    case TemplateNameDependence::DEPENDENT: return "DEPENDENT";
    case TemplateNameDependence::ERROR: return "ERROR";
    case TemplateNameDependence::NONE: return "NONE";
    case TemplateNameDependence::DEPENDENT_INSTANTIATION: return "DEPENDENT_INSTANTIATION";
    case TemplateNameDependence::ALL: return "ALL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TemplateSpecializationKind e) {
  switch (e) {
    case TemplateSpecializationKind::UNDECLARED: return "UNDECLARED";
    case TemplateSpecializationKind::IMPLICIT_INSTANTIATION: return "IMPLICIT_INSTANTIATION";
    case TemplateSpecializationKind::EXPLICIT_SPECIALIZATION: return "EXPLICIT_SPECIALIZATION";
    case TemplateSpecializationKind::EXPLICIT_INSTANTIATION_DECLARATION: return "EXPLICIT_INSTANTIATION_DECLARATION";
    case TemplateSpecializationKind::EXPLICIT_INSTANTIATION_DEFINITION: return "EXPLICIT_INSTANTIATION_DEFINITION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TextDiagnosticFormat e) {
  switch (e) {
    case TextDiagnosticFormat::CLANG: return "CLANG";
    case TextDiagnosticFormat::MSVC: return "MSVC";
    case TextDiagnosticFormat::VI: return "VI";
    case TextDiagnosticFormat::SARIF: return "SARIF";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ThreadModelKind e) {
  switch (e) {
    case ThreadModelKind::POSIX: return "POSIX";
    case ThreadModelKind::SINGLE: return "SINGLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(ThreadStorageClassSpecifier e) {
  switch (e) {
    case ThreadStorageClassSpecifier::UNSPECIFIED: return "UNSPECIFIED";
    case ThreadStorageClassSpecifier::__THREAD: return "__THREAD";
    case ThreadStorageClassSpecifier::THREAD_LOCAL: return "THREAD_LOCAL";
    case ThreadStorageClassSpecifier::_THREAD_LOCAL: return "_THREAD_LOCAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TokenKind e) {
  switch (e) {
    case TokenKind::UNKNOWN: return "UNKNOWN";
    case TokenKind::END_OF_FILE: return "END_OF_FILE";
    case TokenKind::END_OF_DIRECTIVE: return "END_OF_DIRECTIVE";
    case TokenKind::CODE_COMPLETION: return "CODE_COMPLETION";
    case TokenKind::COMMENT: return "COMMENT";
    case TokenKind::IDENTIFIER: return "IDENTIFIER";
    case TokenKind::WHITESPACE: return "WHITESPACE";
    case TokenKind::NUMERIC_CONSTANT: return "NUMERIC_CONSTANT";
    case TokenKind::CHARACTER_CONSTANT: return "CHARACTER_CONSTANT";
    case TokenKind::WIDE_CHARACTER_CONSTANT: return "WIDE_CHARACTER_CONSTANT";
    case TokenKind::UTF8_CHARACTER_CONSTANT: return "UTF8_CHARACTER_CONSTANT";
    case TokenKind::UTF16_CHARACTER_CONSTANT: return "UTF16_CHARACTER_CONSTANT";
    case TokenKind::UTF32_CHARACTER_CONSTANT: return "UTF32_CHARACTER_CONSTANT";
    case TokenKind::STRING_LITERAL: return "STRING_LITERAL";
    case TokenKind::WIDE_STRING_LITERAL: return "WIDE_STRING_LITERAL";
    case TokenKind::HEADER_NAME: return "HEADER_NAME";
    case TokenKind::UTF8_STRING_LITERAL: return "UTF8_STRING_LITERAL";
    case TokenKind::UTF16_STRING_LITERAL: return "UTF16_STRING_LITERAL";
    case TokenKind::UTF32_STRING_LITERAL: return "UTF32_STRING_LITERAL";
    case TokenKind::L_SQUARE: return "L_SQUARE";
    case TokenKind::R_SQUARE: return "R_SQUARE";
    case TokenKind::L_PARENTHESIS: return "L_PARENTHESIS";
    case TokenKind::R_PARENTHESIS: return "R_PARENTHESIS";
    case TokenKind::L_BRACE_TOKEN: return "L_BRACE_TOKEN";
    case TokenKind::R_BRACE_TOKEN: return "R_BRACE_TOKEN";
    case TokenKind::PERIOD: return "PERIOD";
    case TokenKind::ELLIPSIS: return "ELLIPSIS";
    case TokenKind::AMP: return "AMP";
    case TokenKind::AMP_AMP: return "AMP_AMP";
    case TokenKind::AMP_EQUAL: return "AMP_EQUAL";
    case TokenKind::STAR: return "STAR";
    case TokenKind::STAR_EQUAL: return "STAR_EQUAL";
    case TokenKind::PLUS: return "PLUS";
    case TokenKind::PLUS_PLUS: return "PLUS_PLUS";
    case TokenKind::PLUS_EQUAL: return "PLUS_EQUAL";
    case TokenKind::MINUS: return "MINUS";
    case TokenKind::ARROW: return "ARROW";
    case TokenKind::MINUS_MINUS: return "MINUS_MINUS";
    case TokenKind::MINUS_EQUAL: return "MINUS_EQUAL";
    case TokenKind::TILDE: return "TILDE";
    case TokenKind::EXCLAIM: return "EXCLAIM";
    case TokenKind::EXCLAIM_EQUAL: return "EXCLAIM_EQUAL";
    case TokenKind::SLASH: return "SLASH";
    case TokenKind::SLASH_EQUAL: return "SLASH_EQUAL";
    case TokenKind::PERCENT: return "PERCENT";
    case TokenKind::PERCENT_EQUAL: return "PERCENT_EQUAL";
    case TokenKind::LESS: return "LESS";
    case TokenKind::LESS_LESS: return "LESS_LESS";
    case TokenKind::LESS_EQUAL: return "LESS_EQUAL";
    case TokenKind::LESS_LESS_EQUAL: return "LESS_LESS_EQUAL";
    case TokenKind::SPACESHIP: return "SPACESHIP";
    case TokenKind::GREATER: return "GREATER";
    case TokenKind::GREATER_GREATER: return "GREATER_GREATER";
    case TokenKind::GREATER_EQUAL: return "GREATER_EQUAL";
    case TokenKind::GREATER_GREATER_EQUAL: return "GREATER_GREATER_EQUAL";
    case TokenKind::CARET: return "CARET";
    case TokenKind::CARET_EQUAL: return "CARET_EQUAL";
    case TokenKind::PIPE: return "PIPE";
    case TokenKind::PIPE_PIPE: return "PIPE_PIPE";
    case TokenKind::PIPE_EQUAL: return "PIPE_EQUAL";
    case TokenKind::QUESTION: return "QUESTION";
    case TokenKind::COLON: return "COLON";
    case TokenKind::SEMI: return "SEMI";
    case TokenKind::EQUAL: return "EQUAL";
    case TokenKind::EQUAL_EQUAL: return "EQUAL_EQUAL";
    case TokenKind::COMMA: return "COMMA";
    case TokenKind::HASH: return "HASH";
    case TokenKind::HASH_HASH: return "HASH_HASH";
    case TokenKind::HASHAT: return "HASHAT";
    case TokenKind::PERIOD_STAR: return "PERIOD_STAR";
    case TokenKind::ARROW_STAR: return "ARROW_STAR";
    case TokenKind::COLON_COLON: return "COLON_COLON";
    case TokenKind::AT: return "AT";
    case TokenKind::LESS_LESS_LESS: return "LESS_LESS_LESS";
    case TokenKind::GREATER_GREATER_GREATER: return "GREATER_GREATER_GREATER";
    case TokenKind::CARETCARET: return "CARETCARET";
    case TokenKind::KEYWORD_AUTO: return "KEYWORD_AUTO";
    case TokenKind::KEYWORD_BREAK: return "KEYWORD_BREAK";
    case TokenKind::KEYWORD_CASE: return "KEYWORD_CASE";
    case TokenKind::KEYWORD_CHARACTER: return "KEYWORD_CHARACTER";
    case TokenKind::KEYWORD_CONST: return "KEYWORD_CONST";
    case TokenKind::KEYWORD_CONTINUE: return "KEYWORD_CONTINUE";
    case TokenKind::KEYWORD_DEFAULT: return "KEYWORD_DEFAULT";
    case TokenKind::KEYWORD_DO: return "KEYWORD_DO";
    case TokenKind::KEYWORD_DOUBLE: return "KEYWORD_DOUBLE";
    case TokenKind::KEYWORD_ELSE: return "KEYWORD_ELSE";
    case TokenKind::KEYWORD_ENUM: return "KEYWORD_ENUM";
    case TokenKind::KEYWORD_EXTERN: return "KEYWORD_EXTERN";
    case TokenKind::KEYWORD_FLOAT: return "KEYWORD_FLOAT";
    case TokenKind::KEYWORD_FOR: return "KEYWORD_FOR";
    case TokenKind::KEYWORD_GOTO: return "KEYWORD_GOTO";
    case TokenKind::KEYWORD_IF: return "KEYWORD_IF";
    case TokenKind::KEYWORD_INLINE: return "KEYWORD_INLINE";
    case TokenKind::KEYWORD_INT: return "KEYWORD_INT";
    case TokenKind::KEYWORD__EXT_INT: return "KEYWORD__EXT_INT";
    case TokenKind::KEYWORD__BIT_INT: return "KEYWORD__BIT_INT";
    case TokenKind::KEYWORD_LONG: return "KEYWORD_LONG";
    case TokenKind::KEYWORD_REGISTER: return "KEYWORD_REGISTER";
    case TokenKind::KEYWORD_RESTRICT: return "KEYWORD_RESTRICT";
    case TokenKind::KEYWORD_RETURN: return "KEYWORD_RETURN";
    case TokenKind::KEYWORD_SHORT: return "KEYWORD_SHORT";
    case TokenKind::KEYWORD_SIGNED: return "KEYWORD_SIGNED";
    case TokenKind::KEYWORD_SIZEOF: return "KEYWORD_SIZEOF";
    case TokenKind::KEYWORD_STATIC: return "KEYWORD_STATIC";
    case TokenKind::KEYWORD_STRUCT: return "KEYWORD_STRUCT";
    case TokenKind::KEYWORD_SWITCH: return "KEYWORD_SWITCH";
    case TokenKind::KEYWORD_TYPEDEF: return "KEYWORD_TYPEDEF";
    case TokenKind::KEYWORD_UNION: return "KEYWORD_UNION";
    case TokenKind::KEYWORD_UNSIGNED: return "KEYWORD_UNSIGNED";
    case TokenKind::KEYWORD_VOID: return "KEYWORD_VOID";
    case TokenKind::KEYWORD_VOLATILE: return "KEYWORD_VOLATILE";
    case TokenKind::KEYWORD_WHILE: return "KEYWORD_WHILE";
    case TokenKind::KEYWORD__ALIGNAS: return "KEYWORD__ALIGNAS";
    case TokenKind::KEYWORD__ALIGNOF: return "KEYWORD__ALIGNOF";
    case TokenKind::KEYWORD__ATOMIC: return "KEYWORD__ATOMIC";
    case TokenKind::KEYWORD__BOOLEAN: return "KEYWORD__BOOLEAN";
    case TokenKind::KEYWORD__COMPLEX: return "KEYWORD__COMPLEX";
    case TokenKind::KEYWORD__GENERIC: return "KEYWORD__GENERIC";
    case TokenKind::KEYWORD__IMAGINARY: return "KEYWORD__IMAGINARY";
    case TokenKind::KEYWORD__NORETURN: return "KEYWORD__NORETURN";
    case TokenKind::KEYWORD__STATIC_ASSERT: return "KEYWORD__STATIC_ASSERT";
    case TokenKind::KEYWORD__THREAD_LOCAL: return "KEYWORD__THREAD_LOCAL";
    case TokenKind::KEYWORD___FUNC__: return "KEYWORD___FUNC__";
    case TokenKind::KEYWORD___OBJC_YES: return "KEYWORD___OBJC_YES";
    case TokenKind::KEYWORD___OBJC_NO: return "KEYWORD___OBJC_NO";
    case TokenKind::KEYWORD_ASSEMBLY: return "KEYWORD_ASSEMBLY";
    case TokenKind::KEYWORD_BOOLEAN: return "KEYWORD_BOOLEAN";
    case TokenKind::KEYWORD_CATCH: return "KEYWORD_CATCH";
    case TokenKind::KEYWORD_CLASS: return "KEYWORD_CLASS";
    case TokenKind::KEYWORD_CONST_CAST: return "KEYWORD_CONST_CAST";
    case TokenKind::KEYWORD_DELETE: return "KEYWORD_DELETE";
    case TokenKind::KEYWORD_DYNAMIC_CAST: return "KEYWORD_DYNAMIC_CAST";
    case TokenKind::KEYWORD_EXPLICIT: return "KEYWORD_EXPLICIT";
    case TokenKind::KEYWORD_EXPORT: return "KEYWORD_EXPORT";
    case TokenKind::KEYWORD_FALSE: return "KEYWORD_FALSE";
    case TokenKind::KEYWORD_FRIEND: return "KEYWORD_FRIEND";
    case TokenKind::KEYWORD_MUTABLE: return "KEYWORD_MUTABLE";
    case TokenKind::KEYWORD_NAMESPACE: return "KEYWORD_NAMESPACE";
    case TokenKind::KEYWORD_NEW: return "KEYWORD_NEW";
    case TokenKind::KEYWORD_OPERATOR: return "KEYWORD_OPERATOR";
    case TokenKind::KEYWORD_PRIVATE: return "KEYWORD_PRIVATE";
    case TokenKind::KEYWORD_PROTECTED: return "KEYWORD_PROTECTED";
    case TokenKind::KEYWORD_PUBLIC: return "KEYWORD_PUBLIC";
    case TokenKind::KEYWORD_REINTERPRET_CAST: return "KEYWORD_REINTERPRET_CAST";
    case TokenKind::KEYWORD_STATIC_CAST: return "KEYWORD_STATIC_CAST";
    case TokenKind::KEYWORD_TEMPLATE: return "KEYWORD_TEMPLATE";
    case TokenKind::KEYWORD_THIS: return "KEYWORD_THIS";
    case TokenKind::KEYWORD_THROW: return "KEYWORD_THROW";
    case TokenKind::KEYWORD_TRUE: return "KEYWORD_TRUE";
    case TokenKind::KEYWORD_TRY: return "KEYWORD_TRY";
    case TokenKind::KEYWORD_TYPENAME: return "KEYWORD_TYPENAME";
    case TokenKind::KEYWORD_TYPEID: return "KEYWORD_TYPEID";
    case TokenKind::KEYWORD_USING: return "KEYWORD_USING";
    case TokenKind::KEYWORD_VIRTUAL: return "KEYWORD_VIRTUAL";
    case TokenKind::KEYWORD_WCHAR_T: return "KEYWORD_WCHAR_T";
    case TokenKind::KEYWORD_ALIGNAS: return "KEYWORD_ALIGNAS";
    case TokenKind::KEYWORD_ALIGNOF: return "KEYWORD_ALIGNOF";
    case TokenKind::KEYWORD_CHAR16_T: return "KEYWORD_CHAR16_T";
    case TokenKind::KEYWORD_CHAR32_T: return "KEYWORD_CHAR32_T";
    case TokenKind::KEYWORD_CONSTEXPR: return "KEYWORD_CONSTEXPR";
    case TokenKind::KEYWORD_DECLTYPE: return "KEYWORD_DECLTYPE";
    case TokenKind::KEYWORD_NOEXCEPT: return "KEYWORD_NOEXCEPT";
    case TokenKind::KEYWORD_NULLPTR: return "KEYWORD_NULLPTR";
    case TokenKind::KEYWORD_STATIC_ASSERT: return "KEYWORD_STATIC_ASSERT";
    case TokenKind::KEYWORD_THREAD_LOCAL: return "KEYWORD_THREAD_LOCAL";
    case TokenKind::KEYWORD_CONCEPT: return "KEYWORD_CONCEPT";
    case TokenKind::KEYWORD_REQUIRES: return "KEYWORD_REQUIRES";
    case TokenKind::KEYWORD_CO_AWAIT: return "KEYWORD_CO_AWAIT";
    case TokenKind::KEYWORD_CO_RETURN: return "KEYWORD_CO_RETURN";
    case TokenKind::KEYWORD_CO_YIELD: return "KEYWORD_CO_YIELD";
    case TokenKind::KEYWORD_MODULE: return "KEYWORD_MODULE";
    case TokenKind::KEYWORD_IMPORT: return "KEYWORD_IMPORT";
    case TokenKind::KEYWORD_CONSTEVAL: return "KEYWORD_CONSTEVAL";
    case TokenKind::KEYWORD_CONSTINIT: return "KEYWORD_CONSTINIT";
    case TokenKind::KEYWORD_CHAR8_T: return "KEYWORD_CHAR8_T";
    case TokenKind::KEYWORD__FLOAT16: return "KEYWORD__FLOAT16";
    case TokenKind::KEYWORD__ACCUM: return "KEYWORD__ACCUM";
    case TokenKind::KEYWORD__FRACT: return "KEYWORD__FRACT";
    case TokenKind::KEYWORD__SAT: return "KEYWORD__SAT";
    case TokenKind::KEYWORD__DECIMAL32: return "KEYWORD__DECIMAL32";
    case TokenKind::KEYWORD__DECIMAL64: return "KEYWORD__DECIMAL64";
    case TokenKind::KEYWORD__DECIMAL128: return "KEYWORD__DECIMAL128";
    case TokenKind::KEYWORD___NULL: return "KEYWORD___NULL";
    case TokenKind::KEYWORD___ALIGNOF: return "KEYWORD___ALIGNOF";
    case TokenKind::KEYWORD___ATTRIBUTE: return "KEYWORD___ATTRIBUTE";
    case TokenKind::KEYWORD___BUILTIN_CHOOSE_EXPRESSION: return "KEYWORD___BUILTIN_CHOOSE_EXPRESSION";
    case TokenKind::KEYWORD___BUILTIN_OFFSETOF: return "KEYWORD___BUILTIN_OFFSETOF";
    case TokenKind::KEYWORD___BUILTIN_FILE: return "KEYWORD___BUILTIN_FILE";
    case TokenKind::KEYWORD___BUILTIN_FUNCTION: return "KEYWORD___BUILTIN_FUNCTION";
    case TokenKind::KEYWORD___BUILTIN_LINE: return "KEYWORD___BUILTIN_LINE";
    case TokenKind::KEYWORD___BUILTIN_COLUMN: return "KEYWORD___BUILTIN_COLUMN";
    case TokenKind::KEYWORD___BUILTIN_SOURCE_TOKEN: return "KEYWORD___BUILTIN_SOURCE_TOKEN";
    case TokenKind::KEYWORD___BUILTIN_TYPES_COMPATIBLE_P: return "KEYWORD___BUILTIN_TYPES_COMPATIBLE_P";
    case TokenKind::KEYWORD___BUILTIN_VA_ARGUMENT: return "KEYWORD___BUILTIN_VA_ARGUMENT";
    case TokenKind::KEYWORD___EXTENSION__: return "KEYWORD___EXTENSION__";
    case TokenKind::KEYWORD___FLOAT128: return "KEYWORD___FLOAT128";
    case TokenKind::KEYWORD___IBM128: return "KEYWORD___IBM128";
    case TokenKind::KEYWORD___IMAG: return "KEYWORD___IMAG";
    case TokenKind::KEYWORD___INT128: return "KEYWORD___INT128";
    case TokenKind::KEYWORD___LABEL__: return "KEYWORD___LABEL__";
    case TokenKind::KEYWORD___REAL: return "KEYWORD___REAL";
    case TokenKind::KEYWORD___THREAD: return "KEYWORD___THREAD";
    case TokenKind::KEYWORD___FUNCTION__: return "KEYWORD___FUNCTION__";
    case TokenKind::KEYWORD___PRETTYFUNCTION__: return "KEYWORD___PRETTYFUNCTION__";
    case TokenKind::KEYWORD___AUTO_TYPE: return "KEYWORD___AUTO_TYPE";
    case TokenKind::KEYWORD_TYPEOF: return "KEYWORD_TYPEOF";
    case TokenKind::KEYWORD___FUNCDNAME__: return "KEYWORD___FUNCDNAME__";
    case TokenKind::KEYWORD___FUNCSIG__: return "KEYWORD___FUNCSIG__";
    case TokenKind::KEYWORD_LFUNCTION__: return "KEYWORD_LFUNCTION__";
    case TokenKind::KEYWORD_LFUNCSIG__: return "KEYWORD_LFUNCSIG__";
    case TokenKind::KEYWORD___IS_INTERFACE_CLASS: return "KEYWORD___IS_INTERFACE_CLASS";
    case TokenKind::KEYWORD___IS_SEALED: return "KEYWORD___IS_SEALED";
    case TokenKind::KEYWORD___IS_DESTRUCTIBLE: return "KEYWORD___IS_DESTRUCTIBLE";
    case TokenKind::KEYWORD___IS_TRIVIALLY_DESTRUCTIBLE: return "KEYWORD___IS_TRIVIALLY_DESTRUCTIBLE";
    case TokenKind::KEYWORD___IS_NOTHROW_DESTRUCTIBLE: return "KEYWORD___IS_NOTHROW_DESTRUCTIBLE";
    case TokenKind::KEYWORD___IS_NOTHROW_ASSIGNABLE: return "KEYWORD___IS_NOTHROW_ASSIGNABLE";
    case TokenKind::KEYWORD___IS_CONSTRUCTIBLE: return "KEYWORD___IS_CONSTRUCTIBLE";
    case TokenKind::KEYWORD___IS_NOTHROW_CONSTRUCTIBLE: return "KEYWORD___IS_NOTHROW_CONSTRUCTIBLE";
    case TokenKind::KEYWORD___IS_ASSIGNABLE: return "KEYWORD___IS_ASSIGNABLE";
    case TokenKind::KEYWORD___HAS_NOTHROW_MOVE_ASSIGN: return "KEYWORD___HAS_NOTHROW_MOVE_ASSIGN";
    case TokenKind::KEYWORD___HAS_TRIVIAL_MOVE_ASSIGN: return "KEYWORD___HAS_TRIVIAL_MOVE_ASSIGN";
    case TokenKind::KEYWORD___HAS_TRIVIAL_MOVE_CONSTRUCTOR: return "KEYWORD___HAS_TRIVIAL_MOVE_CONSTRUCTOR";
    case TokenKind::KEYWORD___HAS_NOTHROW_ASSIGN: return "KEYWORD___HAS_NOTHROW_ASSIGN";
    case TokenKind::KEYWORD___HAS_NOTHROW_COPY: return "KEYWORD___HAS_NOTHROW_COPY";
    case TokenKind::KEYWORD___HAS_NOTHROW_CONSTRUCTOR: return "KEYWORD___HAS_NOTHROW_CONSTRUCTOR";
    case TokenKind::KEYWORD___HAS_TRIVIAL_ASSIGN: return "KEYWORD___HAS_TRIVIAL_ASSIGN";
    case TokenKind::KEYWORD___HAS_TRIVIAL_COPY: return "KEYWORD___HAS_TRIVIAL_COPY";
    case TokenKind::KEYWORD___HAS_TRIVIAL_CONSTRUCTOR: return "KEYWORD___HAS_TRIVIAL_CONSTRUCTOR";
    case TokenKind::KEYWORD___HAS_TRIVIAL_DESTRUCTOR: return "KEYWORD___HAS_TRIVIAL_DESTRUCTOR";
    case TokenKind::KEYWORD___HAS_VIRTUAL_DESTRUCTOR: return "KEYWORD___HAS_VIRTUAL_DESTRUCTOR";
    case TokenKind::KEYWORD___IS_ABSTRACT: return "KEYWORD___IS_ABSTRACT";
    case TokenKind::KEYWORD___IS_AGGREGATE: return "KEYWORD___IS_AGGREGATE";
    case TokenKind::KEYWORD___IS_BASE_OF: return "KEYWORD___IS_BASE_OF";
    case TokenKind::KEYWORD___IS_CLASS: return "KEYWORD___IS_CLASS";
    case TokenKind::KEYWORD___IS_CONVERTIBLE_TO: return "KEYWORD___IS_CONVERTIBLE_TO";
    case TokenKind::KEYWORD___IS_EMPTY: return "KEYWORD___IS_EMPTY";
    case TokenKind::KEYWORD___IS_ENUM: return "KEYWORD___IS_ENUM";
    case TokenKind::KEYWORD___IS_FINAL: return "KEYWORD___IS_FINAL";
    case TokenKind::KEYWORD___IS_LITERAL: return "KEYWORD___IS_LITERAL";
    case TokenKind::KEYWORD___IS_POD: return "KEYWORD___IS_POD";
    case TokenKind::KEYWORD___IS_POLYMORPHIC: return "KEYWORD___IS_POLYMORPHIC";
    case TokenKind::KEYWORD___IS_STANDARD_LAYOUT: return "KEYWORD___IS_STANDARD_LAYOUT";
    case TokenKind::KEYWORD___IS_TRIVIAL: return "KEYWORD___IS_TRIVIAL";
    case TokenKind::KEYWORD___IS_TRIVIALLY_ASSIGNABLE: return "KEYWORD___IS_TRIVIALLY_ASSIGNABLE";
    case TokenKind::KEYWORD___IS_TRIVIALLY_CONSTRUCTIBLE: return "KEYWORD___IS_TRIVIALLY_CONSTRUCTIBLE";
    case TokenKind::KEYWORD___IS_TRIVIALLY_COPYABLE: return "KEYWORD___IS_TRIVIALLY_COPYABLE";
    case TokenKind::KEYWORD___IS_UNION: return "KEYWORD___IS_UNION";
    case TokenKind::KEYWORD___HAS_UNIQUE_OBJECT_REPRESENTATIONS: return "KEYWORD___HAS_UNIQUE_OBJECT_REPRESENTATIONS";
    case TokenKind::KEYWORD___UNDERLYING_TYPE: return "KEYWORD___UNDERLYING_TYPE";
    case TokenKind::KEYWORD___IS_TRIVIALLY_RELOCATABLE: return "KEYWORD___IS_TRIVIALLY_RELOCATABLE";
    case TokenKind::KEYWORD___REFERENCE_BINDS_TO_TEMPORARY: return "KEYWORD___REFERENCE_BINDS_TO_TEMPORARY";
    case TokenKind::KEYWORD___IS_LVALUE_EXPRESSION: return "KEYWORD___IS_LVALUE_EXPRESSION";
    case TokenKind::KEYWORD___IS_RVALUE_EXPRESSION: return "KEYWORD___IS_RVALUE_EXPRESSION";
    case TokenKind::KEYWORD___IS_ARITHMETIC: return "KEYWORD___IS_ARITHMETIC";
    case TokenKind::KEYWORD___IS_FLOATING_POINT: return "KEYWORD___IS_FLOATING_POINT";
    case TokenKind::KEYWORD___IS_INTEGRAL: return "KEYWORD___IS_INTEGRAL";
    case TokenKind::KEYWORD___IS_COMPLETE_TYPE: return "KEYWORD___IS_COMPLETE_TYPE";
    case TokenKind::KEYWORD___IS_VOID: return "KEYWORD___IS_VOID";
    case TokenKind::KEYWORD___IS_ARRAY: return "KEYWORD___IS_ARRAY";
    case TokenKind::KEYWORD___IS_FUNCTION: return "KEYWORD___IS_FUNCTION";
    case TokenKind::KEYWORD___IS_REFERENCE: return "KEYWORD___IS_REFERENCE";
    case TokenKind::KEYWORD___IS_LVALUE_REFERENCE: return "KEYWORD___IS_LVALUE_REFERENCE";
    case TokenKind::KEYWORD___IS_RVALUE_REFERENCE: return "KEYWORD___IS_RVALUE_REFERENCE";
    case TokenKind::KEYWORD___IS_FUNDAMENTAL: return "KEYWORD___IS_FUNDAMENTAL";
    case TokenKind::KEYWORD___IS_OBJECT: return "KEYWORD___IS_OBJECT";
    case TokenKind::KEYWORD___IS_SCALAR: return "KEYWORD___IS_SCALAR";
    case TokenKind::KEYWORD___IS_COMPOUND: return "KEYWORD___IS_COMPOUND";
    case TokenKind::KEYWORD___IS_POINTER: return "KEYWORD___IS_POINTER";
    case TokenKind::KEYWORD___IS_MEMBER_OBJECT_POINTER: return "KEYWORD___IS_MEMBER_OBJECT_POINTER";
    case TokenKind::KEYWORD___IS_MEMBER_FUNCTION_POINTER: return "KEYWORD___IS_MEMBER_FUNCTION_POINTER";
    case TokenKind::KEYWORD___IS_MEMBER_POINTER: return "KEYWORD___IS_MEMBER_POINTER";
    case TokenKind::KEYWORD___IS_CONST: return "KEYWORD___IS_CONST";
    case TokenKind::KEYWORD___IS_VOLATILE: return "KEYWORD___IS_VOLATILE";
    case TokenKind::KEYWORD___IS_SIGNED: return "KEYWORD___IS_SIGNED";
    case TokenKind::KEYWORD___IS_UNSIGNED: return "KEYWORD___IS_UNSIGNED";
    case TokenKind::KEYWORD___IS_SAME: return "KEYWORD___IS_SAME";
    case TokenKind::KEYWORD___IS_CONVERTIBLE: return "KEYWORD___IS_CONVERTIBLE";
    case TokenKind::KEYWORD___ARRAY_RANK: return "KEYWORD___ARRAY_RANK";
    case TokenKind::KEYWORD___ARRAY_EXTENT: return "KEYWORD___ARRAY_EXTENT";
    case TokenKind::KEYWORD___PRIVATE_EXTERN__: return "KEYWORD___PRIVATE_EXTERN__";
    case TokenKind::KEYWORD___MODULE_PRIVATE__: return "KEYWORD___MODULE_PRIVATE__";
    case TokenKind::KEYWORD___DECLSPEC: return "KEYWORD___DECLSPEC";
    case TokenKind::KEYWORD___CDECL: return "KEYWORD___CDECL";
    case TokenKind::KEYWORD___STDCALL: return "KEYWORD___STDCALL";
    case TokenKind::KEYWORD___FASTCALL: return "KEYWORD___FASTCALL";
    case TokenKind::KEYWORD___THISCALL: return "KEYWORD___THISCALL";
    case TokenKind::KEYWORD___REGCALL: return "KEYWORD___REGCALL";
    case TokenKind::KEYWORD___VECTORCALL: return "KEYWORD___VECTORCALL";
    case TokenKind::KEYWORD___FORCEINLINE: return "KEYWORD___FORCEINLINE";
    case TokenKind::KEYWORD___UNALIGNED: return "KEYWORD___UNALIGNED";
    case TokenKind::KEYWORD___SUPER: return "KEYWORD___SUPER";
    case TokenKind::KEYWORD___GLOBAL: return "KEYWORD___GLOBAL";
    case TokenKind::KEYWORD___LOCAL: return "KEYWORD___LOCAL";
    case TokenKind::KEYWORD___CONSTANT: return "KEYWORD___CONSTANT";
    case TokenKind::KEYWORD___PRIVATE: return "KEYWORD___PRIVATE";
    case TokenKind::KEYWORD___GENERIC: return "KEYWORD___GENERIC";
    case TokenKind::KEYWORD___KERNEL: return "KEYWORD___KERNEL";
    case TokenKind::KEYWORD___READ_ONLY: return "KEYWORD___READ_ONLY";
    case TokenKind::KEYWORD___WRITE_ONLY: return "KEYWORD___WRITE_ONLY";
    case TokenKind::KEYWORD___READ_WRITE: return "KEYWORD___READ_WRITE";
    case TokenKind::KEYWORD___BUILTIN_ASTYPE: return "KEYWORD___BUILTIN_ASTYPE";
    case TokenKind::KEYWORD_VEC_STEP: return "KEYWORD_VEC_STEP";
    case TokenKind::KEYWORD_IMAGE_1D_T: return "KEYWORD_IMAGE_1D_T";
    case TokenKind::KEYWORD_IMAGE_1D_ARRAY_T: return "KEYWORD_IMAGE_1D_ARRAY_T";
    case TokenKind::KEYWORD_IMAGE_1D_BUFFER_T: return "KEYWORD_IMAGE_1D_BUFFER_T";
    case TokenKind::KEYWORD_IMAGE_2D_T: return "KEYWORD_IMAGE_2D_T";
    case TokenKind::KEYWORD_IMAGE_2D_ARRAY_T: return "KEYWORD_IMAGE_2D_ARRAY_T";
    case TokenKind::KEYWORD_IMAGE_2D_DEPTH_T: return "KEYWORD_IMAGE_2D_DEPTH_T";
    case TokenKind::KEYWORD_IMAGE_2D_ARRAY_DEPTH_T: return "KEYWORD_IMAGE_2D_ARRAY_DEPTH_T";
    case TokenKind::KEYWORD_IMAGE_2D_MSAA_T: return "KEYWORD_IMAGE_2D_MSAA_T";
    case TokenKind::KEYWORD_IMAGE_2D_ARRAY_MSAA_T: return "KEYWORD_IMAGE_2D_ARRAY_MSAA_T";
    case TokenKind::KEYWORD_IMAGE_2D_MSAA_DEPTH_T: return "KEYWORD_IMAGE_2D_MSAA_DEPTH_T";
    case TokenKind::KEYWORD_IMAGE_2D_ARRAY_MSAA_DEPTH_T: return "KEYWORD_IMAGE_2D_ARRAY_MSAA_DEPTH_T";
    case TokenKind::KEYWORD_IMAGE_3D_T: return "KEYWORD_IMAGE_3D_T";
    case TokenKind::KEYWORD_PIPE: return "KEYWORD_PIPE";
    case TokenKind::KEYWORD_ADDRSPACE_CAST: return "KEYWORD_ADDRSPACE_CAST";
    case TokenKind::KEYWORD___NOINLINE__: return "KEYWORD___NOINLINE__";
    case TokenKind::KEYWORD___BUILTIN_OMP_REQUIRED_SIMD_ALIGN: return "KEYWORD___BUILTIN_OMP_REQUIRED_SIMD_ALIGN";
    case TokenKind::KEYWORD___PASCAL: return "KEYWORD___PASCAL";
    case TokenKind::KEYWORD___VECTOR: return "KEYWORD___VECTOR";
    case TokenKind::KEYWORD___PIXEL: return "KEYWORD___PIXEL";
    case TokenKind::KEYWORD___BOOLEAN: return "KEYWORD___BOOLEAN";
    case TokenKind::KEYWORD___BF16: return "KEYWORD___BF16";
    case TokenKind::KEYWORD_HALF: return "KEYWORD_HALF";
    case TokenKind::KEYWORD___BRIDGE: return "KEYWORD___BRIDGE";
    case TokenKind::KEYWORD___BRIDGE_TRANSFER: return "KEYWORD___BRIDGE_TRANSFER";
    case TokenKind::KEYWORD___BRIDGE_RETAINED: return "KEYWORD___BRIDGE_RETAINED";
    case TokenKind::KEYWORD___BRIDGE_RETAIN: return "KEYWORD___BRIDGE_RETAIN";
    case TokenKind::KEYWORD___COVARIANT: return "KEYWORD___COVARIANT";
    case TokenKind::KEYWORD___CONTRAVARIANT: return "KEYWORD___CONTRAVARIANT";
    case TokenKind::KEYWORD___KINDOF: return "KEYWORD___KINDOF";
    case TokenKind::KEYWORD__NONNULL: return "KEYWORD__NONNULL";
    case TokenKind::KEYWORD__NULLABLE: return "KEYWORD__NULLABLE";
    case TokenKind::KEYWORD__NULLABLE_RESULT: return "KEYWORD__NULLABLE_RESULT";
    case TokenKind::KEYWORD__NULL_UNSPECIFIED: return "KEYWORD__NULL_UNSPECIFIED";
    case TokenKind::KEYWORD___PTR64: return "KEYWORD___PTR64";
    case TokenKind::KEYWORD___PTR32: return "KEYWORD___PTR32";
    case TokenKind::KEYWORD___SPTR: return "KEYWORD___SPTR";
    case TokenKind::KEYWORD___UPTR: return "KEYWORD___UPTR";
    case TokenKind::KEYWORD___W64: return "KEYWORD___W64";
    case TokenKind::KEYWORD___UUIDOF: return "KEYWORD___UUIDOF";
    case TokenKind::KEYWORD___TRY: return "KEYWORD___TRY";
    case TokenKind::KEYWORD___FINALLY: return "KEYWORD___FINALLY";
    case TokenKind::KEYWORD___LEAVE: return "KEYWORD___LEAVE";
    case TokenKind::KEYWORD___INT64: return "KEYWORD___INT64";
    case TokenKind::KEYWORD___IF_EXISTS: return "KEYWORD___IF_EXISTS";
    case TokenKind::KEYWORD___IF_NOT_EXISTS: return "KEYWORD___IF_NOT_EXISTS";
    case TokenKind::KEYWORD___SINGLE_INHERITANCE: return "KEYWORD___SINGLE_INHERITANCE";
    case TokenKind::KEYWORD___MULTIPLE_INHERITANCE: return "KEYWORD___MULTIPLE_INHERITANCE";
    case TokenKind::KEYWORD___VIRTUAL_INHERITANCE: return "KEYWORD___VIRTUAL_INHERITANCE";
    case TokenKind::KEYWORD___INTERFACE: return "KEYWORD___INTERFACE";
    case TokenKind::KEYWORD___BUILTIN_CONVERTVECTOR: return "KEYWORD___BUILTIN_CONVERTVECTOR";
    case TokenKind::KEYWORD___BUILTIN_BIT_CAST: return "KEYWORD___BUILTIN_BIT_CAST";
    case TokenKind::KEYWORD___BUILTIN_AVAILABLE: return "KEYWORD___BUILTIN_AVAILABLE";
    case TokenKind::KEYWORD___BUILTIN_SYCL_UNIQUE_STABLE_NAME: return "KEYWORD___BUILTIN_SYCL_UNIQUE_STABLE_NAME";
    case TokenKind::KEYWORD___UNKNOWN_ANYTYPE: return "KEYWORD___UNKNOWN_ANYTYPE";
    case TokenKind::ANNOT_CXXSCOPE: return "ANNOT_CXXSCOPE";
    case TokenKind::ANNOT_TYPENAME: return "ANNOT_TYPENAME";
    case TokenKind::ANNOT_TEMPLATE_ID: return "ANNOT_TEMPLATE_ID";
    case TokenKind::ANNOT_NON_TYPE: return "ANNOT_NON_TYPE";
    case TokenKind::ANNOT_NON_TYPE_UNDECLARED: return "ANNOT_NON_TYPE_UNDECLARED";
    case TokenKind::ANNOT_NON_TYPE_DEPENDENT: return "ANNOT_NON_TYPE_DEPENDENT";
    case TokenKind::ANNOT_OVERLOAD: return "ANNOT_OVERLOAD";
    case TokenKind::ANNOT_PRIMARY_EXPRESSION: return "ANNOT_PRIMARY_EXPRESSION";
    case TokenKind::ANNOT_DECLTYPE: return "ANNOT_DECLTYPE";
    case TokenKind::ANNOT_PRAGMA_UNUSED: return "ANNOT_PRAGMA_UNUSED";
    case TokenKind::ANNOT_PRAGMA_VIS: return "ANNOT_PRAGMA_VIS";
    case TokenKind::ANNOT_PRAGMA_PACK: return "ANNOT_PRAGMA_PACK";
    case TokenKind::ANNOT_PRAGMA_PARSER_CRASH: return "ANNOT_PRAGMA_PARSER_CRASH";
    case TokenKind::ANNOT_PRAGMA_CAPTURED: return "ANNOT_PRAGMA_CAPTURED";
    case TokenKind::ANNOT_PRAGMA_DUMP: return "ANNOT_PRAGMA_DUMP";
    case TokenKind::ANNOT_PRAGMA_MSSTRUCT: return "ANNOT_PRAGMA_MSSTRUCT";
    case TokenKind::ANNOT_PRAGMA_ALIGN: return "ANNOT_PRAGMA_ALIGN";
    case TokenKind::ANNOT_PRAGMA_WEAK: return "ANNOT_PRAGMA_WEAK";
    case TokenKind::ANNOT_PRAGMA_WEAKALIAS: return "ANNOT_PRAGMA_WEAKALIAS";
    case TokenKind::ANNOT_PRAGMA_REDEFINE_EXTNAME: return "ANNOT_PRAGMA_REDEFINE_EXTNAME";
    case TokenKind::ANNOT_PRAGMA_FP_CONTRACT: return "ANNOT_PRAGMA_FP_CONTRACT";
    case TokenKind::ANNOT_PRAGMA_FENV_ACCESS: return "ANNOT_PRAGMA_FENV_ACCESS";
    case TokenKind::ANNOT_PRAGMA_FENV_ACCESS_MS: return "ANNOT_PRAGMA_FENV_ACCESS_MS";
    case TokenKind::ANNOT_PRAGMA_FENV_ROUND: return "ANNOT_PRAGMA_FENV_ROUND";
    case TokenKind::ANNOT_PRAGMA_FLOAT_CONTROL: return "ANNOT_PRAGMA_FLOAT_CONTROL";
    case TokenKind::ANNOT_PRAGMA_MS_POINTERS_TO_MEMBERS: return "ANNOT_PRAGMA_MS_POINTERS_TO_MEMBERS";
    case TokenKind::ANNOT_PRAGMA_MS_VTORDISP: return "ANNOT_PRAGMA_MS_VTORDISP";
    case TokenKind::ANNOT_PRAGMA_MS_PRAGMA: return "ANNOT_PRAGMA_MS_PRAGMA";
    case TokenKind::ANNOT_PRAGMA_OPENCL_EXTENSION: return "ANNOT_PRAGMA_OPENCL_EXTENSION";
    case TokenKind::ANNOT_ATTRIBUTE_OPENMP: return "ANNOT_ATTRIBUTE_OPENMP";
    case TokenKind::ANNOT_PRAGMA_OPENMP: return "ANNOT_PRAGMA_OPENMP";
    case TokenKind::ANNOT_PRAGMA_OPENMP_END: return "ANNOT_PRAGMA_OPENMP_END";
    case TokenKind::ANNOT_PRAGMA_LOOP_HINT: return "ANNOT_PRAGMA_LOOP_HINT";
    case TokenKind::ANNOT_PRAGMA_FP: return "ANNOT_PRAGMA_FP";
    case TokenKind::ANNOT_PRAGMA_ATTRIBUTE: return "ANNOT_PRAGMA_ATTRIBUTE";
    case TokenKind::ANNOT_PRAGMA_RISCV: return "ANNOT_PRAGMA_RISCV";
    case TokenKind::ANNOT_MODULE_INCLUDE: return "ANNOT_MODULE_INCLUDE";
    case TokenKind::ANNOT_MODULE_BEGIN: return "ANNOT_MODULE_BEGIN";
    case TokenKind::ANNOT_MODULE_END: return "ANNOT_MODULE_END";
    case TokenKind::ANNOT_HEADER_UNIT: return "ANNOT_HEADER_UNIT";
    case TokenKind::PP_IF: return "PP_IF";
    case TokenKind::PP_IFDEF: return "PP_IFDEF";
    case TokenKind::PP_IFNDEF: return "PP_IFNDEF";
    case TokenKind::PP_ELIF: return "PP_ELIF";
    case TokenKind::PP_ELIFDEF: return "PP_ELIFDEF";
    case TokenKind::PP_ELIFNDEF: return "PP_ELIFNDEF";
    case TokenKind::PP_ELSE: return "PP_ELSE";
    case TokenKind::PP_ENDIF: return "PP_ENDIF";
    case TokenKind::PP_DEFINED: return "PP_DEFINED";
    case TokenKind::PP_INCLUDE: return "PP_INCLUDE";
    case TokenKind::PP___INCLUDE_MACROS: return "PP___INCLUDE_MACROS";
    case TokenKind::PP_DEFINE: return "PP_DEFINE";
    case TokenKind::PP_UNDEF: return "PP_UNDEF";
    case TokenKind::PP_LINE: return "PP_LINE";
    case TokenKind::PP_ERROR: return "PP_ERROR";
    case TokenKind::PP_PRAGMA: return "PP_PRAGMA";
    case TokenKind::PP_IMPORT: return "PP_IMPORT";
    case TokenKind::PP_INCLUDE_NEXT: return "PP_INCLUDE_NEXT";
    case TokenKind::PP_WARNING: return "PP_WARNING";
    case TokenKind::PP_IDENTIFIER: return "PP_IDENTIFIER";
    case TokenKind::PP_SCCS: return "PP_SCCS";
    case TokenKind::PP_ASSERT: return "PP_ASSERT";
    case TokenKind::PP_UNASSERT: return "PP_UNASSERT";
    case TokenKind::PP___PUBLIC_MACRO: return "PP___PUBLIC_MACRO";
    case TokenKind::PP___PRIVATE_MACRO: return "PP___PRIVATE_MACRO";
    case TokenKind::OBJC_AT_CLASS: return "OBJC_AT_CLASS";
    case TokenKind::OBJC_AT_COMPATIBILITY_ALIAS: return "OBJC_AT_COMPATIBILITY_ALIAS";
    case TokenKind::OBJC_AT_DEFINITIONS: return "OBJC_AT_DEFINITIONS";
    case TokenKind::OBJC_AT_ENCODE: return "OBJC_AT_ENCODE";
    case TokenKind::OBJC_AT_OBJC_END: return "OBJC_AT_OBJC_END";
    case TokenKind::OBJC_AT_IMPLEMENTATION: return "OBJC_AT_IMPLEMENTATION";
    case TokenKind::OBJC_AT_INTERFACE: return "OBJC_AT_INTERFACE";
    case TokenKind::OBJC_AT_PRIVATE: return "OBJC_AT_PRIVATE";
    case TokenKind::OBJC_AT_PROTECTED: return "OBJC_AT_PROTECTED";
    case TokenKind::OBJC_AT_PROTOCOL: return "OBJC_AT_PROTOCOL";
    case TokenKind::OBJC_AT_PUBLIC: return "OBJC_AT_PUBLIC";
    case TokenKind::OBJC_AT_SELECTOR: return "OBJC_AT_SELECTOR";
    case TokenKind::OBJC_AT_THROW: return "OBJC_AT_THROW";
    case TokenKind::OBJC_AT_TRY: return "OBJC_AT_TRY";
    case TokenKind::OBJC_AT_CATCH: return "OBJC_AT_CATCH";
    case TokenKind::OBJC_AT_FINALLY: return "OBJC_AT_FINALLY";
    case TokenKind::OBJC_AT_SYNCHRONIZED: return "OBJC_AT_SYNCHRONIZED";
    case TokenKind::OBJC_AT_AUTORELEASEPOOL: return "OBJC_AT_AUTORELEASEPOOL";
    case TokenKind::OBJC_AT_PROPERTY: return "OBJC_AT_PROPERTY";
    case TokenKind::OBJC_AT_PACKAGE: return "OBJC_AT_PACKAGE";
    case TokenKind::OBJC_AT_REQUIRED: return "OBJC_AT_REQUIRED";
    case TokenKind::OBJC_AT_OPTIONAL: return "OBJC_AT_OPTIONAL";
    case TokenKind::OBJC_AT_SYNTHESIZE: return "OBJC_AT_SYNTHESIZE";
    case TokenKind::OBJC_AT_DYNAMIC: return "OBJC_AT_DYNAMIC";
    case TokenKind::OBJC_AT_IMPORT: return "OBJC_AT_IMPORT";
    case TokenKind::OBJC_AT_AVAILABLE: return "OBJC_AT_AVAILABLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TrailingAllocKind e) {
  switch (e) {
    case TrailingAllocKind::TAK_INHERITS_CONSTRUCTOR: return "TAK_INHERITS_CONSTRUCTOR";
    case TrailingAllocKind::TAK_HAS_TAIL_EXPLICIT: return "TAK_HAS_TAIL_EXPLICIT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TranslationUnitKind e) {
  switch (e) {
    case TranslationUnitKind::COMPLETE: return "COMPLETE";
    case TranslationUnitKind::PREFIX: return "PREFIX";
    case TranslationUnitKind::MODULE: return "MODULE";
    case TranslationUnitKind::INCREMENTAL: return "INCREMENTAL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TrivialAutoVarInitKind e) {
  switch (e) {
    case TrivialAutoVarInitKind::UNINITIALIZED: return "UNINITIALIZED";
    case TrivialAutoVarInitKind::ZERO: return "ZERO";
    case TrivialAutoVarInitKind::PATTERN: return "PATTERN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeDependence e) {
  switch (e) {
    case TypeDependence::UNEXPANDED_PACK: return "UNEXPANDED_PACK";
    case TypeDependence::INSTANTIATION: return "INSTANTIATION";
    case TypeDependence::DEPENDENT: return "DEPENDENT";
    case TypeDependence::VARIABLY_MODIFIED: return "VARIABLY_MODIFIED";
    case TypeDependence::ERROR: return "ERROR";
    case TypeDependence::NONE: return "NONE";
    case TypeDependence::ALL: return "ALL";
    case TypeDependence::DEPENDENT_INSTANTIATION: return "DEPENDENT_INSTANTIATION";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeLocClass e) {
  switch (e) {
    case TypeLocClass::ADJUSTED: return "ADJUSTED";
    case TypeLocClass::DECAYED: return "DECAYED";
    case TypeLocClass::CONSTANT_ARRAY: return "CONSTANT_ARRAY";
    case TypeLocClass::DEPENDENT_SIZED_ARRAY: return "DEPENDENT_SIZED_ARRAY";
    case TypeLocClass::INCOMPLETE_ARRAY: return "INCOMPLETE_ARRAY";
    case TypeLocClass::VARIABLE_ARRAY: return "VARIABLE_ARRAY";
    case TypeLocClass::ATOMIC: return "ATOMIC";
    case TypeLocClass::ATTRIBUTED: return "ATTRIBUTED";
    case TypeLocClass::BTF_TAG_ATTRIBUTED: return "BTF_TAG_ATTRIBUTED";
    case TypeLocClass::BIT_INT: return "BIT_INT";
    case TypeLocClass::BLOCK_POINTER: return "BLOCK_POINTER";
    case TypeLocClass::BUILTIN: return "BUILTIN";
    case TypeLocClass::COMPLEX: return "COMPLEX";
    case TypeLocClass::DECLTYPE: return "DECLTYPE";
    case TypeLocClass::AUTO: return "AUTO";
    case TypeLocClass::DEDUCED_TEMPLATE_SPECIALIZATION: return "DEDUCED_TEMPLATE_SPECIALIZATION";
    case TypeLocClass::DEPENDENT_ADDRESS_SPACE: return "DEPENDENT_ADDRESS_SPACE";
    case TypeLocClass::DEPENDENT_BIT_INT: return "DEPENDENT_BIT_INT";
    case TypeLocClass::DEPENDENT_NAME: return "DEPENDENT_NAME";
    case TypeLocClass::DEPENDENT_SIZED_EXT_VECTOR: return "DEPENDENT_SIZED_EXT_VECTOR";
    case TypeLocClass::DEPENDENT_TEMPLATE_SPECIALIZATION: return "DEPENDENT_TEMPLATE_SPECIALIZATION";
    case TypeLocClass::DEPENDENT_VECTOR: return "DEPENDENT_VECTOR";
    case TypeLocClass::ELABORATED: return "ELABORATED";
    case TypeLocClass::FUNCTION_NO_PROTO: return "FUNCTION_NO_PROTO";
    case TypeLocClass::FUNCTION_PROTO: return "FUNCTION_PROTO";
    case TypeLocClass::INJECTED_CLASS_NAME: return "INJECTED_CLASS_NAME";
    case TypeLocClass::MACRO_QUALIFIED: return "MACRO_QUALIFIED";
    case TypeLocClass::CONSTANT_MATRIX: return "CONSTANT_MATRIX";
    case TypeLocClass::DEPENDENT_SIZED_MATRIX: return "DEPENDENT_SIZED_MATRIX";
    case TypeLocClass::MEMBER_POINTER: return "MEMBER_POINTER";
    case TypeLocClass::OBJ_C_OBJECT_POINTER: return "OBJ_C_OBJECT_POINTER";
    case TypeLocClass::OBJ_C_OBJECT: return "OBJ_C_OBJECT";
    case TypeLocClass::OBJ_C_INTERFACE: return "OBJ_C_INTERFACE";
    case TypeLocClass::OBJ_C_TYPE_PARAMETER: return "OBJ_C_TYPE_PARAMETER";
    case TypeLocClass::PACK_EXPANSION: return "PACK_EXPANSION";
    case TypeLocClass::PARENTHESIS: return "PARENTHESIS";
    case TypeLocClass::PIPE: return "PIPE";
    case TypeLocClass::POINTER: return "POINTER";
    case TypeLocClass::L_VALUE_REFERENCE: return "L_VALUE_REFERENCE";
    case TypeLocClass::R_VALUE_REFERENCE: return "R_VALUE_REFERENCE";
    case TypeLocClass::SUBST_TEMPLATE_TYPE_PARM_PACK: return "SUBST_TEMPLATE_TYPE_PARM_PACK";
    case TypeLocClass::SUBST_TEMPLATE_TYPE_PARM: return "SUBST_TEMPLATE_TYPE_PARM";
    case TypeLocClass::ENUM: return "ENUM";
    case TypeLocClass::RECORD: return "RECORD";
    case TypeLocClass::TEMPLATE_SPECIALIZATION: return "TEMPLATE_SPECIALIZATION";
    case TypeLocClass::TEMPLATE_TYPE_PARM: return "TEMPLATE_TYPE_PARM";
    case TypeLocClass::TYPE_OF_EXPRESSION: return "TYPE_OF_EXPRESSION";
    case TypeLocClass::TYPE_OF: return "TYPE_OF";
    case TypeLocClass::TYPEDEF: return "TYPEDEF";
    case TypeLocClass::UNARY_TRANSFORM: return "UNARY_TRANSFORM";
    case TypeLocClass::UNRESOLVED_USING: return "UNRESOLVED_USING";
    case TypeLocClass::USING: return "USING";
    case TypeLocClass::VECTOR: return "VECTOR";
    case TypeLocClass::EXT_VECTOR: return "EXT_VECTOR";
    case TypeLocClass::QUALIFIED: return "QUALIFIED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeSpecifierSign e) {
  switch (e) {
    case TypeSpecifierSign::UNSPECIFIED: return "UNSPECIFIED";
    case TypeSpecifierSign::SIGNED: return "SIGNED";
    case TypeSpecifierSign::UNSIGNED: return "UNSIGNED";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeSpecifierType e) {
  switch (e) {
    case TypeSpecifierType::UNSPECIFIED: return "UNSPECIFIED";
    case TypeSpecifierType::VOID: return "VOID";
    case TypeSpecifierType::CHARACTER: return "CHARACTER";
    case TypeSpecifierType::WCHAR: return "WCHAR";
    case TypeSpecifierType::CHAR8: return "CHAR8";
    case TypeSpecifierType::CHAR16: return "CHAR16";
    case TypeSpecifierType::CHAR32: return "CHAR32";
    case TypeSpecifierType::INT: return "INT";
    case TypeSpecifierType::INT128: return "INT128";
    case TypeSpecifierType::BITINT: return "BITINT";
    case TypeSpecifierType::HALF: return "HALF";
    case TypeSpecifierType::FLOAT16: return "FLOAT16";
    case TypeSpecifierType::ACCUM: return "ACCUM";
    case TypeSpecifierType::FRACT: return "FRACT";
    case TypeSpecifierType::B_FLOAT16: return "B_FLOAT16";
    case TypeSpecifierType::FLOAT: return "FLOAT";
    case TypeSpecifierType::DOUBLE: return "DOUBLE";
    case TypeSpecifierType::FLOAT128: return "FLOAT128";
    case TypeSpecifierType::IBM128: return "IBM128";
    case TypeSpecifierType::BOOLEAN: return "BOOLEAN";
    case TypeSpecifierType::DECIMAL32: return "DECIMAL32";
    case TypeSpecifierType::DECIMAL64: return "DECIMAL64";
    case TypeSpecifierType::DECIMAL128: return "DECIMAL128";
    case TypeSpecifierType::ENUM: return "ENUM";
    case TypeSpecifierType::UNION: return "UNION";
    case TypeSpecifierType::STRUCT: return "STRUCT";
    case TypeSpecifierType::CLASS: return "CLASS";
    case TypeSpecifierType::INTERFACE: return "INTERFACE";
    case TypeSpecifierType::TYPENAME: return "TYPENAME";
    case TypeSpecifierType::TYPEOF_TYPE: return "TYPEOF_TYPE";
    case TypeSpecifierType::TYPEOF_EXPRESSION: return "TYPEOF_EXPRESSION";
    case TypeSpecifierType::DECLTYPE: return "DECLTYPE";
    case TypeSpecifierType::UNDERLYING_TYPE: return "UNDERLYING_TYPE";
    case TypeSpecifierType::AUTO: return "AUTO";
    case TypeSpecifierType::DECLTYPE_AUTO: return "DECLTYPE_AUTO";
    case TypeSpecifierType::AUTO_TYPE: return "AUTO_TYPE";
    case TypeSpecifierType::UNKNOWN_ANYTYPE: return "UNKNOWN_ANYTYPE";
    case TypeSpecifierType::ATOMIC: return "ATOMIC";
    case TypeSpecifierType::IMAGE_1D_T: return "IMAGE_1D_T";
    case TypeSpecifierType::IMAGE_1D_ARRAY_T: return "IMAGE_1D_ARRAY_T";
    case TypeSpecifierType::IMAGE_1D_BUFFER_T: return "IMAGE_1D_BUFFER_T";
    case TypeSpecifierType::IMAGE_2D_T: return "IMAGE_2D_T";
    case TypeSpecifierType::IMAGE_2D_ARRAY_T: return "IMAGE_2D_ARRAY_T";
    case TypeSpecifierType::IMAGE_2D_DEPTH_T: return "IMAGE_2D_DEPTH_T";
    case TypeSpecifierType::IMAGE_2D_ARRAY_DEPTH_T: return "IMAGE_2D_ARRAY_DEPTH_T";
    case TypeSpecifierType::IMAGE_2D_MSAA_T: return "IMAGE_2D_MSAA_T";
    case TypeSpecifierType::IMAGE_2D_ARRAY_MSAA_T: return "IMAGE_2D_ARRAY_MSAA_T";
    case TypeSpecifierType::IMAGE_2D_MSAA_DEPTH_T: return "IMAGE_2D_MSAA_DEPTH_T";
    case TypeSpecifierType::IMAGE_2D_ARRAY_MSAA_DEPTH_T: return "IMAGE_2D_ARRAY_MSAA_DEPTH_T";
    case TypeSpecifierType::IMAGE_3D_T: return "IMAGE_3D_T";
    case TypeSpecifierType::ERROR: return "ERROR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeSpecifierWidth e) {
  switch (e) {
    case TypeSpecifierWidth::UNSPECIFIED: return "UNSPECIFIED";
    case TypeSpecifierWidth::SHORT: return "SHORT";
    case TypeSpecifierWidth::LONG: return "LONG";
    case TypeSpecifierWidth::LONG_LONG: return "LONG_LONG";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeSpecifiersPipe e) {
  switch (e) {
    case TypeSpecifiersPipe::UNSPECIFIED: return "UNSPECIFIED";
    case TypeSpecifiersPipe::PIPE: return "PIPE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TypeTrait e) {
  switch (e) {
    case TypeTrait::IS_INTERFACE_CLASS: return "IS_INTERFACE_CLASS";
    case TypeTrait::IS_SEALED: return "IS_SEALED";
    case TypeTrait::IS_DESTRUCTIBLE: return "IS_DESTRUCTIBLE";
    case TypeTrait::IS_TRIVIALLY_DESTRUCTIBLE: return "IS_TRIVIALLY_DESTRUCTIBLE";
    case TypeTrait::IS_NOTHROW_DESTRUCTIBLE: return "IS_NOTHROW_DESTRUCTIBLE";
    case TypeTrait::HAS_NOTHROW_MOVE_ASSIGN: return "HAS_NOTHROW_MOVE_ASSIGN";
    case TypeTrait::HAS_TRIVIAL_MOVE_ASSIGN: return "HAS_TRIVIAL_MOVE_ASSIGN";
    case TypeTrait::HAS_TRIVIAL_MOVE_CONSTRUCTOR: return "HAS_TRIVIAL_MOVE_CONSTRUCTOR";
    case TypeTrait::HAS_NOTHROW_ASSIGN: return "HAS_NOTHROW_ASSIGN";
    case TypeTrait::HAS_NOTHROW_COPY: return "HAS_NOTHROW_COPY";
    case TypeTrait::HAS_NOTHROW_CONSTRUCTOR: return "HAS_NOTHROW_CONSTRUCTOR";
    case TypeTrait::HAS_TRIVIAL_ASSIGN: return "HAS_TRIVIAL_ASSIGN";
    case TypeTrait::HAS_TRIVIAL_COPY: return "HAS_TRIVIAL_COPY";
    case TypeTrait::HAS_TRIVIAL_DEFAULT_CONSTRUCTOR: return "HAS_TRIVIAL_DEFAULT_CONSTRUCTOR";
    case TypeTrait::HAS_TRIVIAL_DESTRUCTOR: return "HAS_TRIVIAL_DESTRUCTOR";
    case TypeTrait::HAS_VIRTUAL_DESTRUCTOR: return "HAS_VIRTUAL_DESTRUCTOR";
    case TypeTrait::IS_ABSTRACT: return "IS_ABSTRACT";
    case TypeTrait::IS_AGGREGATE: return "IS_AGGREGATE";
    case TypeTrait::IS_CLASS: return "IS_CLASS";
    case TypeTrait::IS_EMPTY: return "IS_EMPTY";
    case TypeTrait::IS_ENUM: return "IS_ENUM";
    case TypeTrait::IS_FINAL: return "IS_FINAL";
    case TypeTrait::IS_LITERAL: return "IS_LITERAL";
    case TypeTrait::IS_POD: return "IS_POD";
    case TypeTrait::IS_POLYMORPHIC: return "IS_POLYMORPHIC";
    case TypeTrait::IS_STANDARD_LAYOUT: return "IS_STANDARD_LAYOUT";
    case TypeTrait::IS_TRIVIAL: return "IS_TRIVIAL";
    case TypeTrait::IS_TRIVIALLY_COPYABLE: return "IS_TRIVIALLY_COPYABLE";
    case TypeTrait::IS_UNION: return "IS_UNION";
    case TypeTrait::HAS_UNIQUE_OBJECT_REPRESENTATIONS: return "HAS_UNIQUE_OBJECT_REPRESENTATIONS";
    case TypeTrait::IS_TRIVIALLY_RELOCATABLE: return "IS_TRIVIALLY_RELOCATABLE";
    case TypeTrait::IS_ARITHMETIC: return "IS_ARITHMETIC";
    case TypeTrait::IS_FLOATING_POINT: return "IS_FLOATING_POINT";
    case TypeTrait::IS_INTEGRAL: return "IS_INTEGRAL";
    case TypeTrait::IS_COMPLETE_TYPE: return "IS_COMPLETE_TYPE";
    case TypeTrait::IS_VOID: return "IS_VOID";
    case TypeTrait::IS_ARRAY: return "IS_ARRAY";
    case TypeTrait::IS_FUNCTION: return "IS_FUNCTION";
    case TypeTrait::IS_REFERENCE: return "IS_REFERENCE";
    case TypeTrait::IS_LVALUE_REFERENCE: return "IS_LVALUE_REFERENCE";
    case TypeTrait::IS_RVALUE_REFERENCE: return "IS_RVALUE_REFERENCE";
    case TypeTrait::IS_FUNDAMENTAL: return "IS_FUNDAMENTAL";
    case TypeTrait::IS_OBJECT: return "IS_OBJECT";
    case TypeTrait::IS_SCALAR: return "IS_SCALAR";
    case TypeTrait::IS_COMPOUND: return "IS_COMPOUND";
    case TypeTrait::IS_POINTER: return "IS_POINTER";
    case TypeTrait::IS_MEMBER_OBJECT_POINTER: return "IS_MEMBER_OBJECT_POINTER";
    case TypeTrait::IS_MEMBER_FUNCTION_POINTER: return "IS_MEMBER_FUNCTION_POINTER";
    case TypeTrait::IS_MEMBER_POINTER: return "IS_MEMBER_POINTER";
    case TypeTrait::IS_CONST: return "IS_CONST";
    case TypeTrait::IS_VOLATILE: return "IS_VOLATILE";
    case TypeTrait::IS_SIGNED: return "IS_SIGNED";
    case TypeTrait::IS_UNSIGNED: return "IS_UNSIGNED";
    case TypeTrait::TYPE_COMPATIBLE: return "TYPE_COMPATIBLE";
    case TypeTrait::IS_NOTHROW_ASSIGNABLE: return "IS_NOTHROW_ASSIGNABLE";
    case TypeTrait::IS_ASSIGNABLE: return "IS_ASSIGNABLE";
    case TypeTrait::IS_BASE_OF: return "IS_BASE_OF";
    case TypeTrait::IS_CONVERTIBLE_TO: return "IS_CONVERTIBLE_TO";
    case TypeTrait::IS_TRIVIALLY_ASSIGNABLE: return "IS_TRIVIALLY_ASSIGNABLE";
    case TypeTrait::REFERENCE_BINDS_TO_TEMPORARY: return "REFERENCE_BINDS_TO_TEMPORARY";
    case TypeTrait::IS_SAME: return "IS_SAME";
    case TypeTrait::IS_CONVERTIBLE: return "IS_CONVERTIBLE";
    case TypeTrait::IS_CONSTRUCTIBLE: return "IS_CONSTRUCTIBLE";
    case TypeTrait::IS_NOTHROW_CONSTRUCTIBLE: return "IS_NOTHROW_CONSTRUCTIBLE";
    case TypeTrait::IS_TRIVIALLY_CONSTRUCTIBLE: return "IS_TRIVIALLY_CONSTRUCTIBLE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnaryExprOrTypeTrait e) {
  switch (e) {
    case UnaryExprOrTypeTrait::SIZE_OF: return "SIZE_OF";
    case UnaryExprOrTypeTrait::ALIGN_OF: return "ALIGN_OF";
    case UnaryExprOrTypeTrait::PREFERRED_ALIGN_OF: return "PREFERRED_ALIGN_OF";
    case UnaryExprOrTypeTrait::VEC_STEP: return "VEC_STEP";
    case UnaryExprOrTypeTrait::OPEN_MP_REQUIRED_SIMD_ALIGN: return "OPEN_MP_REQUIRED_SIMD_ALIGN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(UnaryOperatorKind e) {
  switch (e) {
    case UnaryOperatorKind::POST_INCREMENT: return "POST_INCREMENT";
    case UnaryOperatorKind::POST_DEC: return "POST_DEC";
    case UnaryOperatorKind::PRE_INCREMENT: return "PRE_INCREMENT";
    case UnaryOperatorKind::PRE_DEC: return "PRE_DEC";
    case UnaryOperatorKind::ADDRESS_OF: return "ADDRESS_OF";
    case UnaryOperatorKind::DEREF: return "DEREF";
    case UnaryOperatorKind::PLUS: return "PLUS";
    case UnaryOperatorKind::MINUS: return "MINUS";
    case UnaryOperatorKind::NOT: return "NOT";
    case UnaryOperatorKind::L_NOT: return "L_NOT";
    case UnaryOperatorKind::REAL: return "REAL";
    case UnaryOperatorKind::IMAG: return "IMAG";
    case UnaryOperatorKind::EXTENSION: return "EXTENSION";
    case UnaryOperatorKind::COAWAIT: return "COAWAIT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(APValueKind e) {
  switch (e) {
    case APValueKind::NONE: return "NONE";
    case APValueKind::INDETERMINATE: return "INDETERMINATE";
    case APValueKind::INT: return "INT";
    case APValueKind::FLOAT: return "FLOAT";
    case APValueKind::FIXED_POINT: return "FIXED_POINT";
    case APValueKind::COMPLEX_INT: return "COMPLEX_INT";
    case APValueKind::COMPLEX_FLOAT: return "COMPLEX_FLOAT";
    case APValueKind::L_VALUE: return "L_VALUE";
    case APValueKind::VECTOR: return "VECTOR";
    case APValueKind::ARRAY: return "ARRAY";
    case APValueKind::STRUCT: return "STRUCT";
    case APValueKind::UNION: return "UNION";
    case APValueKind::MEMBER_POINTER: return "MEMBER_POINTER";
    case APValueKind::ADDRESS_LABEL_DIFF: return "ADDRESS_LABEL_DIFF";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(VectorLibrary e) {
  switch (e) {
    case VectorLibrary::NO_LIBRARY: return "NO_LIBRARY";
    case VectorLibrary::ACCELERATE: return "ACCELERATE";
    case VectorLibrary::LIBMVEC: return "LIBMVEC";
    case VectorLibrary::MASSV: return "MASSV";
    case VectorLibrary::SVML: return "SVML";
    case VectorLibrary::DARWIN_LIBSYSTEM_M: return "DARWIN_LIBSYSTEM_M";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(Visibility e) {
  switch (e) {
    case Visibility::HIDDEN_VISIBILITY: return "HIDDEN_VISIBILITY";
    case Visibility::PROTECTED_VISIBILITY: return "PROTECTED_VISIBILITY";
    case Visibility::DEFAULT_VISIBILITY: return "DEFAULT_VISIBILITY";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(AttributeSyntax e) {
  switch (e) {
    case AttributeSyntax::GNU: return "GNU";
    case AttributeSyntax::CXX11: return "CXX11";
    case AttributeSyntax::C2X: return "C2X";
    case AttributeSyntax::DECLSPEC: return "DECLSPEC";
    case AttributeSyntax::MICROSOFT: return "MICROSOFT";
    case AttributeSyntax::KEYWORD: return "KEYWORD";
    case AttributeSyntax::PRAGMA: return "PRAGMA";
    case AttributeSyntax::CONTEXT_SENSITIVE_KEYWORD: return "CONTEXT_SENSITIVE_KEYWORD";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(DeclCategory e) {
  switch (e) {
    case DeclCategory::UNKNOWN: return "UNKNOWN";
    case DeclCategory::LOCAL_VARIABLE: return "LOCAL_VARIABLE";
    case DeclCategory::GLOBAL_VARIABLE: return "GLOBAL_VARIABLE";
    case DeclCategory::PARAMETER_VARIABLE: return "PARAMETER_VARIABLE";
    case DeclCategory::FUNCTION: return "FUNCTION";
    case DeclCategory::INSTANCE_METHOD: return "INSTANCE_METHOD";
    case DeclCategory::INSTANCE_MEMBER: return "INSTANCE_MEMBER";
    case DeclCategory::CLASS_METHOD: return "CLASS_METHOD";
    case DeclCategory::CLASS_MEMBER: return "CLASS_MEMBER";
    case DeclCategory::THIS: return "THIS";
    case DeclCategory::CLASS: return "CLASS";
    case DeclCategory::STRUCTURE: return "STRUCTURE";
    case DeclCategory::UNION: return "UNION";
    case DeclCategory::CONCEPT: return "CONCEPT";
    case DeclCategory::INTERFACE: return "INTERFACE";
    case DeclCategory::ENUMERATION: return "ENUMERATION";
    case DeclCategory::ENUMERATOR: return "ENUMERATOR";
    case DeclCategory::NAMESPACE: return "NAMESPACE";
    case DeclCategory::TYPE_ALIAS: return "TYPE_ALIAS";
    case DeclCategory::TEMPLATE_TYPE_PARAMETER: return "TEMPLATE_TYPE_PARAMETER";
    case DeclCategory::TEMPLATE_VALUE_PARAMETER: return "TEMPLATE_VALUE_PARAMETER";
    case DeclCategory::LABEL: return "LABEL";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(MacroKind e) {
  switch (e) {
    case MacroKind::SUBSTITUTION: return "SUBSTITUTION";
    case MacroKind::EXPANSION: return "EXPANSION";
    case MacroKind::ARGUMENT: return "ARGUMENT";
    case MacroKind::PARAMETER: return "PARAMETER";
    case MacroKind::OTHER_DIRECTIVE: return "OTHER_DIRECTIVE";
    case MacroKind::IF_DIRECTIVE: return "IF_DIRECTIVE";
    case MacroKind::IF_DEFINED_DIRECTIVE: return "IF_DEFINED_DIRECTIVE";
    case MacroKind::IF_NOT_DEFINED_DIRECTIVE: return "IF_NOT_DEFINED_DIRECTIVE";
    case MacroKind::ELSE_IF_DIRECTIVE: return "ELSE_IF_DIRECTIVE";
    case MacroKind::ELSE_IF_DEFINED_DIRECTIVE: return "ELSE_IF_DEFINED_DIRECTIVE";
    case MacroKind::ELSE_IF_NOT_DEFINED_DIRECTIVE: return "ELSE_IF_NOT_DEFINED_DIRECTIVE";
    case MacroKind::ELSE_DIRECTIVE: return "ELSE_DIRECTIVE";
    case MacroKind::END_IF_DIRECTIVE: return "END_IF_DIRECTIVE";
    case MacroKind::DEFINE_DIRECTIVE: return "DEFINE_DIRECTIVE";
    case MacroKind::UNDEFINE_DIRECTIVE: return "UNDEFINE_DIRECTIVE";
    case MacroKind::PRAGMA_DIRECTIVE: return "PRAGMA_DIRECTIVE";
    case MacroKind::INCLUDE_DIRECTIVE: return "INCLUDE_DIRECTIVE";
    case MacroKind::INCLUDE_NEXT_DIRECTIVE: return "INCLUDE_NEXT_DIRECTIVE";
    case MacroKind::INCLUDE_MACROS_DIRECTIVE: return "INCLUDE_MACROS_DIRECTIVE";
    case MacroKind::IMPORT_DIRECTIVE: return "IMPORT_DIRECTIVE";
    case MacroKind::STRINGIFY: return "STRINGIFY";
    case MacroKind::CONCATENATE: return "CONCATENATE";
    case MacroKind::VA_OPT: return "VA_OPT";
    case MacroKind::VA_OPT_ARGUMENT: return "VA_OPT_ARGUMENT";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PathKind e) {
  switch (e) {
    case PathKind::UNIX: return "UNIX";
    case PathKind::WINDOWS: return "WINDOWS";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(FileType e) {
  switch (e) {
    case FileType::NONE: return "NONE";
    case FileType::NOT_FOUND: return "NOT_FOUND";
    case FileType::REGULAR: return "REGULAR";
    case FileType::DIRECTORY: return "DIRECTORY";
    case FileType::SYMBOLIC_LINK: return "SYMBOLIC_LINK";
    case FileType::BLOCK: return "BLOCK";
    case FileType::CHARACTER: return "CHARACTER";
    case FileType::FIRST_IN_FIRST_OUT: return "FIRST_IN_FIRST_OUT";
    case FileType::SOCKET: return "SOCKET";
    case FileType::KNKNOWN: return "KNKNOWN";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(CompilerName e) {
  switch (e) {
    case CompilerName::UNKNOWN: return "UNKNOWN";
    case CompilerName::CLANG: return "CLANG";
    case CompilerName::APPLE_CLANG: return "APPLE_CLANG";
    case CompilerName::CLANG_CL: return "CLANG_CL";
    case CompilerName::CL: return "CL";
    case CompilerName::GNU: return "GNU";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(IncludePathLocation e) {
  switch (e) {
    case IncludePathLocation::ABSOLUTE: return "ABSOLUTE";
    case IncludePathLocation::SYSROOT_RELATIVE: return "SYSROOT_RELATIVE";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TargetLanguage e) {
  switch (e) {
    case TargetLanguage::C: return "C";
    case TargetLanguage::CXX: return "CXX";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(PseudoKind e) {
  switch (e) {
    case PseudoKind::TEMPLATE_ARGUMENT: return "TEMPLATE_ARGUMENT";
    case PseudoKind::TEMPLATE_PARAMETER_LIST: return "TEMPLATE_PARAMETER_LIST";
    case PseudoKind::CXX_BASE_SPECIFIER: return "CXX_BASE_SPECIFIER";
    case PseudoKind::DESIGNATOR: return "DESIGNATOR";
    default: return "<invalid>";
  }
}

const char *EnumeratorName(TokenCategory e) {
  switch (e) {
    case TokenCategory::UNKNOWN: return "UNKNOWN";
    case TokenCategory::IDENTIFIER: return "IDENTIFIER";
    case TokenCategory::MACRO_NAME: return "MACRO_NAME";
    case TokenCategory::MACRO_PARAMETER_NAME: return "MACRO_PARAMETER_NAME";
    case TokenCategory::MACRO_DIRECTIVE_NAME: return "MACRO_DIRECTIVE_NAME";
    case TokenCategory::KEYWORD: return "KEYWORD";
    case TokenCategory::OBJECTIVE_C_KEYWORD: return "OBJECTIVE_C_KEYWORD";
    case TokenCategory::BUILTIN_TYPE_NAME: return "BUILTIN_TYPE_NAME";
    case TokenCategory::PUNCTUATION: return "PUNCTUATION";
    case TokenCategory::LITERAL: return "LITERAL";
    case TokenCategory::COMMENT: return "COMMENT";
    case TokenCategory::LOCAL_VARIABLE: return "LOCAL_VARIABLE";
    case TokenCategory::GLOBAL_VARIABLE: return "GLOBAL_VARIABLE";
    case TokenCategory::PARAMETER_VARIABLE: return "PARAMETER_VARIABLE";
    case TokenCategory::FUNCTION: return "FUNCTION";
    case TokenCategory::INSTANCE_METHOD: return "INSTANCE_METHOD";
    case TokenCategory::INSTANCE_MEMBER: return "INSTANCE_MEMBER";
    case TokenCategory::CLASS_METHOD: return "CLASS_METHOD";
    case TokenCategory::CLASS_MEMBER: return "CLASS_MEMBER";
    case TokenCategory::THIS: return "THIS";
    case TokenCategory::CLASS: return "CLASS";
    case TokenCategory::STRUCT: return "STRUCT";
    case TokenCategory::UNION: return "UNION";
    case TokenCategory::CONCEPT: return "CONCEPT";
    case TokenCategory::INTERFACE: return "INTERFACE";
    case TokenCategory::ENUM: return "ENUM";
    case TokenCategory::ENUMERATOR: return "ENUMERATOR";
    case TokenCategory::NAMESPACE: return "NAMESPACE";
    case TokenCategory::TYPE_ALIAS: return "TYPE_ALIAS";
    case TokenCategory::TEMPLATE_PARAMETER_TYPE: return "TEMPLATE_PARAMETER_TYPE";
    case TokenCategory::TEMPLATE_PARAMETER_VALUE: return "TEMPLATE_PARAMETER_VALUE";
    case TokenCategory::LABEL: return "LABEL";
    case TokenCategory::WHITESPACE: return "WHITESPACE";
    default: return "<invalid>";
  }
}

#if !defined(MX_DISABLE_API) || defined(MX_ENABLE_API)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
inline const std::shared_ptr<EntityProvider> &Designator::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Designator::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

bool Designator::is_field_designator(void) const {
  return impl->reader.getVal0();
}

bool Designator::is_array_designator(void) const {
  return impl->reader.getVal1();
}

bool Designator::is_array_range_designator(void) const {
  return impl->reader.getVal2();
}

std::optional<FieldDecl> Designator::field(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal3();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FieldDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TokenRange Designator::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal4(), impl->reader.getVal5());
}

Token Designator::dot_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal6());
}

Token Designator::field_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal7());
}

Token Designator::left_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal8());
}

Token Designator::right_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Token Designator::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

std::optional<unsigned> Designator::first_expression_index(void) const {
  if (!impl->reader.getVal12()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal11());
  }
  return std::nullopt;
}

inline const std::shared_ptr<EntityProvider> &CXXBaseSpecifier::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &CXXBaseSpecifier::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

TokenRange CXXBaseSpecifier::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal0(), impl->reader.getVal1());
}

Token CXXBaseSpecifier::base_type_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal2());
}

bool CXXBaseSpecifier::is_virtual(void) const {
  return impl->reader.getVal3();
}

TagTypeKind CXXBaseSpecifier::base_kind(void) const {
  return static_cast<TagTypeKind>(impl->reader.getVal4());
}

bool CXXBaseSpecifier::is_pack_expansion(void) const {
  return impl->reader.getVal5();
}

bool CXXBaseSpecifier::constructors_are_inherited(void) const {
  return impl->reader.getVal6();
}

Token CXXBaseSpecifier::ellipsis_token(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal7();
    if (eid == kInvalidEntityId) {
      return Token();
    }
    return impl->ep->TokenFor(impl->ep, eid);
  }
  return Token();
}

AccessSpecifier CXXBaseSpecifier::semantic_access_specifier(void) const {
  return static_cast<AccessSpecifier>(impl->reader.getVal8());
}

AccessSpecifier CXXBaseSpecifier::lexical_access_specifier(void) const {
  return static_cast<AccessSpecifier>(impl->reader.getVal9());
}

Type CXXBaseSpecifier::base_type(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

inline const std::shared_ptr<EntityProvider> &TemplateParameterList::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &TemplateParameterList::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

unsigned TemplateParameterList::num_parameters(void) const {
  return impl->reader.getVal0();
}

unsigned TemplateParameterList::num_required_parameters(void) const {
  return impl->reader.getVal1();
}

unsigned TemplateParameterList::depth(void) const {
  return impl->reader.getVal2();
}

bool TemplateParameterList::has_unexpanded_parameter_pack(void) const {
  return impl->reader.getVal3();
}

bool TemplateParameterList::has_parameter_pack(void) const {
  return impl->reader.getVal4();
}

std::optional<Expr> TemplateParameterList::requires_clause(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal5();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token TemplateParameterList::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal6());
}

Token TemplateParameterList::left_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal7());
}

Token TemplateParameterList::right_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal8());
}

TokenRange TemplateParameterList::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal9(), impl->reader.getVal10());
}

std::optional<NamedDecl> TemplateParameterList::nth_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<NamedDecl> TemplateParameterList::parameters(void) const {
  auto list = impl->reader.getVal11();
  for (auto v : list) {
    EntityId id(v);
    if (auto d11 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = NamedDecl::from(Decl(std::move(d11)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

inline const std::shared_ptr<EntityProvider> &TemplateArgument::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &TemplateArgument::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

TemplateArgumentKind TemplateArgument::kind(void) const {
  return static_cast<TemplateArgumentKind>(impl->reader.getVal0());
}

bool TemplateArgument::is_null(void) const {
  return impl->reader.getVal1();
}

bool TemplateArgument::is_dependent(void) const {
  return impl->reader.getVal2();
}

bool TemplateArgument::is_instantiation_dependent(void) const {
  return impl->reader.getVal3();
}

bool TemplateArgument::contains_unexpanded_parameter_pack(void) const {
  return impl->reader.getVal4();
}

bool TemplateArgument::is_pack_expansion(void) const {
  return impl->reader.getVal5();
}

std::optional<ValueDecl> TemplateArgument::as_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal6();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ValueDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> TemplateArgument::as_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal7();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> TemplateArgument::parameter_type_for_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> TemplateArgument::null_pointer_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

inline const std::shared_ptr<EntityProvider> &Macro::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Macro::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

gap::generator<Macro> Macro::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = Macro::from(*impl)) {
      co_yield *d;
    }
  }
}

bool Macro::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : Macro::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool Macro::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : Macro::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<Macro> Macro::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = Macro::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<Macro> Macro::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    index.macro(eid.Pack());
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

gap::generator<Macro> Macro::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroImplPtr eptr : ep->MacrosFor(ep)) {
    if (std::optional<Macro> e = Macro::from(Macro(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Macro> Macro::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroImplPtr eptr : ep->MacrosFor(ep, frag_id)) {
    if (std::optional<Macro> e = Macro::from(Macro(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Macro> Macro::in(const Index &index, std::span<MacroKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      co_yield Macro(std::move(eptr));
    }
  }
}

gap::generator<Macro> Macro::in(const Fragment &frag, std::span<MacroKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      co_yield Macro(std::move(eptr));
    }
  }
}

MacroKind Macro::kind(void) const {
  return static_cast<MacroKind>(impl->reader.getVal0());
}

std::optional<Macro> Macro::parent(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal1();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->MacroFor(impl->ep, eid)) {
      return Macro(std::move(eptr));
    }
  }
  return std::nullopt;
}

gap::generator<MacroOrToken> Macro::children(void) const {
  auto index = Index(impl->ep);
  auto list = impl->reader.getVal2();
  for (auto v : list) {
    VariantEntity e = index.entity(EntityId(v));
    if (std::holds_alternative<Macro>(e)) {
      co_yield std::move(std::get<Macro>(e));
    } else if (std::holds_alternative<Token>(e)) {
      co_yield std::move(std::get<Token>(e));
    } else {
      assert(false);
    }
  }
}

gap::generator<MacroVAOptArgument> MacroVAOptArgument::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroVAOptArgument::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroVAOptArgument::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroVAOptArgument::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroVAOptArgument::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroVAOptArgument::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroVAOptArgument> MacroVAOptArgument::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroVAOptArgument::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroVAOptArgument> MacroVAOptArgument::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroVAOptArgument::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroVAOptArgumentDerivedKinds[] = {
    MacroVAOptArgument::static_kind(),
};

gap::generator<MacroVAOptArgument> MacroVAOptArgument::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroVAOptArgumentDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroVAOptArgument> e = MacroVAOptArgument::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroVAOptArgument> MacroVAOptArgument::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroVAOptArgumentDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroVAOptArgument> e = MacroVAOptArgument::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroVAOptArgument> MacroVAOptArgument::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::VA_OPT_ARGUMENT:
      return reinterpret_cast<const MacroVAOptArgument &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroSubstitution> MacroSubstitution::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroSubstitution::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroSubstitution::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroSubstitution::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroSubstitution::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroSubstitution::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroSubstitution> MacroSubstitution::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroSubstitution::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroSubstitution> MacroSubstitution::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroSubstitution::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroSubstitutionDerivedKinds[] = {
    MacroSubstitution::static_kind(),
    MacroExpansion::static_kind(),
    MacroStringify::static_kind(),
    MacroConcatenate::static_kind(),
    MacroVAOpt::static_kind(),
};

gap::generator<MacroSubstitution> MacroSubstitution::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroSubstitutionDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroSubstitution> e = MacroSubstitution::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroSubstitution> MacroSubstitution::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroSubstitutionDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroSubstitution> e = MacroSubstitution::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroSubstitution> MacroSubstitution::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::SUBSTITUTION:
    case mx::MacroKind::VA_OPT:
    case mx::MacroKind::CONCATENATE:
    case mx::MacroKind::STRINGIFY:
    case mx::MacroKind::EXPANSION:
      return reinterpret_cast<const MacroSubstitution &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroOrToken> MacroSubstitution::replacement_children(void) const {
  auto index = Index(impl->ep);
  auto list = impl->reader.getVal3();
  for (auto v : list) {
    VariantEntity e = index.entity(EntityId(v));
    if (std::holds_alternative<Macro>(e)) {
      co_yield std::move(std::get<Macro>(e));
    } else if (std::holds_alternative<Token>(e)) {
      co_yield std::move(std::get<Token>(e));
    } else {
      assert(false);
    }
  }
}

gap::generator<MacroVAOpt> MacroVAOpt::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroVAOpt::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroVAOpt::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroVAOpt::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroVAOpt::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroVAOpt::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroVAOpt> MacroVAOpt::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroVAOpt::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroVAOpt> MacroVAOpt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroVAOpt::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroVAOptDerivedKinds[] = {
    MacroVAOpt::static_kind(),
};

gap::generator<MacroVAOpt> MacroVAOpt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroVAOptDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroVAOpt> e = MacroVAOpt::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroVAOpt> MacroVAOpt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroVAOptDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroVAOpt> e = MacroVAOpt::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroVAOpt> MacroVAOpt::from(const MacroSubstitution &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<MacroVAOpt> MacroVAOpt::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::VA_OPT:
      return reinterpret_cast<const MacroVAOpt &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroConcatenate> MacroConcatenate::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroConcatenate::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroConcatenate::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroConcatenate::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroConcatenate::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroConcatenate::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroConcatenate> MacroConcatenate::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroConcatenate::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroConcatenate> MacroConcatenate::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroConcatenate::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroConcatenateDerivedKinds[] = {
    MacroConcatenate::static_kind(),
};

gap::generator<MacroConcatenate> MacroConcatenate::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroConcatenateDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroConcatenate> e = MacroConcatenate::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroConcatenate> MacroConcatenate::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroConcatenateDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroConcatenate> e = MacroConcatenate::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroConcatenate> MacroConcatenate::from(const MacroSubstitution &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<MacroConcatenate> MacroConcatenate::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::CONCATENATE:
      return reinterpret_cast<const MacroConcatenate &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroStringify> MacroStringify::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroStringify::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroStringify::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroStringify::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroStringify::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroStringify::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroStringify> MacroStringify::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroStringify::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroStringify> MacroStringify::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroStringify::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroStringifyDerivedKinds[] = {
    MacroStringify::static_kind(),
};

gap::generator<MacroStringify> MacroStringify::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroStringifyDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroStringify> e = MacroStringify::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroStringify> MacroStringify::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroStringifyDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroStringify> e = MacroStringify::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroStringify> MacroStringify::from(const MacroSubstitution &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<MacroStringify> MacroStringify::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::STRINGIFY:
      return reinterpret_cast<const MacroStringify &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroExpansion> MacroExpansion::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroExpansion::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroExpansion::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroExpansion::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroExpansion::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroExpansion::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroExpansion> MacroExpansion::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroExpansion::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroExpansion> MacroExpansion::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroExpansion::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroExpansionDerivedKinds[] = {
    MacroExpansion::static_kind(),
};

gap::generator<MacroExpansion> MacroExpansion::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroExpansionDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroExpansion> e = MacroExpansion::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroExpansion> MacroExpansion::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroExpansionDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroExpansion> e = MacroExpansion::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroExpansion> MacroExpansion::from(const MacroSubstitution &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<MacroExpansion> MacroExpansion::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::EXPANSION:
      return reinterpret_cast<const MacroExpansion &>(parent);
    default: return std::nullopt;
  }
}

std::optional<DefineMacroDirective> MacroExpansion::definition(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal4();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->MacroFor(impl->ep, eid)) {
      return DefineMacroDirective::from(Macro(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<MacroArgument> MacroExpansion::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<MacroArgument> MacroExpansion::arguments(void) const {
  auto list = impl->reader.getVal5();
  for (auto v : list) {
    EntityId id(v);
    if (auto d5 = impl->ep->MacroFor(impl->ep, v)) {
      if (auto e = MacroArgument::from(Macro(std::move(d5)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<MacroArgument> MacroArgument::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroArgument::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroArgument::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroArgument::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroArgument::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroArgument::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroArgument> MacroArgument::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroArgument::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroArgument> MacroArgument::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroArgument::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroArgumentDerivedKinds[] = {
    MacroArgument::static_kind(),
};

gap::generator<MacroArgument> MacroArgument::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroArgumentDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroArgument> e = MacroArgument::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroArgument> MacroArgument::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroArgumentDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroArgument> e = MacroArgument::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroArgument> MacroArgument::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::ARGUMENT:
      return reinterpret_cast<const MacroArgument &>(parent);
    default: return std::nullopt;
  }
}

bool MacroArgument::is_variadic(void) const {
  return impl->reader.getVal6();
}

unsigned MacroArgument::index(void) const {
  return impl->reader.getVal7();
}

gap::generator<MacroParameter> MacroParameter::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroParameter::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroParameter::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroParameter::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroParameter::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroParameter::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroParameter> MacroParameter::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroParameter::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroParameter> MacroParameter::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroParameter::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroParameterDerivedKinds[] = {
    MacroParameter::static_kind(),
};

gap::generator<MacroParameter> MacroParameter::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroParameterDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroParameter> e = MacroParameter::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroParameter> MacroParameter::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroParameterDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroParameter> e = MacroParameter::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroParameter> MacroParameter::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::PARAMETER:
      return reinterpret_cast<const MacroParameter &>(parent);
    default: return std::nullopt;
  }
}

Token MacroParameter::variadic_dots(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal4();
    if (eid == kInvalidEntityId) {
      return Token();
    }
    return impl->ep->TokenFor(impl->ep, eid);
  }
  return Token();
}

Token MacroParameter::name(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return Token();
    }
    return impl->ep->TokenFor(impl->ep, eid);
  }
  return Token();
}

unsigned MacroParameter::index(void) const {
  return impl->reader.getVal7();
}

gap::generator<MacroDirective> MacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = MacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool MacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : MacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool MacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : MacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MacroDirective> MacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = MacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<MacroDirective> MacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return MacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kMacroDirectiveDerivedKinds[] = {
    OtherMacroDirective::static_kind(),
    UndefineMacroDirective::static_kind(),
    PragmaMacroDirective::static_kind(),
    DefineMacroDirective::static_kind(),
    IncludeMacroDirective::static_kind(),
    IncludeNextMacroDirective::static_kind(),
    IncludeMacrosMacroDirective::static_kind(),
    ImportMacroDirective::static_kind(),
    IfMacroDirective::static_kind(),
    IfDefinedMacroDirective::static_kind(),
    IfNotDefinedMacroDirective::static_kind(),
    ElseIfMacroDirective::static_kind(),
    ElseIfDefinedMacroDirective::static_kind(),
    ElseIfNotDefinedMacroDirective::static_kind(),
    ElseMacroDirective::static_kind(),
    EndIfMacroDirective::static_kind(),
};

gap::generator<MacroDirective> MacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<MacroDirective> e = MacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroDirective> MacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<MacroDirective> e = MacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroDirective> MacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::DEFINE_DIRECTIVE:
    case mx::MacroKind::PRAGMA_DIRECTIVE:
    case mx::MacroKind::UNDEFINE_DIRECTIVE:
    case mx::MacroKind::OTHER_DIRECTIVE:
    case mx::MacroKind::END_IF_DIRECTIVE:
    case mx::MacroKind::ELSE_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_NOT_DEFINED_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_DEFINED_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_DIRECTIVE:
    case mx::MacroKind::IF_NOT_DEFINED_DIRECTIVE:
    case mx::MacroKind::IF_DEFINED_DIRECTIVE:
    case mx::MacroKind::IF_DIRECTIVE:
    case mx::MacroKind::IMPORT_DIRECTIVE:
    case mx::MacroKind::INCLUDE_MACROS_DIRECTIVE:
    case mx::MacroKind::INCLUDE_NEXT_DIRECTIVE:
    case mx::MacroKind::INCLUDE_DIRECTIVE:
      return reinterpret_cast<const MacroDirective &>(parent);
    default: return std::nullopt;
  }
}

Token MacroDirective::hash(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal4());
}

Token MacroDirective::directive_name(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return Token();
    }
    return impl->ep->TokenFor(impl->ep, eid);
  }
  return Token();
}

gap::generator<DefineMacroDirective> DefineMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = DefineMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool DefineMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : DefineMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool DefineMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : DefineMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DefineMacroDirective> DefineMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = DefineMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<DefineMacroDirective> DefineMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return DefineMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kDefineMacroDirectiveDerivedKinds[] = {
    DefineMacroDirective::static_kind(),
};

gap::generator<DefineMacroDirective> DefineMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kDefineMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<DefineMacroDirective> e = DefineMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DefineMacroDirective> DefineMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kDefineMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<DefineMacroDirective> e = DefineMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DefineMacroDirective> DefineMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<DefineMacroDirective> DefineMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::DEFINE_DIRECTIVE:
      return reinterpret_cast<const DefineMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

Token DefineMacroDirective::name(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return Token();
    }
    return impl->ep->TokenFor(impl->ep, eid);
  }
  return Token();
}

gap::generator<MacroOrToken> DefineMacroDirective::body(void) const {
  auto index = Index(impl->ep);
  auto list = impl->reader.getVal3();
  for (auto v : list) {
    VariantEntity e = index.entity(EntityId(v));
    if (std::holds_alternative<Macro>(e)) {
      co_yield std::move(std::get<Macro>(e));
    } else if (std::holds_alternative<Token>(e)) {
      co_yield std::move(std::get<Token>(e));
    } else {
      assert(false);
    }
  }
}

unsigned DefineMacroDirective::num_explicit_parameters(void) const {
  return impl->reader.getVal7();
}

bool DefineMacroDirective::is_variadic(void) const {
  return impl->reader.getVal6();
}

bool DefineMacroDirective::is_function_like(void) const {
  return impl->reader.getVal10();
}

gap::generator<MacroOrToken> DefineMacroDirective::parameters(void) const {
  auto index = Index(impl->ep);
  auto list = impl->reader.getVal5();
  for (auto v : list) {
    VariantEntity e = index.entity(EntityId(v));
    if (std::holds_alternative<Macro>(e)) {
      co_yield std::move(std::get<Macro>(e));
    } else if (std::holds_alternative<Token>(e)) {
      co_yield std::move(std::get<Token>(e));
    } else {
      assert(false);
    }
  }
}

gap::generator<PragmaMacroDirective> PragmaMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = PragmaMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool PragmaMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : PragmaMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool PragmaMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : PragmaMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PragmaMacroDirective> PragmaMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = PragmaMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<PragmaMacroDirective> PragmaMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return PragmaMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kPragmaMacroDirectiveDerivedKinds[] = {
    PragmaMacroDirective::static_kind(),
};

gap::generator<PragmaMacroDirective> PragmaMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kPragmaMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<PragmaMacroDirective> e = PragmaMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaMacroDirective> PragmaMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kPragmaMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<PragmaMacroDirective> e = PragmaMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaMacroDirective> PragmaMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<PragmaMacroDirective> PragmaMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::PRAGMA_DIRECTIVE:
      return reinterpret_cast<const PragmaMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UndefineMacroDirective> UndefineMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = UndefineMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool UndefineMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : UndefineMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool UndefineMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : UndefineMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UndefineMacroDirective> UndefineMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = UndefineMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<UndefineMacroDirective> UndefineMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return UndefineMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kUndefineMacroDirectiveDerivedKinds[] = {
    UndefineMacroDirective::static_kind(),
};

gap::generator<UndefineMacroDirective> UndefineMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kUndefineMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<UndefineMacroDirective> e = UndefineMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UndefineMacroDirective> UndefineMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kUndefineMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<UndefineMacroDirective> e = UndefineMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UndefineMacroDirective> UndefineMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<UndefineMacroDirective> UndefineMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::UNDEFINE_DIRECTIVE:
      return reinterpret_cast<const UndefineMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OtherMacroDirective> OtherMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = OtherMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool OtherMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : OtherMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool OtherMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : OtherMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OtherMacroDirective> OtherMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = OtherMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<OtherMacroDirective> OtherMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return OtherMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kOtherMacroDirectiveDerivedKinds[] = {
    OtherMacroDirective::static_kind(),
};

gap::generator<OtherMacroDirective> OtherMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kOtherMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<OtherMacroDirective> e = OtherMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OtherMacroDirective> OtherMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kOtherMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<OtherMacroDirective> e = OtherMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OtherMacroDirective> OtherMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<OtherMacroDirective> OtherMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::OTHER_DIRECTIVE:
      return reinterpret_cast<const OtherMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConditionalMacroDirective> ConditionalMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ConditionalMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ConditionalMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ConditionalMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ConditionalMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ConditionalMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConditionalMacroDirective> ConditionalMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ConditionalMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ConditionalMacroDirective> ConditionalMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ConditionalMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kConditionalMacroDirectiveDerivedKinds[] = {
    IfMacroDirective::static_kind(),
    IfDefinedMacroDirective::static_kind(),
    IfNotDefinedMacroDirective::static_kind(),
    ElseIfMacroDirective::static_kind(),
    ElseIfDefinedMacroDirective::static_kind(),
    ElseIfNotDefinedMacroDirective::static_kind(),
    ElseMacroDirective::static_kind(),
    EndIfMacroDirective::static_kind(),
};

gap::generator<ConditionalMacroDirective> ConditionalMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kConditionalMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ConditionalMacroDirective> e = ConditionalMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConditionalMacroDirective> ConditionalMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kConditionalMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ConditionalMacroDirective> e = ConditionalMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConditionalMacroDirective> ConditionalMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ConditionalMacroDirective> ConditionalMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::END_IF_DIRECTIVE:
    case mx::MacroKind::ELSE_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_NOT_DEFINED_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_DEFINED_DIRECTIVE:
    case mx::MacroKind::ELSE_IF_DIRECTIVE:
    case mx::MacroKind::IF_NOT_DEFINED_DIRECTIVE:
    case mx::MacroKind::IF_DEFINED_DIRECTIVE:
    case mx::MacroKind::IF_DIRECTIVE:
      return reinterpret_cast<const ConditionalMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<EndIfMacroDirective> EndIfMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = EndIfMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool EndIfMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : EndIfMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool EndIfMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : EndIfMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<EndIfMacroDirective> EndIfMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = EndIfMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<EndIfMacroDirective> EndIfMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return EndIfMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kEndIfMacroDirectiveDerivedKinds[] = {
    EndIfMacroDirective::static_kind(),
};

gap::generator<EndIfMacroDirective> EndIfMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kEndIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<EndIfMacroDirective> e = EndIfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EndIfMacroDirective> EndIfMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kEndIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<EndIfMacroDirective> e = EndIfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EndIfMacroDirective> EndIfMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<EndIfMacroDirective> EndIfMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<EndIfMacroDirective> EndIfMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::END_IF_DIRECTIVE:
      return reinterpret_cast<const EndIfMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ElseMacroDirective> ElseMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ElseMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ElseMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ElseMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ElseMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ElseMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ElseMacroDirective> ElseMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ElseMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ElseMacroDirective> ElseMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ElseMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kElseMacroDirectiveDerivedKinds[] = {
    ElseMacroDirective::static_kind(),
};

gap::generator<ElseMacroDirective> ElseMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kElseMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ElseMacroDirective> e = ElseMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ElseMacroDirective> ElseMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kElseMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ElseMacroDirective> e = ElseMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ElseMacroDirective> ElseMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseMacroDirective> ElseMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseMacroDirective> ElseMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::ELSE_DIRECTIVE:
      return reinterpret_cast<const ElseMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ElseIfNotDefinedMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ElseIfNotDefinedMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ElseIfNotDefinedMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ElseIfNotDefinedMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ElseIfNotDefinedMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ElseIfNotDefinedMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ElseIfNotDefinedMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kElseIfNotDefinedMacroDirectiveDerivedKinds[] = {
    ElseIfNotDefinedMacroDirective::static_kind(),
};

gap::generator<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kElseIfNotDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ElseIfNotDefinedMacroDirective> e = ElseIfNotDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kElseIfNotDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ElseIfNotDefinedMacroDirective> e = ElseIfNotDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfNotDefinedMacroDirective> ElseIfNotDefinedMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::ELSE_IF_NOT_DEFINED_DIRECTIVE:
      return reinterpret_cast<const ElseIfNotDefinedMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ElseIfDefinedMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ElseIfDefinedMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ElseIfDefinedMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ElseIfDefinedMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ElseIfDefinedMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ElseIfDefinedMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ElseIfDefinedMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kElseIfDefinedMacroDirectiveDerivedKinds[] = {
    ElseIfDefinedMacroDirective::static_kind(),
};

gap::generator<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kElseIfDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ElseIfDefinedMacroDirective> e = ElseIfDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kElseIfDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ElseIfDefinedMacroDirective> e = ElseIfDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfDefinedMacroDirective> ElseIfDefinedMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::ELSE_IF_DEFINED_DIRECTIVE:
      return reinterpret_cast<const ElseIfDefinedMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ElseIfMacroDirective> ElseIfMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ElseIfMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ElseIfMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ElseIfMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ElseIfMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ElseIfMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ElseIfMacroDirective> ElseIfMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ElseIfMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ElseIfMacroDirective> ElseIfMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ElseIfMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kElseIfMacroDirectiveDerivedKinds[] = {
    ElseIfMacroDirective::static_kind(),
};

gap::generator<ElseIfMacroDirective> ElseIfMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kElseIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ElseIfMacroDirective> e = ElseIfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ElseIfMacroDirective> ElseIfMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kElseIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ElseIfMacroDirective> e = ElseIfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ElseIfMacroDirective> ElseIfMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfMacroDirective> ElseIfMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ElseIfMacroDirective> ElseIfMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::ELSE_IF_DIRECTIVE:
      return reinterpret_cast<const ElseIfMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IfNotDefinedMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IfNotDefinedMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IfNotDefinedMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IfNotDefinedMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IfNotDefinedMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IfNotDefinedMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IfNotDefinedMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIfNotDefinedMacroDirectiveDerivedKinds[] = {
    IfNotDefinedMacroDirective::static_kind(),
};

gap::generator<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIfNotDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IfNotDefinedMacroDirective> e = IfNotDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIfNotDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IfNotDefinedMacroDirective> e = IfNotDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfNotDefinedMacroDirective> IfNotDefinedMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::IF_NOT_DEFINED_DIRECTIVE:
      return reinterpret_cast<const IfNotDefinedMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IfDefinedMacroDirective> IfDefinedMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IfDefinedMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IfDefinedMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IfDefinedMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IfDefinedMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IfDefinedMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IfDefinedMacroDirective> IfDefinedMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IfDefinedMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IfDefinedMacroDirective> IfDefinedMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IfDefinedMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIfDefinedMacroDirectiveDerivedKinds[] = {
    IfDefinedMacroDirective::static_kind(),
};

gap::generator<IfDefinedMacroDirective> IfDefinedMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIfDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IfDefinedMacroDirective> e = IfDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IfDefinedMacroDirective> IfDefinedMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIfDefinedMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IfDefinedMacroDirective> e = IfDefinedMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IfDefinedMacroDirective> IfDefinedMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfDefinedMacroDirective> IfDefinedMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfDefinedMacroDirective> IfDefinedMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::IF_DEFINED_DIRECTIVE:
      return reinterpret_cast<const IfDefinedMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IfMacroDirective> IfMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IfMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IfMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IfMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IfMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IfMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IfMacroDirective> IfMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IfMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IfMacroDirective> IfMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IfMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIfMacroDirectiveDerivedKinds[] = {
    IfMacroDirective::static_kind(),
};

gap::generator<IfMacroDirective> IfMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IfMacroDirective> e = IfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IfMacroDirective> IfMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIfMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IfMacroDirective> e = IfMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IfMacroDirective> IfMacroDirective::from(const ConditionalMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfMacroDirective> IfMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IfMacroDirective> IfMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::IF_DIRECTIVE:
      return reinterpret_cast<const IfMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IncludeLikeMacroDirective> IncludeLikeMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IncludeLikeMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IncludeLikeMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IncludeLikeMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IncludeLikeMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IncludeLikeMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IncludeLikeMacroDirective> IncludeLikeMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IncludeLikeMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IncludeLikeMacroDirective> IncludeLikeMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IncludeLikeMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIncludeLikeMacroDirectiveDerivedKinds[] = {
    IncludeMacroDirective::static_kind(),
    IncludeNextMacroDirective::static_kind(),
    IncludeMacrosMacroDirective::static_kind(),
    ImportMacroDirective::static_kind(),
};

gap::generator<IncludeLikeMacroDirective> IncludeLikeMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIncludeLikeMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IncludeLikeMacroDirective> e = IncludeLikeMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IncludeLikeMacroDirective> IncludeLikeMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIncludeLikeMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IncludeLikeMacroDirective> e = IncludeLikeMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IncludeLikeMacroDirective> IncludeLikeMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeLikeMacroDirective> IncludeLikeMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::IMPORT_DIRECTIVE:
    case mx::MacroKind::INCLUDE_MACROS_DIRECTIVE:
    case mx::MacroKind::INCLUDE_NEXT_DIRECTIVE:
    case mx::MacroKind::INCLUDE_DIRECTIVE:
      return reinterpret_cast<const IncludeLikeMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

std::optional<File> IncludeLikeMacroDirective::included_file(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->FileFor(impl->ep, eid)) {
      return File(std::move(eptr));
    }
  }
  return std::nullopt;
}

gap::generator<ImportMacroDirective> ImportMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = ImportMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool ImportMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : ImportMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool ImportMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : ImportMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImportMacroDirective> ImportMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = ImportMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<ImportMacroDirective> ImportMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return ImportMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kImportMacroDirectiveDerivedKinds[] = {
    ImportMacroDirective::static_kind(),
};

gap::generator<ImportMacroDirective> ImportMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kImportMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<ImportMacroDirective> e = ImportMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImportMacroDirective> ImportMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kImportMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<ImportMacroDirective> e = ImportMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImportMacroDirective> ImportMacroDirective::from(const IncludeLikeMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ImportMacroDirective> ImportMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<ImportMacroDirective> ImportMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::IMPORT_DIRECTIVE:
      return reinterpret_cast<const ImportMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IncludeMacrosMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IncludeMacrosMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IncludeMacrosMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IncludeMacrosMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IncludeMacrosMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IncludeMacrosMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IncludeMacrosMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIncludeMacrosMacroDirectiveDerivedKinds[] = {
    IncludeMacrosMacroDirective::static_kind(),
};

gap::generator<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIncludeMacrosMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IncludeMacrosMacroDirective> e = IncludeMacrosMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIncludeMacrosMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IncludeMacrosMacroDirective> e = IncludeMacrosMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::from(const IncludeLikeMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeMacrosMacroDirective> IncludeMacrosMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::INCLUDE_MACROS_DIRECTIVE:
      return reinterpret_cast<const IncludeMacrosMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IncludeNextMacroDirective> IncludeNextMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IncludeNextMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IncludeNextMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IncludeNextMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IncludeNextMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IncludeNextMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IncludeNextMacroDirective> IncludeNextMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IncludeNextMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IncludeNextMacroDirective> IncludeNextMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IncludeNextMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIncludeNextMacroDirectiveDerivedKinds[] = {
    IncludeNextMacroDirective::static_kind(),
};

gap::generator<IncludeNextMacroDirective> IncludeNextMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIncludeNextMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IncludeNextMacroDirective> e = IncludeNextMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IncludeNextMacroDirective> IncludeNextMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIncludeNextMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IncludeNextMacroDirective> e = IncludeNextMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IncludeNextMacroDirective> IncludeNextMacroDirective::from(const IncludeLikeMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeNextMacroDirective> IncludeNextMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeNextMacroDirective> IncludeNextMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::INCLUDE_NEXT_DIRECTIVE:
      return reinterpret_cast<const IncludeNextMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IncludeMacroDirective> IncludeMacroDirective::containing(const Macro &macro) {
  for (auto impl = macro.parent(); impl; impl = impl->parent()) {
    if (auto d = IncludeMacroDirective::from(*impl)) {
      co_yield *d;
    }
  }
}

bool IncludeMacroDirective::contains(const Macro &macro) {
  auto id_ = id();
  for (auto &parent : IncludeMacroDirective::containing(macro)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

bool IncludeMacroDirective::contains(const Token &token) {
  auto id_ = id();
  for (auto &parent : IncludeMacroDirective::containing(token)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IncludeMacroDirective> IncludeMacroDirective::containing(const Token &token) {
  for (auto m : Macro::containing_internal(token)) {
    if (auto d = IncludeMacroDirective::from(m)) {
      co_yield *d;
    }
  }
}

std::optional<IncludeMacroDirective> IncludeMacroDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<MacroId>(vid)) {
    return IncludeMacroDirective::from(index.macro(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const MacroKind kIncludeMacroDirectiveDerivedKinds[] = {
    IncludeMacroDirective::static_kind(),
};

gap::generator<IncludeMacroDirective> IncludeMacroDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (MacroKind k : kIncludeMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k)) {
      if (std::optional<IncludeMacroDirective> e = IncludeMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IncludeMacroDirective> IncludeMacroDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (MacroKind k : kIncludeMacroDirectiveDerivedKinds) {
    for (MacroImplPtr eptr : ep->MacrosFor(ep, k, frag_id)) {
      if (std::optional<IncludeMacroDirective> e = IncludeMacroDirective::from(Macro(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IncludeMacroDirective> IncludeMacroDirective::from(const IncludeLikeMacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeMacroDirective> IncludeMacroDirective::from(const MacroDirective &parent) {
  return from(reinterpret_cast<const Macro &>(parent));
}

std::optional<IncludeMacroDirective> IncludeMacroDirective::from(const Macro &parent) {
  switch (parent.kind()) {
    case mx::MacroKind::INCLUDE_DIRECTIVE:
      return reinterpret_cast<const IncludeMacroDirective &>(parent);
    default: return std::nullopt;
  }
}

inline const std::shared_ptr<EntityProvider> &Attr::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Attr::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

gap::generator<Attr> Attr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Attr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Attr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Attr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<Attr> Attr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    index.attribute(eid.Pack());
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

gap::generator<Attr> Attr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrImplPtr eptr : ep->AttrsFor(ep)) {
    if (std::optional<Attr> e = Attr::from(Attr(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Attr> Attr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrImplPtr eptr : ep->AttrsFor(ep, frag_id)) {
    if (std::optional<Attr> e = Attr::from(Attr(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Attr> Attr::in(const Index &index, std::span<AttrKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      co_yield Attr(std::move(eptr));
    }
  }
}

gap::generator<Attr> Attr::in(const Fragment &frag, std::span<AttrKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      co_yield Attr(std::move(eptr));
    }
  }
}

Token Attr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal0());
}

bool Attr::is_implicit(void) const {
  return impl->reader.getVal1();
}

bool Attr::is_inherited(void) const {
  return impl->reader.getVal2();
}

bool Attr::is_late_parsed(void) const {
  return impl->reader.getVal3();
}

bool Attr::is_pack_expansion(void) const {
  return impl->reader.getVal4();
}

AttrKind Attr::kind(void) const {
  return static_cast<AttrKind>(impl->reader.getVal5());
}

TokenRange Attr::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal6(), impl->reader.getVal7());
}

gap::generator<AlignValueAttr> AlignValueAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlignValueAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlignValueAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlignValueAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlignValueAttr> AlignValueAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlignValueAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlignValueAttrDerivedKinds[] = {
    AlignValueAttr::static_kind(),
};

gap::generator<AlignValueAttr> AlignValueAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlignValueAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlignValueAttr> e = AlignValueAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlignValueAttr> AlignValueAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlignValueAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlignValueAttr> e = AlignValueAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlignValueAttr> AlignValueAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALIGN_VALUE:
      return reinterpret_cast<const AlignValueAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr AlignValueAttr::alignment(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<AliasAttr> AliasAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AliasAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AliasAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AliasAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AliasAttr> AliasAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AliasAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAliasAttrDerivedKinds[] = {
    AliasAttr::static_kind(),
};

gap::generator<AliasAttr> AliasAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AliasAttr> e = AliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AliasAttr> AliasAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AliasAttr> e = AliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AliasAttr> AliasAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALIAS:
      return reinterpret_cast<const AliasAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AliasAttr::aliasee(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<AbiTagAttr> AbiTagAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AbiTagAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AbiTagAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AbiTagAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AbiTagAttr> AbiTagAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AbiTagAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAbiTagAttrDerivedKinds[] = {
    AbiTagAttr::static_kind(),
};

gap::generator<AbiTagAttr> AbiTagAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAbiTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AbiTagAttr> e = AbiTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AbiTagAttr> AbiTagAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAbiTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AbiTagAttr> e = AbiTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AbiTagAttr> AbiTagAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ABI_TAG:
      return reinterpret_cast<const AbiTagAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeAttr> TypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeAttr> TypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeAttrDerivedKinds[] = {
    TypeNonNullAttr::static_kind(),
    TypeNullUnspecifiedAttr::static_kind(),
    TypeNullableAttr::static_kind(),
    TypeNullableResultAttr::static_kind(),
    UPtrAttr::static_kind(),
    AddressSpaceAttr::static_kind(),
    AnnotateTypeAttr::static_kind(),
    ArmMveStrictPolymorphismAttr::static_kind(),
    BTFTypeTagAttr::static_kind(),
    CmseNSCallAttr::static_kind(),
    NoDerefAttr::static_kind(),
    ObjCGCAttr::static_kind(),
    ObjCInertUnsafeUnretainedAttr::static_kind(),
    ObjCKindOfAttr::static_kind(),
    OpenCLConstantAddressSpaceAttr::static_kind(),
    OpenCLGenericAddressSpaceAttr::static_kind(),
    OpenCLGlobalAddressSpaceAttr::static_kind(),
    OpenCLGlobalDeviceAddressSpaceAttr::static_kind(),
    OpenCLGlobalHostAddressSpaceAttr::static_kind(),
    OpenCLLocalAddressSpaceAttr::static_kind(),
    OpenCLPrivateAddressSpaceAttr::static_kind(),
    Ptr32Attr::static_kind(),
    Ptr64Attr::static_kind(),
    SPtrAttr::static_kind(),
};

gap::generator<TypeAttr> TypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeAttr> e = TypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeAttr> TypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeAttr> e = TypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeAttr> TypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::S_PTR:
    case mx::AttrKind::PTR64:
    case mx::AttrKind::PTR32:
    case mx::AttrKind::OPEN_CL_PRIVATE_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_LOCAL_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_GLOBAL_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_GENERIC_ADDRESS_SPACE:
    case mx::AttrKind::OPEN_CL_CONSTANT_ADDRESS_SPACE:
    case mx::AttrKind::OBJ_C_KIND_OF:
    case mx::AttrKind::OBJ_C_INERT_UNSAFE_UNRETAINED:
    case mx::AttrKind::OBJ_CGC:
    case mx::AttrKind::NO_DEREF:
    case mx::AttrKind::CMSE_NS_CALL:
    case mx::AttrKind::BTF_TYPE_TAG:
    case mx::AttrKind::ARM_MVE_STRICT_POLYMORPHISM:
    case mx::AttrKind::ANNOTATE_TYPE:
    case mx::AttrKind::ADDRESS_SPACE:
    case mx::AttrKind::U_PTR:
    case mx::AttrKind::TYPE_NULLABLE_RESULT:
    case mx::AttrKind::TYPE_NULLABLE:
    case mx::AttrKind::TYPE_NULL_UNSPECIFIED:
    case mx::AttrKind::TYPE_NON_NULL:
      return reinterpret_cast<const TypeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SPtrAttr> SPtrAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SPtrAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SPtrAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SPtrAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SPtrAttr> SPtrAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SPtrAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSPtrAttrDerivedKinds[] = {
    SPtrAttr::static_kind(),
};

gap::generator<SPtrAttr> SPtrAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSPtrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SPtrAttr> e = SPtrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SPtrAttr> SPtrAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSPtrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SPtrAttr> e = SPtrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SPtrAttr> SPtrAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SPtrAttr> SPtrAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::S_PTR:
      return reinterpret_cast<const SPtrAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Ptr64Attr> Ptr64Attr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Ptr64Attr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Ptr64Attr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Ptr64Attr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<Ptr64Attr> Ptr64Attr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return Ptr64Attr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPtr64AttrDerivedKinds[] = {
    Ptr64Attr::static_kind(),
};

gap::generator<Ptr64Attr> Ptr64Attr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPtr64AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<Ptr64Attr> e = Ptr64Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<Ptr64Attr> Ptr64Attr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPtr64AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<Ptr64Attr> e = Ptr64Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<Ptr64Attr> Ptr64Attr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<Ptr64Attr> Ptr64Attr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PTR64:
      return reinterpret_cast<const Ptr64Attr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Ptr32Attr> Ptr32Attr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Ptr32Attr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Ptr32Attr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Ptr32Attr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<Ptr32Attr> Ptr32Attr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return Ptr32Attr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPtr32AttrDerivedKinds[] = {
    Ptr32Attr::static_kind(),
};

gap::generator<Ptr32Attr> Ptr32Attr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPtr32AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<Ptr32Attr> e = Ptr32Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<Ptr32Attr> Ptr32Attr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPtr32AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<Ptr32Attr> e = Ptr32Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<Ptr32Attr> Ptr32Attr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<Ptr32Attr> Ptr32Attr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PTR32:
      return reinterpret_cast<const Ptr32Attr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLPrivateAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLPrivateAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLPrivateAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLPrivateAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLPrivateAddressSpaceAttrDerivedKinds[] = {
    OpenCLPrivateAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLPrivateAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLPrivateAddressSpaceAttr> e = OpenCLPrivateAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLPrivateAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLPrivateAddressSpaceAttr> e = OpenCLPrivateAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLPrivateAddressSpaceAttr> OpenCLPrivateAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_PRIVATE_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLPrivateAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLPrivateAddressSpaceAttrSpelling OpenCLPrivateAddressSpaceAttr::semantic_spelling(void) const {
  return static_cast<OpenCLPrivateAddressSpaceAttrSpelling>(impl->reader.getVal10());
}

gap::generator<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLLocalAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLLocalAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLLocalAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLLocalAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLLocalAddressSpaceAttrDerivedKinds[] = {
    OpenCLLocalAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLLocalAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLLocalAddressSpaceAttr> e = OpenCLLocalAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLLocalAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLLocalAddressSpaceAttr> e = OpenCLLocalAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLLocalAddressSpaceAttr> OpenCLLocalAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_LOCAL_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLLocalAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLLocalAddressSpaceAttrSpelling OpenCLLocalAddressSpaceAttr::semantic_spelling(void) const {
  return static_cast<OpenCLLocalAddressSpaceAttrSpelling>(impl->reader.getVal10());
}

gap::generator<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLGlobalHostAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLGlobalHostAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLGlobalHostAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLGlobalHostAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLGlobalHostAddressSpaceAttrDerivedKinds[] = {
    OpenCLGlobalHostAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLGlobalHostAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLGlobalHostAddressSpaceAttr> e = OpenCLGlobalHostAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLGlobalHostAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLGlobalHostAddressSpaceAttr> e = OpenCLGlobalHostAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLGlobalHostAddressSpaceAttr> OpenCLGlobalHostAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLGlobalHostAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLGlobalDeviceAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLGlobalDeviceAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLGlobalDeviceAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLGlobalDeviceAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLGlobalDeviceAddressSpaceAttrDerivedKinds[] = {
    OpenCLGlobalDeviceAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLGlobalDeviceAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLGlobalDeviceAddressSpaceAttr> e = OpenCLGlobalDeviceAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLGlobalDeviceAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLGlobalDeviceAddressSpaceAttr> e = OpenCLGlobalDeviceAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLGlobalDeviceAddressSpaceAttr> OpenCLGlobalDeviceAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLGlobalDeviceAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLGlobalAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLGlobalAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLGlobalAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLGlobalAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLGlobalAddressSpaceAttrDerivedKinds[] = {
    OpenCLGlobalAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLGlobalAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLGlobalAddressSpaceAttr> e = OpenCLGlobalAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLGlobalAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLGlobalAddressSpaceAttr> e = OpenCLGlobalAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLGlobalAddressSpaceAttr> OpenCLGlobalAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_GLOBAL_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLGlobalAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLGlobalAddressSpaceAttrSpelling OpenCLGlobalAddressSpaceAttr::semantic_spelling(void) const {
  return static_cast<OpenCLGlobalAddressSpaceAttrSpelling>(impl->reader.getVal10());
}

gap::generator<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLGenericAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLGenericAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLGenericAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLGenericAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLGenericAddressSpaceAttrDerivedKinds[] = {
    OpenCLGenericAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLGenericAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLGenericAddressSpaceAttr> e = OpenCLGenericAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLGenericAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLGenericAddressSpaceAttr> e = OpenCLGenericAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLGenericAddressSpaceAttr> OpenCLGenericAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_GENERIC_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLGenericAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLGenericAddressSpaceAttrSpelling OpenCLGenericAddressSpaceAttr::semantic_spelling(void) const {
  return static_cast<OpenCLGenericAddressSpaceAttrSpelling>(impl->reader.getVal10());
}

gap::generator<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLConstantAddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLConstantAddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLConstantAddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLConstantAddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLConstantAddressSpaceAttrDerivedKinds[] = {
    OpenCLConstantAddressSpaceAttr::static_kind(),
};

gap::generator<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLConstantAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLConstantAddressSpaceAttr> e = OpenCLConstantAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLConstantAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLConstantAddressSpaceAttr> e = OpenCLConstantAddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLConstantAddressSpaceAttr> OpenCLConstantAddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_CONSTANT_ADDRESS_SPACE:
      return reinterpret_cast<const OpenCLConstantAddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLConstantAddressSpaceAttrSpelling OpenCLConstantAddressSpaceAttr::semantic_spelling(void) const {
  return static_cast<OpenCLConstantAddressSpaceAttrSpelling>(impl->reader.getVal10());
}

gap::generator<ObjCKindOfAttr> ObjCKindOfAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCKindOfAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCKindOfAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCKindOfAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCKindOfAttr> ObjCKindOfAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCKindOfAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCKindOfAttrDerivedKinds[] = {
    ObjCKindOfAttr::static_kind(),
};

gap::generator<ObjCKindOfAttr> ObjCKindOfAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCKindOfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCKindOfAttr> e = ObjCKindOfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCKindOfAttr> ObjCKindOfAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCKindOfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCKindOfAttr> e = ObjCKindOfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCKindOfAttr> ObjCKindOfAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCKindOfAttr> ObjCKindOfAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_KIND_OF:
      return reinterpret_cast<const ObjCKindOfAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCInertUnsafeUnretainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCInertUnsafeUnretainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCInertUnsafeUnretainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCInertUnsafeUnretainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCInertUnsafeUnretainedAttrDerivedKinds[] = {
    ObjCInertUnsafeUnretainedAttr::static_kind(),
};

gap::generator<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCInertUnsafeUnretainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCInertUnsafeUnretainedAttr> e = ObjCInertUnsafeUnretainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCInertUnsafeUnretainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCInertUnsafeUnretainedAttr> e = ObjCInertUnsafeUnretainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCInertUnsafeUnretainedAttr> ObjCInertUnsafeUnretainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_INERT_UNSAFE_UNRETAINED:
      return reinterpret_cast<const ObjCInertUnsafeUnretainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCGCAttr> ObjCGCAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCGCAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCGCAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCGCAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCGCAttr> ObjCGCAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCGCAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCGCAttrDerivedKinds[] = {
    ObjCGCAttr::static_kind(),
};

gap::generator<ObjCGCAttr> ObjCGCAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCGCAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCGCAttr> e = ObjCGCAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCGCAttr> ObjCGCAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCGCAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCGCAttr> e = ObjCGCAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCGCAttr> ObjCGCAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCGCAttr> ObjCGCAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_CGC:
      return reinterpret_cast<const ObjCGCAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoDerefAttr> NoDerefAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoDerefAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoDerefAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoDerefAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoDerefAttr> NoDerefAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoDerefAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoDerefAttrDerivedKinds[] = {
    NoDerefAttr::static_kind(),
};

gap::generator<NoDerefAttr> NoDerefAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoDerefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoDerefAttr> e = NoDerefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoDerefAttr> NoDerefAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoDerefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoDerefAttr> e = NoDerefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoDerefAttr> NoDerefAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoDerefAttr> NoDerefAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_DEREF:
      return reinterpret_cast<const NoDerefAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CmseNSCallAttr> CmseNSCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CmseNSCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CmseNSCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CmseNSCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CmseNSCallAttr> CmseNSCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CmseNSCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCmseNSCallAttrDerivedKinds[] = {
    CmseNSCallAttr::static_kind(),
};

gap::generator<CmseNSCallAttr> CmseNSCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCmseNSCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CmseNSCallAttr> e = CmseNSCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CmseNSCallAttr> CmseNSCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCmseNSCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CmseNSCallAttr> e = CmseNSCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CmseNSCallAttr> CmseNSCallAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CmseNSCallAttr> CmseNSCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CMSE_NS_CALL:
      return reinterpret_cast<const CmseNSCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<BTFTypeTagAttr> BTFTypeTagAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BTFTypeTagAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BTFTypeTagAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BTFTypeTagAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BTFTypeTagAttr> BTFTypeTagAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BTFTypeTagAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBTFTypeTagAttrDerivedKinds[] = {
    BTFTypeTagAttr::static_kind(),
};

gap::generator<BTFTypeTagAttr> BTFTypeTagAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBTFTypeTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BTFTypeTagAttr> e = BTFTypeTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BTFTypeTagAttr> BTFTypeTagAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBTFTypeTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BTFTypeTagAttr> e = BTFTypeTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BTFTypeTagAttr> BTFTypeTagAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<BTFTypeTagAttr> BTFTypeTagAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BTF_TYPE_TAG:
      return reinterpret_cast<const BTFTypeTagAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view BTFTypeTagAttr::btf_type_tag(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArmMveStrictPolymorphismAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArmMveStrictPolymorphismAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArmMveStrictPolymorphismAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ArmMveStrictPolymorphismAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kArmMveStrictPolymorphismAttrDerivedKinds[] = {
    ArmMveStrictPolymorphismAttr::static_kind(),
};

gap::generator<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kArmMveStrictPolymorphismAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ArmMveStrictPolymorphismAttr> e = ArmMveStrictPolymorphismAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kArmMveStrictPolymorphismAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ArmMveStrictPolymorphismAttr> e = ArmMveStrictPolymorphismAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ArmMveStrictPolymorphismAttr> ArmMveStrictPolymorphismAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARM_MVE_STRICT_POLYMORPHISM:
      return reinterpret_cast<const ArmMveStrictPolymorphismAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnnotateTypeAttr> AnnotateTypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnnotateTypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnnotateTypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnnotateTypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnnotateTypeAttr> AnnotateTypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnnotateTypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnnotateTypeAttrDerivedKinds[] = {
    AnnotateTypeAttr::static_kind(),
};

gap::generator<AnnotateTypeAttr> AnnotateTypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnnotateTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnnotateTypeAttr> e = AnnotateTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnnotateTypeAttr> AnnotateTypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnnotateTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnnotateTypeAttr> e = AnnotateTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnnotateTypeAttr> AnnotateTypeAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnnotateTypeAttr> AnnotateTypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANNOTATE_TYPE:
      return reinterpret_cast<const AnnotateTypeAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AnnotateTypeAttr::annotation(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<AddressSpaceAttr> AddressSpaceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AddressSpaceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AddressSpaceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AddressSpaceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AddressSpaceAttr> AddressSpaceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AddressSpaceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAddressSpaceAttrDerivedKinds[] = {
    AddressSpaceAttr::static_kind(),
};

gap::generator<AddressSpaceAttr> AddressSpaceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AddressSpaceAttr> e = AddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AddressSpaceAttr> AddressSpaceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAddressSpaceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AddressSpaceAttr> e = AddressSpaceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AddressSpaceAttr> AddressSpaceAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AddressSpaceAttr> AddressSpaceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ADDRESS_SPACE:
      return reinterpret_cast<const AddressSpaceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UPtrAttr> UPtrAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UPtrAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UPtrAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UPtrAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UPtrAttr> UPtrAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UPtrAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUPtrAttrDerivedKinds[] = {
    UPtrAttr::static_kind(),
};

gap::generator<UPtrAttr> UPtrAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUPtrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UPtrAttr> e = UPtrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UPtrAttr> UPtrAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUPtrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UPtrAttr> e = UPtrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UPtrAttr> UPtrAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UPtrAttr> UPtrAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::U_PTR:
      return reinterpret_cast<const UPtrAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeNullableResultAttr> TypeNullableResultAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeNullableResultAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeNullableResultAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeNullableResultAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeNullableResultAttr> TypeNullableResultAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeNullableResultAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeNullableResultAttrDerivedKinds[] = {
    TypeNullableResultAttr::static_kind(),
};

gap::generator<TypeNullableResultAttr> TypeNullableResultAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeNullableResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeNullableResultAttr> e = TypeNullableResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeNullableResultAttr> TypeNullableResultAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeNullableResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeNullableResultAttr> e = TypeNullableResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeNullableResultAttr> TypeNullableResultAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeNullableResultAttr> TypeNullableResultAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_NULLABLE_RESULT:
      return reinterpret_cast<const TypeNullableResultAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeNullableAttr> TypeNullableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeNullableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeNullableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeNullableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeNullableAttr> TypeNullableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeNullableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeNullableAttrDerivedKinds[] = {
    TypeNullableAttr::static_kind(),
};

gap::generator<TypeNullableAttr> TypeNullableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeNullableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeNullableAttr> e = TypeNullableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeNullableAttr> TypeNullableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeNullableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeNullableAttr> e = TypeNullableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeNullableAttr> TypeNullableAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeNullableAttr> TypeNullableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_NULLABLE:
      return reinterpret_cast<const TypeNullableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeNullUnspecifiedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeNullUnspecifiedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeNullUnspecifiedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeNullUnspecifiedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeNullUnspecifiedAttrDerivedKinds[] = {
    TypeNullUnspecifiedAttr::static_kind(),
};

gap::generator<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeNullUnspecifiedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeNullUnspecifiedAttr> e = TypeNullUnspecifiedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeNullUnspecifiedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeNullUnspecifiedAttr> e = TypeNullUnspecifiedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeNullUnspecifiedAttr> TypeNullUnspecifiedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_NULL_UNSPECIFIED:
      return reinterpret_cast<const TypeNullUnspecifiedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeNonNullAttr> TypeNonNullAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeNonNullAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeNonNullAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeNonNullAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeNonNullAttr> TypeNonNullAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeNonNullAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeNonNullAttrDerivedKinds[] = {
    TypeNonNullAttr::static_kind(),
};

gap::generator<TypeNonNullAttr> TypeNonNullAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeNonNullAttr> e = TypeNonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeNonNullAttr> TypeNonNullAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeNonNullAttr> e = TypeNonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeNonNullAttr> TypeNonNullAttr::from(const TypeAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeNonNullAttr> TypeNonNullAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_NON_NULL:
      return reinterpret_cast<const TypeNonNullAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ThreadAttr> ThreadAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ThreadAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ThreadAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ThreadAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ThreadAttr> ThreadAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ThreadAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kThreadAttrDerivedKinds[] = {
    ThreadAttr::static_kind(),
};

gap::generator<ThreadAttr> ThreadAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kThreadAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ThreadAttr> e = ThreadAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ThreadAttr> ThreadAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kThreadAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ThreadAttr> e = ThreadAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ThreadAttr> ThreadAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::THREAD:
      return reinterpret_cast<const ThreadAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftObjCMembersAttr> SwiftObjCMembersAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftObjCMembersAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftObjCMembersAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftObjCMembersAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftObjCMembersAttr> SwiftObjCMembersAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftObjCMembersAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftObjCMembersAttrDerivedKinds[] = {
    SwiftObjCMembersAttr::static_kind(),
};

gap::generator<SwiftObjCMembersAttr> SwiftObjCMembersAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftObjCMembersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftObjCMembersAttr> e = SwiftObjCMembersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftObjCMembersAttr> SwiftObjCMembersAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftObjCMembersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftObjCMembersAttr> e = SwiftObjCMembersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftObjCMembersAttr> SwiftObjCMembersAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_OBJ_C_MEMBERS:
      return reinterpret_cast<const SwiftObjCMembersAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<StmtAttr> StmtAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StmtAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StmtAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StmtAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<StmtAttr> StmtAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return StmtAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kStmtAttrDerivedKinds[] = {
    SuppressAttr::static_kind(),
    UnlikelyAttr::static_kind(),
    FallThroughAttr::static_kind(),
    LikelyAttr::static_kind(),
    MustTailAttr::static_kind(),
    OpenCLUnrollHintAttr::static_kind(),
};

gap::generator<StmtAttr> StmtAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kStmtAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<StmtAttr> e = StmtAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StmtAttr> StmtAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kStmtAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<StmtAttr> e = StmtAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StmtAttr> StmtAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_UNROLL_HINT:
    case mx::AttrKind::MUST_TAIL:
    case mx::AttrKind::LIKELY:
    case mx::AttrKind::FALL_THROUGH:
    case mx::AttrKind::UNLIKELY:
    case mx::AttrKind::SUPPRESS:
      return reinterpret_cast<const StmtAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLUnrollHintAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLUnrollHintAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLUnrollHintAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLUnrollHintAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLUnrollHintAttrDerivedKinds[] = {
    OpenCLUnrollHintAttr::static_kind(),
};

gap::generator<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLUnrollHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLUnrollHintAttr> e = OpenCLUnrollHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLUnrollHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLUnrollHintAttr> e = OpenCLUnrollHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLUnrollHintAttr> OpenCLUnrollHintAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_UNROLL_HINT:
      return reinterpret_cast<const OpenCLUnrollHintAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MustTailAttr> MustTailAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MustTailAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MustTailAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MustTailAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MustTailAttr> MustTailAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MustTailAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMustTailAttrDerivedKinds[] = {
    MustTailAttr::static_kind(),
};

gap::generator<MustTailAttr> MustTailAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMustTailAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MustTailAttr> e = MustTailAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MustTailAttr> MustTailAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMustTailAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MustTailAttr> e = MustTailAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MustTailAttr> MustTailAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MustTailAttr> MustTailAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MUST_TAIL:
      return reinterpret_cast<const MustTailAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LikelyAttr> LikelyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LikelyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LikelyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LikelyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LikelyAttr> LikelyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LikelyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLikelyAttrDerivedKinds[] = {
    LikelyAttr::static_kind(),
};

gap::generator<LikelyAttr> LikelyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLikelyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LikelyAttr> e = LikelyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LikelyAttr> LikelyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLikelyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LikelyAttr> e = LikelyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LikelyAttr> LikelyAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LikelyAttr> LikelyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LIKELY:
      return reinterpret_cast<const LikelyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FallThroughAttr> FallThroughAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FallThroughAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FallThroughAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FallThroughAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FallThroughAttr> FallThroughAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FallThroughAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFallThroughAttrDerivedKinds[] = {
    FallThroughAttr::static_kind(),
};

gap::generator<FallThroughAttr> FallThroughAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFallThroughAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FallThroughAttr> e = FallThroughAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FallThroughAttr> FallThroughAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFallThroughAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FallThroughAttr> e = FallThroughAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FallThroughAttr> FallThroughAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FallThroughAttr> FallThroughAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FALL_THROUGH:
      return reinterpret_cast<const FallThroughAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UnlikelyAttr> UnlikelyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnlikelyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnlikelyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnlikelyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UnlikelyAttr> UnlikelyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UnlikelyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUnlikelyAttrDerivedKinds[] = {
    UnlikelyAttr::static_kind(),
};

gap::generator<UnlikelyAttr> UnlikelyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUnlikelyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UnlikelyAttr> e = UnlikelyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnlikelyAttr> UnlikelyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUnlikelyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UnlikelyAttr> e = UnlikelyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnlikelyAttr> UnlikelyAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UnlikelyAttr> UnlikelyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::UNLIKELY:
      return reinterpret_cast<const UnlikelyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SuppressAttr> SuppressAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SuppressAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SuppressAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SuppressAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SuppressAttr> SuppressAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SuppressAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSuppressAttrDerivedKinds[] = {
    SuppressAttr::static_kind(),
};

gap::generator<SuppressAttr> SuppressAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSuppressAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SuppressAttr> e = SuppressAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SuppressAttr> SuppressAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSuppressAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SuppressAttr> e = SuppressAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SuppressAttr> SuppressAttr::from(const StmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SuppressAttr> SuppressAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SUPPRESS:
      return reinterpret_cast<const SuppressAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<RenderScriptKernelAttr> RenderScriptKernelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RenderScriptKernelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RenderScriptKernelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RenderScriptKernelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RenderScriptKernelAttr> RenderScriptKernelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RenderScriptKernelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRenderScriptKernelAttrDerivedKinds[] = {
    RenderScriptKernelAttr::static_kind(),
};

gap::generator<RenderScriptKernelAttr> RenderScriptKernelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRenderScriptKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RenderScriptKernelAttr> e = RenderScriptKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RenderScriptKernelAttr> RenderScriptKernelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRenderScriptKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RenderScriptKernelAttr> e = RenderScriptKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RenderScriptKernelAttr> RenderScriptKernelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RENDER_SCRIPT_KERNEL:
      return reinterpret_cast<const RenderScriptKernelAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OverloadableAttr> OverloadableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OverloadableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OverloadableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OverloadableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OverloadableAttr> OverloadableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OverloadableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOverloadableAttrDerivedKinds[] = {
    OverloadableAttr::static_kind(),
};

gap::generator<OverloadableAttr> OverloadableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOverloadableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OverloadableAttr> e = OverloadableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OverloadableAttr> OverloadableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOverloadableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OverloadableAttr> e = OverloadableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OverloadableAttr> OverloadableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OVERLOADABLE:
      return reinterpret_cast<const OverloadableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLAccessAttr> OpenCLAccessAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLAccessAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLAccessAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLAccessAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLAccessAttr> OpenCLAccessAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLAccessAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLAccessAttrDerivedKinds[] = {
    OpenCLAccessAttr::static_kind(),
};

gap::generator<OpenCLAccessAttr> OpenCLAccessAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLAccessAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLAccessAttr> e = OpenCLAccessAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLAccessAttr> OpenCLAccessAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLAccessAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLAccessAttr> e = OpenCLAccessAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLAccessAttr> OpenCLAccessAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_ACCESS:
      return reinterpret_cast<const OpenCLAccessAttr &>(parent);
    default: return std::nullopt;
  }
}

OpenCLAccessAttrSpelling OpenCLAccessAttr::semantic_spelling(void) const {
  return static_cast<OpenCLAccessAttrSpelling>(impl->reader.getVal10());
}

bool OpenCLAccessAttr::is_read_only(void) const {
  return impl->reader.getVal11();
}

bool OpenCLAccessAttr::is_read_write(void) const {
  return impl->reader.getVal12();
}

bool OpenCLAccessAttr::is_write_only(void) const {
  return impl->reader.getVal13();
}

gap::generator<ObjCRuntimeVisibleAttr> ObjCRuntimeVisibleAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCRuntimeVisibleAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCRuntimeVisibleAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCRuntimeVisibleAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCRuntimeVisibleAttr> ObjCRuntimeVisibleAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCRuntimeVisibleAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCRuntimeVisibleAttrDerivedKinds[] = {
    ObjCRuntimeVisibleAttr::static_kind(),
};

gap::generator<ObjCRuntimeVisibleAttr> ObjCRuntimeVisibleAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCRuntimeVisibleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCRuntimeVisibleAttr> e = ObjCRuntimeVisibleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCRuntimeVisibleAttr> ObjCRuntimeVisibleAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCRuntimeVisibleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCRuntimeVisibleAttr> e = ObjCRuntimeVisibleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCRuntimeVisibleAttr> ObjCRuntimeVisibleAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_RUNTIME_VISIBLE:
      return reinterpret_cast<const ObjCRuntimeVisibleAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCRuntimeNameAttr> ObjCRuntimeNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCRuntimeNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCRuntimeNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCRuntimeNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCRuntimeNameAttr> ObjCRuntimeNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCRuntimeNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCRuntimeNameAttrDerivedKinds[] = {
    ObjCRuntimeNameAttr::static_kind(),
};

gap::generator<ObjCRuntimeNameAttr> ObjCRuntimeNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCRuntimeNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCRuntimeNameAttr> e = ObjCRuntimeNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCRuntimeNameAttr> ObjCRuntimeNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCRuntimeNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCRuntimeNameAttr> e = ObjCRuntimeNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCRuntimeNameAttr> ObjCRuntimeNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_RUNTIME_NAME:
      return reinterpret_cast<const ObjCRuntimeNameAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view ObjCRuntimeNameAttr::metadata_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<ObjCNonRuntimeProtocolAttr> ObjCNonRuntimeProtocolAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCNonRuntimeProtocolAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCNonRuntimeProtocolAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCNonRuntimeProtocolAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCNonRuntimeProtocolAttr> ObjCNonRuntimeProtocolAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCNonRuntimeProtocolAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCNonRuntimeProtocolAttrDerivedKinds[] = {
    ObjCNonRuntimeProtocolAttr::static_kind(),
};

gap::generator<ObjCNonRuntimeProtocolAttr> ObjCNonRuntimeProtocolAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCNonRuntimeProtocolAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCNonRuntimeProtocolAttr> e = ObjCNonRuntimeProtocolAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCNonRuntimeProtocolAttr> ObjCNonRuntimeProtocolAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCNonRuntimeProtocolAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCNonRuntimeProtocolAttr> e = ObjCNonRuntimeProtocolAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCNonRuntimeProtocolAttr> ObjCNonRuntimeProtocolAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_NON_RUNTIME_PROTOCOL:
      return reinterpret_cast<const ObjCNonRuntimeProtocolAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCNonLazyClassAttr> ObjCNonLazyClassAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCNonLazyClassAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCNonLazyClassAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCNonLazyClassAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCNonLazyClassAttr> ObjCNonLazyClassAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCNonLazyClassAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCNonLazyClassAttrDerivedKinds[] = {
    ObjCNonLazyClassAttr::static_kind(),
};

gap::generator<ObjCNonLazyClassAttr> ObjCNonLazyClassAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCNonLazyClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCNonLazyClassAttr> e = ObjCNonLazyClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCNonLazyClassAttr> ObjCNonLazyClassAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCNonLazyClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCNonLazyClassAttr> e = ObjCNonLazyClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCNonLazyClassAttr> ObjCNonLazyClassAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_NON_LAZY_CLASS:
      return reinterpret_cast<const ObjCNonLazyClassAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCDirectMembersAttr> ObjCDirectMembersAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCDirectMembersAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCDirectMembersAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCDirectMembersAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCDirectMembersAttr> ObjCDirectMembersAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCDirectMembersAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCDirectMembersAttrDerivedKinds[] = {
    ObjCDirectMembersAttr::static_kind(),
};

gap::generator<ObjCDirectMembersAttr> ObjCDirectMembersAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCDirectMembersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCDirectMembersAttr> e = ObjCDirectMembersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCDirectMembersAttr> ObjCDirectMembersAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCDirectMembersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCDirectMembersAttr> e = ObjCDirectMembersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCDirectMembersAttr> ObjCDirectMembersAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_DIRECT_MEMBERS:
      return reinterpret_cast<const ObjCDirectMembersAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCDirectAttr> ObjCDirectAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCDirectAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCDirectAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCDirectAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCDirectAttr> ObjCDirectAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCDirectAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCDirectAttrDerivedKinds[] = {
    ObjCDirectAttr::static_kind(),
};

gap::generator<ObjCDirectAttr> ObjCDirectAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCDirectAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCDirectAttr> e = ObjCDirectAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCDirectAttr> ObjCDirectAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCDirectAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCDirectAttr> e = ObjCDirectAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCDirectAttr> ObjCDirectAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_DIRECT:
      return reinterpret_cast<const ObjCDirectAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCDesignatedInitializerAttr> ObjCDesignatedInitializerAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCDesignatedInitializerAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCDesignatedInitializerAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCDesignatedInitializerAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCDesignatedInitializerAttr> ObjCDesignatedInitializerAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCDesignatedInitializerAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCDesignatedInitializerAttrDerivedKinds[] = {
    ObjCDesignatedInitializerAttr::static_kind(),
};

gap::generator<ObjCDesignatedInitializerAttr> ObjCDesignatedInitializerAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCDesignatedInitializerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCDesignatedInitializerAttr> e = ObjCDesignatedInitializerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCDesignatedInitializerAttr> ObjCDesignatedInitializerAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCDesignatedInitializerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCDesignatedInitializerAttr> e = ObjCDesignatedInitializerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCDesignatedInitializerAttr> ObjCDesignatedInitializerAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_DESIGNATED_INITIALIZER:
      return reinterpret_cast<const ObjCDesignatedInitializerAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCClassStubAttr> ObjCClassStubAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCClassStubAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCClassStubAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCClassStubAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCClassStubAttr> ObjCClassStubAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCClassStubAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCClassStubAttrDerivedKinds[] = {
    ObjCClassStubAttr::static_kind(),
};

gap::generator<ObjCClassStubAttr> ObjCClassStubAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCClassStubAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCClassStubAttr> e = ObjCClassStubAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCClassStubAttr> ObjCClassStubAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCClassStubAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCClassStubAttr> e = ObjCClassStubAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCClassStubAttr> ObjCClassStubAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_CLASS_STUB:
      return reinterpret_cast<const ObjCClassStubAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCBoxableAttr> ObjCBoxableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBoxableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBoxableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBoxableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCBoxableAttr> ObjCBoxableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCBoxableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCBoxableAttrDerivedKinds[] = {
    ObjCBoxableAttr::static_kind(),
};

gap::generator<ObjCBoxableAttr> ObjCBoxableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCBoxableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCBoxableAttr> e = ObjCBoxableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBoxableAttr> ObjCBoxableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCBoxableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBoxableAttr> e = ObjCBoxableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBoxableAttr> ObjCBoxableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_BOXABLE:
      return reinterpret_cast<const ObjCBoxableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPReferencedVarAttr> OMPReferencedVarAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPReferencedVarAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPReferencedVarAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPReferencedVarAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPReferencedVarAttr> OMPReferencedVarAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPReferencedVarAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPReferencedVarAttrDerivedKinds[] = {
    OMPReferencedVarAttr::static_kind(),
};

gap::generator<OMPReferencedVarAttr> OMPReferencedVarAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPReferencedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPReferencedVarAttr> e = OMPReferencedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPReferencedVarAttr> OMPReferencedVarAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPReferencedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPReferencedVarAttr> e = OMPReferencedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPReferencedVarAttr> OMPReferencedVarAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_REFERENCED_VAR:
      return reinterpret_cast<const OMPReferencedVarAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPReferencedVarAttr::reference(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPDeclareSimdDeclAttr> OMPDeclareSimdDeclAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclareSimdDeclAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclareSimdDeclAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclareSimdDeclAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPDeclareSimdDeclAttr> OMPDeclareSimdDeclAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPDeclareSimdDeclAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPDeclareSimdDeclAttrDerivedKinds[] = {
    OMPDeclareSimdDeclAttr::static_kind(),
};

gap::generator<OMPDeclareSimdDeclAttr> OMPDeclareSimdDeclAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPDeclareSimdDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPDeclareSimdDeclAttr> e = OMPDeclareSimdDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclareSimdDeclAttr> OMPDeclareSimdDeclAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPDeclareSimdDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclareSimdDeclAttr> e = OMPDeclareSimdDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclareSimdDeclAttr> OMPDeclareSimdDeclAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_DECLARE_SIMD_DECL:
      return reinterpret_cast<const OMPDeclareSimdDeclAttr &>(parent);
    default: return std::nullopt;
  }
}

OMPDeclareSimdDeclAttrBranchStateTy OMPDeclareSimdDeclAttr::branch_state(void) const {
  return static_cast<OMPDeclareSimdDeclAttrBranchStateTy>(impl->reader.getVal10());
}

Expr OMPDeclareSimdDeclAttr::simdlen(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPCaptureKindAttr> OMPCaptureKindAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCaptureKindAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCaptureKindAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCaptureKindAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPCaptureKindAttr> OMPCaptureKindAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPCaptureKindAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPCaptureKindAttrDerivedKinds[] = {
    OMPCaptureKindAttr::static_kind(),
};

gap::generator<OMPCaptureKindAttr> OMPCaptureKindAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPCaptureKindAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPCaptureKindAttr> e = OMPCaptureKindAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCaptureKindAttr> OMPCaptureKindAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPCaptureKindAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPCaptureKindAttr> e = OMPCaptureKindAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCaptureKindAttr> OMPCaptureKindAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_CAPTURE_KIND:
      return reinterpret_cast<const OMPCaptureKindAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoEscapeAttr> NoEscapeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoEscapeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoEscapeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoEscapeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoEscapeAttr> NoEscapeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoEscapeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoEscapeAttrDerivedKinds[] = {
    NoEscapeAttr::static_kind(),
};

gap::generator<NoEscapeAttr> NoEscapeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoEscapeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoEscapeAttr> e = NoEscapeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoEscapeAttr> NoEscapeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoEscapeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoEscapeAttr> e = NoEscapeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoEscapeAttr> NoEscapeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_ESCAPE:
      return reinterpret_cast<const NoEscapeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoBuiltinAttr> NoBuiltinAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoBuiltinAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoBuiltinAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoBuiltinAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoBuiltinAttr> NoBuiltinAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoBuiltinAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoBuiltinAttrDerivedKinds[] = {
    NoBuiltinAttr::static_kind(),
};

gap::generator<NoBuiltinAttr> NoBuiltinAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoBuiltinAttr> e = NoBuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoBuiltinAttr> NoBuiltinAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoBuiltinAttr> e = NoBuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoBuiltinAttr> NoBuiltinAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_BUILTIN:
      return reinterpret_cast<const NoBuiltinAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ModeAttr> ModeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ModeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ModeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ModeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ModeAttr> ModeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ModeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kModeAttrDerivedKinds[] = {
    ModeAttr::static_kind(),
};

gap::generator<ModeAttr> ModeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kModeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ModeAttr> e = ModeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ModeAttr> ModeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kModeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ModeAttr> e = ModeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ModeAttr> ModeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MODE:
      return reinterpret_cast<const ModeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LoopHintAttr> LoopHintAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LoopHintAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LoopHintAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LoopHintAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LoopHintAttr> LoopHintAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LoopHintAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLoopHintAttrDerivedKinds[] = {
    LoopHintAttr::static_kind(),
};

gap::generator<LoopHintAttr> LoopHintAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLoopHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LoopHintAttr> e = LoopHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LoopHintAttr> LoopHintAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLoopHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LoopHintAttr> e = LoopHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LoopHintAttr> LoopHintAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LOOP_HINT:
      return reinterpret_cast<const LoopHintAttr &>(parent);
    default: return std::nullopt;
  }
}

LoopHintAttrOptionType LoopHintAttr::option(void) const {
  return static_cast<LoopHintAttrOptionType>(impl->reader.getVal10());
}

LoopHintAttrSpelling LoopHintAttr::semantic_spelling(void) const {
  return static_cast<LoopHintAttrSpelling>(impl->reader.getVal14());
}

LoopHintAttrLoopHintState LoopHintAttr::state(void) const {
  return static_cast<LoopHintAttrLoopHintState>(impl->reader.getVal15());
}

Expr LoopHintAttr::value(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<LoaderUninitializedAttr> LoaderUninitializedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LoaderUninitializedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LoaderUninitializedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LoaderUninitializedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LoaderUninitializedAttr> LoaderUninitializedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LoaderUninitializedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLoaderUninitializedAttrDerivedKinds[] = {
    LoaderUninitializedAttr::static_kind(),
};

gap::generator<LoaderUninitializedAttr> LoaderUninitializedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLoaderUninitializedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LoaderUninitializedAttr> e = LoaderUninitializedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LoaderUninitializedAttr> LoaderUninitializedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLoaderUninitializedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LoaderUninitializedAttr> e = LoaderUninitializedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LoaderUninitializedAttr> LoaderUninitializedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LOADER_UNINITIALIZED:
      return reinterpret_cast<const LoaderUninitializedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<InitSegAttr> InitSegAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InitSegAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InitSegAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InitSegAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InitSegAttr> InitSegAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return InitSegAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kInitSegAttrDerivedKinds[] = {
    InitSegAttr::static_kind(),
};

gap::generator<InitSegAttr> InitSegAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kInitSegAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<InitSegAttr> e = InitSegAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InitSegAttr> InitSegAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kInitSegAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<InitSegAttr> e = InitSegAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InitSegAttr> InitSegAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::INIT_SEG:
      return reinterpret_cast<const InitSegAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view InitSegAttr::section(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<InheritableAttr> InheritableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InheritableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InheritableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InheritableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InheritableAttr> InheritableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return InheritableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kInheritableAttrDerivedKinds[] = {
    InitPriorityAttr::static_kind(),
    IntelOclBiccAttr::static_kind(),
    InternalLinkageAttr::static_kind(),
    LTOVisibilityPublicAttr::static_kind(),
    LayoutVersionAttr::static_kind(),
    LeafAttr::static_kind(),
    LifetimeBoundAttr::static_kind(),
    LockReturnedAttr::static_kind(),
    LocksExcludedAttr::static_kind(),
    M68kInterruptAttr::static_kind(),
    MIGServerRoutineAttr::static_kind(),
    MSABIAttr::static_kind(),
    MSAllocatorAttr::static_kind(),
    MSInheritanceAttr::static_kind(),
    MSNoVTableAttr::static_kind(),
    MSP430InterruptAttr::static_kind(),
    MSStructAttr::static_kind(),
    MSVtorDispAttr::static_kind(),
    MaxFieldAlignmentAttr::static_kind(),
    MayAliasAttr::static_kind(),
    MicroMipsAttr::static_kind(),
    MinSizeAttr::static_kind(),
    MinVectorWidthAttr::static_kind(),
    Mips16Attr::static_kind(),
    MipsInterruptAttr::static_kind(),
    MipsLongCallAttr::static_kind(),
    MipsShortCallAttr::static_kind(),
    NSConsumesSelfAttr::static_kind(),
    NSErrorDomainAttr::static_kind(),
    NSReturnsAutoreleasedAttr::static_kind(),
    NSReturnsNotRetainedAttr::static_kind(),
    NSReturnsRetainedAttr::static_kind(),
    NakedAttr::static_kind(),
    NoAliasAttr::static_kind(),
    NoCommonAttr::static_kind(),
    NoDebugAttr::static_kind(),
    NoDestroyAttr::static_kind(),
    NoDuplicateAttr::static_kind(),
    NoInstrumentFunctionAttr::static_kind(),
    NoMicroMipsAttr::static_kind(),
    NoMips16Attr::static_kind(),
    NoProfileFunctionAttr::static_kind(),
    NoRandomizeLayoutAttr::static_kind(),
    NoReturnAttr::static_kind(),
    NoSanitizeAttr::static_kind(),
    NoSpeculativeLoadHardeningAttr::static_kind(),
    NoSplitStackAttr::static_kind(),
    NoStackProtectorAttr::static_kind(),
    NoThreadSafetyAnalysisAttr::static_kind(),
    NoThrowAttr::static_kind(),
    NoUniqueAddressAttr::static_kind(),
    NotTailCalledAttr::static_kind(),
    OMPAllocateDeclAttr::static_kind(),
    OMPCaptureNoInitAttr::static_kind(),
    OMPDeclareTargetDeclAttr::static_kind(),
    OMPDeclareVariantAttr::static_kind(),
    OMPThreadPrivateDeclAttr::static_kind(),
    OSConsumesThisAttr::static_kind(),
    OSReturnsNotRetainedAttr::static_kind(),
    OSReturnsRetainedAttr::static_kind(),
    OSReturnsRetainedOnNonZeroAttr::static_kind(),
    OSReturnsRetainedOnZeroAttr::static_kind(),
    ObjCBridgeAttr::static_kind(),
    ObjCBridgeMutableAttr::static_kind(),
    ObjCBridgeRelatedAttr::static_kind(),
    ObjCExceptionAttr::static_kind(),
    ObjCExplicitProtocolImplAttr::static_kind(),
    ObjCExternallyRetainedAttr::static_kind(),
    ObjCIndependentClassAttr::static_kind(),
    ObjCMethodFamilyAttr::static_kind(),
    ObjCNSObjectAttr::static_kind(),
    ObjCOwnershipAttr::static_kind(),
    ObjCPreciseLifetimeAttr::static_kind(),
    ObjCRequiresPropertyDefsAttr::static_kind(),
    ObjCRequiresSuperAttr::static_kind(),
    ObjCReturnsInnerPointerAttr::static_kind(),
    ObjCRootClassAttr::static_kind(),
    ObjCSubclassingRestrictedAttr::static_kind(),
    OpenCLIntelReqdSubGroupSizeAttr::static_kind(),
    OpenCLKernelAttr::static_kind(),
    OptimizeNoneAttr::static_kind(),
    OverrideAttr::static_kind(),
    OwnerAttr::static_kind(),
    OwnershipAttr::static_kind(),
    PackedAttr::static_kind(),
    ParamTypestateAttr::static_kind(),
    PascalAttr::static_kind(),
    PatchableFunctionEntryAttr::static_kind(),
    PcsAttr::static_kind(),
    PointerAttr::static_kind(),
    PragmaClangBSSSectionAttr::static_kind(),
    PragmaClangDataSectionAttr::static_kind(),
    PragmaClangRelroSectionAttr::static_kind(),
    PragmaClangRodataSectionAttr::static_kind(),
    PragmaClangTextSectionAttr::static_kind(),
    PreferredNameAttr::static_kind(),
    PreserveAllAttr::static_kind(),
    PreserveMostAttr::static_kind(),
    PtGuardedByAttr::static_kind(),
    PtGuardedVarAttr::static_kind(),
    PureAttr::static_kind(),
    RISCVInterruptAttr::static_kind(),
    RandomizeLayoutAttr::static_kind(),
    RegCallAttr::static_kind(),
    ReinitializesAttr::static_kind(),
    ReleaseCapabilityAttr::static_kind(),
    ReqdWorkGroupSizeAttr::static_kind(),
    RequiresCapabilityAttr::static_kind(),
    RestrictAttr::static_kind(),
    RetainAttr::static_kind(),
    ReturnTypestateAttr::static_kind(),
    ReturnsNonNullAttr::static_kind(),
    ReturnsTwiceAttr::static_kind(),
    SYCLKernelAttr::static_kind(),
    SYCLSpecialClassAttr::static_kind(),
    ScopedLockableAttr::static_kind(),
    SectionAttr::static_kind(),
    SelectAnyAttr::static_kind(),
    SentinelAttr::static_kind(),
    SetTypestateAttr::static_kind(),
    SharedTrylockFunctionAttr::static_kind(),
    SpeculativeLoadHardeningAttr::static_kind(),
    StandaloneDebugAttr::static_kind(),
    StdCallAttr::static_kind(),
    StrictFPAttr::static_kind(),
    SwiftAsyncAttr::static_kind(),
    SwiftAsyncCallAttr::static_kind(),
    SwiftAsyncErrorAttr::static_kind(),
    SwiftAsyncNameAttr::static_kind(),
    SwiftAttrAttr::static_kind(),
    SwiftBridgeAttr::static_kind(),
    SwiftBridgedTypedefAttr::static_kind(),
    SwiftCallAttr::static_kind(),
    SwiftErrorAttr::static_kind(),
    SwiftNameAttr::static_kind(),
    SwiftNewTypeAttr::static_kind(),
    SwiftPrivateAttr::static_kind(),
    SysVABIAttr::static_kind(),
    TLSModelAttr::static_kind(),
    TargetAttr::static_kind(),
    TargetClonesAttr::static_kind(),
    TestTypestateAttr::static_kind(),
    ThisCallAttr::static_kind(),
    TransparentUnionAttr::static_kind(),
    TrivialABIAttr::static_kind(),
    TryAcquireCapabilityAttr::static_kind(),
    TypeTagForDatatypeAttr::static_kind(),
    TypeVisibilityAttr::static_kind(),
    UnavailableAttr::static_kind(),
    UninitializedAttr::static_kind(),
    UnusedAttr::static_kind(),
    UsedAttr::static_kind(),
    UsingIfExistsAttr::static_kind(),
    UuidAttr::static_kind(),
    VecReturnAttr::static_kind(),
    VecTypeHintAttr::static_kind(),
    VectorCallAttr::static_kind(),
    VisibilityAttr::static_kind(),
    WarnUnusedAttr::static_kind(),
    WarnUnusedResultAttr::static_kind(),
    WeakAttr::static_kind(),
    WeakImportAttr::static_kind(),
    WeakRefAttr::static_kind(),
    WebAssemblyExportNameAttr::static_kind(),
    WebAssemblyImportModuleAttr::static_kind(),
    WebAssemblyImportNameAttr::static_kind(),
    WorkGroupSizeHintAttr::static_kind(),
    X86ForceAlignArgPointerAttr::static_kind(),
    XRayInstrumentAttr::static_kind(),
    XRayLogArgsAttr::static_kind(),
    ZeroCallUsedRegsAttr::static_kind(),
    AArch64SVEPcsAttr::static_kind(),
    AArch64VectorPcsAttr::static_kind(),
    AMDGPUFlatWorkGroupSizeAttr::static_kind(),
    AMDGPUKernelCallAttr::static_kind(),
    AMDGPUNumSGPRAttr::static_kind(),
    AMDGPUNumVGPRAttr::static_kind(),
    AMDGPUWavesPerEUAttr::static_kind(),
    ARMInterruptAttr::static_kind(),
    AVRInterruptAttr::static_kind(),
    AVRSignalAttr::static_kind(),
    AcquireCapabilityAttr::static_kind(),
    AcquireHandleAttr::static_kind(),
    AcquiredAfterAttr::static_kind(),
    AcquiredBeforeAttr::static_kind(),
    AlignMac68kAttr::static_kind(),
    AlignNaturalAttr::static_kind(),
    AlignedAttr::static_kind(),
    AllocAlignAttr::static_kind(),
    AllocSizeAttr::static_kind(),
    AlwaysDestroyAttr::static_kind(),
    AnalyzerNoReturnAttr::static_kind(),
    AnyX86InterruptAttr::static_kind(),
    AnyX86NoCallerSavedRegistersAttr::static_kind(),
    AnyX86NoCfCheckAttr::static_kind(),
    ArcWeakrefUnavailableAttr::static_kind(),
    ArgumentWithTypeTagAttr::static_kind(),
    ArmBuiltinAliasAttr::static_kind(),
    ArtificialAttr::static_kind(),
    AsmLabelAttr::static_kind(),
    AssertCapabilityAttr::static_kind(),
    AssertExclusiveLockAttr::static_kind(),
    AssertSharedLockAttr::static_kind(),
    AssumeAlignedAttr::static_kind(),
    AssumptionAttr::static_kind(),
    AvailabilityAttr::static_kind(),
    BPFPreserveAccessIndexAttr::static_kind(),
    BTFDeclTagAttr::static_kind(),
    BlocksAttr::static_kind(),
    BuiltinAttr::static_kind(),
    C11NoReturnAttr::static_kind(),
    CDeclAttr::static_kind(),
    CFAuditedTransferAttr::static_kind(),
    CFGuardAttr::static_kind(),
    CFICanonicalJumpTableAttr::static_kind(),
    CFReturnsNotRetainedAttr::static_kind(),
    CFReturnsRetainedAttr::static_kind(),
    CFUnknownTransferAttr::static_kind(),
    CPUDispatchAttr::static_kind(),
    CPUSpecificAttr::static_kind(),
    CUDAConstantAttr::static_kind(),
    CUDADeviceAttr::static_kind(),
    CUDADeviceBuiltinSurfaceTypeAttr::static_kind(),
    CUDADeviceBuiltinTextureTypeAttr::static_kind(),
    CUDAGlobalAttr::static_kind(),
    CUDAHostAttr::static_kind(),
    CUDAInvalidTargetAttr::static_kind(),
    CUDALaunchBoundsAttr::static_kind(),
    CUDASharedAttr::static_kind(),
    CXX11NoReturnAttr::static_kind(),
    CallableWhenAttr::static_kind(),
    CallbackAttr::static_kind(),
    CapabilityAttr::static_kind(),
    CapturedRecordAttr::static_kind(),
    CleanupAttr::static_kind(),
    CmseNSEntryAttr::static_kind(),
    CodeSegAttr::static_kind(),
    ColdAttr::static_kind(),
    CommonAttr::static_kind(),
    ConstAttr::static_kind(),
    ConstInitAttr::static_kind(),
    ConstructorAttr::static_kind(),
    ConsumableAttr::static_kind(),
    ConsumableAutoCastAttr::static_kind(),
    ConsumableSetOnReadAttr::static_kind(),
    ConvergentAttr::static_kind(),
    DLLExportAttr::static_kind(),
    DLLExportStaticLocalAttr::static_kind(),
    DLLImportAttr::static_kind(),
    DLLImportStaticLocalAttr::static_kind(),
    DeprecatedAttr::static_kind(),
    DestructorAttr::static_kind(),
    DiagnoseAsBuiltinAttr::static_kind(),
    DiagnoseIfAttr::static_kind(),
    DisableSanitizerInstrumentationAttr::static_kind(),
    DisableTailCallsAttr::static_kind(),
    EmptyBasesAttr::static_kind(),
    EnableIfAttr::static_kind(),
    EnforceTCBAttr::static_kind(),
    EnforceTCBLeafAttr::static_kind(),
    EnumExtensibilityAttr::static_kind(),
    ErrorAttr::static_kind(),
    ExcludeFromExplicitInstantiationAttr::static_kind(),
    ExclusiveTrylockFunctionAttr::static_kind(),
    ExternalSourceSymbolAttr::static_kind(),
    FastCallAttr::static_kind(),
    FinalAttr::static_kind(),
    FlagEnumAttr::static_kind(),
    FlattenAttr::static_kind(),
    FormatArgAttr::static_kind(),
    FormatAttr::static_kind(),
    FunctionReturnThunksAttr::static_kind(),
    GNUInlineAttr::static_kind(),
    GuardedByAttr::static_kind(),
    GuardedVarAttr::static_kind(),
    HIPManagedAttr::static_kind(),
    HLSLNumThreadsAttr::static_kind(),
    HLSLSV_GroupIndexAttr::static_kind(),
    HLSLShaderAttr::static_kind(),
    HotAttr::static_kind(),
    IBActionAttr::static_kind(),
    IBOutletAttr::static_kind(),
    IBOutletCollectionAttr::static_kind(),
    NSConsumedAttr::static_kind(),
    NonNullAttr::static_kind(),
    OSConsumedAttr::static_kind(),
    PassObjectSizeAttr::static_kind(),
    ReleaseHandleAttr::static_kind(),
    UseHandleAttr::static_kind(),
    AnnotateAttr::static_kind(),
    CFConsumedAttr::static_kind(),
    CarriesDependencyAttr::static_kind(),
    NoInlineAttr::static_kind(),
    NoMergeAttr::static_kind(),
    AlwaysInlineAttr::static_kind(),
    SwiftAsyncContextAttr::static_kind(),
    SwiftContextAttr::static_kind(),
    SwiftErrorResultAttr::static_kind(),
    SwiftIndirectResultAttr::static_kind(),
};

gap::generator<InheritableAttr> InheritableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kInheritableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<InheritableAttr> e = InheritableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InheritableAttr> InheritableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kInheritableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<InheritableAttr> e = InheritableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InheritableAttr> InheritableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::IB_OUTLET_COLLECTION:
    case mx::AttrKind::IB_OUTLET:
    case mx::AttrKind::IB_ACTION:
    case mx::AttrKind::HOT:
    case mx::AttrKind::HLSL_SHADER:
    case mx::AttrKind::HLSLSV__GROUP_INDEX:
    case mx::AttrKind::HLSL_NUM_THREADS:
    case mx::AttrKind::HIP_MANAGED:
    case mx::AttrKind::GUARDED_VAR:
    case mx::AttrKind::GUARDED_BY:
    case mx::AttrKind::GNU_INLINE:
    case mx::AttrKind::FUNCTION_RETURN_THUNKS:
    case mx::AttrKind::FORMAT:
    case mx::AttrKind::FORMAT_ARG:
    case mx::AttrKind::FLATTEN:
    case mx::AttrKind::FLAG_ENUM:
    case mx::AttrKind::FINAL:
    case mx::AttrKind::FAST_CALL:
    case mx::AttrKind::EXTERNAL_SOURCE_SYMBOL:
    case mx::AttrKind::EXCLUSIVE_TRYLOCK_FUNCTION:
    case mx::AttrKind::EXCLUDE_FROM_EXPLICIT_INSTANTIATION:
    case mx::AttrKind::ERROR:
    case mx::AttrKind::ENUM_EXTENSIBILITY:
    case mx::AttrKind::ENFORCE_TCB_LEAF:
    case mx::AttrKind::ENFORCE_TCB:
    case mx::AttrKind::ENABLE_IF:
    case mx::AttrKind::EMPTY_BASES:
    case mx::AttrKind::DISABLE_TAIL_CALLS:
    case mx::AttrKind::DISABLE_SANITIZER_INSTRUMENTATION:
    case mx::AttrKind::DIAGNOSE_IF:
    case mx::AttrKind::DIAGNOSE_AS_BUILTIN:
    case mx::AttrKind::DESTRUCTOR:
    case mx::AttrKind::DEPRECATED:
    case mx::AttrKind::ALWAYS_INLINE:
    case mx::AttrKind::NO_MERGE:
    case mx::AttrKind::NO_INLINE:
    case mx::AttrKind::DLL_IMPORT_STATIC_LOCAL:
    case mx::AttrKind::DLL_IMPORT:
    case mx::AttrKind::DLL_EXPORT_STATIC_LOCAL:
    case mx::AttrKind::DLL_EXPORT:
    case mx::AttrKind::CONVERGENT:
    case mx::AttrKind::CONSUMABLE_SET_ON_READ:
    case mx::AttrKind::CONSUMABLE_AUTO_CAST:
    case mx::AttrKind::CONSUMABLE:
    case mx::AttrKind::CONSTRUCTOR:
    case mx::AttrKind::CONST_INIT:
    case mx::AttrKind::CONST:
    case mx::AttrKind::COMMON:
    case mx::AttrKind::COLD:
    case mx::AttrKind::CODE_SEG:
    case mx::AttrKind::CMSE_NS_ENTRY:
    case mx::AttrKind::CLEANUP:
    case mx::AttrKind::CAPTURED_RECORD:
    case mx::AttrKind::CAPABILITY:
    case mx::AttrKind::CALLBACK:
    case mx::AttrKind::CALLABLE_WHEN:
    case mx::AttrKind::CXX11_NO_RETURN:
    case mx::AttrKind::CUDA_SHARED:
    case mx::AttrKind::CUDA_LAUNCH_BOUNDS:
    case mx::AttrKind::CUDA_INVALID_TARGET:
    case mx::AttrKind::CUDA_HOST:
    case mx::AttrKind::CUDA_GLOBAL:
    case mx::AttrKind::CUDA_DEVICE_BUILTIN_TEXTURE_TYPE:
    case mx::AttrKind::CUDA_DEVICE_BUILTIN_SURFACE_TYPE:
    case mx::AttrKind::CUDA_DEVICE:
    case mx::AttrKind::CUDA_CONSTANT:
    case mx::AttrKind::CPU_SPECIFIC:
    case mx::AttrKind::CPU_DISPATCH:
    case mx::AttrKind::CF_UNKNOWN_TRANSFER:
    case mx::AttrKind::CF_RETURNS_RETAINED:
    case mx::AttrKind::CF_RETURNS_NOT_RETAINED:
    case mx::AttrKind::CFI_CANONICAL_JUMP_TABLE:
    case mx::AttrKind::CF_GUARD:
    case mx::AttrKind::CF_AUDITED_TRANSFER:
    case mx::AttrKind::C_DECL:
    case mx::AttrKind::C11_NO_RETURN:
    case mx::AttrKind::BUILTIN:
    case mx::AttrKind::BLOCKS:
    case mx::AttrKind::BTF_DECL_TAG:
    case mx::AttrKind::BPF_PRESERVE_ACCESS_INDEX:
    case mx::AttrKind::AVAILABILITY:
    case mx::AttrKind::ASSUMPTION:
    case mx::AttrKind::ASSUME_ALIGNED:
    case mx::AttrKind::ASSERT_SHARED_LOCK:
    case mx::AttrKind::ASSERT_EXCLUSIVE_LOCK:
    case mx::AttrKind::ASSERT_CAPABILITY:
    case mx::AttrKind::ASM_LABEL:
    case mx::AttrKind::ARTIFICIAL:
    case mx::AttrKind::ARM_BUILTIN_ALIAS:
    case mx::AttrKind::ARGUMENT_WITH_TYPE_TAG:
    case mx::AttrKind::ARC_WEAKREF_UNAVAILABLE:
    case mx::AttrKind::ANY_X86_NO_CF_CHECK:
    case mx::AttrKind::ANY_X86_NO_CALLER_SAVED_REGISTERS:
    case mx::AttrKind::ANY_X86_INTERRUPT:
    case mx::AttrKind::ANALYZER_NO_RETURN:
    case mx::AttrKind::ALWAYS_DESTROY:
    case mx::AttrKind::ALLOC_SIZE:
    case mx::AttrKind::ALLOC_ALIGN:
    case mx::AttrKind::ALIGNED:
    case mx::AttrKind::ALIGN_NATURAL:
    case mx::AttrKind::ALIGN_MAC68K:
    case mx::AttrKind::ACQUIRED_BEFORE:
    case mx::AttrKind::ACQUIRED_AFTER:
    case mx::AttrKind::ACQUIRE_HANDLE:
    case mx::AttrKind::ACQUIRE_CAPABILITY:
    case mx::AttrKind::AVR_SIGNAL:
    case mx::AttrKind::AVR_INTERRUPT:
    case mx::AttrKind::ARM_INTERRUPT:
    case mx::AttrKind::AMDGPU_WAVES_PER_EU:
    case mx::AttrKind::AMDGPU_NUM_VGPR:
    case mx::AttrKind::AMDGPU_NUM_SGPR:
    case mx::AttrKind::AMDGPU_KERNEL_CALL:
    case mx::AttrKind::AMDGPU_FLAT_WORK_GROUP_SIZE:
    case mx::AttrKind::A_ARCH64_VECTOR_PCS:
    case mx::AttrKind::A_ARCH64_SVE_PCS:
    case mx::AttrKind::ZERO_CALL_USED_REGS:
    case mx::AttrKind::X_RAY_LOG_ARGS:
    case mx::AttrKind::X_RAY_INSTRUMENT:
    case mx::AttrKind::X86_FORCE_ALIGN_ARG_POINTER:
    case mx::AttrKind::WORK_GROUP_SIZE_HINT:
    case mx::AttrKind::WEB_ASSEMBLY_IMPORT_NAME:
    case mx::AttrKind::WEB_ASSEMBLY_IMPORT_MODULE:
    case mx::AttrKind::WEB_ASSEMBLY_EXPORT_NAME:
    case mx::AttrKind::WEAK_REF:
    case mx::AttrKind::WEAK_IMPORT:
    case mx::AttrKind::WEAK:
    case mx::AttrKind::WARN_UNUSED_RESULT:
    case mx::AttrKind::WARN_UNUSED:
    case mx::AttrKind::VISIBILITY:
    case mx::AttrKind::VECTOR_CALL:
    case mx::AttrKind::VEC_TYPE_HINT:
    case mx::AttrKind::VEC_RETURN:
    case mx::AttrKind::UUID:
    case mx::AttrKind::USING_IF_EXISTS:
    case mx::AttrKind::USED:
    case mx::AttrKind::UNUSED:
    case mx::AttrKind::UNINITIALIZED:
    case mx::AttrKind::UNAVAILABLE:
    case mx::AttrKind::TYPE_VISIBILITY:
    case mx::AttrKind::TYPE_TAG_FOR_DATATYPE:
    case mx::AttrKind::TRY_ACQUIRE_CAPABILITY:
    case mx::AttrKind::TRIVIAL_ABI:
    case mx::AttrKind::TRANSPARENT_UNION:
    case mx::AttrKind::THIS_CALL:
    case mx::AttrKind::TEST_TYPESTATE:
    case mx::AttrKind::TARGET_CLONES:
    case mx::AttrKind::TARGET:
    case mx::AttrKind::TLS_MODEL:
    case mx::AttrKind::SYS_VABI:
    case mx::AttrKind::SWIFT_PRIVATE:
    case mx::AttrKind::SWIFT_NEW_TYPE:
    case mx::AttrKind::SWIFT_NAME:
    case mx::AttrKind::SWIFT_ERROR:
    case mx::AttrKind::SWIFT_CALL:
    case mx::AttrKind::SWIFT_BRIDGED_TYPEDEF:
    case mx::AttrKind::SWIFT_BRIDGE:
    case mx::AttrKind::SWIFT_ATTR:
    case mx::AttrKind::SWIFT_ASYNC_NAME:
    case mx::AttrKind::SWIFT_ASYNC_ERROR:
    case mx::AttrKind::SWIFT_ASYNC_CALL:
    case mx::AttrKind::SWIFT_ASYNC:
    case mx::AttrKind::STRICT_FP:
    case mx::AttrKind::STD_CALL:
    case mx::AttrKind::STANDALONE_DEBUG:
    case mx::AttrKind::SPECULATIVE_LOAD_HARDENING:
    case mx::AttrKind::SHARED_TRYLOCK_FUNCTION:
    case mx::AttrKind::SET_TYPESTATE:
    case mx::AttrKind::SENTINEL:
    case mx::AttrKind::SELECT_ANY:
    case mx::AttrKind::SECTION:
    case mx::AttrKind::SCOPED_LOCKABLE:
    case mx::AttrKind::SYCL_SPECIAL_CLASS:
    case mx::AttrKind::SYCL_KERNEL:
    case mx::AttrKind::RETURNS_TWICE:
    case mx::AttrKind::RETURNS_NON_NULL:
    case mx::AttrKind::RETURN_TYPESTATE:
    case mx::AttrKind::RETAIN:
    case mx::AttrKind::RESTRICT:
    case mx::AttrKind::REQUIRES_CAPABILITY:
    case mx::AttrKind::REQD_WORK_GROUP_SIZE:
    case mx::AttrKind::RELEASE_CAPABILITY:
    case mx::AttrKind::REINITIALIZES:
    case mx::AttrKind::REG_CALL:
    case mx::AttrKind::RANDOMIZE_LAYOUT:
    case mx::AttrKind::RISCV_INTERRUPT:
    case mx::AttrKind::PURE:
    case mx::AttrKind::PT_GUARDED_VAR:
    case mx::AttrKind::PT_GUARDED_BY:
    case mx::AttrKind::PRESERVE_MOST:
    case mx::AttrKind::PRESERVE_ALL:
    case mx::AttrKind::PREFERRED_NAME:
    case mx::AttrKind::PRAGMA_CLANG_TEXT_SECTION:
    case mx::AttrKind::PRAGMA_CLANG_RODATA_SECTION:
    case mx::AttrKind::PRAGMA_CLANG_RELRO_SECTION:
    case mx::AttrKind::PRAGMA_CLANG_DATA_SECTION:
    case mx::AttrKind::PRAGMA_CLANG_BSS_SECTION:
    case mx::AttrKind::POINTER:
    case mx::AttrKind::PCS:
    case mx::AttrKind::PATCHABLE_FUNCTION_ENTRY:
    case mx::AttrKind::PASCAL:
    case mx::AttrKind::PARAM_TYPESTATE:
    case mx::AttrKind::PACKED:
    case mx::AttrKind::OWNERSHIP:
    case mx::AttrKind::OWNER:
    case mx::AttrKind::OVERRIDE:
    case mx::AttrKind::OPTIMIZE_NONE:
    case mx::AttrKind::OPEN_CL_KERNEL:
    case mx::AttrKind::OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE:
    case mx::AttrKind::OBJ_C_SUBCLASSING_RESTRICTED:
    case mx::AttrKind::OBJ_C_ROOT_CLASS:
    case mx::AttrKind::OBJ_C_RETURNS_INNER_POINTER:
    case mx::AttrKind::OBJ_C_REQUIRES_SUPER:
    case mx::AttrKind::OBJ_C_REQUIRES_PROPERTY_DEFS:
    case mx::AttrKind::OBJ_C_PRECISE_LIFETIME:
    case mx::AttrKind::OBJ_C_OWNERSHIP:
    case mx::AttrKind::OBJ_CNS_OBJECT:
    case mx::AttrKind::OBJ_C_METHOD_FAMILY:
    case mx::AttrKind::OBJ_C_INDEPENDENT_CLASS:
    case mx::AttrKind::OBJ_C_EXTERNALLY_RETAINED:
    case mx::AttrKind::OBJ_C_EXPLICIT_PROTOCOL_IMPL:
    case mx::AttrKind::OBJ_C_EXCEPTION:
    case mx::AttrKind::OBJ_C_BRIDGE_RELATED:
    case mx::AttrKind::OBJ_C_BRIDGE_MUTABLE:
    case mx::AttrKind::OBJ_C_BRIDGE:
    case mx::AttrKind::OS_RETURNS_RETAINED_ON_ZERO:
    case mx::AttrKind::OS_RETURNS_RETAINED_ON_NON_ZERO:
    case mx::AttrKind::OS_RETURNS_RETAINED:
    case mx::AttrKind::OS_RETURNS_NOT_RETAINED:
    case mx::AttrKind::OS_CONSUMES_THIS:
    case mx::AttrKind::OMP_THREAD_PRIVATE_DECL:
    case mx::AttrKind::OMP_DECLARE_VARIANT:
    case mx::AttrKind::OMP_DECLARE_TARGET_DECL:
    case mx::AttrKind::OMP_CAPTURE_NO_INIT:
    case mx::AttrKind::OMP_ALLOCATE_DECL:
    case mx::AttrKind::NOT_TAIL_CALLED:
    case mx::AttrKind::NO_UNIQUE_ADDRESS:
    case mx::AttrKind::NO_THROW:
    case mx::AttrKind::NO_THREAD_SAFETY_ANALYSIS:
    case mx::AttrKind::NO_STACK_PROTECTOR:
    case mx::AttrKind::NO_SPLIT_STACK:
    case mx::AttrKind::NO_SPECULATIVE_LOAD_HARDENING:
    case mx::AttrKind::NO_SANITIZE:
    case mx::AttrKind::NO_RETURN:
    case mx::AttrKind::NO_RANDOMIZE_LAYOUT:
    case mx::AttrKind::NO_PROFILE_FUNCTION:
    case mx::AttrKind::NO_MIPS16:
    case mx::AttrKind::NO_MICRO_MIPS:
    case mx::AttrKind::NO_INSTRUMENT_FUNCTION:
    case mx::AttrKind::NO_DUPLICATE:
    case mx::AttrKind::NO_DESTROY:
    case mx::AttrKind::NO_DEBUG:
    case mx::AttrKind::NO_COMMON:
    case mx::AttrKind::NO_ALIAS:
    case mx::AttrKind::NAKED:
    case mx::AttrKind::NS_RETURNS_RETAINED:
    case mx::AttrKind::NS_RETURNS_NOT_RETAINED:
    case mx::AttrKind::NS_RETURNS_AUTORELEASED:
    case mx::AttrKind::NS_ERROR_DOMAIN:
    case mx::AttrKind::NS_CONSUMES_SELF:
    case mx::AttrKind::MIPS_SHORT_CALL:
    case mx::AttrKind::MIPS_LONG_CALL:
    case mx::AttrKind::MIPS_INTERRUPT:
    case mx::AttrKind::MIPS16:
    case mx::AttrKind::MIN_VECTOR_WIDTH:
    case mx::AttrKind::MIN_SIZE:
    case mx::AttrKind::MICRO_MIPS:
    case mx::AttrKind::MAY_ALIAS:
    case mx::AttrKind::MAX_FIELD_ALIGNMENT:
    case mx::AttrKind::MS_VTOR_DISP:
    case mx::AttrKind::MS_STRUCT:
    case mx::AttrKind::MSP430_INTERRUPT:
    case mx::AttrKind::MS_NO_V_TABLE:
    case mx::AttrKind::MS_INHERITANCE:
    case mx::AttrKind::MS_ALLOCATOR:
    case mx::AttrKind::MSABI:
    case mx::AttrKind::MIG_SERVER_ROUTINE_:
    case mx::AttrKind::M68K_INTERRUPT:
    case mx::AttrKind::LOCKS_EXCLUDED:
    case mx::AttrKind::LOCK_RETURNED:
    case mx::AttrKind::LIFETIME_BOUND:
    case mx::AttrKind::LEAF:
    case mx::AttrKind::LAYOUT_VERSION:
    case mx::AttrKind::LTO_VISIBILITY_PUBLIC:
    case mx::AttrKind::INTERNAL_LINKAGE:
    case mx::AttrKind::INTEL_OCL_BICC:
    case mx::AttrKind::INIT_PRIORITY:
    case mx::AttrKind::CARRIES_DEPENDENCY:
    case mx::AttrKind::CF_CONSUMED:
    case mx::AttrKind::ANNOTATE:
    case mx::AttrKind::USE_HANDLE:
    case mx::AttrKind::RELEASE_HANDLE:
    case mx::AttrKind::PASS_OBJECT_SIZE:
    case mx::AttrKind::SWIFT_INDIRECT_RESULT:
    case mx::AttrKind::SWIFT_ERROR_RESULT:
    case mx::AttrKind::SWIFT_CONTEXT:
    case mx::AttrKind::SWIFT_ASYNC_CONTEXT:
    case mx::AttrKind::OS_CONSUMED:
    case mx::AttrKind::NON_NULL:
    case mx::AttrKind::NS_CONSUMED:
      return reinterpret_cast<const InheritableAttr &>(parent);
    default: return std::nullopt;
  }
}

bool InheritableAttr::should_inherit_even_if_already_present(void) const {
  return impl->reader.getVal11();
}

gap::generator<IBOutletCollectionAttr> IBOutletCollectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IBOutletCollectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IBOutletCollectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IBOutletCollectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IBOutletCollectionAttr> IBOutletCollectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return IBOutletCollectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kIBOutletCollectionAttrDerivedKinds[] = {
    IBOutletCollectionAttr::static_kind(),
};

gap::generator<IBOutletCollectionAttr> IBOutletCollectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kIBOutletCollectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<IBOutletCollectionAttr> e = IBOutletCollectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IBOutletCollectionAttr> IBOutletCollectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kIBOutletCollectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<IBOutletCollectionAttr> e = IBOutletCollectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IBOutletCollectionAttr> IBOutletCollectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<IBOutletCollectionAttr> IBOutletCollectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::IB_OUTLET_COLLECTION:
      return reinterpret_cast<const IBOutletCollectionAttr &>(parent);
    default: return std::nullopt;
  }
}

Type IBOutletCollectionAttr::interface(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type IBOutletCollectionAttr::interface_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<IBOutletAttr> IBOutletAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IBOutletAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IBOutletAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IBOutletAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IBOutletAttr> IBOutletAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return IBOutletAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kIBOutletAttrDerivedKinds[] = {
    IBOutletAttr::static_kind(),
};

gap::generator<IBOutletAttr> IBOutletAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kIBOutletAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<IBOutletAttr> e = IBOutletAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IBOutletAttr> IBOutletAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kIBOutletAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<IBOutletAttr> e = IBOutletAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IBOutletAttr> IBOutletAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<IBOutletAttr> IBOutletAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::IB_OUTLET:
      return reinterpret_cast<const IBOutletAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IBActionAttr> IBActionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IBActionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IBActionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IBActionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IBActionAttr> IBActionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return IBActionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kIBActionAttrDerivedKinds[] = {
    IBActionAttr::static_kind(),
};

gap::generator<IBActionAttr> IBActionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kIBActionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<IBActionAttr> e = IBActionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IBActionAttr> IBActionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kIBActionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<IBActionAttr> e = IBActionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IBActionAttr> IBActionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<IBActionAttr> IBActionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::IB_ACTION:
      return reinterpret_cast<const IBActionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<HotAttr> HotAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = HotAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool HotAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : HotAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<HotAttr> HotAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return HotAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kHotAttrDerivedKinds[] = {
    HotAttr::static_kind(),
};

gap::generator<HotAttr> HotAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kHotAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<HotAttr> e = HotAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<HotAttr> HotAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kHotAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<HotAttr> e = HotAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<HotAttr> HotAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<HotAttr> HotAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::HOT:
      return reinterpret_cast<const HotAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<HLSLShaderAttr> HLSLShaderAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = HLSLShaderAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool HLSLShaderAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : HLSLShaderAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<HLSLShaderAttr> HLSLShaderAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return HLSLShaderAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kHLSLShaderAttrDerivedKinds[] = {
    HLSLShaderAttr::static_kind(),
};

gap::generator<HLSLShaderAttr> HLSLShaderAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kHLSLShaderAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<HLSLShaderAttr> e = HLSLShaderAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<HLSLShaderAttr> HLSLShaderAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kHLSLShaderAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<HLSLShaderAttr> e = HLSLShaderAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<HLSLShaderAttr> HLSLShaderAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<HLSLShaderAttr> HLSLShaderAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::HLSL_SHADER:
      return reinterpret_cast<const HLSLShaderAttr &>(parent);
    default: return std::nullopt;
  }
}

HLSLShaderAttrShaderType HLSLShaderAttr::type(void) const {
  return static_cast<HLSLShaderAttrShaderType>(impl->reader.getVal10());
}

gap::generator<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = HLSLSV_GroupIndexAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool HLSLSV_GroupIndexAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : HLSLSV_GroupIndexAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return HLSLSV_GroupIndexAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kHLSLSV_GroupIndexAttrDerivedKinds[] = {
    HLSLSV_GroupIndexAttr::static_kind(),
};

gap::generator<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kHLSLSV_GroupIndexAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<HLSLSV_GroupIndexAttr> e = HLSLSV_GroupIndexAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kHLSLSV_GroupIndexAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<HLSLSV_GroupIndexAttr> e = HLSLSV_GroupIndexAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<HLSLSV_GroupIndexAttr> HLSLSV_GroupIndexAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::HLSLSV__GROUP_INDEX:
      return reinterpret_cast<const HLSLSV_GroupIndexAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<HLSLNumThreadsAttr> HLSLNumThreadsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = HLSLNumThreadsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool HLSLNumThreadsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : HLSLNumThreadsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<HLSLNumThreadsAttr> HLSLNumThreadsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return HLSLNumThreadsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kHLSLNumThreadsAttrDerivedKinds[] = {
    HLSLNumThreadsAttr::static_kind(),
};

gap::generator<HLSLNumThreadsAttr> HLSLNumThreadsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kHLSLNumThreadsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<HLSLNumThreadsAttr> e = HLSLNumThreadsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<HLSLNumThreadsAttr> HLSLNumThreadsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kHLSLNumThreadsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<HLSLNumThreadsAttr> e = HLSLNumThreadsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<HLSLNumThreadsAttr> HLSLNumThreadsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<HLSLNumThreadsAttr> HLSLNumThreadsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::HLSL_NUM_THREADS:
      return reinterpret_cast<const HLSLNumThreadsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<HIPManagedAttr> HIPManagedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = HIPManagedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool HIPManagedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : HIPManagedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<HIPManagedAttr> HIPManagedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return HIPManagedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kHIPManagedAttrDerivedKinds[] = {
    HIPManagedAttr::static_kind(),
};

gap::generator<HIPManagedAttr> HIPManagedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kHIPManagedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<HIPManagedAttr> e = HIPManagedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<HIPManagedAttr> HIPManagedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kHIPManagedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<HIPManagedAttr> e = HIPManagedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<HIPManagedAttr> HIPManagedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<HIPManagedAttr> HIPManagedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::HIP_MANAGED:
      return reinterpret_cast<const HIPManagedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<GuardedVarAttr> GuardedVarAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GuardedVarAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GuardedVarAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GuardedVarAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<GuardedVarAttr> GuardedVarAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return GuardedVarAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kGuardedVarAttrDerivedKinds[] = {
    GuardedVarAttr::static_kind(),
};

gap::generator<GuardedVarAttr> GuardedVarAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kGuardedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<GuardedVarAttr> e = GuardedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GuardedVarAttr> GuardedVarAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kGuardedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<GuardedVarAttr> e = GuardedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GuardedVarAttr> GuardedVarAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<GuardedVarAttr> GuardedVarAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::GUARDED_VAR:
      return reinterpret_cast<const GuardedVarAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<GuardedByAttr> GuardedByAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GuardedByAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GuardedByAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GuardedByAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<GuardedByAttr> GuardedByAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return GuardedByAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kGuardedByAttrDerivedKinds[] = {
    GuardedByAttr::static_kind(),
};

gap::generator<GuardedByAttr> GuardedByAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kGuardedByAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<GuardedByAttr> e = GuardedByAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GuardedByAttr> GuardedByAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kGuardedByAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<GuardedByAttr> e = GuardedByAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GuardedByAttr> GuardedByAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<GuardedByAttr> GuardedByAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::GUARDED_BY:
      return reinterpret_cast<const GuardedByAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr GuardedByAttr::argument(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<GNUInlineAttr> GNUInlineAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GNUInlineAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GNUInlineAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GNUInlineAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<GNUInlineAttr> GNUInlineAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return GNUInlineAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kGNUInlineAttrDerivedKinds[] = {
    GNUInlineAttr::static_kind(),
};

gap::generator<GNUInlineAttr> GNUInlineAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kGNUInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<GNUInlineAttr> e = GNUInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GNUInlineAttr> GNUInlineAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kGNUInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<GNUInlineAttr> e = GNUInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GNUInlineAttr> GNUInlineAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<GNUInlineAttr> GNUInlineAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::GNU_INLINE:
      return reinterpret_cast<const GNUInlineAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FunctionReturnThunksAttr> FunctionReturnThunksAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionReturnThunksAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionReturnThunksAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionReturnThunksAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FunctionReturnThunksAttr> FunctionReturnThunksAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FunctionReturnThunksAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFunctionReturnThunksAttrDerivedKinds[] = {
    FunctionReturnThunksAttr::static_kind(),
};

gap::generator<FunctionReturnThunksAttr> FunctionReturnThunksAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFunctionReturnThunksAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FunctionReturnThunksAttr> e = FunctionReturnThunksAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionReturnThunksAttr> FunctionReturnThunksAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFunctionReturnThunksAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FunctionReturnThunksAttr> e = FunctionReturnThunksAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionReturnThunksAttr> FunctionReturnThunksAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FunctionReturnThunksAttr> FunctionReturnThunksAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FUNCTION_RETURN_THUNKS:
      return reinterpret_cast<const FunctionReturnThunksAttr &>(parent);
    default: return std::nullopt;
  }
}

FunctionReturnThunksAttrKind FunctionReturnThunksAttr::thunk_type(void) const {
  return static_cast<FunctionReturnThunksAttrKind>(impl->reader.getVal10());
}

gap::generator<FormatAttr> FormatAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FormatAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FormatAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FormatAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FormatAttr> FormatAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FormatAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFormatAttrDerivedKinds[] = {
    FormatAttr::static_kind(),
};

gap::generator<FormatAttr> FormatAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFormatAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FormatAttr> e = FormatAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FormatAttr> FormatAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFormatAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FormatAttr> e = FormatAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FormatAttr> FormatAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FormatAttr> FormatAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FORMAT:
      return reinterpret_cast<const FormatAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FormatArgAttr> FormatArgAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FormatArgAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FormatArgAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FormatArgAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FormatArgAttr> FormatArgAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FormatArgAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFormatArgAttrDerivedKinds[] = {
    FormatArgAttr::static_kind(),
};

gap::generator<FormatArgAttr> FormatArgAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFormatArgAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FormatArgAttr> e = FormatArgAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FormatArgAttr> FormatArgAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFormatArgAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FormatArgAttr> e = FormatArgAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FormatArgAttr> FormatArgAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FormatArgAttr> FormatArgAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FORMAT_ARG:
      return reinterpret_cast<const FormatArgAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FlattenAttr> FlattenAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FlattenAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FlattenAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FlattenAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FlattenAttr> FlattenAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FlattenAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFlattenAttrDerivedKinds[] = {
    FlattenAttr::static_kind(),
};

gap::generator<FlattenAttr> FlattenAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFlattenAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FlattenAttr> e = FlattenAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FlattenAttr> FlattenAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFlattenAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FlattenAttr> e = FlattenAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FlattenAttr> FlattenAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FlattenAttr> FlattenAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FLATTEN:
      return reinterpret_cast<const FlattenAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FlagEnumAttr> FlagEnumAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FlagEnumAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FlagEnumAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FlagEnumAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FlagEnumAttr> FlagEnumAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FlagEnumAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFlagEnumAttrDerivedKinds[] = {
    FlagEnumAttr::static_kind(),
};

gap::generator<FlagEnumAttr> FlagEnumAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFlagEnumAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FlagEnumAttr> e = FlagEnumAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FlagEnumAttr> FlagEnumAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFlagEnumAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FlagEnumAttr> e = FlagEnumAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FlagEnumAttr> FlagEnumAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FlagEnumAttr> FlagEnumAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FLAG_ENUM:
      return reinterpret_cast<const FlagEnumAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<FinalAttr> FinalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FinalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FinalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FinalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FinalAttr> FinalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FinalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFinalAttrDerivedKinds[] = {
    FinalAttr::static_kind(),
};

gap::generator<FinalAttr> FinalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFinalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FinalAttr> e = FinalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FinalAttr> FinalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFinalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FinalAttr> e = FinalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FinalAttr> FinalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FinalAttr> FinalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FINAL:
      return reinterpret_cast<const FinalAttr &>(parent);
    default: return std::nullopt;
  }
}

FinalAttrSpelling FinalAttr::semantic_spelling(void) const {
  return static_cast<FinalAttrSpelling>(impl->reader.getVal10());
}

bool FinalAttr::is_spelled_as_sealed(void) const {
  return impl->reader.getVal12();
}

gap::generator<FastCallAttr> FastCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FastCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FastCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FastCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FastCallAttr> FastCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return FastCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kFastCallAttrDerivedKinds[] = {
    FastCallAttr::static_kind(),
};

gap::generator<FastCallAttr> FastCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kFastCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<FastCallAttr> e = FastCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FastCallAttr> FastCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kFastCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<FastCallAttr> e = FastCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FastCallAttr> FastCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<FastCallAttr> FastCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::FAST_CALL:
      return reinterpret_cast<const FastCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExternalSourceSymbolAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExternalSourceSymbolAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExternalSourceSymbolAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ExternalSourceSymbolAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kExternalSourceSymbolAttrDerivedKinds[] = {
    ExternalSourceSymbolAttr::static_kind(),
};

gap::generator<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kExternalSourceSymbolAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ExternalSourceSymbolAttr> e = ExternalSourceSymbolAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kExternalSourceSymbolAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ExternalSourceSymbolAttr> e = ExternalSourceSymbolAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ExternalSourceSymbolAttr> ExternalSourceSymbolAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::EXTERNAL_SOURCE_SYMBOL:
      return reinterpret_cast<const ExternalSourceSymbolAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view ExternalSourceSymbolAttr::defined_in(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

bool ExternalSourceSymbolAttr::generated_declaration(void) const {
  return impl->reader.getVal12();
}

std::string_view ExternalSourceSymbolAttr::language(void) const {
  capnp::Text::Reader data = impl->reader.getVal17();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExclusiveTrylockFunctionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExclusiveTrylockFunctionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExclusiveTrylockFunctionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ExclusiveTrylockFunctionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kExclusiveTrylockFunctionAttrDerivedKinds[] = {
    ExclusiveTrylockFunctionAttr::static_kind(),
};

gap::generator<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kExclusiveTrylockFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ExclusiveTrylockFunctionAttr> e = ExclusiveTrylockFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kExclusiveTrylockFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ExclusiveTrylockFunctionAttr> e = ExclusiveTrylockFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ExclusiveTrylockFunctionAttr> ExclusiveTrylockFunctionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::EXCLUSIVE_TRYLOCK_FUNCTION:
      return reinterpret_cast<const ExclusiveTrylockFunctionAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr ExclusiveTrylockFunctionAttr::success_value(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExcludeFromExplicitInstantiationAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExcludeFromExplicitInstantiationAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExcludeFromExplicitInstantiationAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ExcludeFromExplicitInstantiationAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kExcludeFromExplicitInstantiationAttrDerivedKinds[] = {
    ExcludeFromExplicitInstantiationAttr::static_kind(),
};

gap::generator<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kExcludeFromExplicitInstantiationAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ExcludeFromExplicitInstantiationAttr> e = ExcludeFromExplicitInstantiationAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kExcludeFromExplicitInstantiationAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ExcludeFromExplicitInstantiationAttr> e = ExcludeFromExplicitInstantiationAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ExcludeFromExplicitInstantiationAttr> ExcludeFromExplicitInstantiationAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::EXCLUDE_FROM_EXPLICIT_INSTANTIATION:
      return reinterpret_cast<const ExcludeFromExplicitInstantiationAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ErrorAttr> ErrorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ErrorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ErrorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ErrorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ErrorAttr> ErrorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ErrorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kErrorAttrDerivedKinds[] = {
    ErrorAttr::static_kind(),
};

gap::generator<ErrorAttr> ErrorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ErrorAttr> e = ErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ErrorAttr> ErrorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ErrorAttr> e = ErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ErrorAttr> ErrorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ErrorAttr> ErrorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ERROR:
      return reinterpret_cast<const ErrorAttr &>(parent);
    default: return std::nullopt;
  }
}

ErrorAttrSpelling ErrorAttr::semantic_spelling(void) const {
  return static_cast<ErrorAttrSpelling>(impl->reader.getVal10());
}

std::string_view ErrorAttr::user_diagnostic(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

bool ErrorAttr::is_error(void) const {
  return impl->reader.getVal12();
}

bool ErrorAttr::is_warning(void) const {
  return impl->reader.getVal13();
}

gap::generator<EnumExtensibilityAttr> EnumExtensibilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnumExtensibilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnumExtensibilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnumExtensibilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EnumExtensibilityAttr> EnumExtensibilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return EnumExtensibilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kEnumExtensibilityAttrDerivedKinds[] = {
    EnumExtensibilityAttr::static_kind(),
};

gap::generator<EnumExtensibilityAttr> EnumExtensibilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kEnumExtensibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<EnumExtensibilityAttr> e = EnumExtensibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnumExtensibilityAttr> EnumExtensibilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kEnumExtensibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<EnumExtensibilityAttr> e = EnumExtensibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnumExtensibilityAttr> EnumExtensibilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<EnumExtensibilityAttr> EnumExtensibilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ENUM_EXTENSIBILITY:
      return reinterpret_cast<const EnumExtensibilityAttr &>(parent);
    default: return std::nullopt;
  }
}

EnumExtensibilityAttrKind EnumExtensibilityAttr::extensibility(void) const {
  return static_cast<EnumExtensibilityAttrKind>(impl->reader.getVal10());
}

gap::generator<EnforceTCBLeafAttr> EnforceTCBLeafAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnforceTCBLeafAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnforceTCBLeafAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnforceTCBLeafAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EnforceTCBLeafAttr> EnforceTCBLeafAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return EnforceTCBLeafAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kEnforceTCBLeafAttrDerivedKinds[] = {
    EnforceTCBLeafAttr::static_kind(),
};

gap::generator<EnforceTCBLeafAttr> EnforceTCBLeafAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kEnforceTCBLeafAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<EnforceTCBLeafAttr> e = EnforceTCBLeafAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnforceTCBLeafAttr> EnforceTCBLeafAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kEnforceTCBLeafAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<EnforceTCBLeafAttr> e = EnforceTCBLeafAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnforceTCBLeafAttr> EnforceTCBLeafAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<EnforceTCBLeafAttr> EnforceTCBLeafAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ENFORCE_TCB_LEAF:
      return reinterpret_cast<const EnforceTCBLeafAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view EnforceTCBLeafAttr::tcb_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<EnforceTCBAttr> EnforceTCBAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnforceTCBAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnforceTCBAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnforceTCBAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EnforceTCBAttr> EnforceTCBAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return EnforceTCBAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kEnforceTCBAttrDerivedKinds[] = {
    EnforceTCBAttr::static_kind(),
};

gap::generator<EnforceTCBAttr> EnforceTCBAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kEnforceTCBAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<EnforceTCBAttr> e = EnforceTCBAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnforceTCBAttr> EnforceTCBAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kEnforceTCBAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<EnforceTCBAttr> e = EnforceTCBAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnforceTCBAttr> EnforceTCBAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<EnforceTCBAttr> EnforceTCBAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ENFORCE_TCB:
      return reinterpret_cast<const EnforceTCBAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view EnforceTCBAttr::tcb_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<EnableIfAttr> EnableIfAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnableIfAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnableIfAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnableIfAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EnableIfAttr> EnableIfAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return EnableIfAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kEnableIfAttrDerivedKinds[] = {
    EnableIfAttr::static_kind(),
};

gap::generator<EnableIfAttr> EnableIfAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kEnableIfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<EnableIfAttr> e = EnableIfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnableIfAttr> EnableIfAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kEnableIfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<EnableIfAttr> e = EnableIfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnableIfAttr> EnableIfAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<EnableIfAttr> EnableIfAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ENABLE_IF:
      return reinterpret_cast<const EnableIfAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr EnableIfAttr::condition(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::string_view EnableIfAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<EmptyBasesAttr> EmptyBasesAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EmptyBasesAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EmptyBasesAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EmptyBasesAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EmptyBasesAttr> EmptyBasesAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return EmptyBasesAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kEmptyBasesAttrDerivedKinds[] = {
    EmptyBasesAttr::static_kind(),
};

gap::generator<EmptyBasesAttr> EmptyBasesAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kEmptyBasesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<EmptyBasesAttr> e = EmptyBasesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EmptyBasesAttr> EmptyBasesAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kEmptyBasesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<EmptyBasesAttr> e = EmptyBasesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EmptyBasesAttr> EmptyBasesAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<EmptyBasesAttr> EmptyBasesAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::EMPTY_BASES:
      return reinterpret_cast<const EmptyBasesAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DisableTailCallsAttr> DisableTailCallsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DisableTailCallsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DisableTailCallsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DisableTailCallsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DisableTailCallsAttr> DisableTailCallsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DisableTailCallsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDisableTailCallsAttrDerivedKinds[] = {
    DisableTailCallsAttr::static_kind(),
};

gap::generator<DisableTailCallsAttr> DisableTailCallsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDisableTailCallsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DisableTailCallsAttr> e = DisableTailCallsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DisableTailCallsAttr> DisableTailCallsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDisableTailCallsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DisableTailCallsAttr> e = DisableTailCallsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DisableTailCallsAttr> DisableTailCallsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DisableTailCallsAttr> DisableTailCallsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DISABLE_TAIL_CALLS:
      return reinterpret_cast<const DisableTailCallsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DisableSanitizerInstrumentationAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DisableSanitizerInstrumentationAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DisableSanitizerInstrumentationAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DisableSanitizerInstrumentationAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDisableSanitizerInstrumentationAttrDerivedKinds[] = {
    DisableSanitizerInstrumentationAttr::static_kind(),
};

gap::generator<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDisableSanitizerInstrumentationAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DisableSanitizerInstrumentationAttr> e = DisableSanitizerInstrumentationAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDisableSanitizerInstrumentationAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DisableSanitizerInstrumentationAttr> e = DisableSanitizerInstrumentationAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DisableSanitizerInstrumentationAttr> DisableSanitizerInstrumentationAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DISABLE_SANITIZER_INSTRUMENTATION:
      return reinterpret_cast<const DisableSanitizerInstrumentationAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DiagnoseIfAttr> DiagnoseIfAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DiagnoseIfAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DiagnoseIfAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DiagnoseIfAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DiagnoseIfAttr> DiagnoseIfAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DiagnoseIfAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDiagnoseIfAttrDerivedKinds[] = {
    DiagnoseIfAttr::static_kind(),
};

gap::generator<DiagnoseIfAttr> DiagnoseIfAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDiagnoseIfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DiagnoseIfAttr> e = DiagnoseIfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DiagnoseIfAttr> DiagnoseIfAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDiagnoseIfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DiagnoseIfAttr> e = DiagnoseIfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DiagnoseIfAttr> DiagnoseIfAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DiagnoseIfAttr> DiagnoseIfAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DIAGNOSE_IF:
      return reinterpret_cast<const DiagnoseIfAttr &>(parent);
    default: return std::nullopt;
  }
}

bool DiagnoseIfAttr::argument_dependent(void) const {
  return impl->reader.getVal12();
}

Expr DiagnoseIfAttr::condition(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

DiagnoseIfAttrDiagnosticType DiagnoseIfAttr::diagnostic_type(void) const {
  return static_cast<DiagnoseIfAttrDiagnosticType>(impl->reader.getVal10());
}

std::string_view DiagnoseIfAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

NamedDecl DiagnoseIfAttr::parent(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool DiagnoseIfAttr::is_error(void) const {
  return impl->reader.getVal13();
}

bool DiagnoseIfAttr::is_warning(void) const {
  return impl->reader.getVal18();
}

gap::generator<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DiagnoseAsBuiltinAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DiagnoseAsBuiltinAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DiagnoseAsBuiltinAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DiagnoseAsBuiltinAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDiagnoseAsBuiltinAttrDerivedKinds[] = {
    DiagnoseAsBuiltinAttr::static_kind(),
};

gap::generator<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDiagnoseAsBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DiagnoseAsBuiltinAttr> e = DiagnoseAsBuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDiagnoseAsBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DiagnoseAsBuiltinAttr> e = DiagnoseAsBuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DiagnoseAsBuiltinAttr> DiagnoseAsBuiltinAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DIAGNOSE_AS_BUILTIN:
      return reinterpret_cast<const DiagnoseAsBuiltinAttr &>(parent);
    default: return std::nullopt;
  }
}

FunctionDecl DiagnoseAsBuiltinAttr::function(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return FunctionDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<DestructorAttr> DestructorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DestructorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DestructorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DestructorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DestructorAttr> DestructorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DestructorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDestructorAttrDerivedKinds[] = {
    DestructorAttr::static_kind(),
};

gap::generator<DestructorAttr> DestructorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDestructorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DestructorAttr> e = DestructorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DestructorAttr> DestructorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDestructorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DestructorAttr> e = DestructorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DestructorAttr> DestructorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DestructorAttr> DestructorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DESTRUCTOR:
      return reinterpret_cast<const DestructorAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DeprecatedAttr> DeprecatedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeprecatedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeprecatedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeprecatedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DeprecatedAttr> DeprecatedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DeprecatedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDeprecatedAttrDerivedKinds[] = {
    DeprecatedAttr::static_kind(),
};

gap::generator<DeprecatedAttr> DeprecatedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDeprecatedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DeprecatedAttr> e = DeprecatedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeprecatedAttr> DeprecatedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDeprecatedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DeprecatedAttr> e = DeprecatedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeprecatedAttr> DeprecatedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DeprecatedAttr> DeprecatedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DEPRECATED:
      return reinterpret_cast<const DeprecatedAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view DeprecatedAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

std::string_view DeprecatedAttr::replacement(void) const {
  capnp::Text::Reader data = impl->reader.getVal17();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<DeclOrStmtAttr> DeclOrStmtAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeclOrStmtAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeclOrStmtAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeclOrStmtAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DeclOrStmtAttr> DeclOrStmtAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DeclOrStmtAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDeclOrStmtAttrDerivedKinds[] = {
    NoInlineAttr::static_kind(),
    NoMergeAttr::static_kind(),
    AlwaysInlineAttr::static_kind(),
};

gap::generator<DeclOrStmtAttr> DeclOrStmtAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDeclOrStmtAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DeclOrStmtAttr> e = DeclOrStmtAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeclOrStmtAttr> DeclOrStmtAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDeclOrStmtAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DeclOrStmtAttr> e = DeclOrStmtAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeclOrStmtAttr> DeclOrStmtAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DeclOrStmtAttr> DeclOrStmtAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALWAYS_INLINE:
    case mx::AttrKind::NO_MERGE:
    case mx::AttrKind::NO_INLINE:
      return reinterpret_cast<const DeclOrStmtAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AlwaysInlineAttr> AlwaysInlineAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlwaysInlineAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlwaysInlineAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlwaysInlineAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlwaysInlineAttr> AlwaysInlineAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlwaysInlineAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlwaysInlineAttrDerivedKinds[] = {
    AlwaysInlineAttr::static_kind(),
};

gap::generator<AlwaysInlineAttr> AlwaysInlineAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlwaysInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlwaysInlineAttr> e = AlwaysInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlwaysInlineAttr> AlwaysInlineAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlwaysInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlwaysInlineAttr> e = AlwaysInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlwaysInlineAttr> AlwaysInlineAttr::from(const DeclOrStmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlwaysInlineAttr> AlwaysInlineAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlwaysInlineAttr> AlwaysInlineAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALWAYS_INLINE:
      return reinterpret_cast<const AlwaysInlineAttr &>(parent);
    default: return std::nullopt;
  }
}

AlwaysInlineAttrSpelling AlwaysInlineAttr::semantic_spelling(void) const {
  return static_cast<AlwaysInlineAttrSpelling>(impl->reader.getVal10());
}

bool AlwaysInlineAttr::is_clang_always_inline(void) const {
  return impl->reader.getVal12();
}

gap::generator<NoMergeAttr> NoMergeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoMergeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoMergeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoMergeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoMergeAttr> NoMergeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoMergeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoMergeAttrDerivedKinds[] = {
    NoMergeAttr::static_kind(),
};

gap::generator<NoMergeAttr> NoMergeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoMergeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoMergeAttr> e = NoMergeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoMergeAttr> NoMergeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoMergeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoMergeAttr> e = NoMergeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoMergeAttr> NoMergeAttr::from(const DeclOrStmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoMergeAttr> NoMergeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoMergeAttr> NoMergeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_MERGE:
      return reinterpret_cast<const NoMergeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoInlineAttr> NoInlineAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoInlineAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoInlineAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoInlineAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoInlineAttr> NoInlineAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoInlineAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoInlineAttrDerivedKinds[] = {
    NoInlineAttr::static_kind(),
};

gap::generator<NoInlineAttr> NoInlineAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoInlineAttr> e = NoInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoInlineAttr> NoInlineAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoInlineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoInlineAttr> e = NoInlineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoInlineAttr> NoInlineAttr::from(const DeclOrStmtAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoInlineAttr> NoInlineAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoInlineAttr> NoInlineAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_INLINE:
      return reinterpret_cast<const NoInlineAttr &>(parent);
    default: return std::nullopt;
  }
}

bool NoInlineAttr::is_clang_no_inline(void) const {
  return impl->reader.getVal12();
}

gap::generator<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DLLImportStaticLocalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DLLImportStaticLocalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DLLImportStaticLocalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DLLImportStaticLocalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDLLImportStaticLocalAttrDerivedKinds[] = {
    DLLImportStaticLocalAttr::static_kind(),
};

gap::generator<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDLLImportStaticLocalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DLLImportStaticLocalAttr> e = DLLImportStaticLocalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDLLImportStaticLocalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DLLImportStaticLocalAttr> e = DLLImportStaticLocalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DLLImportStaticLocalAttr> DLLImportStaticLocalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DLL_IMPORT_STATIC_LOCAL:
      return reinterpret_cast<const DLLImportStaticLocalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DLLImportAttr> DLLImportAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DLLImportAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DLLImportAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DLLImportAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DLLImportAttr> DLLImportAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DLLImportAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDLLImportAttrDerivedKinds[] = {
    DLLImportAttr::static_kind(),
};

gap::generator<DLLImportAttr> DLLImportAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDLLImportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DLLImportAttr> e = DLLImportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DLLImportAttr> DLLImportAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDLLImportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DLLImportAttr> e = DLLImportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DLLImportAttr> DLLImportAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DLLImportAttr> DLLImportAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DLL_IMPORT:
      return reinterpret_cast<const DLLImportAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DLLExportStaticLocalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DLLExportStaticLocalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DLLExportStaticLocalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DLLExportStaticLocalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDLLExportStaticLocalAttrDerivedKinds[] = {
    DLLExportStaticLocalAttr::static_kind(),
};

gap::generator<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDLLExportStaticLocalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DLLExportStaticLocalAttr> e = DLLExportStaticLocalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDLLExportStaticLocalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DLLExportStaticLocalAttr> e = DLLExportStaticLocalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DLLExportStaticLocalAttr> DLLExportStaticLocalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DLL_EXPORT_STATIC_LOCAL:
      return reinterpret_cast<const DLLExportStaticLocalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<DLLExportAttr> DLLExportAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DLLExportAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DLLExportAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DLLExportAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DLLExportAttr> DLLExportAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return DLLExportAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kDLLExportAttrDerivedKinds[] = {
    DLLExportAttr::static_kind(),
};

gap::generator<DLLExportAttr> DLLExportAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kDLLExportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<DLLExportAttr> e = DLLExportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DLLExportAttr> DLLExportAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kDLLExportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<DLLExportAttr> e = DLLExportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DLLExportAttr> DLLExportAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<DLLExportAttr> DLLExportAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::DLL_EXPORT:
      return reinterpret_cast<const DLLExportAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConvergentAttr> ConvergentAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConvergentAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConvergentAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConvergentAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConvergentAttr> ConvergentAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConvergentAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConvergentAttrDerivedKinds[] = {
    ConvergentAttr::static_kind(),
};

gap::generator<ConvergentAttr> ConvergentAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConvergentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConvergentAttr> e = ConvergentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConvergentAttr> ConvergentAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConvergentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConvergentAttr> e = ConvergentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConvergentAttr> ConvergentAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConvergentAttr> ConvergentAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONVERGENT:
      return reinterpret_cast<const ConvergentAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConsumableSetOnReadAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConsumableSetOnReadAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConsumableSetOnReadAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConsumableSetOnReadAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConsumableSetOnReadAttrDerivedKinds[] = {
    ConsumableSetOnReadAttr::static_kind(),
};

gap::generator<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConsumableSetOnReadAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConsumableSetOnReadAttr> e = ConsumableSetOnReadAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConsumableSetOnReadAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConsumableSetOnReadAttr> e = ConsumableSetOnReadAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConsumableSetOnReadAttr> ConsumableSetOnReadAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONSUMABLE_SET_ON_READ:
      return reinterpret_cast<const ConsumableSetOnReadAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConsumableAutoCastAttr> ConsumableAutoCastAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConsumableAutoCastAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConsumableAutoCastAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConsumableAutoCastAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConsumableAutoCastAttr> ConsumableAutoCastAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConsumableAutoCastAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConsumableAutoCastAttrDerivedKinds[] = {
    ConsumableAutoCastAttr::static_kind(),
};

gap::generator<ConsumableAutoCastAttr> ConsumableAutoCastAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConsumableAutoCastAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConsumableAutoCastAttr> e = ConsumableAutoCastAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConsumableAutoCastAttr> ConsumableAutoCastAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConsumableAutoCastAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConsumableAutoCastAttr> e = ConsumableAutoCastAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConsumableAutoCastAttr> ConsumableAutoCastAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConsumableAutoCastAttr> ConsumableAutoCastAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONSUMABLE_AUTO_CAST:
      return reinterpret_cast<const ConsumableAutoCastAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConsumableAttr> ConsumableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConsumableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConsumableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConsumableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConsumableAttr> ConsumableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConsumableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConsumableAttrDerivedKinds[] = {
    ConsumableAttr::static_kind(),
};

gap::generator<ConsumableAttr> ConsumableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConsumableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConsumableAttr> e = ConsumableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConsumableAttr> ConsumableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConsumableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConsumableAttr> e = ConsumableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConsumableAttr> ConsumableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConsumableAttr> ConsumableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONSUMABLE:
      return reinterpret_cast<const ConsumableAttr &>(parent);
    default: return std::nullopt;
  }
}

ConsumableAttrConsumedState ConsumableAttr::default_state(void) const {
  return static_cast<ConsumableAttrConsumedState>(impl->reader.getVal10());
}

gap::generator<ConstructorAttr> ConstructorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstructorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstructorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstructorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConstructorAttr> ConstructorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConstructorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConstructorAttrDerivedKinds[] = {
    ConstructorAttr::static_kind(),
};

gap::generator<ConstructorAttr> ConstructorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConstructorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConstructorAttr> e = ConstructorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstructorAttr> ConstructorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConstructorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConstructorAttr> e = ConstructorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstructorAttr> ConstructorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConstructorAttr> ConstructorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONSTRUCTOR:
      return reinterpret_cast<const ConstructorAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConstInitAttr> ConstInitAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstInitAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstInitAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstInitAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConstInitAttr> ConstInitAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConstInitAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConstInitAttrDerivedKinds[] = {
    ConstInitAttr::static_kind(),
};

gap::generator<ConstInitAttr> ConstInitAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConstInitAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConstInitAttr> e = ConstInitAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstInitAttr> ConstInitAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConstInitAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConstInitAttr> e = ConstInitAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstInitAttr> ConstInitAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConstInitAttr> ConstInitAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONST_INIT:
      return reinterpret_cast<const ConstInitAttr &>(parent);
    default: return std::nullopt;
  }
}

ConstInitAttrSpelling ConstInitAttr::semantic_spelling(void) const {
  return static_cast<ConstInitAttrSpelling>(impl->reader.getVal10());
}

bool ConstInitAttr::is_constinit(void) const {
  return impl->reader.getVal12();
}

gap::generator<ConstAttr> ConstAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConstAttr> ConstAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ConstAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kConstAttrDerivedKinds[] = {
    ConstAttr::static_kind(),
};

gap::generator<ConstAttr> ConstAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kConstAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ConstAttr> e = ConstAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstAttr> ConstAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kConstAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ConstAttr> e = ConstAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstAttr> ConstAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ConstAttr> ConstAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CONST:
      return reinterpret_cast<const ConstAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CommonAttr> CommonAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CommonAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CommonAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CommonAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CommonAttr> CommonAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CommonAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCommonAttrDerivedKinds[] = {
    CommonAttr::static_kind(),
};

gap::generator<CommonAttr> CommonAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCommonAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CommonAttr> e = CommonAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CommonAttr> CommonAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCommonAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CommonAttr> e = CommonAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CommonAttr> CommonAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CommonAttr> CommonAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::COMMON:
      return reinterpret_cast<const CommonAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ColdAttr> ColdAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ColdAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ColdAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ColdAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ColdAttr> ColdAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ColdAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kColdAttrDerivedKinds[] = {
    ColdAttr::static_kind(),
};

gap::generator<ColdAttr> ColdAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kColdAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ColdAttr> e = ColdAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ColdAttr> ColdAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kColdAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ColdAttr> e = ColdAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ColdAttr> ColdAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ColdAttr> ColdAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::COLD:
      return reinterpret_cast<const ColdAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CodeSegAttr> CodeSegAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CodeSegAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CodeSegAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CodeSegAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CodeSegAttr> CodeSegAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CodeSegAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCodeSegAttrDerivedKinds[] = {
    CodeSegAttr::static_kind(),
};

gap::generator<CodeSegAttr> CodeSegAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCodeSegAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CodeSegAttr> e = CodeSegAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CodeSegAttr> CodeSegAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCodeSegAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CodeSegAttr> e = CodeSegAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CodeSegAttr> CodeSegAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CodeSegAttr> CodeSegAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CODE_SEG:
      return reinterpret_cast<const CodeSegAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view CodeSegAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<CmseNSEntryAttr> CmseNSEntryAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CmseNSEntryAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CmseNSEntryAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CmseNSEntryAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CmseNSEntryAttr> CmseNSEntryAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CmseNSEntryAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCmseNSEntryAttrDerivedKinds[] = {
    CmseNSEntryAttr::static_kind(),
};

gap::generator<CmseNSEntryAttr> CmseNSEntryAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCmseNSEntryAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CmseNSEntryAttr> e = CmseNSEntryAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CmseNSEntryAttr> CmseNSEntryAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCmseNSEntryAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CmseNSEntryAttr> e = CmseNSEntryAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CmseNSEntryAttr> CmseNSEntryAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CmseNSEntryAttr> CmseNSEntryAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CMSE_NS_ENTRY:
      return reinterpret_cast<const CmseNSEntryAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CleanupAttr> CleanupAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CleanupAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CleanupAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CleanupAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CleanupAttr> CleanupAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CleanupAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCleanupAttrDerivedKinds[] = {
    CleanupAttr::static_kind(),
};

gap::generator<CleanupAttr> CleanupAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCleanupAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CleanupAttr> e = CleanupAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CleanupAttr> CleanupAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCleanupAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CleanupAttr> e = CleanupAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CleanupAttr> CleanupAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CleanupAttr> CleanupAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CLEANUP:
      return reinterpret_cast<const CleanupAttr &>(parent);
    default: return std::nullopt;
  }
}

FunctionDecl CleanupAttr::function_declaration(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return FunctionDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<CapturedRecordAttr> CapturedRecordAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CapturedRecordAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CapturedRecordAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CapturedRecordAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CapturedRecordAttr> CapturedRecordAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CapturedRecordAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCapturedRecordAttrDerivedKinds[] = {
    CapturedRecordAttr::static_kind(),
};

gap::generator<CapturedRecordAttr> CapturedRecordAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCapturedRecordAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CapturedRecordAttr> e = CapturedRecordAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CapturedRecordAttr> CapturedRecordAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCapturedRecordAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CapturedRecordAttr> e = CapturedRecordAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CapturedRecordAttr> CapturedRecordAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CapturedRecordAttr> CapturedRecordAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CAPTURED_RECORD:
      return reinterpret_cast<const CapturedRecordAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CapabilityAttr> CapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CapabilityAttr> CapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCapabilityAttrDerivedKinds[] = {
    CapabilityAttr::static_kind(),
};

gap::generator<CapabilityAttr> CapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CapabilityAttr> e = CapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CapabilityAttr> CapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CapabilityAttr> e = CapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CapabilityAttr> CapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CapabilityAttr> CapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CAPABILITY:
      return reinterpret_cast<const CapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view CapabilityAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

CapabilityAttrSpelling CapabilityAttr::semantic_spelling(void) const {
  return static_cast<CapabilityAttrSpelling>(impl->reader.getVal10());
}

bool CapabilityAttr::is_shared(void) const {
  return impl->reader.getVal12();
}

gap::generator<CallbackAttr> CallbackAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CallbackAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CallbackAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CallbackAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CallbackAttr> CallbackAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CallbackAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCallbackAttrDerivedKinds[] = {
    CallbackAttr::static_kind(),
};

gap::generator<CallbackAttr> CallbackAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCallbackAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CallbackAttr> e = CallbackAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CallbackAttr> CallbackAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCallbackAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CallbackAttr> e = CallbackAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CallbackAttr> CallbackAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CallbackAttr> CallbackAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CALLBACK:
      return reinterpret_cast<const CallbackAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CallableWhenAttr> CallableWhenAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CallableWhenAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CallableWhenAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CallableWhenAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CallableWhenAttr> CallableWhenAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CallableWhenAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCallableWhenAttrDerivedKinds[] = {
    CallableWhenAttr::static_kind(),
};

gap::generator<CallableWhenAttr> CallableWhenAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCallableWhenAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CallableWhenAttr> e = CallableWhenAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CallableWhenAttr> CallableWhenAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCallableWhenAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CallableWhenAttr> e = CallableWhenAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CallableWhenAttr> CallableWhenAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CallableWhenAttr> CallableWhenAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CALLABLE_WHEN:
      return reinterpret_cast<const CallableWhenAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXX11NoReturnAttr> CXX11NoReturnAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXX11NoReturnAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXX11NoReturnAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXX11NoReturnAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CXX11NoReturnAttr> CXX11NoReturnAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CXX11NoReturnAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCXX11NoReturnAttrDerivedKinds[] = {
    CXX11NoReturnAttr::static_kind(),
};

gap::generator<CXX11NoReturnAttr> CXX11NoReturnAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCXX11NoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CXX11NoReturnAttr> e = CXX11NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXX11NoReturnAttr> CXX11NoReturnAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCXX11NoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CXX11NoReturnAttr> e = CXX11NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXX11NoReturnAttr> CXX11NoReturnAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CXX11NoReturnAttr> CXX11NoReturnAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CXX11_NO_RETURN:
      return reinterpret_cast<const CXX11NoReturnAttr &>(parent);
    default: return std::nullopt;
  }
}

CXX11NoReturnAttrSpelling CXX11NoReturnAttr::semantic_spelling(void) const {
  return static_cast<CXX11NoReturnAttrSpelling>(impl->reader.getVal10());
}

gap::generator<CUDASharedAttr> CUDASharedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDASharedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDASharedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDASharedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDASharedAttr> CUDASharedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDASharedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDASharedAttrDerivedKinds[] = {
    CUDASharedAttr::static_kind(),
};

gap::generator<CUDASharedAttr> CUDASharedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDASharedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDASharedAttr> e = CUDASharedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDASharedAttr> CUDASharedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDASharedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDASharedAttr> e = CUDASharedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDASharedAttr> CUDASharedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDASharedAttr> CUDASharedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_SHARED:
      return reinterpret_cast<const CUDASharedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDALaunchBoundsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDALaunchBoundsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDALaunchBoundsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDALaunchBoundsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDALaunchBoundsAttrDerivedKinds[] = {
    CUDALaunchBoundsAttr::static_kind(),
};

gap::generator<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDALaunchBoundsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDALaunchBoundsAttr> e = CUDALaunchBoundsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDALaunchBoundsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDALaunchBoundsAttr> e = CUDALaunchBoundsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDALaunchBoundsAttr> CUDALaunchBoundsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_LAUNCH_BOUNDS:
      return reinterpret_cast<const CUDALaunchBoundsAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr CUDALaunchBoundsAttr::max_threads(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CUDALaunchBoundsAttr::min_blocks(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDAInvalidTargetAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDAInvalidTargetAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDAInvalidTargetAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDAInvalidTargetAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDAInvalidTargetAttrDerivedKinds[] = {
    CUDAInvalidTargetAttr::static_kind(),
};

gap::generator<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDAInvalidTargetAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDAInvalidTargetAttr> e = CUDAInvalidTargetAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDAInvalidTargetAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDAInvalidTargetAttr> e = CUDAInvalidTargetAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDAInvalidTargetAttr> CUDAInvalidTargetAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_INVALID_TARGET:
      return reinterpret_cast<const CUDAInvalidTargetAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDAHostAttr> CUDAHostAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDAHostAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDAHostAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDAHostAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDAHostAttr> CUDAHostAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDAHostAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDAHostAttrDerivedKinds[] = {
    CUDAHostAttr::static_kind(),
};

gap::generator<CUDAHostAttr> CUDAHostAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDAHostAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDAHostAttr> e = CUDAHostAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDAHostAttr> CUDAHostAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDAHostAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDAHostAttr> e = CUDAHostAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDAHostAttr> CUDAHostAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDAHostAttr> CUDAHostAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_HOST:
      return reinterpret_cast<const CUDAHostAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDAGlobalAttr> CUDAGlobalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDAGlobalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDAGlobalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDAGlobalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDAGlobalAttr> CUDAGlobalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDAGlobalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDAGlobalAttrDerivedKinds[] = {
    CUDAGlobalAttr::static_kind(),
};

gap::generator<CUDAGlobalAttr> CUDAGlobalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDAGlobalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDAGlobalAttr> e = CUDAGlobalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDAGlobalAttr> CUDAGlobalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDAGlobalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDAGlobalAttr> e = CUDAGlobalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDAGlobalAttr> CUDAGlobalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDAGlobalAttr> CUDAGlobalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_GLOBAL:
      return reinterpret_cast<const CUDAGlobalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDADeviceBuiltinTextureTypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDADeviceBuiltinTextureTypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDADeviceBuiltinTextureTypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDADeviceBuiltinTextureTypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDADeviceBuiltinTextureTypeAttrDerivedKinds[] = {
    CUDADeviceBuiltinTextureTypeAttr::static_kind(),
};

gap::generator<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDADeviceBuiltinTextureTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDADeviceBuiltinTextureTypeAttr> e = CUDADeviceBuiltinTextureTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDADeviceBuiltinTextureTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDADeviceBuiltinTextureTypeAttr> e = CUDADeviceBuiltinTextureTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDADeviceBuiltinTextureTypeAttr> CUDADeviceBuiltinTextureTypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_DEVICE_BUILTIN_TEXTURE_TYPE:
      return reinterpret_cast<const CUDADeviceBuiltinTextureTypeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDADeviceBuiltinSurfaceTypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDADeviceBuiltinSurfaceTypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDADeviceBuiltinSurfaceTypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDADeviceBuiltinSurfaceTypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDADeviceBuiltinSurfaceTypeAttrDerivedKinds[] = {
    CUDADeviceBuiltinSurfaceTypeAttr::static_kind(),
};

gap::generator<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDADeviceBuiltinSurfaceTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDADeviceBuiltinSurfaceTypeAttr> e = CUDADeviceBuiltinSurfaceTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDADeviceBuiltinSurfaceTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDADeviceBuiltinSurfaceTypeAttr> e = CUDADeviceBuiltinSurfaceTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDADeviceBuiltinSurfaceTypeAttr> CUDADeviceBuiltinSurfaceTypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_DEVICE_BUILTIN_SURFACE_TYPE:
      return reinterpret_cast<const CUDADeviceBuiltinSurfaceTypeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDADeviceAttr> CUDADeviceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDADeviceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDADeviceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDADeviceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDADeviceAttr> CUDADeviceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDADeviceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDADeviceAttrDerivedKinds[] = {
    CUDADeviceAttr::static_kind(),
};

gap::generator<CUDADeviceAttr> CUDADeviceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDADeviceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDADeviceAttr> e = CUDADeviceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDADeviceAttr> CUDADeviceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDADeviceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDADeviceAttr> e = CUDADeviceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDADeviceAttr> CUDADeviceAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDADeviceAttr> CUDADeviceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_DEVICE:
      return reinterpret_cast<const CUDADeviceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CUDAConstantAttr> CUDAConstantAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDAConstantAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDAConstantAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDAConstantAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CUDAConstantAttr> CUDAConstantAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CUDAConstantAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCUDAConstantAttrDerivedKinds[] = {
    CUDAConstantAttr::static_kind(),
};

gap::generator<CUDAConstantAttr> CUDAConstantAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCUDAConstantAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CUDAConstantAttr> e = CUDAConstantAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDAConstantAttr> CUDAConstantAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCUDAConstantAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CUDAConstantAttr> e = CUDAConstantAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDAConstantAttr> CUDAConstantAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CUDAConstantAttr> CUDAConstantAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CUDA_CONSTANT:
      return reinterpret_cast<const CUDAConstantAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CPUSpecificAttr> CPUSpecificAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CPUSpecificAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CPUSpecificAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CPUSpecificAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CPUSpecificAttr> CPUSpecificAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CPUSpecificAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCPUSpecificAttrDerivedKinds[] = {
    CPUSpecificAttr::static_kind(),
};

gap::generator<CPUSpecificAttr> CPUSpecificAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCPUSpecificAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CPUSpecificAttr> e = CPUSpecificAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CPUSpecificAttr> CPUSpecificAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCPUSpecificAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CPUSpecificAttr> e = CPUSpecificAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CPUSpecificAttr> CPUSpecificAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CPUSpecificAttr> CPUSpecificAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CPU_SPECIFIC:
      return reinterpret_cast<const CPUSpecificAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CPUDispatchAttr> CPUDispatchAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CPUDispatchAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CPUDispatchAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CPUDispatchAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CPUDispatchAttr> CPUDispatchAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CPUDispatchAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCPUDispatchAttrDerivedKinds[] = {
    CPUDispatchAttr::static_kind(),
};

gap::generator<CPUDispatchAttr> CPUDispatchAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCPUDispatchAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CPUDispatchAttr> e = CPUDispatchAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CPUDispatchAttr> CPUDispatchAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCPUDispatchAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CPUDispatchAttr> e = CPUDispatchAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CPUDispatchAttr> CPUDispatchAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CPUDispatchAttr> CPUDispatchAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CPU_DISPATCH:
      return reinterpret_cast<const CPUDispatchAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFUnknownTransferAttr> CFUnknownTransferAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFUnknownTransferAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFUnknownTransferAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFUnknownTransferAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFUnknownTransferAttr> CFUnknownTransferAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFUnknownTransferAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFUnknownTransferAttrDerivedKinds[] = {
    CFUnknownTransferAttr::static_kind(),
};

gap::generator<CFUnknownTransferAttr> CFUnknownTransferAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFUnknownTransferAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFUnknownTransferAttr> e = CFUnknownTransferAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFUnknownTransferAttr> CFUnknownTransferAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFUnknownTransferAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFUnknownTransferAttr> e = CFUnknownTransferAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFUnknownTransferAttr> CFUnknownTransferAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFUnknownTransferAttr> CFUnknownTransferAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_UNKNOWN_TRANSFER:
      return reinterpret_cast<const CFUnknownTransferAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFReturnsRetainedAttr> CFReturnsRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFReturnsRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFReturnsRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFReturnsRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFReturnsRetainedAttr> CFReturnsRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFReturnsRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFReturnsRetainedAttrDerivedKinds[] = {
    CFReturnsRetainedAttr::static_kind(),
};

gap::generator<CFReturnsRetainedAttr> CFReturnsRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFReturnsRetainedAttr> e = CFReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFReturnsRetainedAttr> CFReturnsRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFReturnsRetainedAttr> e = CFReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFReturnsRetainedAttr> CFReturnsRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFReturnsRetainedAttr> CFReturnsRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_RETURNS_RETAINED:
      return reinterpret_cast<const CFReturnsRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFReturnsNotRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFReturnsNotRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFReturnsNotRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFReturnsNotRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFReturnsNotRetainedAttrDerivedKinds[] = {
    CFReturnsNotRetainedAttr::static_kind(),
};

gap::generator<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFReturnsNotRetainedAttr> e = CFReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFReturnsNotRetainedAttr> e = CFReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFReturnsNotRetainedAttr> CFReturnsNotRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_RETURNS_NOT_RETAINED:
      return reinterpret_cast<const CFReturnsNotRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFICanonicalJumpTableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFICanonicalJumpTableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFICanonicalJumpTableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFICanonicalJumpTableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFICanonicalJumpTableAttrDerivedKinds[] = {
    CFICanonicalJumpTableAttr::static_kind(),
};

gap::generator<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFICanonicalJumpTableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFICanonicalJumpTableAttr> e = CFICanonicalJumpTableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFICanonicalJumpTableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFICanonicalJumpTableAttr> e = CFICanonicalJumpTableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFICanonicalJumpTableAttr> CFICanonicalJumpTableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CFI_CANONICAL_JUMP_TABLE:
      return reinterpret_cast<const CFICanonicalJumpTableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFGuardAttr> CFGuardAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFGuardAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFGuardAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFGuardAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFGuardAttr> CFGuardAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFGuardAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFGuardAttrDerivedKinds[] = {
    CFGuardAttr::static_kind(),
};

gap::generator<CFGuardAttr> CFGuardAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFGuardAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFGuardAttr> e = CFGuardAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFGuardAttr> CFGuardAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFGuardAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFGuardAttr> e = CFGuardAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFGuardAttr> CFGuardAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFGuardAttr> CFGuardAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_GUARD:
      return reinterpret_cast<const CFGuardAttr &>(parent);
    default: return std::nullopt;
  }
}

CFGuardAttrGuardArg CFGuardAttr::guard(void) const {
  return static_cast<CFGuardAttrGuardArg>(impl->reader.getVal10());
}

gap::generator<CFAuditedTransferAttr> CFAuditedTransferAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFAuditedTransferAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFAuditedTransferAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFAuditedTransferAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFAuditedTransferAttr> CFAuditedTransferAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFAuditedTransferAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFAuditedTransferAttrDerivedKinds[] = {
    CFAuditedTransferAttr::static_kind(),
};

gap::generator<CFAuditedTransferAttr> CFAuditedTransferAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFAuditedTransferAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFAuditedTransferAttr> e = CFAuditedTransferAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFAuditedTransferAttr> CFAuditedTransferAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFAuditedTransferAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFAuditedTransferAttr> e = CFAuditedTransferAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFAuditedTransferAttr> CFAuditedTransferAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFAuditedTransferAttr> CFAuditedTransferAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_AUDITED_TRANSFER:
      return reinterpret_cast<const CFAuditedTransferAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CDeclAttr> CDeclAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CDeclAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CDeclAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CDeclAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CDeclAttr> CDeclAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CDeclAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCDeclAttrDerivedKinds[] = {
    CDeclAttr::static_kind(),
};

gap::generator<CDeclAttr> CDeclAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CDeclAttr> e = CDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CDeclAttr> CDeclAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CDeclAttr> e = CDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CDeclAttr> CDeclAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CDeclAttr> CDeclAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::C_DECL:
      return reinterpret_cast<const CDeclAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<C11NoReturnAttr> C11NoReturnAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = C11NoReturnAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool C11NoReturnAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : C11NoReturnAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<C11NoReturnAttr> C11NoReturnAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return C11NoReturnAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kC11NoReturnAttrDerivedKinds[] = {
    C11NoReturnAttr::static_kind(),
};

gap::generator<C11NoReturnAttr> C11NoReturnAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kC11NoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<C11NoReturnAttr> e = C11NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<C11NoReturnAttr> C11NoReturnAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kC11NoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<C11NoReturnAttr> e = C11NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<C11NoReturnAttr> C11NoReturnAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<C11NoReturnAttr> C11NoReturnAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::C11_NO_RETURN:
      return reinterpret_cast<const C11NoReturnAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<BuiltinAttr> BuiltinAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BuiltinAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BuiltinAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BuiltinAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BuiltinAttr> BuiltinAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BuiltinAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBuiltinAttrDerivedKinds[] = {
    BuiltinAttr::static_kind(),
};

gap::generator<BuiltinAttr> BuiltinAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BuiltinAttr> e = BuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BuiltinAttr> BuiltinAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBuiltinAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BuiltinAttr> e = BuiltinAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BuiltinAttr> BuiltinAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<BuiltinAttr> BuiltinAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BUILTIN:
      return reinterpret_cast<const BuiltinAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<BlocksAttr> BlocksAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BlocksAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BlocksAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BlocksAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BlocksAttr> BlocksAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BlocksAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBlocksAttrDerivedKinds[] = {
    BlocksAttr::static_kind(),
};

gap::generator<BlocksAttr> BlocksAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBlocksAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BlocksAttr> e = BlocksAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BlocksAttr> BlocksAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBlocksAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BlocksAttr> e = BlocksAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BlocksAttr> BlocksAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<BlocksAttr> BlocksAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BLOCKS:
      return reinterpret_cast<const BlocksAttr &>(parent);
    default: return std::nullopt;
  }
}

BlocksAttrBlockType BlocksAttr::type(void) const {
  return static_cast<BlocksAttrBlockType>(impl->reader.getVal10());
}

gap::generator<BTFDeclTagAttr> BTFDeclTagAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BTFDeclTagAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BTFDeclTagAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BTFDeclTagAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BTFDeclTagAttr> BTFDeclTagAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BTFDeclTagAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBTFDeclTagAttrDerivedKinds[] = {
    BTFDeclTagAttr::static_kind(),
};

gap::generator<BTFDeclTagAttr> BTFDeclTagAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBTFDeclTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BTFDeclTagAttr> e = BTFDeclTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BTFDeclTagAttr> BTFDeclTagAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBTFDeclTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BTFDeclTagAttr> e = BTFDeclTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BTFDeclTagAttr> BTFDeclTagAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<BTFDeclTagAttr> BTFDeclTagAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BTF_DECL_TAG:
      return reinterpret_cast<const BTFDeclTagAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view BTFDeclTagAttr::btf_decl_tag(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BPFPreserveAccessIndexAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BPFPreserveAccessIndexAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BPFPreserveAccessIndexAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BPFPreserveAccessIndexAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBPFPreserveAccessIndexAttrDerivedKinds[] = {
    BPFPreserveAccessIndexAttr::static_kind(),
};

gap::generator<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBPFPreserveAccessIndexAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BPFPreserveAccessIndexAttr> e = BPFPreserveAccessIndexAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBPFPreserveAccessIndexAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BPFPreserveAccessIndexAttr> e = BPFPreserveAccessIndexAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<BPFPreserveAccessIndexAttr> BPFPreserveAccessIndexAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BPF_PRESERVE_ACCESS_INDEX:
      return reinterpret_cast<const BPFPreserveAccessIndexAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AvailabilityAttr> AvailabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AvailabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AvailabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AvailabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AvailabilityAttr> AvailabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AvailabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAvailabilityAttrDerivedKinds[] = {
    AvailabilityAttr::static_kind(),
};

gap::generator<AvailabilityAttr> AvailabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAvailabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AvailabilityAttr> e = AvailabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AvailabilityAttr> AvailabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAvailabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AvailabilityAttr> e = AvailabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AvailabilityAttr> AvailabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AvailabilityAttr> AvailabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AVAILABILITY:
      return reinterpret_cast<const AvailabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AvailabilityAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

std::string_view AvailabilityAttr::replacement(void) const {
  capnp::Text::Reader data = impl->reader.getVal17();
  return std::string_view(data.cStr(), data.size());
}

bool AvailabilityAttr::strict(void) const {
  return impl->reader.getVal12();
}

bool AvailabilityAttr::unavailable(void) const {
  return impl->reader.getVal13();
}

gap::generator<AssumptionAttr> AssumptionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AssumptionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AssumptionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AssumptionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AssumptionAttr> AssumptionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AssumptionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAssumptionAttrDerivedKinds[] = {
    AssumptionAttr::static_kind(),
};

gap::generator<AssumptionAttr> AssumptionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAssumptionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AssumptionAttr> e = AssumptionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AssumptionAttr> AssumptionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAssumptionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AssumptionAttr> e = AssumptionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AssumptionAttr> AssumptionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AssumptionAttr> AssumptionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASSUMPTION:
      return reinterpret_cast<const AssumptionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AssumptionAttr::assumption(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<AssumeAlignedAttr> AssumeAlignedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AssumeAlignedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AssumeAlignedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AssumeAlignedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AssumeAlignedAttr> AssumeAlignedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AssumeAlignedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAssumeAlignedAttrDerivedKinds[] = {
    AssumeAlignedAttr::static_kind(),
};

gap::generator<AssumeAlignedAttr> AssumeAlignedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAssumeAlignedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AssumeAlignedAttr> e = AssumeAlignedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AssumeAlignedAttr> AssumeAlignedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAssumeAlignedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AssumeAlignedAttr> e = AssumeAlignedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AssumeAlignedAttr> AssumeAlignedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AssumeAlignedAttr> AssumeAlignedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASSUME_ALIGNED:
      return reinterpret_cast<const AssumeAlignedAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr AssumeAlignedAttr::alignment(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> AssumeAlignedAttr::offset(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal16();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<AssertSharedLockAttr> AssertSharedLockAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AssertSharedLockAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AssertSharedLockAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AssertSharedLockAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AssertSharedLockAttr> AssertSharedLockAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AssertSharedLockAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAssertSharedLockAttrDerivedKinds[] = {
    AssertSharedLockAttr::static_kind(),
};

gap::generator<AssertSharedLockAttr> AssertSharedLockAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAssertSharedLockAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AssertSharedLockAttr> e = AssertSharedLockAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AssertSharedLockAttr> AssertSharedLockAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAssertSharedLockAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AssertSharedLockAttr> e = AssertSharedLockAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AssertSharedLockAttr> AssertSharedLockAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AssertSharedLockAttr> AssertSharedLockAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASSERT_SHARED_LOCK:
      return reinterpret_cast<const AssertSharedLockAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AssertExclusiveLockAttr> AssertExclusiveLockAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AssertExclusiveLockAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AssertExclusiveLockAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AssertExclusiveLockAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AssertExclusiveLockAttr> AssertExclusiveLockAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AssertExclusiveLockAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAssertExclusiveLockAttrDerivedKinds[] = {
    AssertExclusiveLockAttr::static_kind(),
};

gap::generator<AssertExclusiveLockAttr> AssertExclusiveLockAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAssertExclusiveLockAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AssertExclusiveLockAttr> e = AssertExclusiveLockAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AssertExclusiveLockAttr> AssertExclusiveLockAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAssertExclusiveLockAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AssertExclusiveLockAttr> e = AssertExclusiveLockAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AssertExclusiveLockAttr> AssertExclusiveLockAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AssertExclusiveLockAttr> AssertExclusiveLockAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASSERT_EXCLUSIVE_LOCK:
      return reinterpret_cast<const AssertExclusiveLockAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AssertCapabilityAttr> AssertCapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AssertCapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AssertCapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AssertCapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AssertCapabilityAttr> AssertCapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AssertCapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAssertCapabilityAttrDerivedKinds[] = {
    AssertCapabilityAttr::static_kind(),
};

gap::generator<AssertCapabilityAttr> AssertCapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAssertCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AssertCapabilityAttr> e = AssertCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AssertCapabilityAttr> AssertCapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAssertCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AssertCapabilityAttr> e = AssertCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AssertCapabilityAttr> AssertCapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AssertCapabilityAttr> AssertCapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASSERT_CAPABILITY:
      return reinterpret_cast<const AssertCapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

AssertCapabilityAttrSpelling AssertCapabilityAttr::semantic_spelling(void) const {
  return static_cast<AssertCapabilityAttrSpelling>(impl->reader.getVal10());
}

bool AssertCapabilityAttr::is_shared(void) const {
  return impl->reader.getVal12();
}

gap::generator<AsmLabelAttr> AsmLabelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AsmLabelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AsmLabelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AsmLabelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AsmLabelAttr> AsmLabelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AsmLabelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAsmLabelAttrDerivedKinds[] = {
    AsmLabelAttr::static_kind(),
};

gap::generator<AsmLabelAttr> AsmLabelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAsmLabelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AsmLabelAttr> e = AsmLabelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AsmLabelAttr> AsmLabelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAsmLabelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AsmLabelAttr> e = AsmLabelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AsmLabelAttr> AsmLabelAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AsmLabelAttr> AsmLabelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ASM_LABEL:
      return reinterpret_cast<const AsmLabelAttr &>(parent);
    default: return std::nullopt;
  }
}

bool AsmLabelAttr::is_literal_label(void) const {
  return impl->reader.getVal12();
}

std::string_view AsmLabelAttr::label(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<ArtificialAttr> ArtificialAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArtificialAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArtificialAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArtificialAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArtificialAttr> ArtificialAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ArtificialAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kArtificialAttrDerivedKinds[] = {
    ArtificialAttr::static_kind(),
};

gap::generator<ArtificialAttr> ArtificialAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kArtificialAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ArtificialAttr> e = ArtificialAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArtificialAttr> ArtificialAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kArtificialAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ArtificialAttr> e = ArtificialAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArtificialAttr> ArtificialAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ArtificialAttr> ArtificialAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARTIFICIAL:
      return reinterpret_cast<const ArtificialAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArmBuiltinAliasAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArmBuiltinAliasAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArmBuiltinAliasAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ArmBuiltinAliasAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kArmBuiltinAliasAttrDerivedKinds[] = {
    ArmBuiltinAliasAttr::static_kind(),
};

gap::generator<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kArmBuiltinAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ArmBuiltinAliasAttr> e = ArmBuiltinAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kArmBuiltinAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ArmBuiltinAliasAttr> e = ArmBuiltinAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ArmBuiltinAliasAttr> ArmBuiltinAliasAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARM_BUILTIN_ALIAS:
      return reinterpret_cast<const ArmBuiltinAliasAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArgumentWithTypeTagAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArgumentWithTypeTagAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArgumentWithTypeTagAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ArgumentWithTypeTagAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kArgumentWithTypeTagAttrDerivedKinds[] = {
    ArgumentWithTypeTagAttr::static_kind(),
};

gap::generator<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kArgumentWithTypeTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ArgumentWithTypeTagAttr> e = ArgumentWithTypeTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kArgumentWithTypeTagAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ArgumentWithTypeTagAttr> e = ArgumentWithTypeTagAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ArgumentWithTypeTagAttr> ArgumentWithTypeTagAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARGUMENT_WITH_TYPE_TAG:
      return reinterpret_cast<const ArgumentWithTypeTagAttr &>(parent);
    default: return std::nullopt;
  }
}

bool ArgumentWithTypeTagAttr::is_pointer(void) const {
  return impl->reader.getVal12();
}

ArgumentWithTypeTagAttrSpelling ArgumentWithTypeTagAttr::semantic_spelling(void) const {
  return static_cast<ArgumentWithTypeTagAttrSpelling>(impl->reader.getVal10());
}

gap::generator<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArcWeakrefUnavailableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArcWeakrefUnavailableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArcWeakrefUnavailableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ArcWeakrefUnavailableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kArcWeakrefUnavailableAttrDerivedKinds[] = {
    ArcWeakrefUnavailableAttr::static_kind(),
};

gap::generator<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kArcWeakrefUnavailableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ArcWeakrefUnavailableAttr> e = ArcWeakrefUnavailableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kArcWeakrefUnavailableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ArcWeakrefUnavailableAttr> e = ArcWeakrefUnavailableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ArcWeakrefUnavailableAttr> ArcWeakrefUnavailableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARC_WEAKREF_UNAVAILABLE:
      return reinterpret_cast<const ArcWeakrefUnavailableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnyX86NoCfCheckAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnyX86NoCfCheckAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnyX86NoCfCheckAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnyX86NoCfCheckAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnyX86NoCfCheckAttrDerivedKinds[] = {
    AnyX86NoCfCheckAttr::static_kind(),
};

gap::generator<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnyX86NoCfCheckAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnyX86NoCfCheckAttr> e = AnyX86NoCfCheckAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnyX86NoCfCheckAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnyX86NoCfCheckAttr> e = AnyX86NoCfCheckAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnyX86NoCfCheckAttr> AnyX86NoCfCheckAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANY_X86_NO_CF_CHECK:
      return reinterpret_cast<const AnyX86NoCfCheckAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnyX86NoCallerSavedRegistersAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnyX86NoCallerSavedRegistersAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnyX86NoCallerSavedRegistersAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnyX86NoCallerSavedRegistersAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnyX86NoCallerSavedRegistersAttrDerivedKinds[] = {
    AnyX86NoCallerSavedRegistersAttr::static_kind(),
};

gap::generator<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnyX86NoCallerSavedRegistersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnyX86NoCallerSavedRegistersAttr> e = AnyX86NoCallerSavedRegistersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnyX86NoCallerSavedRegistersAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnyX86NoCallerSavedRegistersAttr> e = AnyX86NoCallerSavedRegistersAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnyX86NoCallerSavedRegistersAttr> AnyX86NoCallerSavedRegistersAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANY_X86_NO_CALLER_SAVED_REGISTERS:
      return reinterpret_cast<const AnyX86NoCallerSavedRegistersAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnyX86InterruptAttr> AnyX86InterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnyX86InterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnyX86InterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnyX86InterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnyX86InterruptAttr> AnyX86InterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnyX86InterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnyX86InterruptAttrDerivedKinds[] = {
    AnyX86InterruptAttr::static_kind(),
};

gap::generator<AnyX86InterruptAttr> AnyX86InterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnyX86InterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnyX86InterruptAttr> e = AnyX86InterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnyX86InterruptAttr> AnyX86InterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnyX86InterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnyX86InterruptAttr> e = AnyX86InterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnyX86InterruptAttr> AnyX86InterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnyX86InterruptAttr> AnyX86InterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANY_X86_INTERRUPT:
      return reinterpret_cast<const AnyX86InterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnalyzerNoReturnAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnalyzerNoReturnAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnalyzerNoReturnAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnalyzerNoReturnAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnalyzerNoReturnAttrDerivedKinds[] = {
    AnalyzerNoReturnAttr::static_kind(),
};

gap::generator<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnalyzerNoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnalyzerNoReturnAttr> e = AnalyzerNoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnalyzerNoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnalyzerNoReturnAttr> e = AnalyzerNoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnalyzerNoReturnAttr> AnalyzerNoReturnAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANALYZER_NO_RETURN:
      return reinterpret_cast<const AnalyzerNoReturnAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AlwaysDestroyAttr> AlwaysDestroyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlwaysDestroyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlwaysDestroyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlwaysDestroyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlwaysDestroyAttr> AlwaysDestroyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlwaysDestroyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlwaysDestroyAttrDerivedKinds[] = {
    AlwaysDestroyAttr::static_kind(),
};

gap::generator<AlwaysDestroyAttr> AlwaysDestroyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlwaysDestroyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlwaysDestroyAttr> e = AlwaysDestroyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlwaysDestroyAttr> AlwaysDestroyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlwaysDestroyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlwaysDestroyAttr> e = AlwaysDestroyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlwaysDestroyAttr> AlwaysDestroyAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlwaysDestroyAttr> AlwaysDestroyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALWAYS_DESTROY:
      return reinterpret_cast<const AlwaysDestroyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AllocSizeAttr> AllocSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AllocSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AllocSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AllocSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AllocSizeAttr> AllocSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AllocSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAllocSizeAttrDerivedKinds[] = {
    AllocSizeAttr::static_kind(),
};

gap::generator<AllocSizeAttr> AllocSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAllocSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AllocSizeAttr> e = AllocSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AllocSizeAttr> AllocSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAllocSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AllocSizeAttr> e = AllocSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AllocSizeAttr> AllocSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AllocSizeAttr> AllocSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALLOC_SIZE:
      return reinterpret_cast<const AllocSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AllocAlignAttr> AllocAlignAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AllocAlignAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AllocAlignAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AllocAlignAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AllocAlignAttr> AllocAlignAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AllocAlignAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAllocAlignAttrDerivedKinds[] = {
    AllocAlignAttr::static_kind(),
};

gap::generator<AllocAlignAttr> AllocAlignAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAllocAlignAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AllocAlignAttr> e = AllocAlignAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AllocAlignAttr> AllocAlignAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAllocAlignAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AllocAlignAttr> e = AllocAlignAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AllocAlignAttr> AllocAlignAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AllocAlignAttr> AllocAlignAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALLOC_ALIGN:
      return reinterpret_cast<const AllocAlignAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AlignedAttr> AlignedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlignedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlignedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlignedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlignedAttr> AlignedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlignedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlignedAttrDerivedKinds[] = {
    AlignedAttr::static_kind(),
};

gap::generator<AlignedAttr> AlignedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlignedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlignedAttr> e = AlignedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlignedAttr> AlignedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlignedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlignedAttr> e = AlignedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlignedAttr> AlignedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlignedAttr> AlignedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALIGNED:
      return reinterpret_cast<const AlignedAttr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> AlignedAttr::alignment_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> AlignedAttr::alignment_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal16();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

AlignedAttrSpelling AlignedAttr::semantic_spelling(void) const {
  return static_cast<AlignedAttrSpelling>(impl->reader.getVal10());
}

bool AlignedAttr::is_alignas(void) const {
  return impl->reader.getVal12();
}

bool AlignedAttr::is_alignment_dependent(void) const {
  return impl->reader.getVal13();
}

bool AlignedAttr::is_alignment_error_dependent(void) const {
  return impl->reader.getVal18();
}

bool AlignedAttr::is_alignment_expression(void) const {
  return impl->reader.getVal19();
}

bool AlignedAttr::is_c11(void) const {
  return impl->reader.getVal20();
}

bool AlignedAttr::is_declspec(void) const {
  return impl->reader.getVal21();
}

bool AlignedAttr::is_gnu(void) const {
  return impl->reader.getVal22();
}

gap::generator<AlignNaturalAttr> AlignNaturalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlignNaturalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlignNaturalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlignNaturalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlignNaturalAttr> AlignNaturalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlignNaturalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlignNaturalAttrDerivedKinds[] = {
    AlignNaturalAttr::static_kind(),
};

gap::generator<AlignNaturalAttr> AlignNaturalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlignNaturalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlignNaturalAttr> e = AlignNaturalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlignNaturalAttr> AlignNaturalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlignNaturalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlignNaturalAttr> e = AlignNaturalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlignNaturalAttr> AlignNaturalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlignNaturalAttr> AlignNaturalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALIGN_NATURAL:
      return reinterpret_cast<const AlignNaturalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AlignMac68kAttr> AlignMac68kAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AlignMac68kAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AlignMac68kAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AlignMac68kAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AlignMac68kAttr> AlignMac68kAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AlignMac68kAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAlignMac68kAttrDerivedKinds[] = {
    AlignMac68kAttr::static_kind(),
};

gap::generator<AlignMac68kAttr> AlignMac68kAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAlignMac68kAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AlignMac68kAttr> e = AlignMac68kAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AlignMac68kAttr> AlignMac68kAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAlignMac68kAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AlignMac68kAttr> e = AlignMac68kAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AlignMac68kAttr> AlignMac68kAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AlignMac68kAttr> AlignMac68kAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ALIGN_MAC68K:
      return reinterpret_cast<const AlignMac68kAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AcquiredBeforeAttr> AcquiredBeforeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AcquiredBeforeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AcquiredBeforeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AcquiredBeforeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AcquiredBeforeAttr> AcquiredBeforeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AcquiredBeforeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAcquiredBeforeAttrDerivedKinds[] = {
    AcquiredBeforeAttr::static_kind(),
};

gap::generator<AcquiredBeforeAttr> AcquiredBeforeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAcquiredBeforeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AcquiredBeforeAttr> e = AcquiredBeforeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AcquiredBeforeAttr> AcquiredBeforeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAcquiredBeforeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AcquiredBeforeAttr> e = AcquiredBeforeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AcquiredBeforeAttr> AcquiredBeforeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AcquiredBeforeAttr> AcquiredBeforeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ACQUIRED_BEFORE:
      return reinterpret_cast<const AcquiredBeforeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AcquiredAfterAttr> AcquiredAfterAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AcquiredAfterAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AcquiredAfterAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AcquiredAfterAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AcquiredAfterAttr> AcquiredAfterAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AcquiredAfterAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAcquiredAfterAttrDerivedKinds[] = {
    AcquiredAfterAttr::static_kind(),
};

gap::generator<AcquiredAfterAttr> AcquiredAfterAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAcquiredAfterAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AcquiredAfterAttr> e = AcquiredAfterAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AcquiredAfterAttr> AcquiredAfterAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAcquiredAfterAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AcquiredAfterAttr> e = AcquiredAfterAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AcquiredAfterAttr> AcquiredAfterAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AcquiredAfterAttr> AcquiredAfterAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ACQUIRED_AFTER:
      return reinterpret_cast<const AcquiredAfterAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AcquireHandleAttr> AcquireHandleAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AcquireHandleAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AcquireHandleAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AcquireHandleAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AcquireHandleAttr> AcquireHandleAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AcquireHandleAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAcquireHandleAttrDerivedKinds[] = {
    AcquireHandleAttr::static_kind(),
};

gap::generator<AcquireHandleAttr> AcquireHandleAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAcquireHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AcquireHandleAttr> e = AcquireHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AcquireHandleAttr> AcquireHandleAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAcquireHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AcquireHandleAttr> e = AcquireHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AcquireHandleAttr> AcquireHandleAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AcquireHandleAttr> AcquireHandleAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ACQUIRE_HANDLE:
      return reinterpret_cast<const AcquireHandleAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AcquireHandleAttr::handle_type(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<AcquireCapabilityAttr> AcquireCapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AcquireCapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AcquireCapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AcquireCapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AcquireCapabilityAttr> AcquireCapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AcquireCapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAcquireCapabilityAttrDerivedKinds[] = {
    AcquireCapabilityAttr::static_kind(),
};

gap::generator<AcquireCapabilityAttr> AcquireCapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAcquireCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AcquireCapabilityAttr> e = AcquireCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AcquireCapabilityAttr> AcquireCapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAcquireCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AcquireCapabilityAttr> e = AcquireCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AcquireCapabilityAttr> AcquireCapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AcquireCapabilityAttr> AcquireCapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ACQUIRE_CAPABILITY:
      return reinterpret_cast<const AcquireCapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

AcquireCapabilityAttrSpelling AcquireCapabilityAttr::semantic_spelling(void) const {
  return static_cast<AcquireCapabilityAttrSpelling>(impl->reader.getVal10());
}

bool AcquireCapabilityAttr::is_shared(void) const {
  return impl->reader.getVal12();
}

gap::generator<AVRSignalAttr> AVRSignalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AVRSignalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AVRSignalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AVRSignalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AVRSignalAttr> AVRSignalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AVRSignalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAVRSignalAttrDerivedKinds[] = {
    AVRSignalAttr::static_kind(),
};

gap::generator<AVRSignalAttr> AVRSignalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAVRSignalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AVRSignalAttr> e = AVRSignalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AVRSignalAttr> AVRSignalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAVRSignalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AVRSignalAttr> e = AVRSignalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AVRSignalAttr> AVRSignalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AVRSignalAttr> AVRSignalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AVR_SIGNAL:
      return reinterpret_cast<const AVRSignalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AVRInterruptAttr> AVRInterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AVRInterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AVRInterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AVRInterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AVRInterruptAttr> AVRInterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AVRInterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAVRInterruptAttrDerivedKinds[] = {
    AVRInterruptAttr::static_kind(),
};

gap::generator<AVRInterruptAttr> AVRInterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAVRInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AVRInterruptAttr> e = AVRInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AVRInterruptAttr> AVRInterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAVRInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AVRInterruptAttr> e = AVRInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AVRInterruptAttr> AVRInterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AVRInterruptAttr> AVRInterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AVR_INTERRUPT:
      return reinterpret_cast<const AVRInterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ARMInterruptAttr> ARMInterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ARMInterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ARMInterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ARMInterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ARMInterruptAttr> ARMInterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ARMInterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kARMInterruptAttrDerivedKinds[] = {
    ARMInterruptAttr::static_kind(),
};

gap::generator<ARMInterruptAttr> ARMInterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kARMInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ARMInterruptAttr> e = ARMInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ARMInterruptAttr> ARMInterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kARMInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ARMInterruptAttr> e = ARMInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ARMInterruptAttr> ARMInterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ARMInterruptAttr> ARMInterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ARM_INTERRUPT:
      return reinterpret_cast<const ARMInterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

ARMInterruptAttrInterruptType ARMInterruptAttr::interrupt(void) const {
  return static_cast<ARMInterruptAttrInterruptType>(impl->reader.getVal10());
}

gap::generator<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AMDGPUWavesPerEUAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AMDGPUWavesPerEUAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AMDGPUWavesPerEUAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AMDGPUWavesPerEUAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAMDGPUWavesPerEUAttrDerivedKinds[] = {
    AMDGPUWavesPerEUAttr::static_kind(),
};

gap::generator<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAMDGPUWavesPerEUAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AMDGPUWavesPerEUAttr> e = AMDGPUWavesPerEUAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAMDGPUWavesPerEUAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AMDGPUWavesPerEUAttr> e = AMDGPUWavesPerEUAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AMDGPUWavesPerEUAttr> AMDGPUWavesPerEUAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AMDGPU_WAVES_PER_EU:
      return reinterpret_cast<const AMDGPUWavesPerEUAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr AMDGPUWavesPerEUAttr::max(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr AMDGPUWavesPerEUAttr::min(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AMDGPUNumVGPRAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AMDGPUNumVGPRAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AMDGPUNumVGPRAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AMDGPUNumVGPRAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAMDGPUNumVGPRAttrDerivedKinds[] = {
    AMDGPUNumVGPRAttr::static_kind(),
};

gap::generator<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAMDGPUNumVGPRAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AMDGPUNumVGPRAttr> e = AMDGPUNumVGPRAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAMDGPUNumVGPRAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AMDGPUNumVGPRAttr> e = AMDGPUNumVGPRAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AMDGPUNumVGPRAttr> AMDGPUNumVGPRAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AMDGPU_NUM_VGPR:
      return reinterpret_cast<const AMDGPUNumVGPRAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AMDGPUNumSGPRAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AMDGPUNumSGPRAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AMDGPUNumSGPRAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AMDGPUNumSGPRAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAMDGPUNumSGPRAttrDerivedKinds[] = {
    AMDGPUNumSGPRAttr::static_kind(),
};

gap::generator<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAMDGPUNumSGPRAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AMDGPUNumSGPRAttr> e = AMDGPUNumSGPRAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAMDGPUNumSGPRAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AMDGPUNumSGPRAttr> e = AMDGPUNumSGPRAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AMDGPUNumSGPRAttr> AMDGPUNumSGPRAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AMDGPU_NUM_SGPR:
      return reinterpret_cast<const AMDGPUNumSGPRAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AMDGPUKernelCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AMDGPUKernelCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AMDGPUKernelCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AMDGPUKernelCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAMDGPUKernelCallAttrDerivedKinds[] = {
    AMDGPUKernelCallAttr::static_kind(),
};

gap::generator<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAMDGPUKernelCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AMDGPUKernelCallAttr> e = AMDGPUKernelCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAMDGPUKernelCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AMDGPUKernelCallAttr> e = AMDGPUKernelCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AMDGPUKernelCallAttr> AMDGPUKernelCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AMDGPU_KERNEL_CALL:
      return reinterpret_cast<const AMDGPUKernelCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AMDGPUFlatWorkGroupSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AMDGPUFlatWorkGroupSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AMDGPUFlatWorkGroupSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AMDGPUFlatWorkGroupSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAMDGPUFlatWorkGroupSizeAttrDerivedKinds[] = {
    AMDGPUFlatWorkGroupSizeAttr::static_kind(),
};

gap::generator<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAMDGPUFlatWorkGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AMDGPUFlatWorkGroupSizeAttr> e = AMDGPUFlatWorkGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAMDGPUFlatWorkGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AMDGPUFlatWorkGroupSizeAttr> e = AMDGPUFlatWorkGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AMDGPUFlatWorkGroupSizeAttr> AMDGPUFlatWorkGroupSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::AMDGPU_FLAT_WORK_GROUP_SIZE:
      return reinterpret_cast<const AMDGPUFlatWorkGroupSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr AMDGPUFlatWorkGroupSizeAttr::max(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr AMDGPUFlatWorkGroupSizeAttr::min(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<AArch64VectorPcsAttr> AArch64VectorPcsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AArch64VectorPcsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AArch64VectorPcsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AArch64VectorPcsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AArch64VectorPcsAttr> AArch64VectorPcsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AArch64VectorPcsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAArch64VectorPcsAttrDerivedKinds[] = {
    AArch64VectorPcsAttr::static_kind(),
};

gap::generator<AArch64VectorPcsAttr> AArch64VectorPcsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAArch64VectorPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AArch64VectorPcsAttr> e = AArch64VectorPcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AArch64VectorPcsAttr> AArch64VectorPcsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAArch64VectorPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AArch64VectorPcsAttr> e = AArch64VectorPcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AArch64VectorPcsAttr> AArch64VectorPcsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AArch64VectorPcsAttr> AArch64VectorPcsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::A_ARCH64_VECTOR_PCS:
      return reinterpret_cast<const AArch64VectorPcsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AArch64SVEPcsAttr> AArch64SVEPcsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AArch64SVEPcsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AArch64SVEPcsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AArch64SVEPcsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AArch64SVEPcsAttr> AArch64SVEPcsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AArch64SVEPcsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAArch64SVEPcsAttrDerivedKinds[] = {
    AArch64SVEPcsAttr::static_kind(),
};

gap::generator<AArch64SVEPcsAttr> AArch64SVEPcsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAArch64SVEPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AArch64SVEPcsAttr> e = AArch64SVEPcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AArch64SVEPcsAttr> AArch64SVEPcsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAArch64SVEPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AArch64SVEPcsAttr> e = AArch64SVEPcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AArch64SVEPcsAttr> AArch64SVEPcsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AArch64SVEPcsAttr> AArch64SVEPcsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::A_ARCH64_SVE_PCS:
      return reinterpret_cast<const AArch64SVEPcsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ZeroCallUsedRegsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ZeroCallUsedRegsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ZeroCallUsedRegsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ZeroCallUsedRegsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kZeroCallUsedRegsAttrDerivedKinds[] = {
    ZeroCallUsedRegsAttr::static_kind(),
};

gap::generator<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kZeroCallUsedRegsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ZeroCallUsedRegsAttr> e = ZeroCallUsedRegsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kZeroCallUsedRegsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ZeroCallUsedRegsAttr> e = ZeroCallUsedRegsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ZeroCallUsedRegsAttr> ZeroCallUsedRegsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ZERO_CALL_USED_REGS:
      return reinterpret_cast<const ZeroCallUsedRegsAttr &>(parent);
    default: return std::nullopt;
  }
}

ZeroCallUsedRegsAttrZeroCallUsedRegsKind ZeroCallUsedRegsAttr::zero_call_used_regs(void) const {
  return static_cast<ZeroCallUsedRegsAttrZeroCallUsedRegsKind>(impl->reader.getVal10());
}

gap::generator<XRayLogArgsAttr> XRayLogArgsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = XRayLogArgsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool XRayLogArgsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : XRayLogArgsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<XRayLogArgsAttr> XRayLogArgsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return XRayLogArgsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kXRayLogArgsAttrDerivedKinds[] = {
    XRayLogArgsAttr::static_kind(),
};

gap::generator<XRayLogArgsAttr> XRayLogArgsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kXRayLogArgsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<XRayLogArgsAttr> e = XRayLogArgsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<XRayLogArgsAttr> XRayLogArgsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kXRayLogArgsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<XRayLogArgsAttr> e = XRayLogArgsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<XRayLogArgsAttr> XRayLogArgsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<XRayLogArgsAttr> XRayLogArgsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::X_RAY_LOG_ARGS:
      return reinterpret_cast<const XRayLogArgsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<XRayInstrumentAttr> XRayInstrumentAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = XRayInstrumentAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool XRayInstrumentAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : XRayInstrumentAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<XRayInstrumentAttr> XRayInstrumentAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return XRayInstrumentAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kXRayInstrumentAttrDerivedKinds[] = {
    XRayInstrumentAttr::static_kind(),
};

gap::generator<XRayInstrumentAttr> XRayInstrumentAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kXRayInstrumentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<XRayInstrumentAttr> e = XRayInstrumentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<XRayInstrumentAttr> XRayInstrumentAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kXRayInstrumentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<XRayInstrumentAttr> e = XRayInstrumentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<XRayInstrumentAttr> XRayInstrumentAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<XRayInstrumentAttr> XRayInstrumentAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::X_RAY_INSTRUMENT:
      return reinterpret_cast<const XRayInstrumentAttr &>(parent);
    default: return std::nullopt;
  }
}

bool XRayInstrumentAttr::always_x_ray_instrument(void) const {
  return impl->reader.getVal12();
}

XRayInstrumentAttrSpelling XRayInstrumentAttr::semantic_spelling(void) const {
  return static_cast<XRayInstrumentAttrSpelling>(impl->reader.getVal10());
}

bool XRayInstrumentAttr::never_x_ray_instrument(void) const {
  return impl->reader.getVal13();
}

gap::generator<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = X86ForceAlignArgPointerAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool X86ForceAlignArgPointerAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : X86ForceAlignArgPointerAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return X86ForceAlignArgPointerAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kX86ForceAlignArgPointerAttrDerivedKinds[] = {
    X86ForceAlignArgPointerAttr::static_kind(),
};

gap::generator<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kX86ForceAlignArgPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<X86ForceAlignArgPointerAttr> e = X86ForceAlignArgPointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kX86ForceAlignArgPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<X86ForceAlignArgPointerAttr> e = X86ForceAlignArgPointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<X86ForceAlignArgPointerAttr> X86ForceAlignArgPointerAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::X86_FORCE_ALIGN_ARG_POINTER:
      return reinterpret_cast<const X86ForceAlignArgPointerAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WorkGroupSizeHintAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WorkGroupSizeHintAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WorkGroupSizeHintAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WorkGroupSizeHintAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWorkGroupSizeHintAttrDerivedKinds[] = {
    WorkGroupSizeHintAttr::static_kind(),
};

gap::generator<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWorkGroupSizeHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WorkGroupSizeHintAttr> e = WorkGroupSizeHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWorkGroupSizeHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WorkGroupSizeHintAttr> e = WorkGroupSizeHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WorkGroupSizeHintAttr> WorkGroupSizeHintAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WORK_GROUP_SIZE_HINT:
      return reinterpret_cast<const WorkGroupSizeHintAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WebAssemblyImportNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WebAssemblyImportNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WebAssemblyImportNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WebAssemblyImportNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWebAssemblyImportNameAttrDerivedKinds[] = {
    WebAssemblyImportNameAttr::static_kind(),
};

gap::generator<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWebAssemblyImportNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WebAssemblyImportNameAttr> e = WebAssemblyImportNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWebAssemblyImportNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WebAssemblyImportNameAttr> e = WebAssemblyImportNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WebAssemblyImportNameAttr> WebAssemblyImportNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEB_ASSEMBLY_IMPORT_NAME:
      return reinterpret_cast<const WebAssemblyImportNameAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view WebAssemblyImportNameAttr::import_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WebAssemblyImportModuleAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WebAssemblyImportModuleAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WebAssemblyImportModuleAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WebAssemblyImportModuleAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWebAssemblyImportModuleAttrDerivedKinds[] = {
    WebAssemblyImportModuleAttr::static_kind(),
};

gap::generator<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWebAssemblyImportModuleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WebAssemblyImportModuleAttr> e = WebAssemblyImportModuleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWebAssemblyImportModuleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WebAssemblyImportModuleAttr> e = WebAssemblyImportModuleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WebAssemblyImportModuleAttr> WebAssemblyImportModuleAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEB_ASSEMBLY_IMPORT_MODULE:
      return reinterpret_cast<const WebAssemblyImportModuleAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view WebAssemblyImportModuleAttr::import_module(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WebAssemblyExportNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WebAssemblyExportNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WebAssemblyExportNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WebAssemblyExportNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWebAssemblyExportNameAttrDerivedKinds[] = {
    WebAssemblyExportNameAttr::static_kind(),
};

gap::generator<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWebAssemblyExportNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WebAssemblyExportNameAttr> e = WebAssemblyExportNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWebAssemblyExportNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WebAssemblyExportNameAttr> e = WebAssemblyExportNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WebAssemblyExportNameAttr> WebAssemblyExportNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEB_ASSEMBLY_EXPORT_NAME:
      return reinterpret_cast<const WebAssemblyExportNameAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view WebAssemblyExportNameAttr::export_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<WeakRefAttr> WeakRefAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WeakRefAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WeakRefAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WeakRefAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WeakRefAttr> WeakRefAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WeakRefAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWeakRefAttrDerivedKinds[] = {
    WeakRefAttr::static_kind(),
};

gap::generator<WeakRefAttr> WeakRefAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWeakRefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WeakRefAttr> e = WeakRefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WeakRefAttr> WeakRefAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWeakRefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WeakRefAttr> e = WeakRefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WeakRefAttr> WeakRefAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WeakRefAttr> WeakRefAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEAK_REF:
      return reinterpret_cast<const WeakRefAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view WeakRefAttr::aliasee(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<WeakImportAttr> WeakImportAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WeakImportAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WeakImportAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WeakImportAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WeakImportAttr> WeakImportAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WeakImportAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWeakImportAttrDerivedKinds[] = {
    WeakImportAttr::static_kind(),
};

gap::generator<WeakImportAttr> WeakImportAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWeakImportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WeakImportAttr> e = WeakImportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WeakImportAttr> WeakImportAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWeakImportAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WeakImportAttr> e = WeakImportAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WeakImportAttr> WeakImportAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WeakImportAttr> WeakImportAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEAK_IMPORT:
      return reinterpret_cast<const WeakImportAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<WeakAttr> WeakAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WeakAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WeakAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WeakAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WeakAttr> WeakAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WeakAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWeakAttrDerivedKinds[] = {
    WeakAttr::static_kind(),
};

gap::generator<WeakAttr> WeakAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWeakAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WeakAttr> e = WeakAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WeakAttr> WeakAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWeakAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WeakAttr> e = WeakAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WeakAttr> WeakAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WeakAttr> WeakAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WEAK:
      return reinterpret_cast<const WeakAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<WarnUnusedResultAttr> WarnUnusedResultAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WarnUnusedResultAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WarnUnusedResultAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WarnUnusedResultAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WarnUnusedResultAttr> WarnUnusedResultAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WarnUnusedResultAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWarnUnusedResultAttrDerivedKinds[] = {
    WarnUnusedResultAttr::static_kind(),
};

gap::generator<WarnUnusedResultAttr> WarnUnusedResultAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWarnUnusedResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WarnUnusedResultAttr> e = WarnUnusedResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WarnUnusedResultAttr> WarnUnusedResultAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWarnUnusedResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WarnUnusedResultAttr> e = WarnUnusedResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WarnUnusedResultAttr> WarnUnusedResultAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WarnUnusedResultAttr> WarnUnusedResultAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WARN_UNUSED_RESULT:
      return reinterpret_cast<const WarnUnusedResultAttr &>(parent);
    default: return std::nullopt;
  }
}

bool WarnUnusedResultAttr::is_cxx11_no_discard(void) const {
  return impl->reader.getVal12();
}

std::string_view WarnUnusedResultAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

WarnUnusedResultAttrSpelling WarnUnusedResultAttr::semantic_spelling(void) const {
  return static_cast<WarnUnusedResultAttrSpelling>(impl->reader.getVal10());
}

gap::generator<WarnUnusedAttr> WarnUnusedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WarnUnusedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WarnUnusedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WarnUnusedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<WarnUnusedAttr> WarnUnusedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return WarnUnusedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kWarnUnusedAttrDerivedKinds[] = {
    WarnUnusedAttr::static_kind(),
};

gap::generator<WarnUnusedAttr> WarnUnusedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kWarnUnusedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<WarnUnusedAttr> e = WarnUnusedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WarnUnusedAttr> WarnUnusedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kWarnUnusedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<WarnUnusedAttr> e = WarnUnusedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WarnUnusedAttr> WarnUnusedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<WarnUnusedAttr> WarnUnusedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::WARN_UNUSED:
      return reinterpret_cast<const WarnUnusedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<VisibilityAttr> VisibilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VisibilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VisibilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VisibilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VisibilityAttr> VisibilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return VisibilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kVisibilityAttrDerivedKinds[] = {
    VisibilityAttr::static_kind(),
};

gap::generator<VisibilityAttr> VisibilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kVisibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<VisibilityAttr> e = VisibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VisibilityAttr> VisibilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kVisibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<VisibilityAttr> e = VisibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VisibilityAttr> VisibilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<VisibilityAttr> VisibilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::VISIBILITY:
      return reinterpret_cast<const VisibilityAttr &>(parent);
    default: return std::nullopt;
  }
}

VisibilityAttrVisibilityType VisibilityAttr::visibility(void) const {
  return static_cast<VisibilityAttrVisibilityType>(impl->reader.getVal10());
}

gap::generator<VectorCallAttr> VectorCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VectorCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VectorCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VectorCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VectorCallAttr> VectorCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return VectorCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kVectorCallAttrDerivedKinds[] = {
    VectorCallAttr::static_kind(),
};

gap::generator<VectorCallAttr> VectorCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kVectorCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<VectorCallAttr> e = VectorCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VectorCallAttr> VectorCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kVectorCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<VectorCallAttr> e = VectorCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VectorCallAttr> VectorCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<VectorCallAttr> VectorCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::VECTOR_CALL:
      return reinterpret_cast<const VectorCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<VecTypeHintAttr> VecTypeHintAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VecTypeHintAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VecTypeHintAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VecTypeHintAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VecTypeHintAttr> VecTypeHintAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return VecTypeHintAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kVecTypeHintAttrDerivedKinds[] = {
    VecTypeHintAttr::static_kind(),
};

gap::generator<VecTypeHintAttr> VecTypeHintAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kVecTypeHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<VecTypeHintAttr> e = VecTypeHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VecTypeHintAttr> VecTypeHintAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kVecTypeHintAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<VecTypeHintAttr> e = VecTypeHintAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VecTypeHintAttr> VecTypeHintAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<VecTypeHintAttr> VecTypeHintAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::VEC_TYPE_HINT:
      return reinterpret_cast<const VecTypeHintAttr &>(parent);
    default: return std::nullopt;
  }
}

Type VecTypeHintAttr::type_hint(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type VecTypeHintAttr::type_hint_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<VecReturnAttr> VecReturnAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VecReturnAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VecReturnAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VecReturnAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VecReturnAttr> VecReturnAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return VecReturnAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kVecReturnAttrDerivedKinds[] = {
    VecReturnAttr::static_kind(),
};

gap::generator<VecReturnAttr> VecReturnAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kVecReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<VecReturnAttr> e = VecReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VecReturnAttr> VecReturnAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kVecReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<VecReturnAttr> e = VecReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VecReturnAttr> VecReturnAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<VecReturnAttr> VecReturnAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::VEC_RETURN:
      return reinterpret_cast<const VecReturnAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UuidAttr> UuidAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UuidAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UuidAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UuidAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UuidAttr> UuidAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UuidAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUuidAttrDerivedKinds[] = {
    UuidAttr::static_kind(),
};

gap::generator<UuidAttr> UuidAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUuidAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UuidAttr> e = UuidAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UuidAttr> UuidAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUuidAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UuidAttr> e = UuidAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UuidAttr> UuidAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UuidAttr> UuidAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::UUID:
      return reinterpret_cast<const UuidAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view UuidAttr::guid(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

MSGuidDecl UuidAttr::guid_declaration(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return MSGuidDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<UsingIfExistsAttr> UsingIfExistsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingIfExistsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingIfExistsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingIfExistsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UsingIfExistsAttr> UsingIfExistsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UsingIfExistsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUsingIfExistsAttrDerivedKinds[] = {
    UsingIfExistsAttr::static_kind(),
};

gap::generator<UsingIfExistsAttr> UsingIfExistsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUsingIfExistsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UsingIfExistsAttr> e = UsingIfExistsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingIfExistsAttr> UsingIfExistsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUsingIfExistsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UsingIfExistsAttr> e = UsingIfExistsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingIfExistsAttr> UsingIfExistsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UsingIfExistsAttr> UsingIfExistsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::USING_IF_EXISTS:
      return reinterpret_cast<const UsingIfExistsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UsedAttr> UsedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UsedAttr> UsedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UsedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUsedAttrDerivedKinds[] = {
    UsedAttr::static_kind(),
};

gap::generator<UsedAttr> UsedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUsedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UsedAttr> e = UsedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsedAttr> UsedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUsedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UsedAttr> e = UsedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsedAttr> UsedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UsedAttr> UsedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::USED:
      return reinterpret_cast<const UsedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UnusedAttr> UnusedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnusedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnusedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnusedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UnusedAttr> UnusedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UnusedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUnusedAttrDerivedKinds[] = {
    UnusedAttr::static_kind(),
};

gap::generator<UnusedAttr> UnusedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUnusedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UnusedAttr> e = UnusedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnusedAttr> UnusedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUnusedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UnusedAttr> e = UnusedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnusedAttr> UnusedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UnusedAttr> UnusedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::UNUSED:
      return reinterpret_cast<const UnusedAttr &>(parent);
    default: return std::nullopt;
  }
}

UnusedAttrSpelling UnusedAttr::semantic_spelling(void) const {
  return static_cast<UnusedAttrSpelling>(impl->reader.getVal10());
}

gap::generator<UninitializedAttr> UninitializedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UninitializedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UninitializedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UninitializedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UninitializedAttr> UninitializedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UninitializedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUninitializedAttrDerivedKinds[] = {
    UninitializedAttr::static_kind(),
};

gap::generator<UninitializedAttr> UninitializedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUninitializedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UninitializedAttr> e = UninitializedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UninitializedAttr> UninitializedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUninitializedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UninitializedAttr> e = UninitializedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UninitializedAttr> UninitializedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UninitializedAttr> UninitializedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::UNINITIALIZED:
      return reinterpret_cast<const UninitializedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UnavailableAttr> UnavailableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnavailableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnavailableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnavailableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UnavailableAttr> UnavailableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UnavailableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUnavailableAttrDerivedKinds[] = {
    UnavailableAttr::static_kind(),
};

gap::generator<UnavailableAttr> UnavailableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUnavailableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UnavailableAttr> e = UnavailableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnavailableAttr> UnavailableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUnavailableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UnavailableAttr> e = UnavailableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnavailableAttr> UnavailableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UnavailableAttr> UnavailableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::UNAVAILABLE:
      return reinterpret_cast<const UnavailableAttr &>(parent);
    default: return std::nullopt;
  }
}

UnavailableAttrImplicitReason UnavailableAttr::implicit_reason(void) const {
  return static_cast<UnavailableAttrImplicitReason>(impl->reader.getVal10());
}

std::string_view UnavailableAttr::message(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<TypeVisibilityAttr> TypeVisibilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeVisibilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeVisibilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeVisibilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeVisibilityAttr> TypeVisibilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeVisibilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeVisibilityAttrDerivedKinds[] = {
    TypeVisibilityAttr::static_kind(),
};

gap::generator<TypeVisibilityAttr> TypeVisibilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeVisibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeVisibilityAttr> e = TypeVisibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeVisibilityAttr> TypeVisibilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeVisibilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeVisibilityAttr> e = TypeVisibilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeVisibilityAttr> TypeVisibilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeVisibilityAttr> TypeVisibilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_VISIBILITY:
      return reinterpret_cast<const TypeVisibilityAttr &>(parent);
    default: return std::nullopt;
  }
}

TypeVisibilityAttrVisibilityType TypeVisibilityAttr::visibility(void) const {
  return static_cast<TypeVisibilityAttrVisibilityType>(impl->reader.getVal10());
}

gap::generator<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeTagForDatatypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeTagForDatatypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeTagForDatatypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TypeTagForDatatypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTypeTagForDatatypeAttrDerivedKinds[] = {
    TypeTagForDatatypeAttr::static_kind(),
};

gap::generator<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTypeTagForDatatypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TypeTagForDatatypeAttr> e = TypeTagForDatatypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTypeTagForDatatypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TypeTagForDatatypeAttr> e = TypeTagForDatatypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TypeTagForDatatypeAttr> TypeTagForDatatypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TYPE_TAG_FOR_DATATYPE:
      return reinterpret_cast<const TypeTagForDatatypeAttr &>(parent);
    default: return std::nullopt;
  }
}

bool TypeTagForDatatypeAttr::layout_compatible(void) const {
  return impl->reader.getVal12();
}

Type TypeTagForDatatypeAttr::matching_c_type(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type TypeTagForDatatypeAttr::matching_c_type_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool TypeTagForDatatypeAttr::must_be_null(void) const {
  return impl->reader.getVal13();
}

gap::generator<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TryAcquireCapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TryAcquireCapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TryAcquireCapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TryAcquireCapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTryAcquireCapabilityAttrDerivedKinds[] = {
    TryAcquireCapabilityAttr::static_kind(),
};

gap::generator<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTryAcquireCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TryAcquireCapabilityAttr> e = TryAcquireCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTryAcquireCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TryAcquireCapabilityAttr> e = TryAcquireCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TryAcquireCapabilityAttr> TryAcquireCapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TRY_ACQUIRE_CAPABILITY:
      return reinterpret_cast<const TryAcquireCapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

TryAcquireCapabilityAttrSpelling TryAcquireCapabilityAttr::semantic_spelling(void) const {
  return static_cast<TryAcquireCapabilityAttrSpelling>(impl->reader.getVal10());
}

Expr TryAcquireCapabilityAttr::success_value(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool TryAcquireCapabilityAttr::is_shared(void) const {
  return impl->reader.getVal12();
}

gap::generator<TrivialABIAttr> TrivialABIAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TrivialABIAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TrivialABIAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TrivialABIAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TrivialABIAttr> TrivialABIAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TrivialABIAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTrivialABIAttrDerivedKinds[] = {
    TrivialABIAttr::static_kind(),
};

gap::generator<TrivialABIAttr> TrivialABIAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTrivialABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TrivialABIAttr> e = TrivialABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TrivialABIAttr> TrivialABIAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTrivialABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TrivialABIAttr> e = TrivialABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TrivialABIAttr> TrivialABIAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TrivialABIAttr> TrivialABIAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TRIVIAL_ABI:
      return reinterpret_cast<const TrivialABIAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TransparentUnionAttr> TransparentUnionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TransparentUnionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TransparentUnionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TransparentUnionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TransparentUnionAttr> TransparentUnionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TransparentUnionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTransparentUnionAttrDerivedKinds[] = {
    TransparentUnionAttr::static_kind(),
};

gap::generator<TransparentUnionAttr> TransparentUnionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTransparentUnionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TransparentUnionAttr> e = TransparentUnionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TransparentUnionAttr> TransparentUnionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTransparentUnionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TransparentUnionAttr> e = TransparentUnionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TransparentUnionAttr> TransparentUnionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TransparentUnionAttr> TransparentUnionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TRANSPARENT_UNION:
      return reinterpret_cast<const TransparentUnionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ThisCallAttr> ThisCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ThisCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ThisCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ThisCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ThisCallAttr> ThisCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ThisCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kThisCallAttrDerivedKinds[] = {
    ThisCallAttr::static_kind(),
};

gap::generator<ThisCallAttr> ThisCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kThisCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ThisCallAttr> e = ThisCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ThisCallAttr> ThisCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kThisCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ThisCallAttr> e = ThisCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ThisCallAttr> ThisCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ThisCallAttr> ThisCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::THIS_CALL:
      return reinterpret_cast<const ThisCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TestTypestateAttr> TestTypestateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TestTypestateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TestTypestateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TestTypestateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TestTypestateAttr> TestTypestateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TestTypestateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTestTypestateAttrDerivedKinds[] = {
    TestTypestateAttr::static_kind(),
};

gap::generator<TestTypestateAttr> TestTypestateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTestTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TestTypestateAttr> e = TestTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TestTypestateAttr> TestTypestateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTestTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TestTypestateAttr> e = TestTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TestTypestateAttr> TestTypestateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TestTypestateAttr> TestTypestateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TEST_TYPESTATE:
      return reinterpret_cast<const TestTypestateAttr &>(parent);
    default: return std::nullopt;
  }
}

TestTypestateAttrConsumedState TestTypestateAttr::test_state(void) const {
  return static_cast<TestTypestateAttrConsumedState>(impl->reader.getVal10());
}

gap::generator<TargetClonesAttr> TargetClonesAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TargetClonesAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TargetClonesAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TargetClonesAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TargetClonesAttr> TargetClonesAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TargetClonesAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTargetClonesAttrDerivedKinds[] = {
    TargetClonesAttr::static_kind(),
};

gap::generator<TargetClonesAttr> TargetClonesAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTargetClonesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TargetClonesAttr> e = TargetClonesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TargetClonesAttr> TargetClonesAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTargetClonesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TargetClonesAttr> e = TargetClonesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TargetClonesAttr> TargetClonesAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TargetClonesAttr> TargetClonesAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TARGET_CLONES:
      return reinterpret_cast<const TargetClonesAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TargetAttr> TargetAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TargetAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TargetAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TargetAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TargetAttr> TargetAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TargetAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTargetAttrDerivedKinds[] = {
    TargetAttr::static_kind(),
};

gap::generator<TargetAttr> TargetAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTargetAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TargetAttr> e = TargetAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TargetAttr> TargetAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTargetAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TargetAttr> e = TargetAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TargetAttr> TargetAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TargetAttr> TargetAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TARGET:
      return reinterpret_cast<const TargetAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view TargetAttr::architecture(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

std::string_view TargetAttr::features_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal17();
  return std::string_view(data.cStr(), data.size());
}

bool TargetAttr::is_default_version(void) const {
  return impl->reader.getVal12();
}

gap::generator<TLSModelAttr> TLSModelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TLSModelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TLSModelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TLSModelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TLSModelAttr> TLSModelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return TLSModelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kTLSModelAttrDerivedKinds[] = {
    TLSModelAttr::static_kind(),
};

gap::generator<TLSModelAttr> TLSModelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kTLSModelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<TLSModelAttr> e = TLSModelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TLSModelAttr> TLSModelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kTLSModelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<TLSModelAttr> e = TLSModelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TLSModelAttr> TLSModelAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<TLSModelAttr> TLSModelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::TLS_MODEL:
      return reinterpret_cast<const TLSModelAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view TLSModelAttr::model(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<SysVABIAttr> SysVABIAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SysVABIAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SysVABIAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SysVABIAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SysVABIAttr> SysVABIAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SysVABIAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSysVABIAttrDerivedKinds[] = {
    SysVABIAttr::static_kind(),
};

gap::generator<SysVABIAttr> SysVABIAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSysVABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SysVABIAttr> e = SysVABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SysVABIAttr> SysVABIAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSysVABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SysVABIAttr> e = SysVABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SysVABIAttr> SysVABIAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SysVABIAttr> SysVABIAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SYS_VABI:
      return reinterpret_cast<const SysVABIAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftPrivateAttr> SwiftPrivateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftPrivateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftPrivateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftPrivateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftPrivateAttr> SwiftPrivateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftPrivateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftPrivateAttrDerivedKinds[] = {
    SwiftPrivateAttr::static_kind(),
};

gap::generator<SwiftPrivateAttr> SwiftPrivateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftPrivateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftPrivateAttr> e = SwiftPrivateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftPrivateAttr> SwiftPrivateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftPrivateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftPrivateAttr> e = SwiftPrivateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftPrivateAttr> SwiftPrivateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftPrivateAttr> SwiftPrivateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_PRIVATE:
      return reinterpret_cast<const SwiftPrivateAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftNewTypeAttr> SwiftNewTypeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftNewTypeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftNewTypeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftNewTypeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftNewTypeAttr> SwiftNewTypeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftNewTypeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftNewTypeAttrDerivedKinds[] = {
    SwiftNewTypeAttr::static_kind(),
};

gap::generator<SwiftNewTypeAttr> SwiftNewTypeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftNewTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftNewTypeAttr> e = SwiftNewTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftNewTypeAttr> SwiftNewTypeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftNewTypeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftNewTypeAttr> e = SwiftNewTypeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftNewTypeAttr> SwiftNewTypeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftNewTypeAttr> SwiftNewTypeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_NEW_TYPE:
      return reinterpret_cast<const SwiftNewTypeAttr &>(parent);
    default: return std::nullopt;
  }
}

SwiftNewTypeAttrNewtypeKind SwiftNewTypeAttr::newtype_kind(void) const {
  return static_cast<SwiftNewTypeAttrNewtypeKind>(impl->reader.getVal10());
}

SwiftNewTypeAttrSpelling SwiftNewTypeAttr::semantic_spelling(void) const {
  return static_cast<SwiftNewTypeAttrSpelling>(impl->reader.getVal14());
}

gap::generator<SwiftNameAttr> SwiftNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftNameAttr> SwiftNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftNameAttrDerivedKinds[] = {
    SwiftNameAttr::static_kind(),
};

gap::generator<SwiftNameAttr> SwiftNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftNameAttr> e = SwiftNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftNameAttr> SwiftNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftNameAttr> e = SwiftNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftNameAttr> SwiftNameAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftNameAttr> SwiftNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_NAME:
      return reinterpret_cast<const SwiftNameAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SwiftNameAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<SwiftErrorAttr> SwiftErrorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftErrorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftErrorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftErrorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftErrorAttr> SwiftErrorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftErrorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftErrorAttrDerivedKinds[] = {
    SwiftErrorAttr::static_kind(),
};

gap::generator<SwiftErrorAttr> SwiftErrorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftErrorAttr> e = SwiftErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftErrorAttr> SwiftErrorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftErrorAttr> e = SwiftErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftErrorAttr> SwiftErrorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftErrorAttr> SwiftErrorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ERROR:
      return reinterpret_cast<const SwiftErrorAttr &>(parent);
    default: return std::nullopt;
  }
}

SwiftErrorAttrConventionKind SwiftErrorAttr::convention(void) const {
  return static_cast<SwiftErrorAttrConventionKind>(impl->reader.getVal10());
}

gap::generator<SwiftCallAttr> SwiftCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftCallAttr> SwiftCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftCallAttrDerivedKinds[] = {
    SwiftCallAttr::static_kind(),
};

gap::generator<SwiftCallAttr> SwiftCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftCallAttr> e = SwiftCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftCallAttr> SwiftCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftCallAttr> e = SwiftCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftCallAttr> SwiftCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftCallAttr> SwiftCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_CALL:
      return reinterpret_cast<const SwiftCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftBridgedTypedefAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftBridgedTypedefAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftBridgedTypedefAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftBridgedTypedefAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftBridgedTypedefAttrDerivedKinds[] = {
    SwiftBridgedTypedefAttr::static_kind(),
};

gap::generator<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftBridgedTypedefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftBridgedTypedefAttr> e = SwiftBridgedTypedefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftBridgedTypedefAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftBridgedTypedefAttr> e = SwiftBridgedTypedefAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftBridgedTypedefAttr> SwiftBridgedTypedefAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_BRIDGED_TYPEDEF:
      return reinterpret_cast<const SwiftBridgedTypedefAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftBridgeAttr> SwiftBridgeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftBridgeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftBridgeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftBridgeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftBridgeAttr> SwiftBridgeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftBridgeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftBridgeAttrDerivedKinds[] = {
    SwiftBridgeAttr::static_kind(),
};

gap::generator<SwiftBridgeAttr> SwiftBridgeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftBridgeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftBridgeAttr> e = SwiftBridgeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftBridgeAttr> SwiftBridgeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftBridgeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftBridgeAttr> e = SwiftBridgeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftBridgeAttr> SwiftBridgeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftBridgeAttr> SwiftBridgeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_BRIDGE:
      return reinterpret_cast<const SwiftBridgeAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SwiftBridgeAttr::swift_type(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<SwiftAttrAttr> SwiftAttrAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAttrAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAttrAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAttrAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAttrAttr> SwiftAttrAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAttrAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAttrAttrDerivedKinds[] = {
    SwiftAttrAttr::static_kind(),
};

gap::generator<SwiftAttrAttr> SwiftAttrAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAttrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAttrAttr> e = SwiftAttrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAttrAttr> SwiftAttrAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAttrAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAttrAttr> e = SwiftAttrAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAttrAttr> SwiftAttrAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAttrAttr> SwiftAttrAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ATTR:
      return reinterpret_cast<const SwiftAttrAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SwiftAttrAttr::attribute(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<SwiftAsyncNameAttr> SwiftAsyncNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAsyncNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAsyncNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAsyncNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAsyncNameAttr> SwiftAsyncNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAsyncNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAsyncNameAttrDerivedKinds[] = {
    SwiftAsyncNameAttr::static_kind(),
};

gap::generator<SwiftAsyncNameAttr> SwiftAsyncNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAsyncNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAsyncNameAttr> e = SwiftAsyncNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAsyncNameAttr> SwiftAsyncNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAsyncNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAsyncNameAttr> e = SwiftAsyncNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAsyncNameAttr> SwiftAsyncNameAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncNameAttr> SwiftAsyncNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ASYNC_NAME:
      return reinterpret_cast<const SwiftAsyncNameAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SwiftAsyncNameAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAsyncErrorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAsyncErrorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAsyncErrorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAsyncErrorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAsyncErrorAttrDerivedKinds[] = {
    SwiftAsyncErrorAttr::static_kind(),
};

gap::generator<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAsyncErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAsyncErrorAttr> e = SwiftAsyncErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAsyncErrorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAsyncErrorAttr> e = SwiftAsyncErrorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncErrorAttr> SwiftAsyncErrorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ASYNC_ERROR:
      return reinterpret_cast<const SwiftAsyncErrorAttr &>(parent);
    default: return std::nullopt;
  }
}

SwiftAsyncErrorAttrConventionKind SwiftAsyncErrorAttr::convention(void) const {
  return static_cast<SwiftAsyncErrorAttrConventionKind>(impl->reader.getVal10());
}

gap::generator<SwiftAsyncCallAttr> SwiftAsyncCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAsyncCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAsyncCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAsyncCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAsyncCallAttr> SwiftAsyncCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAsyncCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAsyncCallAttrDerivedKinds[] = {
    SwiftAsyncCallAttr::static_kind(),
};

gap::generator<SwiftAsyncCallAttr> SwiftAsyncCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAsyncCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAsyncCallAttr> e = SwiftAsyncCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAsyncCallAttr> SwiftAsyncCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAsyncCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAsyncCallAttr> e = SwiftAsyncCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAsyncCallAttr> SwiftAsyncCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncCallAttr> SwiftAsyncCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ASYNC_CALL:
      return reinterpret_cast<const SwiftAsyncCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftAsyncAttr> SwiftAsyncAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAsyncAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAsyncAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAsyncAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAsyncAttr> SwiftAsyncAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAsyncAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAsyncAttrDerivedKinds[] = {
    SwiftAsyncAttr::static_kind(),
};

gap::generator<SwiftAsyncAttr> SwiftAsyncAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAsyncAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAsyncAttr> e = SwiftAsyncAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAsyncAttr> SwiftAsyncAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAsyncAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAsyncAttr> e = SwiftAsyncAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAsyncAttr> SwiftAsyncAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncAttr> SwiftAsyncAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ASYNC:
      return reinterpret_cast<const SwiftAsyncAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<StrictFPAttr> StrictFPAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StrictFPAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StrictFPAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StrictFPAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<StrictFPAttr> StrictFPAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return StrictFPAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kStrictFPAttrDerivedKinds[] = {
    StrictFPAttr::static_kind(),
};

gap::generator<StrictFPAttr> StrictFPAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kStrictFPAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<StrictFPAttr> e = StrictFPAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StrictFPAttr> StrictFPAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kStrictFPAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<StrictFPAttr> e = StrictFPAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StrictFPAttr> StrictFPAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<StrictFPAttr> StrictFPAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::STRICT_FP:
      return reinterpret_cast<const StrictFPAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<StdCallAttr> StdCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StdCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StdCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StdCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<StdCallAttr> StdCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return StdCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kStdCallAttrDerivedKinds[] = {
    StdCallAttr::static_kind(),
};

gap::generator<StdCallAttr> StdCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kStdCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<StdCallAttr> e = StdCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StdCallAttr> StdCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kStdCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<StdCallAttr> e = StdCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StdCallAttr> StdCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<StdCallAttr> StdCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::STD_CALL:
      return reinterpret_cast<const StdCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<StandaloneDebugAttr> StandaloneDebugAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StandaloneDebugAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StandaloneDebugAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StandaloneDebugAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<StandaloneDebugAttr> StandaloneDebugAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return StandaloneDebugAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kStandaloneDebugAttrDerivedKinds[] = {
    StandaloneDebugAttr::static_kind(),
};

gap::generator<StandaloneDebugAttr> StandaloneDebugAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kStandaloneDebugAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<StandaloneDebugAttr> e = StandaloneDebugAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StandaloneDebugAttr> StandaloneDebugAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kStandaloneDebugAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<StandaloneDebugAttr> e = StandaloneDebugAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StandaloneDebugAttr> StandaloneDebugAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<StandaloneDebugAttr> StandaloneDebugAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::STANDALONE_DEBUG:
      return reinterpret_cast<const StandaloneDebugAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SpeculativeLoadHardeningAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SpeculativeLoadHardeningAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SpeculativeLoadHardeningAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SpeculativeLoadHardeningAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSpeculativeLoadHardeningAttrDerivedKinds[] = {
    SpeculativeLoadHardeningAttr::static_kind(),
};

gap::generator<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSpeculativeLoadHardeningAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SpeculativeLoadHardeningAttr> e = SpeculativeLoadHardeningAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSpeculativeLoadHardeningAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SpeculativeLoadHardeningAttr> e = SpeculativeLoadHardeningAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SpeculativeLoadHardeningAttr> SpeculativeLoadHardeningAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SPECULATIVE_LOAD_HARDENING:
      return reinterpret_cast<const SpeculativeLoadHardeningAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SharedTrylockFunctionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SharedTrylockFunctionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SharedTrylockFunctionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SharedTrylockFunctionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSharedTrylockFunctionAttrDerivedKinds[] = {
    SharedTrylockFunctionAttr::static_kind(),
};

gap::generator<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSharedTrylockFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SharedTrylockFunctionAttr> e = SharedTrylockFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSharedTrylockFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SharedTrylockFunctionAttr> e = SharedTrylockFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SharedTrylockFunctionAttr> SharedTrylockFunctionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SHARED_TRYLOCK_FUNCTION:
      return reinterpret_cast<const SharedTrylockFunctionAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr SharedTrylockFunctionAttr::success_value(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<SetTypestateAttr> SetTypestateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SetTypestateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SetTypestateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SetTypestateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SetTypestateAttr> SetTypestateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SetTypestateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSetTypestateAttrDerivedKinds[] = {
    SetTypestateAttr::static_kind(),
};

gap::generator<SetTypestateAttr> SetTypestateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSetTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SetTypestateAttr> e = SetTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SetTypestateAttr> SetTypestateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSetTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SetTypestateAttr> e = SetTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SetTypestateAttr> SetTypestateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SetTypestateAttr> SetTypestateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SET_TYPESTATE:
      return reinterpret_cast<const SetTypestateAttr &>(parent);
    default: return std::nullopt;
  }
}

SetTypestateAttrConsumedState SetTypestateAttr::new_state(void) const {
  return static_cast<SetTypestateAttrConsumedState>(impl->reader.getVal10());
}

gap::generator<SentinelAttr> SentinelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SentinelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SentinelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SentinelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SentinelAttr> SentinelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SentinelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSentinelAttrDerivedKinds[] = {
    SentinelAttr::static_kind(),
};

gap::generator<SentinelAttr> SentinelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSentinelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SentinelAttr> e = SentinelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SentinelAttr> SentinelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSentinelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SentinelAttr> e = SentinelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SentinelAttr> SentinelAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SentinelAttr> SentinelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SENTINEL:
      return reinterpret_cast<const SentinelAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SelectAnyAttr> SelectAnyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SelectAnyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SelectAnyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SelectAnyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SelectAnyAttr> SelectAnyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SelectAnyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSelectAnyAttrDerivedKinds[] = {
    SelectAnyAttr::static_kind(),
};

gap::generator<SelectAnyAttr> SelectAnyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSelectAnyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SelectAnyAttr> e = SelectAnyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SelectAnyAttr> SelectAnyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSelectAnyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SelectAnyAttr> e = SelectAnyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SelectAnyAttr> SelectAnyAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SelectAnyAttr> SelectAnyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SELECT_ANY:
      return reinterpret_cast<const SelectAnyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SectionAttr> SectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SectionAttr> SectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSectionAttrDerivedKinds[] = {
    SectionAttr::static_kind(),
};

gap::generator<SectionAttr> SectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SectionAttr> e = SectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SectionAttr> SectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SectionAttr> e = SectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SectionAttr> SectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SectionAttr> SectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SECTION:
      return reinterpret_cast<const SectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

SectionAttrSpelling SectionAttr::semantic_spelling(void) const {
  return static_cast<SectionAttrSpelling>(impl->reader.getVal10());
}

gap::generator<ScopedLockableAttr> ScopedLockableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ScopedLockableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ScopedLockableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ScopedLockableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ScopedLockableAttr> ScopedLockableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ScopedLockableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kScopedLockableAttrDerivedKinds[] = {
    ScopedLockableAttr::static_kind(),
};

gap::generator<ScopedLockableAttr> ScopedLockableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kScopedLockableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ScopedLockableAttr> e = ScopedLockableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ScopedLockableAttr> ScopedLockableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kScopedLockableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ScopedLockableAttr> e = ScopedLockableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ScopedLockableAttr> ScopedLockableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ScopedLockableAttr> ScopedLockableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SCOPED_LOCKABLE:
      return reinterpret_cast<const ScopedLockableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SYCLSpecialClassAttr> SYCLSpecialClassAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SYCLSpecialClassAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SYCLSpecialClassAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SYCLSpecialClassAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SYCLSpecialClassAttr> SYCLSpecialClassAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SYCLSpecialClassAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSYCLSpecialClassAttrDerivedKinds[] = {
    SYCLSpecialClassAttr::static_kind(),
};

gap::generator<SYCLSpecialClassAttr> SYCLSpecialClassAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSYCLSpecialClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SYCLSpecialClassAttr> e = SYCLSpecialClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SYCLSpecialClassAttr> SYCLSpecialClassAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSYCLSpecialClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SYCLSpecialClassAttr> e = SYCLSpecialClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SYCLSpecialClassAttr> SYCLSpecialClassAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SYCLSpecialClassAttr> SYCLSpecialClassAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SYCL_SPECIAL_CLASS:
      return reinterpret_cast<const SYCLSpecialClassAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SYCLKernelAttr> SYCLKernelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SYCLKernelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SYCLKernelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SYCLKernelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SYCLKernelAttr> SYCLKernelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SYCLKernelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSYCLKernelAttrDerivedKinds[] = {
    SYCLKernelAttr::static_kind(),
};

gap::generator<SYCLKernelAttr> SYCLKernelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSYCLKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SYCLKernelAttr> e = SYCLKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SYCLKernelAttr> SYCLKernelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSYCLKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SYCLKernelAttr> e = SYCLKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SYCLKernelAttr> SYCLKernelAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SYCLKernelAttr> SYCLKernelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SYCL_KERNEL:
      return reinterpret_cast<const SYCLKernelAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ReturnsTwiceAttr> ReturnsTwiceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReturnsTwiceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReturnsTwiceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReturnsTwiceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReturnsTwiceAttr> ReturnsTwiceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReturnsTwiceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReturnsTwiceAttrDerivedKinds[] = {
    ReturnsTwiceAttr::static_kind(),
};

gap::generator<ReturnsTwiceAttr> ReturnsTwiceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReturnsTwiceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReturnsTwiceAttr> e = ReturnsTwiceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReturnsTwiceAttr> ReturnsTwiceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReturnsTwiceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReturnsTwiceAttr> e = ReturnsTwiceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReturnsTwiceAttr> ReturnsTwiceAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReturnsTwiceAttr> ReturnsTwiceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RETURNS_TWICE:
      return reinterpret_cast<const ReturnsTwiceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ReturnsNonNullAttr> ReturnsNonNullAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReturnsNonNullAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReturnsNonNullAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReturnsNonNullAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReturnsNonNullAttr> ReturnsNonNullAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReturnsNonNullAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReturnsNonNullAttrDerivedKinds[] = {
    ReturnsNonNullAttr::static_kind(),
};

gap::generator<ReturnsNonNullAttr> ReturnsNonNullAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReturnsNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReturnsNonNullAttr> e = ReturnsNonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReturnsNonNullAttr> ReturnsNonNullAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReturnsNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReturnsNonNullAttr> e = ReturnsNonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReturnsNonNullAttr> ReturnsNonNullAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReturnsNonNullAttr> ReturnsNonNullAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RETURNS_NON_NULL:
      return reinterpret_cast<const ReturnsNonNullAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ReturnTypestateAttr> ReturnTypestateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReturnTypestateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReturnTypestateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReturnTypestateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReturnTypestateAttr> ReturnTypestateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReturnTypestateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReturnTypestateAttrDerivedKinds[] = {
    ReturnTypestateAttr::static_kind(),
};

gap::generator<ReturnTypestateAttr> ReturnTypestateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReturnTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReturnTypestateAttr> e = ReturnTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReturnTypestateAttr> ReturnTypestateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReturnTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReturnTypestateAttr> e = ReturnTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReturnTypestateAttr> ReturnTypestateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReturnTypestateAttr> ReturnTypestateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RETURN_TYPESTATE:
      return reinterpret_cast<const ReturnTypestateAttr &>(parent);
    default: return std::nullopt;
  }
}

ReturnTypestateAttrConsumedState ReturnTypestateAttr::state(void) const {
  return static_cast<ReturnTypestateAttrConsumedState>(impl->reader.getVal10());
}

gap::generator<RetainAttr> RetainAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RetainAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RetainAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RetainAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RetainAttr> RetainAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RetainAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRetainAttrDerivedKinds[] = {
    RetainAttr::static_kind(),
};

gap::generator<RetainAttr> RetainAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRetainAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RetainAttr> e = RetainAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RetainAttr> RetainAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRetainAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RetainAttr> e = RetainAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RetainAttr> RetainAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RetainAttr> RetainAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RETAIN:
      return reinterpret_cast<const RetainAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<RestrictAttr> RestrictAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RestrictAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RestrictAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RestrictAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RestrictAttr> RestrictAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RestrictAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRestrictAttrDerivedKinds[] = {
    RestrictAttr::static_kind(),
};

gap::generator<RestrictAttr> RestrictAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRestrictAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RestrictAttr> e = RestrictAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RestrictAttr> RestrictAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRestrictAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RestrictAttr> e = RestrictAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RestrictAttr> RestrictAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RestrictAttr> RestrictAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RESTRICT:
      return reinterpret_cast<const RestrictAttr &>(parent);
    default: return std::nullopt;
  }
}

RestrictAttrSpelling RestrictAttr::semantic_spelling(void) const {
  return static_cast<RestrictAttrSpelling>(impl->reader.getVal10());
}

gap::generator<RequiresCapabilityAttr> RequiresCapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RequiresCapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RequiresCapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RequiresCapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RequiresCapabilityAttr> RequiresCapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RequiresCapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRequiresCapabilityAttrDerivedKinds[] = {
    RequiresCapabilityAttr::static_kind(),
};

gap::generator<RequiresCapabilityAttr> RequiresCapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRequiresCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RequiresCapabilityAttr> e = RequiresCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RequiresCapabilityAttr> RequiresCapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRequiresCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RequiresCapabilityAttr> e = RequiresCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RequiresCapabilityAttr> RequiresCapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RequiresCapabilityAttr> RequiresCapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::REQUIRES_CAPABILITY:
      return reinterpret_cast<const RequiresCapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

RequiresCapabilityAttrSpelling RequiresCapabilityAttr::semantic_spelling(void) const {
  return static_cast<RequiresCapabilityAttrSpelling>(impl->reader.getVal10());
}

bool RequiresCapabilityAttr::is_shared(void) const {
  return impl->reader.getVal12();
}

gap::generator<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReqdWorkGroupSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReqdWorkGroupSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReqdWorkGroupSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReqdWorkGroupSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReqdWorkGroupSizeAttrDerivedKinds[] = {
    ReqdWorkGroupSizeAttr::static_kind(),
};

gap::generator<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReqdWorkGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReqdWorkGroupSizeAttr> e = ReqdWorkGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReqdWorkGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReqdWorkGroupSizeAttr> e = ReqdWorkGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReqdWorkGroupSizeAttr> ReqdWorkGroupSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::REQD_WORK_GROUP_SIZE:
      return reinterpret_cast<const ReqdWorkGroupSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ReleaseCapabilityAttr> ReleaseCapabilityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReleaseCapabilityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReleaseCapabilityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReleaseCapabilityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReleaseCapabilityAttr> ReleaseCapabilityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReleaseCapabilityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReleaseCapabilityAttrDerivedKinds[] = {
    ReleaseCapabilityAttr::static_kind(),
};

gap::generator<ReleaseCapabilityAttr> ReleaseCapabilityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReleaseCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReleaseCapabilityAttr> e = ReleaseCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReleaseCapabilityAttr> ReleaseCapabilityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReleaseCapabilityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReleaseCapabilityAttr> e = ReleaseCapabilityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReleaseCapabilityAttr> ReleaseCapabilityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReleaseCapabilityAttr> ReleaseCapabilityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RELEASE_CAPABILITY:
      return reinterpret_cast<const ReleaseCapabilityAttr &>(parent);
    default: return std::nullopt;
  }
}

ReleaseCapabilityAttrSpelling ReleaseCapabilityAttr::semantic_spelling(void) const {
  return static_cast<ReleaseCapabilityAttrSpelling>(impl->reader.getVal10());
}

bool ReleaseCapabilityAttr::is_generic(void) const {
  return impl->reader.getVal12();
}

bool ReleaseCapabilityAttr::is_shared(void) const {
  return impl->reader.getVal13();
}

gap::generator<ReinitializesAttr> ReinitializesAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReinitializesAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReinitializesAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReinitializesAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReinitializesAttr> ReinitializesAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReinitializesAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReinitializesAttrDerivedKinds[] = {
    ReinitializesAttr::static_kind(),
};

gap::generator<ReinitializesAttr> ReinitializesAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReinitializesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReinitializesAttr> e = ReinitializesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReinitializesAttr> ReinitializesAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReinitializesAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReinitializesAttr> e = ReinitializesAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReinitializesAttr> ReinitializesAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReinitializesAttr> ReinitializesAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::REINITIALIZES:
      return reinterpret_cast<const ReinitializesAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<RegCallAttr> RegCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RegCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RegCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RegCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RegCallAttr> RegCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RegCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRegCallAttrDerivedKinds[] = {
    RegCallAttr::static_kind(),
};

gap::generator<RegCallAttr> RegCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRegCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RegCallAttr> e = RegCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RegCallAttr> RegCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRegCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RegCallAttr> e = RegCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RegCallAttr> RegCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RegCallAttr> RegCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::REG_CALL:
      return reinterpret_cast<const RegCallAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<RandomizeLayoutAttr> RandomizeLayoutAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RandomizeLayoutAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RandomizeLayoutAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RandomizeLayoutAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RandomizeLayoutAttr> RandomizeLayoutAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RandomizeLayoutAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRandomizeLayoutAttrDerivedKinds[] = {
    RandomizeLayoutAttr::static_kind(),
};

gap::generator<RandomizeLayoutAttr> RandomizeLayoutAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRandomizeLayoutAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RandomizeLayoutAttr> e = RandomizeLayoutAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RandomizeLayoutAttr> RandomizeLayoutAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRandomizeLayoutAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RandomizeLayoutAttr> e = RandomizeLayoutAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RandomizeLayoutAttr> RandomizeLayoutAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RandomizeLayoutAttr> RandomizeLayoutAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RANDOMIZE_LAYOUT:
      return reinterpret_cast<const RandomizeLayoutAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<RISCVInterruptAttr> RISCVInterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RISCVInterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RISCVInterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RISCVInterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RISCVInterruptAttr> RISCVInterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return RISCVInterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kRISCVInterruptAttrDerivedKinds[] = {
    RISCVInterruptAttr::static_kind(),
};

gap::generator<RISCVInterruptAttr> RISCVInterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kRISCVInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<RISCVInterruptAttr> e = RISCVInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RISCVInterruptAttr> RISCVInterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kRISCVInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<RISCVInterruptAttr> e = RISCVInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RISCVInterruptAttr> RISCVInterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<RISCVInterruptAttr> RISCVInterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RISCV_INTERRUPT:
      return reinterpret_cast<const RISCVInterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

RISCVInterruptAttrInterruptType RISCVInterruptAttr::interrupt(void) const {
  return static_cast<RISCVInterruptAttrInterruptType>(impl->reader.getVal10());
}

gap::generator<PureAttr> PureAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PureAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PureAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PureAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PureAttr> PureAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PureAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPureAttrDerivedKinds[] = {
    PureAttr::static_kind(),
};

gap::generator<PureAttr> PureAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPureAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PureAttr> e = PureAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PureAttr> PureAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPureAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PureAttr> e = PureAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PureAttr> PureAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PureAttr> PureAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PURE:
      return reinterpret_cast<const PureAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<PtGuardedVarAttr> PtGuardedVarAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PtGuardedVarAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PtGuardedVarAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PtGuardedVarAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PtGuardedVarAttr> PtGuardedVarAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PtGuardedVarAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPtGuardedVarAttrDerivedKinds[] = {
    PtGuardedVarAttr::static_kind(),
};

gap::generator<PtGuardedVarAttr> PtGuardedVarAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPtGuardedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PtGuardedVarAttr> e = PtGuardedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PtGuardedVarAttr> PtGuardedVarAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPtGuardedVarAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PtGuardedVarAttr> e = PtGuardedVarAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PtGuardedVarAttr> PtGuardedVarAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PtGuardedVarAttr> PtGuardedVarAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PT_GUARDED_VAR:
      return reinterpret_cast<const PtGuardedVarAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<PtGuardedByAttr> PtGuardedByAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PtGuardedByAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PtGuardedByAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PtGuardedByAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PtGuardedByAttr> PtGuardedByAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PtGuardedByAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPtGuardedByAttrDerivedKinds[] = {
    PtGuardedByAttr::static_kind(),
};

gap::generator<PtGuardedByAttr> PtGuardedByAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPtGuardedByAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PtGuardedByAttr> e = PtGuardedByAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PtGuardedByAttr> PtGuardedByAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPtGuardedByAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PtGuardedByAttr> e = PtGuardedByAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PtGuardedByAttr> PtGuardedByAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PtGuardedByAttr> PtGuardedByAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PT_GUARDED_BY:
      return reinterpret_cast<const PtGuardedByAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr PtGuardedByAttr::argument(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<PreserveMostAttr> PreserveMostAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PreserveMostAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PreserveMostAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PreserveMostAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PreserveMostAttr> PreserveMostAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PreserveMostAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPreserveMostAttrDerivedKinds[] = {
    PreserveMostAttr::static_kind(),
};

gap::generator<PreserveMostAttr> PreserveMostAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPreserveMostAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PreserveMostAttr> e = PreserveMostAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PreserveMostAttr> PreserveMostAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPreserveMostAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PreserveMostAttr> e = PreserveMostAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PreserveMostAttr> PreserveMostAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PreserveMostAttr> PreserveMostAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRESERVE_MOST:
      return reinterpret_cast<const PreserveMostAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<PreserveAllAttr> PreserveAllAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PreserveAllAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PreserveAllAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PreserveAllAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PreserveAllAttr> PreserveAllAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PreserveAllAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPreserveAllAttrDerivedKinds[] = {
    PreserveAllAttr::static_kind(),
};

gap::generator<PreserveAllAttr> PreserveAllAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPreserveAllAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PreserveAllAttr> e = PreserveAllAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PreserveAllAttr> PreserveAllAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPreserveAllAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PreserveAllAttr> e = PreserveAllAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PreserveAllAttr> PreserveAllAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PreserveAllAttr> PreserveAllAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRESERVE_ALL:
      return reinterpret_cast<const PreserveAllAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<PreferredNameAttr> PreferredNameAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PreferredNameAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PreferredNameAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PreferredNameAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PreferredNameAttr> PreferredNameAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PreferredNameAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPreferredNameAttrDerivedKinds[] = {
    PreferredNameAttr::static_kind(),
};

gap::generator<PreferredNameAttr> PreferredNameAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPreferredNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PreferredNameAttr> e = PreferredNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PreferredNameAttr> PreferredNameAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPreferredNameAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PreferredNameAttr> e = PreferredNameAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PreferredNameAttr> PreferredNameAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PreferredNameAttr> PreferredNameAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PREFERRED_NAME:
      return reinterpret_cast<const PreferredNameAttr &>(parent);
    default: return std::nullopt;
  }
}

Type PreferredNameAttr::typedef_type(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type PreferredNameAttr::typedef_type_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaClangTextSectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaClangTextSectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaClangTextSectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PragmaClangTextSectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPragmaClangTextSectionAttrDerivedKinds[] = {
    PragmaClangTextSectionAttr::static_kind(),
};

gap::generator<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPragmaClangTextSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PragmaClangTextSectionAttr> e = PragmaClangTextSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPragmaClangTextSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PragmaClangTextSectionAttr> e = PragmaClangTextSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PragmaClangTextSectionAttr> PragmaClangTextSectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRAGMA_CLANG_TEXT_SECTION:
      return reinterpret_cast<const PragmaClangTextSectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaClangTextSectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaClangRodataSectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaClangRodataSectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaClangRodataSectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PragmaClangRodataSectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPragmaClangRodataSectionAttrDerivedKinds[] = {
    PragmaClangRodataSectionAttr::static_kind(),
};

gap::generator<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPragmaClangRodataSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PragmaClangRodataSectionAttr> e = PragmaClangRodataSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPragmaClangRodataSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PragmaClangRodataSectionAttr> e = PragmaClangRodataSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PragmaClangRodataSectionAttr> PragmaClangRodataSectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRAGMA_CLANG_RODATA_SECTION:
      return reinterpret_cast<const PragmaClangRodataSectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaClangRodataSectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaClangRelroSectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaClangRelroSectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaClangRelroSectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PragmaClangRelroSectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPragmaClangRelroSectionAttrDerivedKinds[] = {
    PragmaClangRelroSectionAttr::static_kind(),
};

gap::generator<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPragmaClangRelroSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PragmaClangRelroSectionAttr> e = PragmaClangRelroSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPragmaClangRelroSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PragmaClangRelroSectionAttr> e = PragmaClangRelroSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PragmaClangRelroSectionAttr> PragmaClangRelroSectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRAGMA_CLANG_RELRO_SECTION:
      return reinterpret_cast<const PragmaClangRelroSectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaClangRelroSectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaClangDataSectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaClangDataSectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaClangDataSectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PragmaClangDataSectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPragmaClangDataSectionAttrDerivedKinds[] = {
    PragmaClangDataSectionAttr::static_kind(),
};

gap::generator<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPragmaClangDataSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PragmaClangDataSectionAttr> e = PragmaClangDataSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPragmaClangDataSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PragmaClangDataSectionAttr> e = PragmaClangDataSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PragmaClangDataSectionAttr> PragmaClangDataSectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRAGMA_CLANG_DATA_SECTION:
      return reinterpret_cast<const PragmaClangDataSectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaClangDataSectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaClangBSSSectionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaClangBSSSectionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaClangBSSSectionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PragmaClangBSSSectionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPragmaClangBSSSectionAttrDerivedKinds[] = {
    PragmaClangBSSSectionAttr::static_kind(),
};

gap::generator<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPragmaClangBSSSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PragmaClangBSSSectionAttr> e = PragmaClangBSSSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPragmaClangBSSSectionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PragmaClangBSSSectionAttr> e = PragmaClangBSSSectionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PragmaClangBSSSectionAttr> PragmaClangBSSSectionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PRAGMA_CLANG_BSS_SECTION:
      return reinterpret_cast<const PragmaClangBSSSectionAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaClangBSSSectionAttr::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PointerAttr> PointerAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PointerAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PointerAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PointerAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PointerAttr> PointerAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PointerAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPointerAttrDerivedKinds[] = {
    PointerAttr::static_kind(),
};

gap::generator<PointerAttr> PointerAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PointerAttr> e = PointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PointerAttr> PointerAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PointerAttr> e = PointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PointerAttr> PointerAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PointerAttr> PointerAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::POINTER:
      return reinterpret_cast<const PointerAttr &>(parent);
    default: return std::nullopt;
  }
}

Type PointerAttr::deref_type(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type PointerAttr::deref_type_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<PcsAttr> PcsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PcsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PcsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PcsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PcsAttr> PcsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PcsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPcsAttrDerivedKinds[] = {
    PcsAttr::static_kind(),
};

gap::generator<PcsAttr> PcsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PcsAttr> e = PcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PcsAttr> PcsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPcsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PcsAttr> e = PcsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PcsAttr> PcsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PcsAttr> PcsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PCS:
      return reinterpret_cast<const PcsAttr &>(parent);
    default: return std::nullopt;
  }
}

PcsAttrPCSType PcsAttr::pcs(void) const {
  return static_cast<PcsAttrPCSType>(impl->reader.getVal10());
}

gap::generator<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PatchableFunctionEntryAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PatchableFunctionEntryAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PatchableFunctionEntryAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PatchableFunctionEntryAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPatchableFunctionEntryAttrDerivedKinds[] = {
    PatchableFunctionEntryAttr::static_kind(),
};

gap::generator<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPatchableFunctionEntryAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PatchableFunctionEntryAttr> e = PatchableFunctionEntryAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPatchableFunctionEntryAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PatchableFunctionEntryAttr> e = PatchableFunctionEntryAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PatchableFunctionEntryAttr> PatchableFunctionEntryAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PATCHABLE_FUNCTION_ENTRY:
      return reinterpret_cast<const PatchableFunctionEntryAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<PascalAttr> PascalAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PascalAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PascalAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PascalAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PascalAttr> PascalAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PascalAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPascalAttrDerivedKinds[] = {
    PascalAttr::static_kind(),
};

gap::generator<PascalAttr> PascalAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPascalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PascalAttr> e = PascalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PascalAttr> PascalAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPascalAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PascalAttr> e = PascalAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PascalAttr> PascalAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PascalAttr> PascalAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PASCAL:
      return reinterpret_cast<const PascalAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ParamTypestateAttr> ParamTypestateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParamTypestateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParamTypestateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParamTypestateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ParamTypestateAttr> ParamTypestateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ParamTypestateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kParamTypestateAttrDerivedKinds[] = {
    ParamTypestateAttr::static_kind(),
};

gap::generator<ParamTypestateAttr> ParamTypestateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kParamTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ParamTypestateAttr> e = ParamTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParamTypestateAttr> ParamTypestateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kParamTypestateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ParamTypestateAttr> e = ParamTypestateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParamTypestateAttr> ParamTypestateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ParamTypestateAttr> ParamTypestateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PARAM_TYPESTATE:
      return reinterpret_cast<const ParamTypestateAttr &>(parent);
    default: return std::nullopt;
  }
}

ParamTypestateAttrConsumedState ParamTypestateAttr::parameter_state(void) const {
  return static_cast<ParamTypestateAttrConsumedState>(impl->reader.getVal10());
}

gap::generator<PackedAttr> PackedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PackedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PackedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PackedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PackedAttr> PackedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PackedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPackedAttrDerivedKinds[] = {
    PackedAttr::static_kind(),
};

gap::generator<PackedAttr> PackedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPackedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PackedAttr> e = PackedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PackedAttr> PackedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPackedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PackedAttr> e = PackedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PackedAttr> PackedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PackedAttr> PackedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PACKED:
      return reinterpret_cast<const PackedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OwnershipAttr> OwnershipAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OwnershipAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OwnershipAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OwnershipAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OwnershipAttr> OwnershipAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OwnershipAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOwnershipAttrDerivedKinds[] = {
    OwnershipAttr::static_kind(),
};

gap::generator<OwnershipAttr> OwnershipAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOwnershipAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OwnershipAttr> e = OwnershipAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OwnershipAttr> OwnershipAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOwnershipAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OwnershipAttr> e = OwnershipAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OwnershipAttr> OwnershipAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OwnershipAttr> OwnershipAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OWNERSHIP:
      return reinterpret_cast<const OwnershipAttr &>(parent);
    default: return std::nullopt;
  }
}

OwnershipAttrOwnershipKind OwnershipAttr::own_kind(void) const {
  return static_cast<OwnershipAttrOwnershipKind>(impl->reader.getVal10());
}

OwnershipAttrSpelling OwnershipAttr::semantic_spelling(void) const {
  return static_cast<OwnershipAttrSpelling>(impl->reader.getVal14());
}

bool OwnershipAttr::is_holds(void) const {
  return impl->reader.getVal12();
}

bool OwnershipAttr::is_returns(void) const {
  return impl->reader.getVal13();
}

bool OwnershipAttr::is_takes(void) const {
  return impl->reader.getVal18();
}

gap::generator<OwnerAttr> OwnerAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OwnerAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OwnerAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OwnerAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OwnerAttr> OwnerAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OwnerAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOwnerAttrDerivedKinds[] = {
    OwnerAttr::static_kind(),
};

gap::generator<OwnerAttr> OwnerAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOwnerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OwnerAttr> e = OwnerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OwnerAttr> OwnerAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOwnerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OwnerAttr> e = OwnerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OwnerAttr> OwnerAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OwnerAttr> OwnerAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OWNER:
      return reinterpret_cast<const OwnerAttr &>(parent);
    default: return std::nullopt;
  }
}

Type OwnerAttr::deref_type(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type OwnerAttr::deref_type_token(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<OverrideAttr> OverrideAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OverrideAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OverrideAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OverrideAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OverrideAttr> OverrideAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OverrideAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOverrideAttrDerivedKinds[] = {
    OverrideAttr::static_kind(),
};

gap::generator<OverrideAttr> OverrideAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOverrideAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OverrideAttr> e = OverrideAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OverrideAttr> OverrideAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOverrideAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OverrideAttr> e = OverrideAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OverrideAttr> OverrideAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OverrideAttr> OverrideAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OVERRIDE:
      return reinterpret_cast<const OverrideAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OptimizeNoneAttr> OptimizeNoneAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OptimizeNoneAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OptimizeNoneAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OptimizeNoneAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OptimizeNoneAttr> OptimizeNoneAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OptimizeNoneAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOptimizeNoneAttrDerivedKinds[] = {
    OptimizeNoneAttr::static_kind(),
};

gap::generator<OptimizeNoneAttr> OptimizeNoneAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOptimizeNoneAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OptimizeNoneAttr> e = OptimizeNoneAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OptimizeNoneAttr> OptimizeNoneAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOptimizeNoneAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OptimizeNoneAttr> e = OptimizeNoneAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OptimizeNoneAttr> OptimizeNoneAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OptimizeNoneAttr> OptimizeNoneAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPTIMIZE_NONE:
      return reinterpret_cast<const OptimizeNoneAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLKernelAttr> OpenCLKernelAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLKernelAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLKernelAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLKernelAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLKernelAttr> OpenCLKernelAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLKernelAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLKernelAttrDerivedKinds[] = {
    OpenCLKernelAttr::static_kind(),
};

gap::generator<OpenCLKernelAttr> OpenCLKernelAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLKernelAttr> e = OpenCLKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLKernelAttr> OpenCLKernelAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLKernelAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLKernelAttr> e = OpenCLKernelAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLKernelAttr> OpenCLKernelAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLKernelAttr> OpenCLKernelAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_KERNEL:
      return reinterpret_cast<const OpenCLKernelAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpenCLIntelReqdSubGroupSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpenCLIntelReqdSubGroupSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpenCLIntelReqdSubGroupSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OpenCLIntelReqdSubGroupSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOpenCLIntelReqdSubGroupSizeAttrDerivedKinds[] = {
    OpenCLIntelReqdSubGroupSizeAttr::static_kind(),
};

gap::generator<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOpenCLIntelReqdSubGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OpenCLIntelReqdSubGroupSizeAttr> e = OpenCLIntelReqdSubGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOpenCLIntelReqdSubGroupSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OpenCLIntelReqdSubGroupSizeAttr> e = OpenCLIntelReqdSubGroupSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OpenCLIntelReqdSubGroupSizeAttr> OpenCLIntelReqdSubGroupSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE:
      return reinterpret_cast<const OpenCLIntelReqdSubGroupSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCSubclassingRestrictedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCSubclassingRestrictedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCSubclassingRestrictedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCSubclassingRestrictedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCSubclassingRestrictedAttrDerivedKinds[] = {
    ObjCSubclassingRestrictedAttr::static_kind(),
};

gap::generator<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCSubclassingRestrictedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCSubclassingRestrictedAttr> e = ObjCSubclassingRestrictedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCSubclassingRestrictedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCSubclassingRestrictedAttr> e = ObjCSubclassingRestrictedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCSubclassingRestrictedAttr> ObjCSubclassingRestrictedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_SUBCLASSING_RESTRICTED:
      return reinterpret_cast<const ObjCSubclassingRestrictedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCRootClassAttr> ObjCRootClassAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCRootClassAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCRootClassAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCRootClassAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCRootClassAttr> ObjCRootClassAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCRootClassAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCRootClassAttrDerivedKinds[] = {
    ObjCRootClassAttr::static_kind(),
};

gap::generator<ObjCRootClassAttr> ObjCRootClassAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCRootClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCRootClassAttr> e = ObjCRootClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCRootClassAttr> ObjCRootClassAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCRootClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCRootClassAttr> e = ObjCRootClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCRootClassAttr> ObjCRootClassAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCRootClassAttr> ObjCRootClassAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_ROOT_CLASS:
      return reinterpret_cast<const ObjCRootClassAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCReturnsInnerPointerAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCReturnsInnerPointerAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCReturnsInnerPointerAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCReturnsInnerPointerAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCReturnsInnerPointerAttrDerivedKinds[] = {
    ObjCReturnsInnerPointerAttr::static_kind(),
};

gap::generator<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCReturnsInnerPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCReturnsInnerPointerAttr> e = ObjCReturnsInnerPointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCReturnsInnerPointerAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCReturnsInnerPointerAttr> e = ObjCReturnsInnerPointerAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCReturnsInnerPointerAttr> ObjCReturnsInnerPointerAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_RETURNS_INNER_POINTER:
      return reinterpret_cast<const ObjCReturnsInnerPointerAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCRequiresSuperAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCRequiresSuperAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCRequiresSuperAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCRequiresSuperAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCRequiresSuperAttrDerivedKinds[] = {
    ObjCRequiresSuperAttr::static_kind(),
};

gap::generator<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCRequiresSuperAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCRequiresSuperAttr> e = ObjCRequiresSuperAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCRequiresSuperAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCRequiresSuperAttr> e = ObjCRequiresSuperAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCRequiresSuperAttr> ObjCRequiresSuperAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_REQUIRES_SUPER:
      return reinterpret_cast<const ObjCRequiresSuperAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCRequiresPropertyDefsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCRequiresPropertyDefsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCRequiresPropertyDefsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCRequiresPropertyDefsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCRequiresPropertyDefsAttrDerivedKinds[] = {
    ObjCRequiresPropertyDefsAttr::static_kind(),
};

gap::generator<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCRequiresPropertyDefsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCRequiresPropertyDefsAttr> e = ObjCRequiresPropertyDefsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCRequiresPropertyDefsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCRequiresPropertyDefsAttr> e = ObjCRequiresPropertyDefsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCRequiresPropertyDefsAttr> ObjCRequiresPropertyDefsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_REQUIRES_PROPERTY_DEFS:
      return reinterpret_cast<const ObjCRequiresPropertyDefsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCPreciseLifetimeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCPreciseLifetimeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCPreciseLifetimeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCPreciseLifetimeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCPreciseLifetimeAttrDerivedKinds[] = {
    ObjCPreciseLifetimeAttr::static_kind(),
};

gap::generator<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCPreciseLifetimeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCPreciseLifetimeAttr> e = ObjCPreciseLifetimeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCPreciseLifetimeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCPreciseLifetimeAttr> e = ObjCPreciseLifetimeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCPreciseLifetimeAttr> ObjCPreciseLifetimeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_PRECISE_LIFETIME:
      return reinterpret_cast<const ObjCPreciseLifetimeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCOwnershipAttr> ObjCOwnershipAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCOwnershipAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCOwnershipAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCOwnershipAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCOwnershipAttr> ObjCOwnershipAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCOwnershipAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCOwnershipAttrDerivedKinds[] = {
    ObjCOwnershipAttr::static_kind(),
};

gap::generator<ObjCOwnershipAttr> ObjCOwnershipAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCOwnershipAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCOwnershipAttr> e = ObjCOwnershipAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCOwnershipAttr> ObjCOwnershipAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCOwnershipAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCOwnershipAttr> e = ObjCOwnershipAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCOwnershipAttr> ObjCOwnershipAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCOwnershipAttr> ObjCOwnershipAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_OWNERSHIP:
      return reinterpret_cast<const ObjCOwnershipAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCNSObjectAttr> ObjCNSObjectAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCNSObjectAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCNSObjectAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCNSObjectAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCNSObjectAttr> ObjCNSObjectAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCNSObjectAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCNSObjectAttrDerivedKinds[] = {
    ObjCNSObjectAttr::static_kind(),
};

gap::generator<ObjCNSObjectAttr> ObjCNSObjectAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCNSObjectAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCNSObjectAttr> e = ObjCNSObjectAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCNSObjectAttr> ObjCNSObjectAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCNSObjectAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCNSObjectAttr> e = ObjCNSObjectAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCNSObjectAttr> ObjCNSObjectAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCNSObjectAttr> ObjCNSObjectAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_CNS_OBJECT:
      return reinterpret_cast<const ObjCNSObjectAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCMethodFamilyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCMethodFamilyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCMethodFamilyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCMethodFamilyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCMethodFamilyAttrDerivedKinds[] = {
    ObjCMethodFamilyAttr::static_kind(),
};

gap::generator<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCMethodFamilyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCMethodFamilyAttr> e = ObjCMethodFamilyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCMethodFamilyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCMethodFamilyAttr> e = ObjCMethodFamilyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCMethodFamilyAttr> ObjCMethodFamilyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_METHOD_FAMILY:
      return reinterpret_cast<const ObjCMethodFamilyAttr &>(parent);
    default: return std::nullopt;
  }
}

ObjCMethodFamilyAttrFamilyKind ObjCMethodFamilyAttr::family(void) const {
  return static_cast<ObjCMethodFamilyAttrFamilyKind>(impl->reader.getVal10());
}

gap::generator<ObjCIndependentClassAttr> ObjCIndependentClassAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCIndependentClassAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCIndependentClassAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCIndependentClassAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCIndependentClassAttr> ObjCIndependentClassAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCIndependentClassAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCIndependentClassAttrDerivedKinds[] = {
    ObjCIndependentClassAttr::static_kind(),
};

gap::generator<ObjCIndependentClassAttr> ObjCIndependentClassAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCIndependentClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCIndependentClassAttr> e = ObjCIndependentClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCIndependentClassAttr> ObjCIndependentClassAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCIndependentClassAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCIndependentClassAttr> e = ObjCIndependentClassAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCIndependentClassAttr> ObjCIndependentClassAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCIndependentClassAttr> ObjCIndependentClassAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_INDEPENDENT_CLASS:
      return reinterpret_cast<const ObjCIndependentClassAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCExternallyRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCExternallyRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCExternallyRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCExternallyRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCExternallyRetainedAttrDerivedKinds[] = {
    ObjCExternallyRetainedAttr::static_kind(),
};

gap::generator<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCExternallyRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCExternallyRetainedAttr> e = ObjCExternallyRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCExternallyRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCExternallyRetainedAttr> e = ObjCExternallyRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCExternallyRetainedAttr> ObjCExternallyRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_EXTERNALLY_RETAINED:
      return reinterpret_cast<const ObjCExternallyRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCExplicitProtocolImplAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCExplicitProtocolImplAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCExplicitProtocolImplAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCExplicitProtocolImplAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCExplicitProtocolImplAttrDerivedKinds[] = {
    ObjCExplicitProtocolImplAttr::static_kind(),
};

gap::generator<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCExplicitProtocolImplAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCExplicitProtocolImplAttr> e = ObjCExplicitProtocolImplAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCExplicitProtocolImplAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCExplicitProtocolImplAttr> e = ObjCExplicitProtocolImplAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCExplicitProtocolImplAttr> ObjCExplicitProtocolImplAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_EXPLICIT_PROTOCOL_IMPL:
      return reinterpret_cast<const ObjCExplicitProtocolImplAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCExceptionAttr> ObjCExceptionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCExceptionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCExceptionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCExceptionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCExceptionAttr> ObjCExceptionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCExceptionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCExceptionAttrDerivedKinds[] = {
    ObjCExceptionAttr::static_kind(),
};

gap::generator<ObjCExceptionAttr> ObjCExceptionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCExceptionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCExceptionAttr> e = ObjCExceptionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCExceptionAttr> ObjCExceptionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCExceptionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCExceptionAttr> e = ObjCExceptionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCExceptionAttr> ObjCExceptionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCExceptionAttr> ObjCExceptionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_EXCEPTION:
      return reinterpret_cast<const ObjCExceptionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBridgeRelatedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBridgeRelatedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBridgeRelatedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCBridgeRelatedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCBridgeRelatedAttrDerivedKinds[] = {
    ObjCBridgeRelatedAttr::static_kind(),
};

gap::generator<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCBridgeRelatedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCBridgeRelatedAttr> e = ObjCBridgeRelatedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCBridgeRelatedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBridgeRelatedAttr> e = ObjCBridgeRelatedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCBridgeRelatedAttr> ObjCBridgeRelatedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_BRIDGE_RELATED:
      return reinterpret_cast<const ObjCBridgeRelatedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBridgeMutableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBridgeMutableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBridgeMutableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCBridgeMutableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCBridgeMutableAttrDerivedKinds[] = {
    ObjCBridgeMutableAttr::static_kind(),
};

gap::generator<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCBridgeMutableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCBridgeMutableAttr> e = ObjCBridgeMutableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCBridgeMutableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBridgeMutableAttr> e = ObjCBridgeMutableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCBridgeMutableAttr> ObjCBridgeMutableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_BRIDGE_MUTABLE:
      return reinterpret_cast<const ObjCBridgeMutableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCBridgeAttr> ObjCBridgeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBridgeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBridgeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBridgeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCBridgeAttr> ObjCBridgeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ObjCBridgeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kObjCBridgeAttrDerivedKinds[] = {
    ObjCBridgeAttr::static_kind(),
};

gap::generator<ObjCBridgeAttr> ObjCBridgeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kObjCBridgeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ObjCBridgeAttr> e = ObjCBridgeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBridgeAttr> ObjCBridgeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kObjCBridgeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBridgeAttr> e = ObjCBridgeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBridgeAttr> ObjCBridgeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ObjCBridgeAttr> ObjCBridgeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OBJ_C_BRIDGE:
      return reinterpret_cast<const ObjCBridgeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSReturnsRetainedOnZeroAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSReturnsRetainedOnZeroAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSReturnsRetainedOnZeroAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSReturnsRetainedOnZeroAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSReturnsRetainedOnZeroAttrDerivedKinds[] = {
    OSReturnsRetainedOnZeroAttr::static_kind(),
};

gap::generator<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSReturnsRetainedOnZeroAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSReturnsRetainedOnZeroAttr> e = OSReturnsRetainedOnZeroAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSReturnsRetainedOnZeroAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSReturnsRetainedOnZeroAttr> e = OSReturnsRetainedOnZeroAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSReturnsRetainedOnZeroAttr> OSReturnsRetainedOnZeroAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_RETURNS_RETAINED_ON_ZERO:
      return reinterpret_cast<const OSReturnsRetainedOnZeroAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSReturnsRetainedOnNonZeroAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSReturnsRetainedOnNonZeroAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSReturnsRetainedOnNonZeroAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSReturnsRetainedOnNonZeroAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSReturnsRetainedOnNonZeroAttrDerivedKinds[] = {
    OSReturnsRetainedOnNonZeroAttr::static_kind(),
};

gap::generator<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSReturnsRetainedOnNonZeroAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSReturnsRetainedOnNonZeroAttr> e = OSReturnsRetainedOnNonZeroAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSReturnsRetainedOnNonZeroAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSReturnsRetainedOnNonZeroAttr> e = OSReturnsRetainedOnNonZeroAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSReturnsRetainedOnNonZeroAttr> OSReturnsRetainedOnNonZeroAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_RETURNS_RETAINED_ON_NON_ZERO:
      return reinterpret_cast<const OSReturnsRetainedOnNonZeroAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSReturnsRetainedAttr> OSReturnsRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSReturnsRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSReturnsRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSReturnsRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSReturnsRetainedAttr> OSReturnsRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSReturnsRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSReturnsRetainedAttrDerivedKinds[] = {
    OSReturnsRetainedAttr::static_kind(),
};

gap::generator<OSReturnsRetainedAttr> OSReturnsRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSReturnsRetainedAttr> e = OSReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSReturnsRetainedAttr> OSReturnsRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSReturnsRetainedAttr> e = OSReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSReturnsRetainedAttr> OSReturnsRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSReturnsRetainedAttr> OSReturnsRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_RETURNS_RETAINED:
      return reinterpret_cast<const OSReturnsRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSReturnsNotRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSReturnsNotRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSReturnsNotRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSReturnsNotRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSReturnsNotRetainedAttrDerivedKinds[] = {
    OSReturnsNotRetainedAttr::static_kind(),
};

gap::generator<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSReturnsNotRetainedAttr> e = OSReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSReturnsNotRetainedAttr> e = OSReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSReturnsNotRetainedAttr> OSReturnsNotRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_RETURNS_NOT_RETAINED:
      return reinterpret_cast<const OSReturnsNotRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSConsumesThisAttr> OSConsumesThisAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSConsumesThisAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSConsumesThisAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSConsumesThisAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSConsumesThisAttr> OSConsumesThisAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSConsumesThisAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSConsumesThisAttrDerivedKinds[] = {
    OSConsumesThisAttr::static_kind(),
};

gap::generator<OSConsumesThisAttr> OSConsumesThisAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSConsumesThisAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSConsumesThisAttr> e = OSConsumesThisAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSConsumesThisAttr> OSConsumesThisAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSConsumesThisAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSConsumesThisAttr> e = OSConsumesThisAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSConsumesThisAttr> OSConsumesThisAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSConsumesThisAttr> OSConsumesThisAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_CONSUMES_THIS:
      return reinterpret_cast<const OSConsumesThisAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPThreadPrivateDeclAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPThreadPrivateDeclAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPThreadPrivateDeclAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPThreadPrivateDeclAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPThreadPrivateDeclAttrDerivedKinds[] = {
    OMPThreadPrivateDeclAttr::static_kind(),
};

gap::generator<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPThreadPrivateDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPThreadPrivateDeclAttr> e = OMPThreadPrivateDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPThreadPrivateDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPThreadPrivateDeclAttr> e = OMPThreadPrivateDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OMPThreadPrivateDeclAttr> OMPThreadPrivateDeclAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_THREAD_PRIVATE_DECL:
      return reinterpret_cast<const OMPThreadPrivateDeclAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPDeclareVariantAttr> OMPDeclareVariantAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclareVariantAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclareVariantAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclareVariantAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPDeclareVariantAttr> OMPDeclareVariantAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPDeclareVariantAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPDeclareVariantAttrDerivedKinds[] = {
    OMPDeclareVariantAttr::static_kind(),
};

gap::generator<OMPDeclareVariantAttr> OMPDeclareVariantAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPDeclareVariantAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPDeclareVariantAttr> e = OMPDeclareVariantAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclareVariantAttr> OMPDeclareVariantAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPDeclareVariantAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclareVariantAttr> e = OMPDeclareVariantAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclareVariantAttr> OMPDeclareVariantAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OMPDeclareVariantAttr> OMPDeclareVariantAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_DECLARE_VARIANT:
      return reinterpret_cast<const OMPDeclareVariantAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPDeclareVariantAttr::variant_func_reference(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclareTargetDeclAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclareTargetDeclAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclareTargetDeclAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPDeclareTargetDeclAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPDeclareTargetDeclAttrDerivedKinds[] = {
    OMPDeclareTargetDeclAttr::static_kind(),
};

gap::generator<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPDeclareTargetDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPDeclareTargetDeclAttr> e = OMPDeclareTargetDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPDeclareTargetDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclareTargetDeclAttr> e = OMPDeclareTargetDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OMPDeclareTargetDeclAttr> OMPDeclareTargetDeclAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_DECLARE_TARGET_DECL:
      return reinterpret_cast<const OMPDeclareTargetDeclAttr &>(parent);
    default: return std::nullopt;
  }
}

OMPDeclareTargetDeclAttrDevTypeTy OMPDeclareTargetDeclAttr::dev_type(void) const {
  return static_cast<OMPDeclareTargetDeclAttrDevTypeTy>(impl->reader.getVal10());
}

bool OMPDeclareTargetDeclAttr::indirect(void) const {
  return impl->reader.getVal12();
}

Expr OMPDeclareTargetDeclAttr::indirect_expression(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

OMPDeclareTargetDeclAttrMapTypeTy OMPDeclareTargetDeclAttr::map_type(void) const {
  return static_cast<OMPDeclareTargetDeclAttrMapTypeTy>(impl->reader.getVal14());
}

gap::generator<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCaptureNoInitAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCaptureNoInitAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCaptureNoInitAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPCaptureNoInitAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPCaptureNoInitAttrDerivedKinds[] = {
    OMPCaptureNoInitAttr::static_kind(),
};

gap::generator<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPCaptureNoInitAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPCaptureNoInitAttr> e = OMPCaptureNoInitAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPCaptureNoInitAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPCaptureNoInitAttr> e = OMPCaptureNoInitAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OMPCaptureNoInitAttr> OMPCaptureNoInitAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_CAPTURE_NO_INIT:
      return reinterpret_cast<const OMPCaptureNoInitAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPAllocateDeclAttr> OMPAllocateDeclAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPAllocateDeclAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPAllocateDeclAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPAllocateDeclAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OMPAllocateDeclAttr> OMPAllocateDeclAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OMPAllocateDeclAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOMPAllocateDeclAttrDerivedKinds[] = {
    OMPAllocateDeclAttr::static_kind(),
};

gap::generator<OMPAllocateDeclAttr> OMPAllocateDeclAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOMPAllocateDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OMPAllocateDeclAttr> e = OMPAllocateDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPAllocateDeclAttr> OMPAllocateDeclAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOMPAllocateDeclAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OMPAllocateDeclAttr> e = OMPAllocateDeclAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPAllocateDeclAttr> OMPAllocateDeclAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OMPAllocateDeclAttr> OMPAllocateDeclAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OMP_ALLOCATE_DECL:
      return reinterpret_cast<const OMPAllocateDeclAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPAllocateDeclAttr::alignment(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAllocateDeclAttr::allocator(void) const {
  RawEntityId eid = impl->reader.getVal16();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

OMPAllocateDeclAttrAllocatorTypeTy OMPAllocateDeclAttr::allocator_type(void) const {
  return static_cast<OMPAllocateDeclAttrAllocatorTypeTy>(impl->reader.getVal10());
}

gap::generator<NotTailCalledAttr> NotTailCalledAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NotTailCalledAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NotTailCalledAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NotTailCalledAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NotTailCalledAttr> NotTailCalledAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NotTailCalledAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNotTailCalledAttrDerivedKinds[] = {
    NotTailCalledAttr::static_kind(),
};

gap::generator<NotTailCalledAttr> NotTailCalledAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNotTailCalledAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NotTailCalledAttr> e = NotTailCalledAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NotTailCalledAttr> NotTailCalledAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNotTailCalledAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NotTailCalledAttr> e = NotTailCalledAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NotTailCalledAttr> NotTailCalledAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NotTailCalledAttr> NotTailCalledAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NOT_TAIL_CALLED:
      return reinterpret_cast<const NotTailCalledAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoUniqueAddressAttr> NoUniqueAddressAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoUniqueAddressAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoUniqueAddressAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoUniqueAddressAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoUniqueAddressAttr> NoUniqueAddressAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoUniqueAddressAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoUniqueAddressAttrDerivedKinds[] = {
    NoUniqueAddressAttr::static_kind(),
};

gap::generator<NoUniqueAddressAttr> NoUniqueAddressAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoUniqueAddressAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoUniqueAddressAttr> e = NoUniqueAddressAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoUniqueAddressAttr> NoUniqueAddressAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoUniqueAddressAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoUniqueAddressAttr> e = NoUniqueAddressAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoUniqueAddressAttr> NoUniqueAddressAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoUniqueAddressAttr> NoUniqueAddressAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_UNIQUE_ADDRESS:
      return reinterpret_cast<const NoUniqueAddressAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoThrowAttr> NoThrowAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoThrowAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoThrowAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoThrowAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoThrowAttr> NoThrowAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoThrowAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoThrowAttrDerivedKinds[] = {
    NoThrowAttr::static_kind(),
};

gap::generator<NoThrowAttr> NoThrowAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoThrowAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoThrowAttr> e = NoThrowAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoThrowAttr> NoThrowAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoThrowAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoThrowAttr> e = NoThrowAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoThrowAttr> NoThrowAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoThrowAttr> NoThrowAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_THROW:
      return reinterpret_cast<const NoThrowAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoThreadSafetyAnalysisAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoThreadSafetyAnalysisAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoThreadSafetyAnalysisAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoThreadSafetyAnalysisAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoThreadSafetyAnalysisAttrDerivedKinds[] = {
    NoThreadSafetyAnalysisAttr::static_kind(),
};

gap::generator<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoThreadSafetyAnalysisAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoThreadSafetyAnalysisAttr> e = NoThreadSafetyAnalysisAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoThreadSafetyAnalysisAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoThreadSafetyAnalysisAttr> e = NoThreadSafetyAnalysisAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoThreadSafetyAnalysisAttr> NoThreadSafetyAnalysisAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_THREAD_SAFETY_ANALYSIS:
      return reinterpret_cast<const NoThreadSafetyAnalysisAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoStackProtectorAttr> NoStackProtectorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoStackProtectorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoStackProtectorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoStackProtectorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoStackProtectorAttr> NoStackProtectorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoStackProtectorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoStackProtectorAttrDerivedKinds[] = {
    NoStackProtectorAttr::static_kind(),
};

gap::generator<NoStackProtectorAttr> NoStackProtectorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoStackProtectorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoStackProtectorAttr> e = NoStackProtectorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoStackProtectorAttr> NoStackProtectorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoStackProtectorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoStackProtectorAttr> e = NoStackProtectorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoStackProtectorAttr> NoStackProtectorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoStackProtectorAttr> NoStackProtectorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_STACK_PROTECTOR:
      return reinterpret_cast<const NoStackProtectorAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoSplitStackAttr> NoSplitStackAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoSplitStackAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoSplitStackAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoSplitStackAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoSplitStackAttr> NoSplitStackAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoSplitStackAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoSplitStackAttrDerivedKinds[] = {
    NoSplitStackAttr::static_kind(),
};

gap::generator<NoSplitStackAttr> NoSplitStackAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoSplitStackAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoSplitStackAttr> e = NoSplitStackAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoSplitStackAttr> NoSplitStackAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoSplitStackAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoSplitStackAttr> e = NoSplitStackAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoSplitStackAttr> NoSplitStackAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoSplitStackAttr> NoSplitStackAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_SPLIT_STACK:
      return reinterpret_cast<const NoSplitStackAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoSpeculativeLoadHardeningAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoSpeculativeLoadHardeningAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoSpeculativeLoadHardeningAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoSpeculativeLoadHardeningAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoSpeculativeLoadHardeningAttrDerivedKinds[] = {
    NoSpeculativeLoadHardeningAttr::static_kind(),
};

gap::generator<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoSpeculativeLoadHardeningAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoSpeculativeLoadHardeningAttr> e = NoSpeculativeLoadHardeningAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoSpeculativeLoadHardeningAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoSpeculativeLoadHardeningAttr> e = NoSpeculativeLoadHardeningAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoSpeculativeLoadHardeningAttr> NoSpeculativeLoadHardeningAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_SPECULATIVE_LOAD_HARDENING:
      return reinterpret_cast<const NoSpeculativeLoadHardeningAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoSanitizeAttr> NoSanitizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoSanitizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoSanitizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoSanitizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoSanitizeAttr> NoSanitizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoSanitizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoSanitizeAttrDerivedKinds[] = {
    NoSanitizeAttr::static_kind(),
};

gap::generator<NoSanitizeAttr> NoSanitizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoSanitizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoSanitizeAttr> e = NoSanitizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoSanitizeAttr> NoSanitizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoSanitizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoSanitizeAttr> e = NoSanitizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoSanitizeAttr> NoSanitizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoSanitizeAttr> NoSanitizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_SANITIZE:
      return reinterpret_cast<const NoSanitizeAttr &>(parent);
    default: return std::nullopt;
  }
}

bool NoSanitizeAttr::has_coverage(void) const {
  return impl->reader.getVal12();
}

gap::generator<NoReturnAttr> NoReturnAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoReturnAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoReturnAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoReturnAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoReturnAttr> NoReturnAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoReturnAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoReturnAttrDerivedKinds[] = {
    NoReturnAttr::static_kind(),
};

gap::generator<NoReturnAttr> NoReturnAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoReturnAttr> e = NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoReturnAttr> NoReturnAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoReturnAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoReturnAttr> e = NoReturnAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoReturnAttr> NoReturnAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoReturnAttr> NoReturnAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_RETURN:
      return reinterpret_cast<const NoReturnAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoRandomizeLayoutAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoRandomizeLayoutAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoRandomizeLayoutAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoRandomizeLayoutAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoRandomizeLayoutAttrDerivedKinds[] = {
    NoRandomizeLayoutAttr::static_kind(),
};

gap::generator<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoRandomizeLayoutAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoRandomizeLayoutAttr> e = NoRandomizeLayoutAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoRandomizeLayoutAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoRandomizeLayoutAttr> e = NoRandomizeLayoutAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoRandomizeLayoutAttr> NoRandomizeLayoutAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_RANDOMIZE_LAYOUT:
      return reinterpret_cast<const NoRandomizeLayoutAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoProfileFunctionAttr> NoProfileFunctionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoProfileFunctionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoProfileFunctionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoProfileFunctionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoProfileFunctionAttr> NoProfileFunctionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoProfileFunctionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoProfileFunctionAttrDerivedKinds[] = {
    NoProfileFunctionAttr::static_kind(),
};

gap::generator<NoProfileFunctionAttr> NoProfileFunctionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoProfileFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoProfileFunctionAttr> e = NoProfileFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoProfileFunctionAttr> NoProfileFunctionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoProfileFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoProfileFunctionAttr> e = NoProfileFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoProfileFunctionAttr> NoProfileFunctionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoProfileFunctionAttr> NoProfileFunctionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_PROFILE_FUNCTION:
      return reinterpret_cast<const NoProfileFunctionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoMips16Attr> NoMips16Attr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoMips16Attr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoMips16Attr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoMips16Attr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoMips16Attr> NoMips16Attr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoMips16Attr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoMips16AttrDerivedKinds[] = {
    NoMips16Attr::static_kind(),
};

gap::generator<NoMips16Attr> NoMips16Attr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoMips16AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoMips16Attr> e = NoMips16Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoMips16Attr> NoMips16Attr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoMips16AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoMips16Attr> e = NoMips16Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoMips16Attr> NoMips16Attr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoMips16Attr> NoMips16Attr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_MIPS16:
      return reinterpret_cast<const NoMips16Attr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoMicroMipsAttr> NoMicroMipsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoMicroMipsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoMicroMipsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoMicroMipsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoMicroMipsAttr> NoMicroMipsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoMicroMipsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoMicroMipsAttrDerivedKinds[] = {
    NoMicroMipsAttr::static_kind(),
};

gap::generator<NoMicroMipsAttr> NoMicroMipsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoMicroMipsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoMicroMipsAttr> e = NoMicroMipsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoMicroMipsAttr> NoMicroMipsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoMicroMipsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoMicroMipsAttr> e = NoMicroMipsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoMicroMipsAttr> NoMicroMipsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoMicroMipsAttr> NoMicroMipsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_MICRO_MIPS:
      return reinterpret_cast<const NoMicroMipsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoInstrumentFunctionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoInstrumentFunctionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoInstrumentFunctionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoInstrumentFunctionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoInstrumentFunctionAttrDerivedKinds[] = {
    NoInstrumentFunctionAttr::static_kind(),
};

gap::generator<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoInstrumentFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoInstrumentFunctionAttr> e = NoInstrumentFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoInstrumentFunctionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoInstrumentFunctionAttr> e = NoInstrumentFunctionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoInstrumentFunctionAttr> NoInstrumentFunctionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_INSTRUMENT_FUNCTION:
      return reinterpret_cast<const NoInstrumentFunctionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoDuplicateAttr> NoDuplicateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoDuplicateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoDuplicateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoDuplicateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoDuplicateAttr> NoDuplicateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoDuplicateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoDuplicateAttrDerivedKinds[] = {
    NoDuplicateAttr::static_kind(),
};

gap::generator<NoDuplicateAttr> NoDuplicateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoDuplicateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoDuplicateAttr> e = NoDuplicateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoDuplicateAttr> NoDuplicateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoDuplicateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoDuplicateAttr> e = NoDuplicateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoDuplicateAttr> NoDuplicateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoDuplicateAttr> NoDuplicateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_DUPLICATE:
      return reinterpret_cast<const NoDuplicateAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoDestroyAttr> NoDestroyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoDestroyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoDestroyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoDestroyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoDestroyAttr> NoDestroyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoDestroyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoDestroyAttrDerivedKinds[] = {
    NoDestroyAttr::static_kind(),
};

gap::generator<NoDestroyAttr> NoDestroyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoDestroyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoDestroyAttr> e = NoDestroyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoDestroyAttr> NoDestroyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoDestroyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoDestroyAttr> e = NoDestroyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoDestroyAttr> NoDestroyAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoDestroyAttr> NoDestroyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_DESTROY:
      return reinterpret_cast<const NoDestroyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoDebugAttr> NoDebugAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoDebugAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoDebugAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoDebugAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoDebugAttr> NoDebugAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoDebugAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoDebugAttrDerivedKinds[] = {
    NoDebugAttr::static_kind(),
};

gap::generator<NoDebugAttr> NoDebugAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoDebugAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoDebugAttr> e = NoDebugAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoDebugAttr> NoDebugAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoDebugAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoDebugAttr> e = NoDebugAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoDebugAttr> NoDebugAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoDebugAttr> NoDebugAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_DEBUG:
      return reinterpret_cast<const NoDebugAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoCommonAttr> NoCommonAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoCommonAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoCommonAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoCommonAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoCommonAttr> NoCommonAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoCommonAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoCommonAttrDerivedKinds[] = {
    NoCommonAttr::static_kind(),
};

gap::generator<NoCommonAttr> NoCommonAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoCommonAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoCommonAttr> e = NoCommonAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoCommonAttr> NoCommonAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoCommonAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoCommonAttr> e = NoCommonAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoCommonAttr> NoCommonAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoCommonAttr> NoCommonAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_COMMON:
      return reinterpret_cast<const NoCommonAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NoAliasAttr> NoAliasAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoAliasAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoAliasAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoAliasAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NoAliasAttr> NoAliasAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NoAliasAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNoAliasAttrDerivedKinds[] = {
    NoAliasAttr::static_kind(),
};

gap::generator<NoAliasAttr> NoAliasAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNoAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NoAliasAttr> e = NoAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoAliasAttr> NoAliasAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNoAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NoAliasAttr> e = NoAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoAliasAttr> NoAliasAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NoAliasAttr> NoAliasAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NO_ALIAS:
      return reinterpret_cast<const NoAliasAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NakedAttr> NakedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NakedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NakedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NakedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NakedAttr> NakedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NakedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNakedAttrDerivedKinds[] = {
    NakedAttr::static_kind(),
};

gap::generator<NakedAttr> NakedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNakedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NakedAttr> e = NakedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NakedAttr> NakedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNakedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NakedAttr> e = NakedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NakedAttr> NakedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NakedAttr> NakedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NAKED:
      return reinterpret_cast<const NakedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NSReturnsRetainedAttr> NSReturnsRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSReturnsRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSReturnsRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSReturnsRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSReturnsRetainedAttr> NSReturnsRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSReturnsRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSReturnsRetainedAttrDerivedKinds[] = {
    NSReturnsRetainedAttr::static_kind(),
};

gap::generator<NSReturnsRetainedAttr> NSReturnsRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSReturnsRetainedAttr> e = NSReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSReturnsRetainedAttr> NSReturnsRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSReturnsRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSReturnsRetainedAttr> e = NSReturnsRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSReturnsRetainedAttr> NSReturnsRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSReturnsRetainedAttr> NSReturnsRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_RETURNS_RETAINED:
      return reinterpret_cast<const NSReturnsRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSReturnsNotRetainedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSReturnsNotRetainedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSReturnsNotRetainedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSReturnsNotRetainedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSReturnsNotRetainedAttrDerivedKinds[] = {
    NSReturnsNotRetainedAttr::static_kind(),
};

gap::generator<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSReturnsNotRetainedAttr> e = NSReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSReturnsNotRetainedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSReturnsNotRetainedAttr> e = NSReturnsNotRetainedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSReturnsNotRetainedAttr> NSReturnsNotRetainedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_RETURNS_NOT_RETAINED:
      return reinterpret_cast<const NSReturnsNotRetainedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSReturnsAutoreleasedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSReturnsAutoreleasedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSReturnsAutoreleasedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSReturnsAutoreleasedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSReturnsAutoreleasedAttrDerivedKinds[] = {
    NSReturnsAutoreleasedAttr::static_kind(),
};

gap::generator<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSReturnsAutoreleasedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSReturnsAutoreleasedAttr> e = NSReturnsAutoreleasedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSReturnsAutoreleasedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSReturnsAutoreleasedAttr> e = NSReturnsAutoreleasedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSReturnsAutoreleasedAttr> NSReturnsAutoreleasedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_RETURNS_AUTORELEASED:
      return reinterpret_cast<const NSReturnsAutoreleasedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NSErrorDomainAttr> NSErrorDomainAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSErrorDomainAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSErrorDomainAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSErrorDomainAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSErrorDomainAttr> NSErrorDomainAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSErrorDomainAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSErrorDomainAttrDerivedKinds[] = {
    NSErrorDomainAttr::static_kind(),
};

gap::generator<NSErrorDomainAttr> NSErrorDomainAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSErrorDomainAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSErrorDomainAttr> e = NSErrorDomainAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSErrorDomainAttr> NSErrorDomainAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSErrorDomainAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSErrorDomainAttr> e = NSErrorDomainAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSErrorDomainAttr> NSErrorDomainAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSErrorDomainAttr> NSErrorDomainAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_ERROR_DOMAIN:
      return reinterpret_cast<const NSErrorDomainAttr &>(parent);
    default: return std::nullopt;
  }
}

VarDecl NSErrorDomainAttr::error_domain(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<NSConsumesSelfAttr> NSConsumesSelfAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSConsumesSelfAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSConsumesSelfAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSConsumesSelfAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSConsumesSelfAttr> NSConsumesSelfAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSConsumesSelfAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSConsumesSelfAttrDerivedKinds[] = {
    NSConsumesSelfAttr::static_kind(),
};

gap::generator<NSConsumesSelfAttr> NSConsumesSelfAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSConsumesSelfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSConsumesSelfAttr> e = NSConsumesSelfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSConsumesSelfAttr> NSConsumesSelfAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSConsumesSelfAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSConsumesSelfAttr> e = NSConsumesSelfAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSConsumesSelfAttr> NSConsumesSelfAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSConsumesSelfAttr> NSConsumesSelfAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_CONSUMES_SELF:
      return reinterpret_cast<const NSConsumesSelfAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MipsShortCallAttr> MipsShortCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MipsShortCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MipsShortCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MipsShortCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MipsShortCallAttr> MipsShortCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MipsShortCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMipsShortCallAttrDerivedKinds[] = {
    MipsShortCallAttr::static_kind(),
};

gap::generator<MipsShortCallAttr> MipsShortCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMipsShortCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MipsShortCallAttr> e = MipsShortCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MipsShortCallAttr> MipsShortCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMipsShortCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MipsShortCallAttr> e = MipsShortCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MipsShortCallAttr> MipsShortCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MipsShortCallAttr> MipsShortCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIPS_SHORT_CALL:
      return reinterpret_cast<const MipsShortCallAttr &>(parent);
    default: return std::nullopt;
  }
}

MipsShortCallAttrSpelling MipsShortCallAttr::semantic_spelling(void) const {
  return static_cast<MipsShortCallAttrSpelling>(impl->reader.getVal10());
}

gap::generator<MipsLongCallAttr> MipsLongCallAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MipsLongCallAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MipsLongCallAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MipsLongCallAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MipsLongCallAttr> MipsLongCallAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MipsLongCallAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMipsLongCallAttrDerivedKinds[] = {
    MipsLongCallAttr::static_kind(),
};

gap::generator<MipsLongCallAttr> MipsLongCallAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMipsLongCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MipsLongCallAttr> e = MipsLongCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MipsLongCallAttr> MipsLongCallAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMipsLongCallAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MipsLongCallAttr> e = MipsLongCallAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MipsLongCallAttr> MipsLongCallAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MipsLongCallAttr> MipsLongCallAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIPS_LONG_CALL:
      return reinterpret_cast<const MipsLongCallAttr &>(parent);
    default: return std::nullopt;
  }
}

MipsLongCallAttrSpelling MipsLongCallAttr::semantic_spelling(void) const {
  return static_cast<MipsLongCallAttrSpelling>(impl->reader.getVal10());
}

gap::generator<MipsInterruptAttr> MipsInterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MipsInterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MipsInterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MipsInterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MipsInterruptAttr> MipsInterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MipsInterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMipsInterruptAttrDerivedKinds[] = {
    MipsInterruptAttr::static_kind(),
};

gap::generator<MipsInterruptAttr> MipsInterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMipsInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MipsInterruptAttr> e = MipsInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MipsInterruptAttr> MipsInterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMipsInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MipsInterruptAttr> e = MipsInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MipsInterruptAttr> MipsInterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MipsInterruptAttr> MipsInterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIPS_INTERRUPT:
      return reinterpret_cast<const MipsInterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

MipsInterruptAttrInterruptType MipsInterruptAttr::interrupt(void) const {
  return static_cast<MipsInterruptAttrInterruptType>(impl->reader.getVal10());
}

gap::generator<Mips16Attr> Mips16Attr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Mips16Attr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Mips16Attr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Mips16Attr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<Mips16Attr> Mips16Attr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return Mips16Attr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMips16AttrDerivedKinds[] = {
    Mips16Attr::static_kind(),
};

gap::generator<Mips16Attr> Mips16Attr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMips16AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<Mips16Attr> e = Mips16Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<Mips16Attr> Mips16Attr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMips16AttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<Mips16Attr> e = Mips16Attr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<Mips16Attr> Mips16Attr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<Mips16Attr> Mips16Attr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIPS16:
      return reinterpret_cast<const Mips16Attr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MinVectorWidthAttr> MinVectorWidthAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MinVectorWidthAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MinVectorWidthAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MinVectorWidthAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MinVectorWidthAttr> MinVectorWidthAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MinVectorWidthAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMinVectorWidthAttrDerivedKinds[] = {
    MinVectorWidthAttr::static_kind(),
};

gap::generator<MinVectorWidthAttr> MinVectorWidthAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMinVectorWidthAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MinVectorWidthAttr> e = MinVectorWidthAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MinVectorWidthAttr> MinVectorWidthAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMinVectorWidthAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MinVectorWidthAttr> e = MinVectorWidthAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MinVectorWidthAttr> MinVectorWidthAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MinVectorWidthAttr> MinVectorWidthAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIN_VECTOR_WIDTH:
      return reinterpret_cast<const MinVectorWidthAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MinSizeAttr> MinSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MinSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MinSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MinSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MinSizeAttr> MinSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MinSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMinSizeAttrDerivedKinds[] = {
    MinSizeAttr::static_kind(),
};

gap::generator<MinSizeAttr> MinSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMinSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MinSizeAttr> e = MinSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MinSizeAttr> MinSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMinSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MinSizeAttr> e = MinSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MinSizeAttr> MinSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MinSizeAttr> MinSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIN_SIZE:
      return reinterpret_cast<const MinSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MicroMipsAttr> MicroMipsAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MicroMipsAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MicroMipsAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MicroMipsAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MicroMipsAttr> MicroMipsAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MicroMipsAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMicroMipsAttrDerivedKinds[] = {
    MicroMipsAttr::static_kind(),
};

gap::generator<MicroMipsAttr> MicroMipsAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMicroMipsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MicroMipsAttr> e = MicroMipsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MicroMipsAttr> MicroMipsAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMicroMipsAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MicroMipsAttr> e = MicroMipsAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MicroMipsAttr> MicroMipsAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MicroMipsAttr> MicroMipsAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MICRO_MIPS:
      return reinterpret_cast<const MicroMipsAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MayAliasAttr> MayAliasAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MayAliasAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MayAliasAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MayAliasAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MayAliasAttr> MayAliasAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MayAliasAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMayAliasAttrDerivedKinds[] = {
    MayAliasAttr::static_kind(),
};

gap::generator<MayAliasAttr> MayAliasAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMayAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MayAliasAttr> e = MayAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MayAliasAttr> MayAliasAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMayAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MayAliasAttr> e = MayAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MayAliasAttr> MayAliasAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MayAliasAttr> MayAliasAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MAY_ALIAS:
      return reinterpret_cast<const MayAliasAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MaxFieldAlignmentAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MaxFieldAlignmentAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MaxFieldAlignmentAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MaxFieldAlignmentAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMaxFieldAlignmentAttrDerivedKinds[] = {
    MaxFieldAlignmentAttr::static_kind(),
};

gap::generator<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMaxFieldAlignmentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MaxFieldAlignmentAttr> e = MaxFieldAlignmentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMaxFieldAlignmentAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MaxFieldAlignmentAttr> e = MaxFieldAlignmentAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MaxFieldAlignmentAttr> MaxFieldAlignmentAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MAX_FIELD_ALIGNMENT:
      return reinterpret_cast<const MaxFieldAlignmentAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MSVtorDispAttr> MSVtorDispAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSVtorDispAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSVtorDispAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSVtorDispAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSVtorDispAttr> MSVtorDispAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSVtorDispAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSVtorDispAttrDerivedKinds[] = {
    MSVtorDispAttr::static_kind(),
};

gap::generator<MSVtorDispAttr> MSVtorDispAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSVtorDispAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSVtorDispAttr> e = MSVtorDispAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSVtorDispAttr> MSVtorDispAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSVtorDispAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSVtorDispAttr> e = MSVtorDispAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSVtorDispAttr> MSVtorDispAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSVtorDispAttr> MSVtorDispAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MS_VTOR_DISP:
      return reinterpret_cast<const MSVtorDispAttr &>(parent);
    default: return std::nullopt;
  }
}

MSVtorDispMode MSVtorDispAttr::vtor_disp_mode(void) const {
  return static_cast<MSVtorDispMode>(impl->reader.getVal10());
}

gap::generator<MSStructAttr> MSStructAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSStructAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSStructAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSStructAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSStructAttr> MSStructAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSStructAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSStructAttrDerivedKinds[] = {
    MSStructAttr::static_kind(),
};

gap::generator<MSStructAttr> MSStructAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSStructAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSStructAttr> e = MSStructAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSStructAttr> MSStructAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSStructAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSStructAttr> e = MSStructAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSStructAttr> MSStructAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSStructAttr> MSStructAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MS_STRUCT:
      return reinterpret_cast<const MSStructAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MSP430InterruptAttr> MSP430InterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSP430InterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSP430InterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSP430InterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSP430InterruptAttr> MSP430InterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSP430InterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSP430InterruptAttrDerivedKinds[] = {
    MSP430InterruptAttr::static_kind(),
};

gap::generator<MSP430InterruptAttr> MSP430InterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSP430InterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSP430InterruptAttr> e = MSP430InterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSP430InterruptAttr> MSP430InterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSP430InterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSP430InterruptAttr> e = MSP430InterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSP430InterruptAttr> MSP430InterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSP430InterruptAttr> MSP430InterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MSP430_INTERRUPT:
      return reinterpret_cast<const MSP430InterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MSNoVTableAttr> MSNoVTableAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSNoVTableAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSNoVTableAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSNoVTableAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSNoVTableAttr> MSNoVTableAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSNoVTableAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSNoVTableAttrDerivedKinds[] = {
    MSNoVTableAttr::static_kind(),
};

gap::generator<MSNoVTableAttr> MSNoVTableAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSNoVTableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSNoVTableAttr> e = MSNoVTableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSNoVTableAttr> MSNoVTableAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSNoVTableAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSNoVTableAttr> e = MSNoVTableAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSNoVTableAttr> MSNoVTableAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSNoVTableAttr> MSNoVTableAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MS_NO_V_TABLE:
      return reinterpret_cast<const MSNoVTableAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MSInheritanceAttr> MSInheritanceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSInheritanceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSInheritanceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSInheritanceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSInheritanceAttr> MSInheritanceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSInheritanceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSInheritanceAttrDerivedKinds[] = {
    MSInheritanceAttr::static_kind(),
};

gap::generator<MSInheritanceAttr> MSInheritanceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSInheritanceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSInheritanceAttr> e = MSInheritanceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSInheritanceAttr> MSInheritanceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSInheritanceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSInheritanceAttr> e = MSInheritanceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSInheritanceAttr> MSInheritanceAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSInheritanceAttr> MSInheritanceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MS_INHERITANCE:
      return reinterpret_cast<const MSInheritanceAttr &>(parent);
    default: return std::nullopt;
  }
}

bool MSInheritanceAttr::best_case(void) const {
  return impl->reader.getVal12();
}

MSInheritanceModel MSInheritanceAttr::inheritance_model(void) const {
  return static_cast<MSInheritanceModel>(impl->reader.getVal10());
}

MSInheritanceAttrSpelling MSInheritanceAttr::semantic_spelling(void) const {
  return static_cast<MSInheritanceAttrSpelling>(impl->reader.getVal14());
}

gap::generator<MSAllocatorAttr> MSAllocatorAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSAllocatorAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSAllocatorAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSAllocatorAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSAllocatorAttr> MSAllocatorAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSAllocatorAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSAllocatorAttrDerivedKinds[] = {
    MSAllocatorAttr::static_kind(),
};

gap::generator<MSAllocatorAttr> MSAllocatorAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSAllocatorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSAllocatorAttr> e = MSAllocatorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSAllocatorAttr> MSAllocatorAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSAllocatorAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSAllocatorAttr> e = MSAllocatorAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSAllocatorAttr> MSAllocatorAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSAllocatorAttr> MSAllocatorAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MS_ALLOCATOR:
      return reinterpret_cast<const MSAllocatorAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MSABIAttr> MSABIAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSABIAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSABIAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSABIAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MSABIAttr> MSABIAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MSABIAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMSABIAttrDerivedKinds[] = {
    MSABIAttr::static_kind(),
};

gap::generator<MSABIAttr> MSABIAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMSABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MSABIAttr> e = MSABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSABIAttr> MSABIAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMSABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MSABIAttr> e = MSABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSABIAttr> MSABIAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MSABIAttr> MSABIAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MSABI:
      return reinterpret_cast<const MSABIAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MIGServerRoutineAttr> MIGServerRoutineAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MIGServerRoutineAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MIGServerRoutineAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MIGServerRoutineAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MIGServerRoutineAttr> MIGServerRoutineAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return MIGServerRoutineAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kMIGServerRoutineAttrDerivedKinds[] = {
    MIGServerRoutineAttr::static_kind(),
};

gap::generator<MIGServerRoutineAttr> MIGServerRoutineAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kMIGServerRoutineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<MIGServerRoutineAttr> e = MIGServerRoutineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MIGServerRoutineAttr> MIGServerRoutineAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kMIGServerRoutineAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<MIGServerRoutineAttr> e = MIGServerRoutineAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MIGServerRoutineAttr> MIGServerRoutineAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<MIGServerRoutineAttr> MIGServerRoutineAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::MIG_SERVER_ROUTINE_:
      return reinterpret_cast<const MIGServerRoutineAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<M68kInterruptAttr> M68kInterruptAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = M68kInterruptAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool M68kInterruptAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : M68kInterruptAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<M68kInterruptAttr> M68kInterruptAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return M68kInterruptAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kM68kInterruptAttrDerivedKinds[] = {
    M68kInterruptAttr::static_kind(),
};

gap::generator<M68kInterruptAttr> M68kInterruptAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kM68kInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<M68kInterruptAttr> e = M68kInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<M68kInterruptAttr> M68kInterruptAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kM68kInterruptAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<M68kInterruptAttr> e = M68kInterruptAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<M68kInterruptAttr> M68kInterruptAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<M68kInterruptAttr> M68kInterruptAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::M68K_INTERRUPT:
      return reinterpret_cast<const M68kInterruptAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LocksExcludedAttr> LocksExcludedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LocksExcludedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LocksExcludedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LocksExcludedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LocksExcludedAttr> LocksExcludedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LocksExcludedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLocksExcludedAttrDerivedKinds[] = {
    LocksExcludedAttr::static_kind(),
};

gap::generator<LocksExcludedAttr> LocksExcludedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLocksExcludedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LocksExcludedAttr> e = LocksExcludedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LocksExcludedAttr> LocksExcludedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLocksExcludedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LocksExcludedAttr> e = LocksExcludedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LocksExcludedAttr> LocksExcludedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LocksExcludedAttr> LocksExcludedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LOCKS_EXCLUDED:
      return reinterpret_cast<const LocksExcludedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LockReturnedAttr> LockReturnedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LockReturnedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LockReturnedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LockReturnedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LockReturnedAttr> LockReturnedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LockReturnedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLockReturnedAttrDerivedKinds[] = {
    LockReturnedAttr::static_kind(),
};

gap::generator<LockReturnedAttr> LockReturnedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLockReturnedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LockReturnedAttr> e = LockReturnedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LockReturnedAttr> LockReturnedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLockReturnedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LockReturnedAttr> e = LockReturnedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LockReturnedAttr> LockReturnedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LockReturnedAttr> LockReturnedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LOCK_RETURNED:
      return reinterpret_cast<const LockReturnedAttr &>(parent);
    default: return std::nullopt;
  }
}

Expr LockReturnedAttr::argument(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<LifetimeBoundAttr> LifetimeBoundAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LifetimeBoundAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LifetimeBoundAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LifetimeBoundAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LifetimeBoundAttr> LifetimeBoundAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LifetimeBoundAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLifetimeBoundAttrDerivedKinds[] = {
    LifetimeBoundAttr::static_kind(),
};

gap::generator<LifetimeBoundAttr> LifetimeBoundAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLifetimeBoundAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LifetimeBoundAttr> e = LifetimeBoundAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LifetimeBoundAttr> LifetimeBoundAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLifetimeBoundAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LifetimeBoundAttr> e = LifetimeBoundAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LifetimeBoundAttr> LifetimeBoundAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LifetimeBoundAttr> LifetimeBoundAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LIFETIME_BOUND:
      return reinterpret_cast<const LifetimeBoundAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LeafAttr> LeafAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LeafAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LeafAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LeafAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LeafAttr> LeafAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LeafAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLeafAttrDerivedKinds[] = {
    LeafAttr::static_kind(),
};

gap::generator<LeafAttr> LeafAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLeafAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LeafAttr> e = LeafAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LeafAttr> LeafAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLeafAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LeafAttr> e = LeafAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LeafAttr> LeafAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LeafAttr> LeafAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LEAF:
      return reinterpret_cast<const LeafAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LayoutVersionAttr> LayoutVersionAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LayoutVersionAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LayoutVersionAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LayoutVersionAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LayoutVersionAttr> LayoutVersionAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LayoutVersionAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLayoutVersionAttrDerivedKinds[] = {
    LayoutVersionAttr::static_kind(),
};

gap::generator<LayoutVersionAttr> LayoutVersionAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLayoutVersionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LayoutVersionAttr> e = LayoutVersionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LayoutVersionAttr> LayoutVersionAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLayoutVersionAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LayoutVersionAttr> e = LayoutVersionAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LayoutVersionAttr> LayoutVersionAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LayoutVersionAttr> LayoutVersionAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LAYOUT_VERSION:
      return reinterpret_cast<const LayoutVersionAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LTOVisibilityPublicAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LTOVisibilityPublicAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LTOVisibilityPublicAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return LTOVisibilityPublicAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kLTOVisibilityPublicAttrDerivedKinds[] = {
    LTOVisibilityPublicAttr::static_kind(),
};

gap::generator<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kLTOVisibilityPublicAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<LTOVisibilityPublicAttr> e = LTOVisibilityPublicAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kLTOVisibilityPublicAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<LTOVisibilityPublicAttr> e = LTOVisibilityPublicAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<LTOVisibilityPublicAttr> LTOVisibilityPublicAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::LTO_VISIBILITY_PUBLIC:
      return reinterpret_cast<const LTOVisibilityPublicAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<InternalLinkageAttr> InternalLinkageAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InternalLinkageAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InternalLinkageAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InternalLinkageAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InternalLinkageAttr> InternalLinkageAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return InternalLinkageAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kInternalLinkageAttrDerivedKinds[] = {
    InternalLinkageAttr::static_kind(),
};

gap::generator<InternalLinkageAttr> InternalLinkageAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kInternalLinkageAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<InternalLinkageAttr> e = InternalLinkageAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InternalLinkageAttr> InternalLinkageAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kInternalLinkageAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<InternalLinkageAttr> e = InternalLinkageAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InternalLinkageAttr> InternalLinkageAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<InternalLinkageAttr> InternalLinkageAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::INTERNAL_LINKAGE:
      return reinterpret_cast<const InternalLinkageAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IntelOclBiccAttr> IntelOclBiccAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IntelOclBiccAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IntelOclBiccAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IntelOclBiccAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IntelOclBiccAttr> IntelOclBiccAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return IntelOclBiccAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kIntelOclBiccAttrDerivedKinds[] = {
    IntelOclBiccAttr::static_kind(),
};

gap::generator<IntelOclBiccAttr> IntelOclBiccAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kIntelOclBiccAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<IntelOclBiccAttr> e = IntelOclBiccAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IntelOclBiccAttr> IntelOclBiccAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kIntelOclBiccAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<IntelOclBiccAttr> e = IntelOclBiccAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IntelOclBiccAttr> IntelOclBiccAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<IntelOclBiccAttr> IntelOclBiccAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::INTEL_OCL_BICC:
      return reinterpret_cast<const IntelOclBiccAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<InitPriorityAttr> InitPriorityAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InitPriorityAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InitPriorityAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InitPriorityAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InitPriorityAttr> InitPriorityAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return InitPriorityAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kInitPriorityAttrDerivedKinds[] = {
    InitPriorityAttr::static_kind(),
};

gap::generator<InitPriorityAttr> InitPriorityAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kInitPriorityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<InitPriorityAttr> e = InitPriorityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InitPriorityAttr> InitPriorityAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kInitPriorityAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<InitPriorityAttr> e = InitPriorityAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InitPriorityAttr> InitPriorityAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<InitPriorityAttr> InitPriorityAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::INIT_PRIORITY:
      return reinterpret_cast<const InitPriorityAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<InheritableParamAttr> InheritableParamAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InheritableParamAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InheritableParamAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InheritableParamAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InheritableParamAttr> InheritableParamAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return InheritableParamAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kInheritableParamAttrDerivedKinds[] = {
    NSConsumedAttr::static_kind(),
    NonNullAttr::static_kind(),
    OSConsumedAttr::static_kind(),
    PassObjectSizeAttr::static_kind(),
    ReleaseHandleAttr::static_kind(),
    UseHandleAttr::static_kind(),
    AnnotateAttr::static_kind(),
    CFConsumedAttr::static_kind(),
    CarriesDependencyAttr::static_kind(),
    SwiftAsyncContextAttr::static_kind(),
    SwiftContextAttr::static_kind(),
    SwiftErrorResultAttr::static_kind(),
    SwiftIndirectResultAttr::static_kind(),
};

gap::generator<InheritableParamAttr> InheritableParamAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kInheritableParamAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<InheritableParamAttr> e = InheritableParamAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InheritableParamAttr> InheritableParamAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kInheritableParamAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<InheritableParamAttr> e = InheritableParamAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InheritableParamAttr> InheritableParamAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<InheritableParamAttr> InheritableParamAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CARRIES_DEPENDENCY:
    case mx::AttrKind::CF_CONSUMED:
    case mx::AttrKind::ANNOTATE:
    case mx::AttrKind::USE_HANDLE:
    case mx::AttrKind::RELEASE_HANDLE:
    case mx::AttrKind::PASS_OBJECT_SIZE:
    case mx::AttrKind::SWIFT_INDIRECT_RESULT:
    case mx::AttrKind::SWIFT_ERROR_RESULT:
    case mx::AttrKind::SWIFT_CONTEXT:
    case mx::AttrKind::SWIFT_ASYNC_CONTEXT:
    case mx::AttrKind::OS_CONSUMED:
    case mx::AttrKind::NON_NULL:
    case mx::AttrKind::NS_CONSUMED:
      return reinterpret_cast<const InheritableParamAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CarriesDependencyAttr> CarriesDependencyAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CarriesDependencyAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CarriesDependencyAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CarriesDependencyAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CarriesDependencyAttr> CarriesDependencyAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CarriesDependencyAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCarriesDependencyAttrDerivedKinds[] = {
    CarriesDependencyAttr::static_kind(),
};

gap::generator<CarriesDependencyAttr> CarriesDependencyAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCarriesDependencyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CarriesDependencyAttr> e = CarriesDependencyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CarriesDependencyAttr> CarriesDependencyAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCarriesDependencyAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CarriesDependencyAttr> e = CarriesDependencyAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CarriesDependencyAttr> CarriesDependencyAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CarriesDependencyAttr> CarriesDependencyAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CarriesDependencyAttr> CarriesDependencyAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CARRIES_DEPENDENCY:
      return reinterpret_cast<const CarriesDependencyAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CFConsumedAttr> CFConsumedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CFConsumedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CFConsumedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CFConsumedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CFConsumedAttr> CFConsumedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CFConsumedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCFConsumedAttrDerivedKinds[] = {
    CFConsumedAttr::static_kind(),
};

gap::generator<CFConsumedAttr> CFConsumedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCFConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CFConsumedAttr> e = CFConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CFConsumedAttr> CFConsumedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCFConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CFConsumedAttr> e = CFConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CFConsumedAttr> CFConsumedAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFConsumedAttr> CFConsumedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<CFConsumedAttr> CFConsumedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CF_CONSUMED:
      return reinterpret_cast<const CFConsumedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AnnotateAttr> AnnotateAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AnnotateAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AnnotateAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AnnotateAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AnnotateAttr> AnnotateAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return AnnotateAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kAnnotateAttrDerivedKinds[] = {
    AnnotateAttr::static_kind(),
};

gap::generator<AnnotateAttr> AnnotateAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kAnnotateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<AnnotateAttr> e = AnnotateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AnnotateAttr> AnnotateAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kAnnotateAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<AnnotateAttr> e = AnnotateAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AnnotateAttr> AnnotateAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnnotateAttr> AnnotateAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<AnnotateAttr> AnnotateAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::ANNOTATE:
      return reinterpret_cast<const AnnotateAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AnnotateAttr::annotation(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<UseHandleAttr> UseHandleAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UseHandleAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UseHandleAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UseHandleAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UseHandleAttr> UseHandleAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return UseHandleAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kUseHandleAttrDerivedKinds[] = {
    UseHandleAttr::static_kind(),
};

gap::generator<UseHandleAttr> UseHandleAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kUseHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<UseHandleAttr> e = UseHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UseHandleAttr> UseHandleAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kUseHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<UseHandleAttr> e = UseHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UseHandleAttr> UseHandleAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UseHandleAttr> UseHandleAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<UseHandleAttr> UseHandleAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::USE_HANDLE:
      return reinterpret_cast<const UseHandleAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view UseHandleAttr::handle_type(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<ReleaseHandleAttr> ReleaseHandleAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReleaseHandleAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReleaseHandleAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReleaseHandleAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReleaseHandleAttr> ReleaseHandleAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ReleaseHandleAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kReleaseHandleAttrDerivedKinds[] = {
    ReleaseHandleAttr::static_kind(),
};

gap::generator<ReleaseHandleAttr> ReleaseHandleAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kReleaseHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ReleaseHandleAttr> e = ReleaseHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReleaseHandleAttr> ReleaseHandleAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kReleaseHandleAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ReleaseHandleAttr> e = ReleaseHandleAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReleaseHandleAttr> ReleaseHandleAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReleaseHandleAttr> ReleaseHandleAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ReleaseHandleAttr> ReleaseHandleAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::RELEASE_HANDLE:
      return reinterpret_cast<const ReleaseHandleAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view ReleaseHandleAttr::handle_type(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PassObjectSizeAttr> PassObjectSizeAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PassObjectSizeAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PassObjectSizeAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PassObjectSizeAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PassObjectSizeAttr> PassObjectSizeAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return PassObjectSizeAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kPassObjectSizeAttrDerivedKinds[] = {
    PassObjectSizeAttr::static_kind(),
};

gap::generator<PassObjectSizeAttr> PassObjectSizeAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kPassObjectSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<PassObjectSizeAttr> e = PassObjectSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PassObjectSizeAttr> PassObjectSizeAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kPassObjectSizeAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<PassObjectSizeAttr> e = PassObjectSizeAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PassObjectSizeAttr> PassObjectSizeAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PassObjectSizeAttr> PassObjectSizeAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<PassObjectSizeAttr> PassObjectSizeAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::PASS_OBJECT_SIZE:
      return reinterpret_cast<const PassObjectSizeAttr &>(parent);
    default: return std::nullopt;
  }
}

PassObjectSizeAttrSpelling PassObjectSizeAttr::semantic_spelling(void) const {
  return static_cast<PassObjectSizeAttrSpelling>(impl->reader.getVal10());
}

bool PassObjectSizeAttr::is_dynamic(void) const {
  return impl->reader.getVal12();
}

gap::generator<ParameterABIAttr> ParameterABIAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParameterABIAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParameterABIAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParameterABIAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ParameterABIAttr> ParameterABIAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return ParameterABIAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kParameterABIAttrDerivedKinds[] = {
    SwiftAsyncContextAttr::static_kind(),
    SwiftContextAttr::static_kind(),
    SwiftErrorResultAttr::static_kind(),
    SwiftIndirectResultAttr::static_kind(),
};

gap::generator<ParameterABIAttr> ParameterABIAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kParameterABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<ParameterABIAttr> e = ParameterABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParameterABIAttr> ParameterABIAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kParameterABIAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<ParameterABIAttr> e = ParameterABIAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParameterABIAttr> ParameterABIAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ParameterABIAttr> ParameterABIAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<ParameterABIAttr> ParameterABIAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_INDIRECT_RESULT:
    case mx::AttrKind::SWIFT_ERROR_RESULT:
    case mx::AttrKind::SWIFT_CONTEXT:
    case mx::AttrKind::SWIFT_ASYNC_CONTEXT:
      return reinterpret_cast<const ParameterABIAttr &>(parent);
    default: return std::nullopt;
  }
}

ParameterABI ParameterABIAttr::abi(void) const {
  return static_cast<ParameterABI>(impl->reader.getVal10());
}

gap::generator<SwiftIndirectResultAttr> SwiftIndirectResultAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftIndirectResultAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftIndirectResultAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftIndirectResultAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftIndirectResultAttr> SwiftIndirectResultAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftIndirectResultAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftIndirectResultAttrDerivedKinds[] = {
    SwiftIndirectResultAttr::static_kind(),
};

gap::generator<SwiftIndirectResultAttr> SwiftIndirectResultAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftIndirectResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftIndirectResultAttr> e = SwiftIndirectResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftIndirectResultAttr> SwiftIndirectResultAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftIndirectResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftIndirectResultAttr> e = SwiftIndirectResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftIndirectResultAttr> SwiftIndirectResultAttr::from(const ParameterABIAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftIndirectResultAttr> SwiftIndirectResultAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftIndirectResultAttr> SwiftIndirectResultAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftIndirectResultAttr> SwiftIndirectResultAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_INDIRECT_RESULT:
      return reinterpret_cast<const SwiftIndirectResultAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftErrorResultAttr> SwiftErrorResultAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftErrorResultAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftErrorResultAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftErrorResultAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftErrorResultAttr> SwiftErrorResultAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftErrorResultAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftErrorResultAttrDerivedKinds[] = {
    SwiftErrorResultAttr::static_kind(),
};

gap::generator<SwiftErrorResultAttr> SwiftErrorResultAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftErrorResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftErrorResultAttr> e = SwiftErrorResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftErrorResultAttr> SwiftErrorResultAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftErrorResultAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftErrorResultAttr> e = SwiftErrorResultAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftErrorResultAttr> SwiftErrorResultAttr::from(const ParameterABIAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftErrorResultAttr> SwiftErrorResultAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftErrorResultAttr> SwiftErrorResultAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftErrorResultAttr> SwiftErrorResultAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ERROR_RESULT:
      return reinterpret_cast<const SwiftErrorResultAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftContextAttr> SwiftContextAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftContextAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftContextAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftContextAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftContextAttr> SwiftContextAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftContextAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftContextAttrDerivedKinds[] = {
    SwiftContextAttr::static_kind(),
};

gap::generator<SwiftContextAttr> SwiftContextAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftContextAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftContextAttr> e = SwiftContextAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftContextAttr> SwiftContextAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftContextAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftContextAttr> e = SwiftContextAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftContextAttr> SwiftContextAttr::from(const ParameterABIAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftContextAttr> SwiftContextAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftContextAttr> SwiftContextAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftContextAttr> SwiftContextAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_CONTEXT:
      return reinterpret_cast<const SwiftContextAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<SwiftAsyncContextAttr> SwiftAsyncContextAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwiftAsyncContextAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwiftAsyncContextAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwiftAsyncContextAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SwiftAsyncContextAttr> SwiftAsyncContextAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return SwiftAsyncContextAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kSwiftAsyncContextAttrDerivedKinds[] = {
    SwiftAsyncContextAttr::static_kind(),
};

gap::generator<SwiftAsyncContextAttr> SwiftAsyncContextAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kSwiftAsyncContextAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<SwiftAsyncContextAttr> e = SwiftAsyncContextAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwiftAsyncContextAttr> SwiftAsyncContextAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kSwiftAsyncContextAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<SwiftAsyncContextAttr> e = SwiftAsyncContextAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwiftAsyncContextAttr> SwiftAsyncContextAttr::from(const ParameterABIAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncContextAttr> SwiftAsyncContextAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncContextAttr> SwiftAsyncContextAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<SwiftAsyncContextAttr> SwiftAsyncContextAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::SWIFT_ASYNC_CONTEXT:
      return reinterpret_cast<const SwiftAsyncContextAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OSConsumedAttr> OSConsumedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OSConsumedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OSConsumedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OSConsumedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<OSConsumedAttr> OSConsumedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return OSConsumedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kOSConsumedAttrDerivedKinds[] = {
    OSConsumedAttr::static_kind(),
};

gap::generator<OSConsumedAttr> OSConsumedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kOSConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<OSConsumedAttr> e = OSConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OSConsumedAttr> OSConsumedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kOSConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<OSConsumedAttr> e = OSConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OSConsumedAttr> OSConsumedAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSConsumedAttr> OSConsumedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<OSConsumedAttr> OSConsumedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::OS_CONSUMED:
      return reinterpret_cast<const OSConsumedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NonNullAttr> NonNullAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NonNullAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NonNullAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NonNullAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NonNullAttr> NonNullAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NonNullAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNonNullAttrDerivedKinds[] = {
    NonNullAttr::static_kind(),
};

gap::generator<NonNullAttr> NonNullAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NonNullAttr> e = NonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NonNullAttr> NonNullAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNonNullAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NonNullAttr> e = NonNullAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NonNullAttr> NonNullAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NonNullAttr> NonNullAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NonNullAttr> NonNullAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NON_NULL:
      return reinterpret_cast<const NonNullAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NSConsumedAttr> NSConsumedAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NSConsumedAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NSConsumedAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NSConsumedAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<NSConsumedAttr> NSConsumedAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return NSConsumedAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kNSConsumedAttrDerivedKinds[] = {
    NSConsumedAttr::static_kind(),
};

gap::generator<NSConsumedAttr> NSConsumedAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kNSConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<NSConsumedAttr> e = NSConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NSConsumedAttr> NSConsumedAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kNSConsumedAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<NSConsumedAttr> e = NSConsumedAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NSConsumedAttr> NSConsumedAttr::from(const InheritableParamAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSConsumedAttr> NSConsumedAttr::from(const InheritableAttr &parent) {
  return from(reinterpret_cast<const Attr &>(parent));
}

std::optional<NSConsumedAttr> NSConsumedAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::NS_CONSUMED:
      return reinterpret_cast<const NSConsumedAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IFuncAttr> IFuncAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IFuncAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IFuncAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IFuncAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IFuncAttr> IFuncAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return IFuncAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kIFuncAttrDerivedKinds[] = {
    IFuncAttr::static_kind(),
};

gap::generator<IFuncAttr> IFuncAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kIFuncAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<IFuncAttr> e = IFuncAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IFuncAttr> IFuncAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kIFuncAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<IFuncAttr> e = IFuncAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IFuncAttr> IFuncAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::I_FUNC:
      return reinterpret_cast<const IFuncAttr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view IFuncAttr::resolver(void) const {
  capnp::Text::Reader data = impl->reader.getVal9();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<CalledOnceAttr> CalledOnceAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CalledOnceAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CalledOnceAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CalledOnceAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<CalledOnceAttr> CalledOnceAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return CalledOnceAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kCalledOnceAttrDerivedKinds[] = {
    CalledOnceAttr::static_kind(),
};

gap::generator<CalledOnceAttr> CalledOnceAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kCalledOnceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<CalledOnceAttr> e = CalledOnceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CalledOnceAttr> CalledOnceAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kCalledOnceAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<CalledOnceAttr> e = CalledOnceAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CalledOnceAttr> CalledOnceAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::CALLED_ONCE:
      return reinterpret_cast<const CalledOnceAttr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<BuiltinAliasAttr> BuiltinAliasAttr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BuiltinAliasAttr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BuiltinAliasAttr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BuiltinAliasAttr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BuiltinAliasAttr> BuiltinAliasAttr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<AttrId>(vid)) {
    return BuiltinAliasAttr::from(index.attribute(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const AttrKind kBuiltinAliasAttrDerivedKinds[] = {
    BuiltinAliasAttr::static_kind(),
};

gap::generator<BuiltinAliasAttr> BuiltinAliasAttr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (AttrKind k : kBuiltinAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k)) {
      if (std::optional<BuiltinAliasAttr> e = BuiltinAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BuiltinAliasAttr> BuiltinAliasAttr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (AttrKind k : kBuiltinAliasAttrDerivedKinds) {
    for (AttrImplPtr eptr : ep->AttrsFor(ep, k, frag_id)) {
      if (std::optional<BuiltinAliasAttr> e = BuiltinAliasAttr::from(Attr(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BuiltinAliasAttr> BuiltinAliasAttr::from(const Attr &parent) {
  switch (parent.kind()) {
    case mx::AttrKind::BUILTIN_ALIAS:
      return reinterpret_cast<const BuiltinAliasAttr &>(parent);
    default: return std::nullopt;
  }
}

BuiltinAliasAttrSpelling BuiltinAliasAttr::semantic_spelling(void) const {
  return static_cast<BuiltinAliasAttrSpelling>(impl->reader.getVal10());
}

inline const std::shared_ptr<EntityProvider> &Type::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Type::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

gap::generator<Type> Type::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Type::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Type::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Type::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<Type> Type::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    index.type(eid.Pack());
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

gap::generator<Type> Type::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeImplPtr eptr : ep->TypesFor(ep)) {
    if (std::optional<Type> e = Type::from(Type(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Type> Type::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeImplPtr eptr : ep->TypesFor(ep, frag_id)) {
    if (std::optional<Type> e = Type::from(Type(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Type> Type::in(const Index &index, std::span<TypeKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      co_yield Type(std::move(eptr));
    }
  }
}

gap::generator<Type> Type::in(const Fragment &frag, std::span<TypeKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      co_yield Type(std::move(eptr));
    }
  }
}

bool Type::is_qualified(void) const {
  return impl->reader.getVal0();
}

Type Type::unqualified_type(void) const {
  RawEntityId eid = impl->reader.getVal1();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool Type::accepts_obj_c_type_parameters(void) const {
  return impl->reader.getVal2();
}

bool Type::can_decay_to_pointer_type(void) const {
  return impl->reader.getVal3();
}

bool Type::can_have_nullability(void) const {
  return impl->reader.getVal4();
}

bool Type::contains_errors(void) const {
  return impl->reader.getVal5();
}

bool Type::contains_unexpanded_parameter_pack(void) const {
  return impl->reader.getVal6();
}

std::optional<Type> Type::array_element_type_no_type_qualified(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal7();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<CXXRecordDecl> Type::as_cxx_record_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXRecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ComplexType> Type::as_complex_integer_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ComplexType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ObjCObjectPointerType> Type::as_obj_c_interface_pointer_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal10();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ObjCObjectPointerType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ObjCObjectType> Type::as_obj_c_interface_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ObjCObjectType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ObjCObjectPointerType> Type::as_obj_c_qualified_class_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal12();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ObjCObjectPointerType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ObjCObjectPointerType> Type::as_obj_c_qualified_id_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal13();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ObjCObjectPointerType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ObjCObjectType> Type::as_obj_c_qualified_interface_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal14();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return ObjCObjectType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<BuiltinType> Type::as_placeholder_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal15();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return BuiltinType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<RecordDecl> Type::as_record_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal16();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return RecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<RecordType> Type::as_structure_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal17();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return RecordType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<TagDecl> Type::as_tag_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal18();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TagDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<RecordType> Type::as_union_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal19();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return RecordType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<AutoType> Type::contained_auto_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal20();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return AutoType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<DeducedType> Type::contained_deduced_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal21();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return DeducedType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Linkage Type::linkage(void) const {
  return static_cast<Linkage>(impl->reader.getVal22());
}

Type Type::locally_unqualified_single_step_desugared_type(void) const {
  RawEntityId eid = impl->reader.getVal23();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<NullabilityKind> Type::nullability(void) const {
  if (!impl->reader.getVal25()) {
    return std::nullopt;
  } else {
    return static_cast<NullabilityKind>(impl->reader.getVal24());
  }
  return std::nullopt;
}

std::optional<CXXRecordDecl> Type::pointee_cxx_record_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal26();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXRecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> Type::pointee_or_array_element_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal27();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> Type::pointee_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal28();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<TypeScalarTypeKind> Type::scalar_type_kind(void) const {
  if (!impl->reader.getVal30()) {
    return std::nullopt;
  } else {
    return static_cast<TypeScalarTypeKind>(impl->reader.getVal29());
  }
  return std::nullopt;
}

std::optional<Type> Type::sve_element_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal31();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

TypeKind Type::kind(void) const {
  return static_cast<TypeKind>(impl->reader.getVal32());
}

Type Type::unqualified_desugared_type(void) const {
  RawEntityId eid = impl->reader.getVal33();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Visibility Type::visibility(void) const {
  return static_cast<Visibility>(impl->reader.getVal34());
}

bool Type::has_auto_for_trailing_return_type(void) const {
  return impl->reader.getVal35();
}

bool Type::has_floating_representation(void) const {
  return impl->reader.getVal36();
}

bool Type::has_integer_representation(void) const {
  return impl->reader.getVal37();
}

bool Type::has_obj_c_pointer_representation(void) const {
  return impl->reader.getVal38();
}

bool Type::has_pointer_representation(void) const {
  return impl->reader.getVal39();
}

bool Type::has_signed_integer_representation(void) const {
  return impl->reader.getVal40();
}

bool Type::has_sized_vla_type(void) const {
  return impl->reader.getVal41();
}

bool Type::has_unnamed_or_local_type(void) const {
  return impl->reader.getVal42();
}

bool Type::has_unsigned_integer_representation(void) const {
  return impl->reader.getVal43();
}

std::optional<bool> Type::is_aggregate_type(void) const {
  if (!impl->reader.getVal45()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal44());
  }
  return std::nullopt;
}

bool Type::is_align_value_t(void) const {
  return impl->reader.getVal46();
}

bool Type::is_any_character_type(void) const {
  return impl->reader.getVal47();
}

bool Type::is_any_complex_type(void) const {
  return impl->reader.getVal48();
}

bool Type::is_any_pointer_type(void) const {
  return impl->reader.getVal49();
}

bool Type::is_arithmetic_type(void) const {
  return impl->reader.getVal50();
}

bool Type::is_array_type(void) const {
  return impl->reader.getVal51();
}

bool Type::is_atomic_type(void) const {
  return impl->reader.getVal52();
}

bool Type::is_b_float16_type(void) const {
  return impl->reader.getVal53();
}

bool Type::is_bit_int_type(void) const {
  return impl->reader.getVal54();
}

bool Type::is_block_compatible_obj_c_pointer_type(void) const {
  return impl->reader.getVal55();
}

bool Type::is_block_pointer_type(void) const {
  return impl->reader.getVal56();
}

bool Type::is_boolean_type(void) const {
  return impl->reader.getVal57();
}

bool Type::is_builtin_type(void) const {
  return impl->reader.getVal58();
}

bool Type::is_carc_bridgable_type(void) const {
  return impl->reader.getVal59();
}

bool Type::is_cuda_device_builtin_surface_type(void) const {
  return impl->reader.getVal60();
}

bool Type::is_cuda_device_builtin_texture_type(void) const {
  return impl->reader.getVal61();
}

bool Type::is_canonical_unqualified(void) const {
  return impl->reader.getVal62();
}

bool Type::is_char16_type(void) const {
  return impl->reader.getVal63();
}

bool Type::is_char32_type(void) const {
  return impl->reader.getVal64();
}

bool Type::is_char8_type(void) const {
  return impl->reader.getVal65();
}

bool Type::is_character_type(void) const {
  return impl->reader.getVal66();
}

bool Type::is_class_type(void) const {
  return impl->reader.getVal67();
}

bool Type::is_clk_event_t(void) const {
  return impl->reader.getVal68();
}

bool Type::is_complex_integer_type(void) const {
  return impl->reader.getVal69();
}

bool Type::is_complex_type(void) const {
  return impl->reader.getVal70();
}

bool Type::is_compound_type(void) const {
  return impl->reader.getVal71();
}

bool Type::is_constant_array_type(void) const {
  return impl->reader.getVal72();
}

bool Type::is_constant_matrix_type(void) const {
  return impl->reader.getVal73();
}

std::optional<bool> Type::is_constant_size_type(void) const {
  if (!impl->reader.getVal75()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal74());
  }
  return std::nullopt;
}

bool Type::is_decltype_type(void) const {
  return impl->reader.getVal76();
}

bool Type::is_dependent_address_space_type(void) const {
  return impl->reader.getVal77();
}

bool Type::is_dependent_sized_array_type(void) const {
  return impl->reader.getVal78();
}

bool Type::is_dependent_type(void) const {
  return impl->reader.getVal79();
}

bool Type::is_elaborated_type_specifier(void) const {
  return impl->reader.getVal80();
}

bool Type::is_enumeral_type(void) const {
  return impl->reader.getVal81();
}

bool Type::is_event_t(void) const {
  return impl->reader.getVal82();
}

bool Type::is_ext_vector_boolean_type(void) const {
  return impl->reader.getVal83();
}

bool Type::is_ext_vector_type(void) const {
  return impl->reader.getVal84();
}

bool Type::is_fixed_point_or_integer_type(void) const {
  return impl->reader.getVal85();
}

bool Type::is_fixed_point_type(void) const {
  return impl->reader.getVal86();
}

bool Type::is_float128_type(void) const {
  return impl->reader.getVal87();
}

bool Type::is_float16_type(void) const {
  return impl->reader.getVal88();
}

bool Type::is_floating_type(void) const {
  return impl->reader.getVal89();
}

bool Type::is_from_ast(void) const {
  return impl->reader.getVal90();
}

bool Type::is_function_no_proto_type(void) const {
  return impl->reader.getVal91();
}

bool Type::is_function_pointer_type(void) const {
  return impl->reader.getVal92();
}

bool Type::is_function_proto_type(void) const {
  return impl->reader.getVal93();
}

bool Type::is_function_reference_type(void) const {
  return impl->reader.getVal94();
}

bool Type::is_function_type(void) const {
  return impl->reader.getVal95();
}

bool Type::is_fundamental_type(void) const {
  return impl->reader.getVal96();
}

bool Type::is_half_type(void) const {
  return impl->reader.getVal97();
}

bool Type::is_ibm128_type(void) const {
  return impl->reader.getVal98();
}

bool Type::is_image_type(void) const {
  return impl->reader.getVal99();
}

bool Type::is_incomplete_array_type(void) const {
  return impl->reader.getVal100();
}

bool Type::is_incomplete_or_object_type(void) const {
  return impl->reader.getVal101();
}

bool Type::is_incomplete_type(void) const {
  return impl->reader.getVal102();
}

bool Type::is_instantiation_dependent_type(void) const {
  return impl->reader.getVal103();
}

bool Type::is_integer_type(void) const {
  return impl->reader.getVal104();
}

bool Type::is_integral_or_enumeration_type(void) const {
  return impl->reader.getVal105();
}

bool Type::is_integral_or_unscoped_enumeration_type(void) const {
  return impl->reader.getVal106();
}

bool Type::is_integral_type(void) const {
  return impl->reader.getVal107();
}

bool Type::is_interface_type(void) const {
  return impl->reader.getVal108();
}

bool Type::is_l_value_reference_type(void) const {
  return impl->reader.getVal109();
}

bool Type::is_linkage_valid(void) const {
  return impl->reader.getVal110();
}

std::optional<bool> Type::is_literal_type(void) const {
  if (!impl->reader.getVal112()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal111());
  }
  return std::nullopt;
}

bool Type::is_matrix_type(void) const {
  return impl->reader.getVal113();
}

bool Type::is_member_data_pointer_type(void) const {
  return impl->reader.getVal114();
}

bool Type::is_member_function_pointer_type(void) const {
  return impl->reader.getVal115();
}

bool Type::is_member_pointer_type(void) const {
  return impl->reader.getVal116();
}

bool Type::is_non_overload_placeholder_type(void) const {
  return impl->reader.getVal117();
}

bool Type::is_nothrow_t(void) const {
  return impl->reader.getVal118();
}

bool Type::is_null_pointer_type(void) const {
  return impl->reader.getVal119();
}

bool Type::is_ocl_ext_opaque_type(void) const {
  return impl->reader.getVal120();
}

bool Type::is_ocl_image_1d_array_ro_type(void) const {
  return impl->reader.getVal121();
}

bool Type::is_ocl_image_1d_array_rw_type(void) const {
  return impl->reader.getVal122();
}

bool Type::is_ocl_image_1d_array_wo_type(void) const {
  return impl->reader.getVal123();
}

bool Type::is_ocl_image_1d_buffer_ro_type(void) const {
  return impl->reader.getVal124();
}

bool Type::is_ocl_image_1d_buffer_rw_type(void) const {
  return impl->reader.getVal125();
}

bool Type::is_ocl_image_1d_buffer_wo_type(void) const {
  return impl->reader.getVal126();
}

bool Type::is_ocl_image_1d_ro_type(void) const {
  return impl->reader.getVal127();
}

bool Type::is_ocl_image_1d_rw_type(void) const {
  return impl->reader.getVal128();
}

bool Type::is_ocl_image_1d_wo_type(void) const {
  return impl->reader.getVal129();
}

bool Type::is_ocl_image_2d_array_depth_ro_type(void) const {
  return impl->reader.getVal130();
}

bool Type::is_ocl_image_2d_array_depth_rw_type(void) const {
  return impl->reader.getVal131();
}

bool Type::is_ocl_image_2d_array_depth_wo_type(void) const {
  return impl->reader.getVal132();
}

bool Type::is_ocl_image_2d_array_msaa_depth_ro_type(void) const {
  return impl->reader.getVal133();
}

bool Type::is_ocl_image_2d_array_msaa_depth_rw_type(void) const {
  return impl->reader.getVal134();
}

bool Type::is_ocl_image_2d_array_msaa_depth_wo_type(void) const {
  return impl->reader.getVal135();
}

bool Type::is_ocl_image_2d_array_msaaro_type(void) const {
  return impl->reader.getVal136();
}

bool Type::is_ocl_image_2d_array_msaarw_type(void) const {
  return impl->reader.getVal137();
}

bool Type::is_ocl_image_2d_array_msaawo_type(void) const {
  return impl->reader.getVal138();
}

bool Type::is_ocl_image_2d_array_ro_type(void) const {
  return impl->reader.getVal139();
}

bool Type::is_ocl_image_2d_array_rw_type(void) const {
  return impl->reader.getVal140();
}

bool Type::is_ocl_image_2d_array_wo_type(void) const {
  return impl->reader.getVal141();
}

bool Type::is_ocl_image_2d_depth_ro_type(void) const {
  return impl->reader.getVal142();
}

bool Type::is_ocl_image_2d_depth_rw_type(void) const {
  return impl->reader.getVal143();
}

bool Type::is_ocl_image_2d_depth_wo_type(void) const {
  return impl->reader.getVal144();
}

bool Type::is_ocl_image_2d_msaa_depth_ro_type(void) const {
  return impl->reader.getVal145();
}

bool Type::is_ocl_image_2d_msaa_depth_rw_type(void) const {
  return impl->reader.getVal146();
}

bool Type::is_ocl_image_2d_msaa_depth_wo_type(void) const {
  return impl->reader.getVal147();
}

bool Type::is_ocl_image_2d_msaaro_type(void) const {
  return impl->reader.getVal148();
}

bool Type::is_ocl_image_2d_msaarw_type(void) const {
  return impl->reader.getVal149();
}

bool Type::is_ocl_image_2d_msaawo_type(void) const {
  return impl->reader.getVal150();
}

bool Type::is_ocl_image_2d_ro_type(void) const {
  return impl->reader.getVal151();
}

bool Type::is_ocl_image_2d_rw_type(void) const {
  return impl->reader.getVal152();
}

bool Type::is_ocl_image_2d_wo_type(void) const {
  return impl->reader.getVal153();
}

bool Type::is_ocl_image_3d_ro_type(void) const {
  return impl->reader.getVal154();
}

bool Type::is_ocl_image_3d_rw_type(void) const {
  return impl->reader.getVal155();
}

bool Type::is_ocl_image_3d_wo_type(void) const {
  return impl->reader.getVal156();
}

bool Type::is_ocl_intel_subgroup_avc_ime_dual_reference_streamin_type(void) const {
  return impl->reader.getVal157();
}

bool Type::is_ocl_intel_subgroup_avc_ime_payload_type(void) const {
  return impl->reader.getVal158();
}

bool Type::is_ocl_intel_subgroup_avc_ime_result_dual_reference_streamout_type(void) const {
  return impl->reader.getVal159();
}

bool Type::is_ocl_intel_subgroup_avc_ime_result_single_reference_streamout_type(void) const {
  return impl->reader.getVal160();
}

bool Type::is_ocl_intel_subgroup_avc_ime_result_type(void) const {
  return impl->reader.getVal161();
}

bool Type::is_ocl_intel_subgroup_avc_ime_single_reference_streamin_type(void) const {
  return impl->reader.getVal162();
}

bool Type::is_ocl_intel_subgroup_avc_mce_payload_type(void) const {
  return impl->reader.getVal163();
}

bool Type::is_ocl_intel_subgroup_avc_mce_result_type(void) const {
  return impl->reader.getVal164();
}

bool Type::is_ocl_intel_subgroup_avc_ref_payload_type(void) const {
  return impl->reader.getVal165();
}

bool Type::is_ocl_intel_subgroup_avc_ref_result_type(void) const {
  return impl->reader.getVal166();
}

bool Type::is_ocl_intel_subgroup_avc_sic_payload_type(void) const {
  return impl->reader.getVal167();
}

bool Type::is_ocl_intel_subgroup_avc_sic_result_type(void) const {
  return impl->reader.getVal168();
}

bool Type::is_ocl_intel_subgroup_avc_type(void) const {
  return impl->reader.getVal169();
}

bool Type::is_obj_carc_bridgable_type(void) const {
  return impl->reader.getVal170();
}

std::optional<bool> Type::is_obj_carc_implicitly_unretained_type(void) const {
  if (!impl->reader.getVal172()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal171());
  }
  return std::nullopt;
}

bool Type::is_obj_c_boxable_record_type(void) const {
  return impl->reader.getVal173();
}

bool Type::is_obj_c_builtin_type(void) const {
  return impl->reader.getVal174();
}

bool Type::is_obj_c_class_or_class_kind_of_type(void) const {
  return impl->reader.getVal175();
}

bool Type::is_obj_c_class_type(void) const {
  return impl->reader.getVal176();
}

bool Type::is_obj_c_id_type(void) const {
  return impl->reader.getVal177();
}

bool Type::is_obj_c_independent_class_type(void) const {
  return impl->reader.getVal178();
}

bool Type::is_obj_c_indirect_lifetime_type(void) const {
  return impl->reader.getVal179();
}

bool Type::is_obj_c_inert_unsafe_unretained_type(void) const {
  return impl->reader.getVal180();
}

bool Type::is_obj_c_lifetime_type(void) const {
  return impl->reader.getVal181();
}

bool Type::is_obj_cns_object_type(void) const {
  return impl->reader.getVal182();
}

bool Type::is_obj_c_object_or_interface_type(void) const {
  return impl->reader.getVal183();
}

bool Type::is_obj_c_object_pointer_type(void) const {
  return impl->reader.getVal184();
}

bool Type::is_obj_c_object_type(void) const {
  return impl->reader.getVal185();
}

bool Type::is_obj_c_qualified_class_type(void) const {
  return impl->reader.getVal186();
}

bool Type::is_obj_c_qualified_id_type(void) const {
  return impl->reader.getVal187();
}

bool Type::is_obj_c_qualified_interface_type(void) const {
  return impl->reader.getVal188();
}

bool Type::is_obj_c_retainable_type(void) const {
  return impl->reader.getVal189();
}

bool Type::is_obj_c_sel_type(void) const {
  return impl->reader.getVal190();
}

bool Type::is_object_pointer_type(void) const {
  return impl->reader.getVal191();
}

bool Type::is_object_type(void) const {
  return impl->reader.getVal192();
}

bool Type::is_open_cl_specific_type(void) const {
  return impl->reader.getVal193();
}

bool Type::is_overloadable_type(void) const {
  return impl->reader.getVal194();
}

bool Type::is_pipe_type(void) const {
  return impl->reader.getVal195();
}

bool Type::is_placeholder_type(void) const {
  return impl->reader.getVal196();
}

bool Type::is_pointer_type(void) const {
  return impl->reader.getVal197();
}

bool Type::is_promotable_integer_type(void) const {
  return impl->reader.getVal198();
}

bool Type::is_queue_t(void) const {
  return impl->reader.getVal199();
}

bool Type::is_r_value_reference_type(void) const {
  return impl->reader.getVal200();
}

bool Type::is_real_floating_type(void) const {
  return impl->reader.getVal201();
}

bool Type::is_real_type(void) const {
  return impl->reader.getVal202();
}

bool Type::is_record_type(void) const {
  return impl->reader.getVal203();
}

bool Type::is_reference_type(void) const {
  return impl->reader.getVal204();
}

bool Type::is_reserve_idt(void) const {
  return impl->reader.getVal205();
}

bool Type::is_sampler_t(void) const {
  return impl->reader.getVal206();
}

bool Type::is_saturated_fixed_point_type(void) const {
  return impl->reader.getVal207();
}

bool Type::is_scalar_type(void) const {
  return impl->reader.getVal208();
}

bool Type::is_scoped_enumeral_type(void) const {
  return impl->reader.getVal209();
}

bool Type::is_signed_fixed_point_type(void) const {
  return impl->reader.getVal210();
}

bool Type::is_signed_integer_or_enumeration_type(void) const {
  return impl->reader.getVal211();
}

bool Type::is_signed_integer_type(void) const {
  return impl->reader.getVal212();
}

bool Type::is_sizeless_builtin_type(void) const {
  return impl->reader.getVal213();
}

bool Type::is_sizeless_type(void) const {
  return impl->reader.getVal214();
}

bool Type::is_specifier_type(void) const {
  return impl->reader.getVal215();
}

std::optional<bool> Type::is_standard_layout_type(void) const {
  if (!impl->reader.getVal217()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal216());
  }
  return std::nullopt;
}

bool Type::is_std_byte_type(void) const {
  return impl->reader.getVal218();
}

std::optional<bool> Type::is_structural_type(void) const {
  if (!impl->reader.getVal220()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal219());
  }
  return std::nullopt;
}

bool Type::is_structure_or_class_type(void) const {
  return impl->reader.getVal221();
}

bool Type::is_structure_type(void) const {
  return impl->reader.getVal222();
}

bool Type::is_template_type_parm_type(void) const {
  return impl->reader.getVal223();
}

bool Type::is_typedef_name_type(void) const {
  return impl->reader.getVal224();
}

bool Type::is_undeduced_auto_type(void) const {
  return impl->reader.getVal225();
}

bool Type::is_undeduced_type(void) const {
  return impl->reader.getVal226();
}

bool Type::is_union_type(void) const {
  return impl->reader.getVal227();
}

bool Type::is_unsaturated_fixed_point_type(void) const {
  return impl->reader.getVal228();
}

bool Type::is_unscoped_enumeration_type(void) const {
  return impl->reader.getVal229();
}

bool Type::is_unsigned_fixed_point_type(void) const {
  return impl->reader.getVal230();
}

bool Type::is_unsigned_integer_or_enumeration_type(void) const {
  return impl->reader.getVal231();
}

bool Type::is_unsigned_integer_type(void) const {
  return impl->reader.getVal232();
}

bool Type::is_vlst_builtin_type(void) const {
  return impl->reader.getVal233();
}

bool Type::is_variable_array_type(void) const {
  return impl->reader.getVal234();
}

bool Type::is_variably_modified_type(void) const {
  return impl->reader.getVal235();
}

bool Type::is_vector_type(void) const {
  return impl->reader.getVal236();
}

bool Type::is_visibility_explicit(void) const {
  return impl->reader.getVal237();
}

bool Type::is_void_pointer_type(void) const {
  return impl->reader.getVal238();
}

bool Type::is_void_type(void) const {
  return impl->reader.getVal239();
}

bool Type::is_wide_character_type(void) const {
  return impl->reader.getVal240();
}

Type Type::ignore_parentheses(void) const {
  RawEntityId eid = impl->reader.getVal241();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

LangAS Type::address_space(void) const {
  return static_cast<LangAS>(impl->reader.getVal242());
}

Type Type::atomic_unqualified_type(void) const {
  RawEntityId eid = impl->reader.getVal243();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::canonical_type(void) const {
  RawEntityId eid = impl->reader.getVal244();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::desugared_type(void) const {
  RawEntityId eid = impl->reader.getVal245();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::local_unqualified_type(void) const {
  RawEntityId eid = impl->reader.getVal246();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::non_l_value_expression_type(void) const {
  RawEntityId eid = impl->reader.getVal247();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::non_pack_expansion_type(void) const {
  RawEntityId eid = impl->reader.getVal248();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::non_reference_type(void) const {
  RawEntityId eid = impl->reader.getVal249();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::single_step_desugared_type(void) const {
  RawEntityId eid = impl->reader.getVal250();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool Type::has_address_space(void) const {
  return impl->reader.getVal251();
}

bool Type::has_local_non_fast_qualifiers(void) const {
  return impl->reader.getVal252();
}

bool Type::has_local_qualifiers(void) const {
  return impl->reader.getVal253();
}

bool Type::has_non_trivial_obj_c_lifetime(void) const {
  return impl->reader.getVal254();
}

bool Type::has_non_trivial_to_primitive_copy_c_union(void) const {
  return impl->reader.getVal255();
}

bool Type::has_non_trivial_to_primitive_default_initialize_c_union(void) const {
  return impl->reader.getVal256();
}

bool Type::has_non_trivial_to_primitive_destruct_c_union(void) const {
  return impl->reader.getVal257();
}

bool Type::has_qualifiers(void) const {
  return impl->reader.getVal258();
}

bool Type::has_strong_or_weak_obj_c_lifetime(void) const {
  return impl->reader.getVal259();
}

bool Type::is_c_forbidden_l_value_type(void) const {
  return impl->reader.getVal260();
}

bool Type::is_cxx11_pod_type(void) const {
  return impl->reader.getVal261();
}

bool Type::is_cxx98_pod_type(void) const {
  return impl->reader.getVal262();
}

bool Type::is_canonical(void) const {
  return impl->reader.getVal263();
}

bool Type::is_canonical_as_parameter(void) const {
  return impl->reader.getVal264();
}

bool Type::is_const_qualified(void) const {
  return impl->reader.getVal265();
}

bool Type::is_constant(void) const {
  return impl->reader.getVal266();
}

QualTypeDestructionKind Type::is_destructed_type(void) const {
  return static_cast<QualTypeDestructionKind>(impl->reader.getVal267());
}

bool Type::is_local_const_qualified(void) const {
  return impl->reader.getVal268();
}

bool Type::is_local_restrict_qualified(void) const {
  return impl->reader.getVal269();
}

bool Type::is_local_volatile_qualified(void) const {
  return impl->reader.getVal270();
}

QualTypePrimitiveCopyKind Type::is_non_trivial_to_primitive_copy(void) const {
  return static_cast<QualTypePrimitiveCopyKind>(impl->reader.getVal271());
}

QualTypePrimitiveDefaultInitializeKind Type::is_non_trivial_to_primitive_default_initialize(void) const {
  return static_cast<QualTypePrimitiveDefaultInitializeKind>(impl->reader.getVal272());
}

QualTypePrimitiveCopyKind Type::is_non_trivial_to_primitive_destructive_move(void) const {
  return static_cast<QualTypePrimitiveCopyKind>(impl->reader.getVal273());
}

bool Type::is_non_weak_in_mrr_with_obj_c_weak(void) const {
  return impl->reader.getVal274();
}

bool Type::is_null(void) const {
  return impl->reader.getVal275();
}

bool Type::is_obj_cgc_strong(void) const {
  return impl->reader.getVal276();
}

bool Type::is_obj_cgc_weak(void) const {
  return impl->reader.getVal277();
}

bool Type::is_pod_type(void) const {
  return impl->reader.getVal278();
}

bool Type::is_restrict_qualified(void) const {
  return impl->reader.getVal279();
}

bool Type::is_trivial_type(void) const {
  return impl->reader.getVal280();
}

bool Type::is_trivially_copyable_type(void) const {
  return impl->reader.getVal281();
}

bool Type::is_trivially_relocatable_type(void) const {
  return impl->reader.getVal282();
}

bool Type::is_volatile_qualified(void) const {
  return impl->reader.getVal283();
}

bool Type::may_be_dynamic_class(void) const {
  return impl->reader.getVal284();
}

bool Type::may_be_not_dynamic_class(void) const {
  return impl->reader.getVal285();
}

Type Type::strip_obj_c_kind_of_type(void) const {
  RawEntityId eid = impl->reader.getVal286();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::with_const(void) const {
  RawEntityId eid = impl->reader.getVal287();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::with_restrict(void) const {
  RawEntityId eid = impl->reader.getVal288();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::with_volatile(void) const {
  RawEntityId eid = impl->reader.getVal289();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type Type::without_local_fast_qualifiers(void) const {
  RawEntityId eid = impl->reader.getVal290();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<TemplateTypeParmType> TemplateTypeParmType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateTypeParmType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateTypeParmType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateTypeParmType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TemplateTypeParmType> TemplateTypeParmType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TemplateTypeParmType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTemplateTypeParmTypeDerivedKinds[] = {
    TemplateTypeParmType::static_kind(),
};

gap::generator<TemplateTypeParmType> TemplateTypeParmType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTemplateTypeParmTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TemplateTypeParmType> e = TemplateTypeParmType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateTypeParmType> TemplateTypeParmType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTemplateTypeParmTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TemplateTypeParmType> e = TemplateTypeParmType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateTypeParmType> TemplateTypeParmType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::TEMPLATE_TYPE_PARM:
      return reinterpret_cast<const TemplateTypeParmType &>(parent);
    default: return std::nullopt;
  }
}

Type TemplateTypeParmType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<TemplateTypeParmDecl> TemplateTypeParmType::declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal292();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TemplateTypeParmDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool TemplateTypeParmType::is_parameter_pack(void) const {
  return impl->reader.getVal293();
}

bool TemplateTypeParmType::is_sugared(void) const {
  return impl->reader.getVal294();
}

gap::generator<TemplateSpecializationType> TemplateSpecializationType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateSpecializationType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateSpecializationType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateSpecializationType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TemplateSpecializationType> TemplateSpecializationType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TemplateSpecializationType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTemplateSpecializationTypeDerivedKinds[] = {
    TemplateSpecializationType::static_kind(),
};

gap::generator<TemplateSpecializationType> TemplateSpecializationType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TemplateSpecializationType> e = TemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateSpecializationType> TemplateSpecializationType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TemplateSpecializationType> e = TemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateSpecializationType> TemplateSpecializationType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::TEMPLATE_SPECIALIZATION:
      return reinterpret_cast<const TemplateSpecializationType &>(parent);
    default: return std::nullopt;
  }
}

Type TemplateSpecializationType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Type> TemplateSpecializationType::aliased_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal292();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool TemplateSpecializationType::is_current_instantiation(void) const {
  return impl->reader.getVal293();
}

bool TemplateSpecializationType::is_sugared(void) const {
  return impl->reader.getVal294();
}

bool TemplateSpecializationType::is_type_alias(void) const {
  return impl->reader.getVal295();
}

std::optional<TemplateArgument> TemplateSpecializationType::nth_template_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> TemplateSpecializationType::template_arguments(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d296));
    }
  }
  co_return;
}

gap::generator<TagType> TagType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TagType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TagType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TagType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TagType> TagType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TagType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTagTypeDerivedKinds[] = {
    EnumType::static_kind(),
    RecordType::static_kind(),
};

gap::generator<TagType> TagType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTagTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TagType> e = TagType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TagType> TagType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTagTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TagType> e = TagType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TagType> TagType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::RECORD:
    case mx::TypeKind::ENUM:
      return reinterpret_cast<const TagType &>(parent);
    default: return std::nullopt;
  }
}

TagDecl TagType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return TagDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool TagType::is_being_defined(void) const {
  return impl->reader.getVal293();
}

gap::generator<RecordType> RecordType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RecordType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RecordType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RecordType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RecordType> RecordType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return RecordType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kRecordTypeDerivedKinds[] = {
    RecordType::static_kind(),
};

gap::generator<RecordType> RecordType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kRecordTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<RecordType> e = RecordType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RecordType> RecordType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kRecordTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<RecordType> e = RecordType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RecordType> RecordType::from(const TagType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<RecordType> RecordType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::RECORD:
      return reinterpret_cast<const RecordType &>(parent);
    default: return std::nullopt;
  }
}

Type RecordType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool RecordType::has_const_fields(void) const {
  return impl->reader.getVal294();
}

bool RecordType::is_sugared(void) const {
  return impl->reader.getVal295();
}

gap::generator<EnumType> EnumType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnumType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnumType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnumType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<EnumType> EnumType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return EnumType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kEnumTypeDerivedKinds[] = {
    EnumType::static_kind(),
};

gap::generator<EnumType> EnumType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kEnumTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<EnumType> e = EnumType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnumType> EnumType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kEnumTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<EnumType> e = EnumType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnumType> EnumType::from(const TagType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<EnumType> EnumType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ENUM:
      return reinterpret_cast<const EnumType &>(parent);
    default: return std::nullopt;
  }
}

Type EnumType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool EnumType::is_sugared(void) const {
  return impl->reader.getVal294();
}

gap::generator<SubstTemplateTypeParmType> SubstTemplateTypeParmType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SubstTemplateTypeParmType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SubstTemplateTypeParmType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SubstTemplateTypeParmType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SubstTemplateTypeParmType> SubstTemplateTypeParmType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return SubstTemplateTypeParmType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kSubstTemplateTypeParmTypeDerivedKinds[] = {
    SubstTemplateTypeParmType::static_kind(),
};

gap::generator<SubstTemplateTypeParmType> SubstTemplateTypeParmType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kSubstTemplateTypeParmTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<SubstTemplateTypeParmType> e = SubstTemplateTypeParmType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SubstTemplateTypeParmType> SubstTemplateTypeParmType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kSubstTemplateTypeParmTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<SubstTemplateTypeParmType> e = SubstTemplateTypeParmType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SubstTemplateTypeParmType> SubstTemplateTypeParmType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::SUBST_TEMPLATE_TYPE_PARM:
      return reinterpret_cast<const SubstTemplateTypeParmType &>(parent);
    default: return std::nullopt;
  }
}

Type SubstTemplateTypeParmType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TemplateTypeParmType SubstTemplateTypeParmType::replaced_parameter(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return TemplateTypeParmType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

Type SubstTemplateTypeParmType::replacement_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool SubstTemplateTypeParmType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<SubstTemplateTypeParmPackType> SubstTemplateTypeParmPackType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SubstTemplateTypeParmPackType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SubstTemplateTypeParmPackType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SubstTemplateTypeParmPackType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<SubstTemplateTypeParmPackType> SubstTemplateTypeParmPackType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return SubstTemplateTypeParmPackType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kSubstTemplateTypeParmPackTypeDerivedKinds[] = {
    SubstTemplateTypeParmPackType::static_kind(),
};

gap::generator<SubstTemplateTypeParmPackType> SubstTemplateTypeParmPackType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kSubstTemplateTypeParmPackTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<SubstTemplateTypeParmPackType> e = SubstTemplateTypeParmPackType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SubstTemplateTypeParmPackType> SubstTemplateTypeParmPackType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kSubstTemplateTypeParmPackTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<SubstTemplateTypeParmPackType> e = SubstTemplateTypeParmPackType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SubstTemplateTypeParmPackType> SubstTemplateTypeParmPackType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::SUBST_TEMPLATE_TYPE_PARM_PACK:
      return reinterpret_cast<const SubstTemplateTypeParmPackType &>(parent);
    default: return std::nullopt;
  }
}

Type SubstTemplateTypeParmPackType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TemplateTypeParmType SubstTemplateTypeParmPackType::replaced_parameter(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return TemplateTypeParmType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

bool SubstTemplateTypeParmPackType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ReferenceType> ReferenceType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReferenceType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReferenceType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReferenceType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ReferenceType> ReferenceType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ReferenceType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kReferenceTypeDerivedKinds[] = {
    LValueReferenceType::static_kind(),
    RValueReferenceType::static_kind(),
};

gap::generator<ReferenceType> ReferenceType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ReferenceType> e = ReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReferenceType> ReferenceType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ReferenceType> e = ReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReferenceType> ReferenceType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::R_VALUE_REFERENCE:
    case mx::TypeKind::L_VALUE_REFERENCE:
      return reinterpret_cast<const ReferenceType &>(parent);
    default: return std::nullopt;
  }
}

Type ReferenceType::pointee_type_as_written(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ReferenceType::is_inner_reference(void) const {
  return impl->reader.getVal293();
}

bool ReferenceType::is_spelled_as_l_value(void) const {
  return impl->reader.getVal294();
}

gap::generator<RValueReferenceType> RValueReferenceType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RValueReferenceType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RValueReferenceType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RValueReferenceType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<RValueReferenceType> RValueReferenceType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return RValueReferenceType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kRValueReferenceTypeDerivedKinds[] = {
    RValueReferenceType::static_kind(),
};

gap::generator<RValueReferenceType> RValueReferenceType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kRValueReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<RValueReferenceType> e = RValueReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RValueReferenceType> RValueReferenceType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kRValueReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<RValueReferenceType> e = RValueReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RValueReferenceType> RValueReferenceType::from(const ReferenceType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<RValueReferenceType> RValueReferenceType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::R_VALUE_REFERENCE:
      return reinterpret_cast<const RValueReferenceType &>(parent);
    default: return std::nullopt;
  }
}

Type RValueReferenceType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool RValueReferenceType::is_sugared(void) const {
  return impl->reader.getVal295();
}

gap::generator<LValueReferenceType> LValueReferenceType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LValueReferenceType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LValueReferenceType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LValueReferenceType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<LValueReferenceType> LValueReferenceType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return LValueReferenceType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kLValueReferenceTypeDerivedKinds[] = {
    LValueReferenceType::static_kind(),
};

gap::generator<LValueReferenceType> LValueReferenceType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kLValueReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<LValueReferenceType> e = LValueReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LValueReferenceType> LValueReferenceType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kLValueReferenceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<LValueReferenceType> e = LValueReferenceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LValueReferenceType> LValueReferenceType::from(const ReferenceType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<LValueReferenceType> LValueReferenceType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::L_VALUE_REFERENCE:
      return reinterpret_cast<const LValueReferenceType &>(parent);
    default: return std::nullopt;
  }
}

Type LValueReferenceType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool LValueReferenceType::is_sugared(void) const {
  return impl->reader.getVal295();
}

gap::generator<PointerType> PointerType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PointerType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PointerType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PointerType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PointerType> PointerType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return PointerType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kPointerTypeDerivedKinds[] = {
    PointerType::static_kind(),
};

gap::generator<PointerType> PointerType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<PointerType> e = PointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PointerType> PointerType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<PointerType> e = PointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PointerType> PointerType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::POINTER:
      return reinterpret_cast<const PointerType &>(parent);
    default: return std::nullopt;
  }
}

Type PointerType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool PointerType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<PipeType> PipeType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PipeType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PipeType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PipeType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PipeType> PipeType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return PipeType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kPipeTypeDerivedKinds[] = {
    PipeType::static_kind(),
};

gap::generator<PipeType> PipeType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kPipeTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<PipeType> e = PipeType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PipeType> PipeType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kPipeTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<PipeType> e = PipeType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PipeType> PipeType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::PIPE:
      return reinterpret_cast<const PipeType &>(parent);
    default: return std::nullopt;
  }
}

Type PipeType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type PipeType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool PipeType::is_read_only(void) const {
  return impl->reader.getVal293();
}

bool PipeType::is_sugared(void) const {
  return impl->reader.getVal294();
}

gap::generator<ParenType> ParenType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParenType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParenType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParenType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ParenType> ParenType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ParenType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kParenTypeDerivedKinds[] = {
    ParenType::static_kind(),
};

gap::generator<ParenType> ParenType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kParenTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ParenType> e = ParenType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParenType> ParenType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kParenTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ParenType> e = ParenType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParenType> ParenType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::PAREN:
      return reinterpret_cast<const ParenType &>(parent);
    default: return std::nullopt;
  }
}

Type ParenType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ParenType::inner_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ParenType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<PackExpansionType> PackExpansionType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PackExpansionType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PackExpansionType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PackExpansionType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<PackExpansionType> PackExpansionType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return PackExpansionType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kPackExpansionTypeDerivedKinds[] = {
    PackExpansionType::static_kind(),
};

gap::generator<PackExpansionType> PackExpansionType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kPackExpansionTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<PackExpansionType> e = PackExpansionType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PackExpansionType> PackExpansionType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kPackExpansionTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<PackExpansionType> e = PackExpansionType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PackExpansionType> PackExpansionType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::PACK_EXPANSION:
      return reinterpret_cast<const PackExpansionType &>(parent);
    default: return std::nullopt;
  }
}

Type PackExpansionType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<unsigned> PackExpansionType::num_expansions(void) const {
  if (!impl->reader.getVal293()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal298());
  }
  return std::nullopt;
}

Type PackExpansionType::pattern(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool PackExpansionType::is_sugared(void) const {
  return impl->reader.getVal294();
}

gap::generator<ObjCTypeParamType> ObjCTypeParamType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCTypeParamType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCTypeParamType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCTypeParamType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCTypeParamType> ObjCTypeParamType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ObjCTypeParamType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kObjCTypeParamTypeDerivedKinds[] = {
    ObjCTypeParamType::static_kind(),
};

gap::generator<ObjCTypeParamType> ObjCTypeParamType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kObjCTypeParamTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ObjCTypeParamType> e = ObjCTypeParamType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCTypeParamType> ObjCTypeParamType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kObjCTypeParamTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ObjCTypeParamType> e = ObjCTypeParamType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCTypeParamType> ObjCTypeParamType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::OBJ_C_TYPE_PARAM:
      return reinterpret_cast<const ObjCTypeParamType &>(parent);
    default: return std::nullopt;
  }
}

Type ObjCTypeParamType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ObjCTypeParamDecl ObjCTypeParamType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return ObjCTypeParamDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ObjCTypeParamType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ObjCObjectType> ObjCObjectType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCObjectType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCObjectType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCObjectType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCObjectType> ObjCObjectType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ObjCObjectType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kObjCObjectTypeDerivedKinds[] = {
    ObjCObjectType::static_kind(),
    ObjCInterfaceType::static_kind(),
};

gap::generator<ObjCObjectType> ObjCObjectType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kObjCObjectTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ObjCObjectType> e = ObjCObjectType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCObjectType> ObjCObjectType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kObjCObjectTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ObjCObjectType> e = ObjCObjectType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCObjectType> ObjCObjectType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::OBJ_C_OBJECT:
    case mx::TypeKind::OBJ_C_INTERFACE:
      return reinterpret_cast<const ObjCObjectType &>(parent);
    default: return std::nullopt;
  }
}

Type ObjCObjectType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ObjCObjectType::base_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ObjCInterfaceDecl ObjCObjectType::interface(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<Type> ObjCObjectType::super_class_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal299();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> ObjCObjectType::nth_type_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : type_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> ObjCObjectType::type_arguments(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d296));
    }
  }
  co_return;
}

gap::generator<Type> ObjCObjectType::type_arguments_as_written(void) const {
  auto list = impl->reader.getVal300();
  for (auto v : list) {
    EntityId id(v);
    if (auto d300 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d300));
    }
  }
  co_return;
}

bool ObjCObjectType::is_kind_of_type(void) const {
  return impl->reader.getVal293();
}

bool ObjCObjectType::is_kind_of_type_as_written(void) const {
  return impl->reader.getVal294();
}

bool ObjCObjectType::is_obj_c_class(void) const {
  return impl->reader.getVal295();
}

bool ObjCObjectType::is_obj_c_id(void) const {
  return impl->reader.getVal301();
}

bool ObjCObjectType::is_obj_c_qualified_class(void) const {
  return impl->reader.getVal302();
}

bool ObjCObjectType::is_obj_c_qualified_id(void) const {
  return impl->reader.getVal303();
}

bool ObjCObjectType::is_obj_c_unqualified_class(void) const {
  return impl->reader.getVal304();
}

bool ObjCObjectType::is_obj_c_unqualified_id(void) const {
  return impl->reader.getVal305();
}

bool ObjCObjectType::is_obj_c_unqualified_id_or_class(void) const {
  return impl->reader.getVal306();
}

bool ObjCObjectType::is_specialized(void) const {
  return impl->reader.getVal307();
}

bool ObjCObjectType::is_specialized_as_written(void) const {
  return impl->reader.getVal308();
}

bool ObjCObjectType::is_sugared(void) const {
  return impl->reader.getVal309();
}

bool ObjCObjectType::is_unspecialized(void) const {
  return impl->reader.getVal310();
}

bool ObjCObjectType::is_unspecialized_as_written(void) const {
  return impl->reader.getVal311();
}

Type ObjCObjectType::strip_obj_c_kind_of_type_and_qualifiers(void) const {
  RawEntityId eid = impl->reader.getVal312();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<ObjCInterfaceType> ObjCInterfaceType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCInterfaceType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCInterfaceType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCInterfaceType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCInterfaceType> ObjCInterfaceType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ObjCInterfaceType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kObjCInterfaceTypeDerivedKinds[] = {
    ObjCInterfaceType::static_kind(),
};

gap::generator<ObjCInterfaceType> ObjCInterfaceType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kObjCInterfaceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ObjCInterfaceType> e = ObjCInterfaceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCInterfaceType> ObjCInterfaceType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kObjCInterfaceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ObjCInterfaceType> e = ObjCInterfaceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCInterfaceType> ObjCInterfaceType::from(const ObjCObjectType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<ObjCInterfaceType> ObjCInterfaceType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::OBJ_C_INTERFACE:
      return reinterpret_cast<const ObjCInterfaceType &>(parent);
    default: return std::nullopt;
  }
}

ObjCInterfaceDecl ObjCInterfaceType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal313();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<ObjCObjectPointerType> ObjCObjectPointerType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCObjectPointerType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCObjectPointerType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCObjectPointerType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ObjCObjectPointerType> ObjCObjectPointerType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ObjCObjectPointerType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kObjCObjectPointerTypeDerivedKinds[] = {
    ObjCObjectPointerType::static_kind(),
};

gap::generator<ObjCObjectPointerType> ObjCObjectPointerType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kObjCObjectPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ObjCObjectPointerType> e = ObjCObjectPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCObjectPointerType> ObjCObjectPointerType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kObjCObjectPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ObjCObjectPointerType> e = ObjCObjectPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCObjectPointerType> ObjCObjectPointerType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::OBJ_C_OBJECT_POINTER:
      return reinterpret_cast<const ObjCObjectPointerType &>(parent);
    default: return std::nullopt;
  }
}

Type ObjCObjectPointerType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ObjCInterfaceDecl ObjCObjectPointerType::interface_declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCInterfaceType ObjCObjectPointerType::interface_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return ObjCInterfaceType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

ObjCObjectType ObjCObjectPointerType::object_type(void) const {
  RawEntityId eid = impl->reader.getVal299();
  return ObjCObjectType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

Type ObjCObjectPointerType::super_class_type(void) const {
  RawEntityId eid = impl->reader.getVal312();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Type> ObjCObjectPointerType::nth_type_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : type_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> ObjCObjectPointerType::type_arguments(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d296));
    }
  }
  co_return;
}

gap::generator<Type> ObjCObjectPointerType::type_arguments_as_written(void) const {
  auto list = impl->reader.getVal300();
  for (auto v : list) {
    EntityId id(v);
    if (auto d300 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d300));
    }
  }
  co_return;
}

bool ObjCObjectPointerType::is_kind_of_type(void) const {
  return impl->reader.getVal293();
}

bool ObjCObjectPointerType::is_obj_c_id_or_class_type(void) const {
  return impl->reader.getVal294();
}

bool ObjCObjectPointerType::is_specialized(void) const {
  return impl->reader.getVal295();
}

bool ObjCObjectPointerType::is_specialized_as_written(void) const {
  return impl->reader.getVal301();
}

bool ObjCObjectPointerType::is_sugared(void) const {
  return impl->reader.getVal302();
}

bool ObjCObjectPointerType::is_unspecialized(void) const {
  return impl->reader.getVal303();
}

bool ObjCObjectPointerType::is_unspecialized_as_written(void) const {
  return impl->reader.getVal304();
}

std::optional<ObjCProtocolDecl> ObjCObjectPointerType::nth_qualifier(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : qualifiers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCObjectPointerType::qualifiers(void) const {
  auto list = impl->reader.getVal314();
  for (auto v : list) {
    EntityId id(v);
    if (auto d314 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d314)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

ObjCObjectPointerType ObjCObjectPointerType::strip_obj_c_kind_of_type_and_qualifiers(void) const {
  RawEntityId eid = impl->reader.getVal313();
  return ObjCObjectPointerType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

std::optional<ObjCProtocolDecl> ObjCObjectPointerType::nth_protocol(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocols()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCObjectPointerType::protocols(void) const {
  auto list = impl->reader.getVal315();
  for (auto v : list) {
    EntityId id(v);
    if (auto d315 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d315)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<MemberPointerType> MemberPointerType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MemberPointerType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MemberPointerType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MemberPointerType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MemberPointerType> MemberPointerType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return MemberPointerType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kMemberPointerTypeDerivedKinds[] = {
    MemberPointerType::static_kind(),
};

gap::generator<MemberPointerType> MemberPointerType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kMemberPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<MemberPointerType> e = MemberPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MemberPointerType> MemberPointerType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kMemberPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<MemberPointerType> e = MemberPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MemberPointerType> MemberPointerType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::MEMBER_POINTER:
      return reinterpret_cast<const MemberPointerType &>(parent);
    default: return std::nullopt;
  }
}

Type MemberPointerType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type MemberPointerType::class_(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

CXXRecordDecl MemberPointerType::most_recent_cxx_record_declaration(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool MemberPointerType::is_member_data_pointer(void) const {
  return impl->reader.getVal293();
}

bool MemberPointerType::is_member_function_pointer(void) const {
  return impl->reader.getVal294();
}

bool MemberPointerType::is_sugared(void) const {
  return impl->reader.getVal295();
}

gap::generator<MatrixType> MatrixType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MatrixType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MatrixType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MatrixType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MatrixType> MatrixType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return MatrixType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kMatrixTypeDerivedKinds[] = {
    ConstantMatrixType::static_kind(),
    DependentSizedMatrixType::static_kind(),
};

gap::generator<MatrixType> MatrixType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<MatrixType> e = MatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MatrixType> MatrixType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<MatrixType> e = MatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MatrixType> MatrixType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_SIZED_MATRIX:
    case mx::TypeKind::CONSTANT_MATRIX:
      return reinterpret_cast<const MatrixType &>(parent);
    default: return std::nullopt;
  }
}

Type MatrixType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type MatrixType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool MatrixType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DependentSizedMatrixType> DependentSizedMatrixType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentSizedMatrixType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentSizedMatrixType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentSizedMatrixType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentSizedMatrixType> DependentSizedMatrixType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentSizedMatrixType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentSizedMatrixTypeDerivedKinds[] = {
    DependentSizedMatrixType::static_kind(),
};

gap::generator<DependentSizedMatrixType> DependentSizedMatrixType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentSizedMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentSizedMatrixType> e = DependentSizedMatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentSizedMatrixType> DependentSizedMatrixType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentSizedMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentSizedMatrixType> e = DependentSizedMatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentSizedMatrixType> DependentSizedMatrixType::from(const MatrixType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DependentSizedMatrixType> DependentSizedMatrixType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_SIZED_MATRIX:
      return reinterpret_cast<const DependentSizedMatrixType &>(parent);
    default: return std::nullopt;
  }
}

Token DependentSizedMatrixType::attribute_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal297());
}

Expr DependentSizedMatrixType::column_expression(void) const {
  RawEntityId eid = impl->reader.getVal299();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr DependentSizedMatrixType::row_expression(void) const {
  RawEntityId eid = impl->reader.getVal312();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ConstantMatrixType> ConstantMatrixType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstantMatrixType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstantMatrixType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstantMatrixType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConstantMatrixType> ConstantMatrixType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ConstantMatrixType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kConstantMatrixTypeDerivedKinds[] = {
    ConstantMatrixType::static_kind(),
};

gap::generator<ConstantMatrixType> ConstantMatrixType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kConstantMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ConstantMatrixType> e = ConstantMatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstantMatrixType> ConstantMatrixType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kConstantMatrixTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ConstantMatrixType> e = ConstantMatrixType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstantMatrixType> ConstantMatrixType::from(const MatrixType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<ConstantMatrixType> ConstantMatrixType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::CONSTANT_MATRIX:
      return reinterpret_cast<const ConstantMatrixType &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MacroQualifiedType> MacroQualifiedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MacroQualifiedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MacroQualifiedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MacroQualifiedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<MacroQualifiedType> MacroQualifiedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return MacroQualifiedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kMacroQualifiedTypeDerivedKinds[] = {
    MacroQualifiedType::static_kind(),
};

gap::generator<MacroQualifiedType> MacroQualifiedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kMacroQualifiedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<MacroQualifiedType> e = MacroQualifiedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MacroQualifiedType> MacroQualifiedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kMacroQualifiedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<MacroQualifiedType> e = MacroQualifiedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MacroQualifiedType> MacroQualifiedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::MACRO_QUALIFIED:
      return reinterpret_cast<const MacroQualifiedType &>(parent);
    default: return std::nullopt;
  }
}

Type MacroQualifiedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type MacroQualifiedType::modified_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type MacroQualifiedType::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool MacroQualifiedType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<InjectedClassNameType> InjectedClassNameType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InjectedClassNameType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InjectedClassNameType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InjectedClassNameType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<InjectedClassNameType> InjectedClassNameType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return InjectedClassNameType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kInjectedClassNameTypeDerivedKinds[] = {
    InjectedClassNameType::static_kind(),
};

gap::generator<InjectedClassNameType> InjectedClassNameType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kInjectedClassNameTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<InjectedClassNameType> e = InjectedClassNameType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InjectedClassNameType> InjectedClassNameType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kInjectedClassNameTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<InjectedClassNameType> e = InjectedClassNameType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InjectedClassNameType> InjectedClassNameType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::INJECTED_CLASS_NAME:
      return reinterpret_cast<const InjectedClassNameType &>(parent);
    default: return std::nullopt;
  }
}

Type InjectedClassNameType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

CXXRecordDecl InjectedClassNameType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Type InjectedClassNameType::injected_specialization_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TemplateSpecializationType InjectedClassNameType::injected_tst(void) const {
  RawEntityId eid = impl->reader.getVal299();
  return TemplateSpecializationType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

bool InjectedClassNameType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<FunctionType> FunctionType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FunctionType> FunctionType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return FunctionType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kFunctionTypeDerivedKinds[] = {
    FunctionNoProtoType::static_kind(),
    FunctionProtoType::static_kind(),
};

gap::generator<FunctionType> FunctionType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kFunctionTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<FunctionType> e = FunctionType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionType> FunctionType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kFunctionTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<FunctionType> e = FunctionType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionType> FunctionType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::FUNCTION_PROTO:
    case mx::TypeKind::FUNCTION_NO_PROTO:
      return reinterpret_cast<const FunctionType &>(parent);
    default: return std::nullopt;
  }
}

CallingConv FunctionType::call_conv(void) const {
  return static_cast<CallingConv>(impl->reader.getVal316());
}

Type FunctionType::call_result_type(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool FunctionType::cmse_ns_call_attribute(void) const {
  return impl->reader.getVal293();
}

bool FunctionType::has_reg_parm(void) const {
  return impl->reader.getVal294();
}

bool FunctionType::no_return_attribute(void) const {
  return impl->reader.getVal295();
}

Type FunctionType::return_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool FunctionType::is_const(void) const {
  return impl->reader.getVal301();
}

bool FunctionType::is_restrict(void) const {
  return impl->reader.getVal302();
}

bool FunctionType::is_volatile(void) const {
  return impl->reader.getVal303();
}

gap::generator<FunctionProtoType> FunctionProtoType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionProtoType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionProtoType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionProtoType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FunctionProtoType> FunctionProtoType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return FunctionProtoType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kFunctionProtoTypeDerivedKinds[] = {
    FunctionProtoType::static_kind(),
};

gap::generator<FunctionProtoType> FunctionProtoType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kFunctionProtoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<FunctionProtoType> e = FunctionProtoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionProtoType> FunctionProtoType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kFunctionProtoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<FunctionProtoType> e = FunctionProtoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionProtoType> FunctionProtoType::from(const FunctionType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<FunctionProtoType> FunctionProtoType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::FUNCTION_PROTO:
      return reinterpret_cast<const FunctionProtoType &>(parent);
    default: return std::nullopt;
  }
}

std::optional<CanThrowResult> FunctionProtoType::can_throw(void) const {
  if (!impl->reader.getVal304()) {
    return std::nullopt;
  } else {
    return static_cast<CanThrowResult>(impl->reader.getVal317());
  }
  return std::nullopt;
}

Type FunctionProtoType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token FunctionProtoType::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal299());
}

std::optional<FunctionDecl> FunctionProtoType::exception_spec_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal312();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<FunctionDecl> FunctionProtoType::exception_spec_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal313();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

ExceptionSpecificationType FunctionProtoType::exception_spec_type(void) const {
  return static_cast<ExceptionSpecificationType>(impl->reader.getVal318());
}

std::optional<Expr> FunctionProtoType::noexcept_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal319();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> FunctionProtoType::nth_parameter_type(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameter_types()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> FunctionProtoType::parameter_types(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d296));
    }
  }
  co_return;
}

RefQualifierKind FunctionProtoType::reference_qualifier(void) const {
  return static_cast<RefQualifierKind>(impl->reader.getVal320());
}

bool FunctionProtoType::has_dependent_exception_spec(void) const {
  return impl->reader.getVal305();
}

bool FunctionProtoType::has_dynamic_exception_spec(void) const {
  return impl->reader.getVal306();
}

bool FunctionProtoType::has_exception_spec(void) const {
  return impl->reader.getVal307();
}

bool FunctionProtoType::has_ext_parameter_infos(void) const {
  return impl->reader.getVal308();
}

bool FunctionProtoType::has_instantiation_dependent_exception_spec(void) const {
  return impl->reader.getVal309();
}

bool FunctionProtoType::has_noexcept_exception_spec(void) const {
  return impl->reader.getVal310();
}

bool FunctionProtoType::has_trailing_return(void) const {
  return impl->reader.getVal311();
}

std::optional<bool> FunctionProtoType::is_nothrow(void) const {
  if (!impl->reader.getVal322()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal321());
  }
  return std::nullopt;
}

bool FunctionProtoType::is_sugared(void) const {
  return impl->reader.getVal323();
}

bool FunctionProtoType::is_template_variadic(void) const {
  return impl->reader.getVal324();
}

bool FunctionProtoType::is_variadic(void) const {
  return impl->reader.getVal325();
}

std::optional<Type> FunctionProtoType::nth_exception_type(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : exception_types()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> FunctionProtoType::exception_types(void) const {
  auto list = impl->reader.getVal300();
  for (auto v : list) {
    EntityId id(v);
    if (auto d300 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d300));
    }
  }
  co_return;
}

gap::generator<FunctionNoProtoType> FunctionNoProtoType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionNoProtoType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionNoProtoType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionNoProtoType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<FunctionNoProtoType> FunctionNoProtoType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return FunctionNoProtoType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kFunctionNoProtoTypeDerivedKinds[] = {
    FunctionNoProtoType::static_kind(),
};

gap::generator<FunctionNoProtoType> FunctionNoProtoType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kFunctionNoProtoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<FunctionNoProtoType> e = FunctionNoProtoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionNoProtoType> FunctionNoProtoType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kFunctionNoProtoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<FunctionNoProtoType> e = FunctionNoProtoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionNoProtoType> FunctionNoProtoType::from(const FunctionType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<FunctionNoProtoType> FunctionNoProtoType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::FUNCTION_NO_PROTO:
      return reinterpret_cast<const FunctionNoProtoType &>(parent);
    default: return std::nullopt;
  }
}

Type FunctionNoProtoType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool FunctionNoProtoType::is_sugared(void) const {
  return impl->reader.getVal304();
}

gap::generator<DependentVectorType> DependentVectorType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentVectorType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentVectorType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentVectorType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentVectorType> DependentVectorType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentVectorType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentVectorTypeDerivedKinds[] = {
    DependentVectorType::static_kind(),
};

gap::generator<DependentVectorType> DependentVectorType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentVectorType> e = DependentVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentVectorType> DependentVectorType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentVectorType> e = DependentVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentVectorType> DependentVectorType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_VECTOR:
      return reinterpret_cast<const DependentVectorType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentVectorType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token DependentVectorType::attribute_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal292());
}

Type DependentVectorType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr DependentVectorType::size_expression(void) const {
  RawEntityId eid = impl->reader.getVal299();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

VectorTypeVectorKind DependentVectorType::vector_kind(void) const {
  return static_cast<VectorTypeVectorKind>(impl->reader.getVal316());
}

bool DependentVectorType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DependentSizedExtVectorType> DependentSizedExtVectorType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentSizedExtVectorType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentSizedExtVectorType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentSizedExtVectorType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentSizedExtVectorType> DependentSizedExtVectorType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentSizedExtVectorType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentSizedExtVectorTypeDerivedKinds[] = {
    DependentSizedExtVectorType::static_kind(),
};

gap::generator<DependentSizedExtVectorType> DependentSizedExtVectorType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentSizedExtVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentSizedExtVectorType> e = DependentSizedExtVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentSizedExtVectorType> DependentSizedExtVectorType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentSizedExtVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentSizedExtVectorType> e = DependentSizedExtVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentSizedExtVectorType> DependentSizedExtVectorType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_SIZED_EXT_VECTOR:
      return reinterpret_cast<const DependentSizedExtVectorType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentSizedExtVectorType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token DependentSizedExtVectorType::attribute_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal292());
}

Type DependentSizedExtVectorType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr DependentSizedExtVectorType::size_expression(void) const {
  RawEntityId eid = impl->reader.getVal299();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool DependentSizedExtVectorType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DependentBitIntType> DependentBitIntType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentBitIntType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentBitIntType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentBitIntType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentBitIntType> DependentBitIntType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentBitIntType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentBitIntTypeDerivedKinds[] = {
    DependentBitIntType::static_kind(),
};

gap::generator<DependentBitIntType> DependentBitIntType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentBitIntTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentBitIntType> e = DependentBitIntType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentBitIntType> DependentBitIntType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentBitIntTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentBitIntType> e = DependentBitIntType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentBitIntType> DependentBitIntType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_BIT_INT:
      return reinterpret_cast<const DependentBitIntType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentBitIntType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr DependentBitIntType::num_bits_expression(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool DependentBitIntType::is_signed(void) const {
  return impl->reader.getVal293();
}

bool DependentBitIntType::is_sugared(void) const {
  return impl->reader.getVal294();
}

bool DependentBitIntType::is_unsigned(void) const {
  return impl->reader.getVal295();
}

gap::generator<DependentAddressSpaceType> DependentAddressSpaceType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentAddressSpaceType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentAddressSpaceType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentAddressSpaceType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentAddressSpaceType> DependentAddressSpaceType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentAddressSpaceType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentAddressSpaceTypeDerivedKinds[] = {
    DependentAddressSpaceType::static_kind(),
};

gap::generator<DependentAddressSpaceType> DependentAddressSpaceType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentAddressSpaceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentAddressSpaceType> e = DependentAddressSpaceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentAddressSpaceType> DependentAddressSpaceType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentAddressSpaceTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentAddressSpaceType> e = DependentAddressSpaceType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentAddressSpaceType> DependentAddressSpaceType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_ADDRESS_SPACE:
      return reinterpret_cast<const DependentAddressSpaceType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentAddressSpaceType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr DependentAddressSpaceType::address_space_expression(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token DependentAddressSpaceType::attribute_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal297());
}

bool DependentAddressSpaceType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DeducedType> DeducedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeducedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeducedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeducedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DeducedType> DeducedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DeducedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDeducedTypeDerivedKinds[] = {
    AutoType::static_kind(),
    DeducedTemplateSpecializationType::static_kind(),
};

gap::generator<DeducedType> DeducedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDeducedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DeducedType> e = DeducedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeducedType> DeducedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDeducedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DeducedType> e = DeducedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeducedType> DeducedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEDUCED_TEMPLATE_SPECIALIZATION:
    case mx::TypeKind::AUTO:
      return reinterpret_cast<const DeducedType &>(parent);
    default: return std::nullopt;
  }
}

Type DeducedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Type> DeducedType::resolved_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal292();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool DeducedType::is_deduced(void) const {
  return impl->reader.getVal293();
}

bool DeducedType::is_sugared(void) const {
  return impl->reader.getVal294();
}

gap::generator<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeducedTemplateSpecializationType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeducedTemplateSpecializationType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeducedTemplateSpecializationType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DeducedTemplateSpecializationType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDeducedTemplateSpecializationTypeDerivedKinds[] = {
    DeducedTemplateSpecializationType::static_kind(),
};

gap::generator<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDeducedTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DeducedTemplateSpecializationType> e = DeducedTemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDeducedTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DeducedTemplateSpecializationType> e = DeducedTemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::from(const DeducedType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DeducedTemplateSpecializationType> DeducedTemplateSpecializationType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEDUCED_TEMPLATE_SPECIALIZATION:
      return reinterpret_cast<const DeducedTemplateSpecializationType &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AutoType> AutoType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AutoType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AutoType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AutoType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AutoType> AutoType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return AutoType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kAutoTypeDerivedKinds[] = {
    AutoType::static_kind(),
};

gap::generator<AutoType> AutoType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kAutoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<AutoType> e = AutoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AutoType> AutoType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kAutoTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<AutoType> e = AutoType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AutoType> AutoType::from(const DeducedType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<AutoType> AutoType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::AUTO:
      return reinterpret_cast<const AutoType &>(parent);
    default: return std::nullopt;
  }
}

AutoTypeKeyword AutoType::keyword(void) const {
  return static_cast<AutoTypeKeyword>(impl->reader.getVal316());
}

std::optional<TemplateArgument> AutoType::nth_type_constraint_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : type_constraint_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> AutoType::type_constraint_arguments(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d296));
    }
  }
  co_return;
}

std::optional<ConceptDecl> AutoType::type_constraint_concept(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal297();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ConceptDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool AutoType::is_constrained(void) const {
  return impl->reader.getVal295();
}

bool AutoType::is_decltype_auto(void) const {
  return impl->reader.getVal301();
}

bool AutoType::is_gnu_auto_type(void) const {
  return impl->reader.getVal302();
}

gap::generator<DecltypeType> DecltypeType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DecltypeType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DecltypeType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DecltypeType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DecltypeType> DecltypeType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DecltypeType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDecltypeTypeDerivedKinds[] = {
    DecltypeType::static_kind(),
};

gap::generator<DecltypeType> DecltypeType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDecltypeTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DecltypeType> e = DecltypeType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DecltypeType> DecltypeType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDecltypeTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DecltypeType> e = DecltypeType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DecltypeType> DecltypeType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DECLTYPE:
      return reinterpret_cast<const DecltypeType &>(parent);
    default: return std::nullopt;
  }
}

Type DecltypeType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr DecltypeType::underlying_expression(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type DecltypeType::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool DecltypeType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ComplexType> ComplexType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ComplexType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ComplexType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ComplexType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ComplexType> ComplexType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ComplexType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kComplexTypeDerivedKinds[] = {
    ComplexType::static_kind(),
};

gap::generator<ComplexType> ComplexType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kComplexTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ComplexType> e = ComplexType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ComplexType> ComplexType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kComplexTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ComplexType> e = ComplexType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ComplexType> ComplexType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::COMPLEX:
      return reinterpret_cast<const ComplexType &>(parent);
    default: return std::nullopt;
  }
}

Type ComplexType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ComplexType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ComplexType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<BuiltinType> BuiltinType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BuiltinType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BuiltinType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BuiltinType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BuiltinType> BuiltinType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return BuiltinType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kBuiltinTypeDerivedKinds[] = {
    BuiltinType::static_kind(),
};

gap::generator<BuiltinType> BuiltinType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kBuiltinTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<BuiltinType> e = BuiltinType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BuiltinType> BuiltinType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kBuiltinTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<BuiltinType> e = BuiltinType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BuiltinType> BuiltinType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::BUILTIN:
      return reinterpret_cast<const BuiltinType &>(parent);
    default: return std::nullopt;
  }
}

Type BuiltinType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

BuiltinTypeKind BuiltinType::builtin_kind(void) const {
  return static_cast<BuiltinTypeKind>(impl->reader.getVal316());
}

bool BuiltinType::is_floating_point(void) const {
  return impl->reader.getVal293();
}

bool BuiltinType::is_integer(void) const {
  return impl->reader.getVal294();
}

bool BuiltinType::is_sve_bool(void) const {
  return impl->reader.getVal295();
}

bool BuiltinType::is_signed_integer(void) const {
  return impl->reader.getVal301();
}

bool BuiltinType::is_sugared(void) const {
  return impl->reader.getVal302();
}

bool BuiltinType::is_unsigned_integer(void) const {
  return impl->reader.getVal303();
}

gap::generator<BlockPointerType> BlockPointerType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BlockPointerType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BlockPointerType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BlockPointerType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BlockPointerType> BlockPointerType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return BlockPointerType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kBlockPointerTypeDerivedKinds[] = {
    BlockPointerType::static_kind(),
};

gap::generator<BlockPointerType> BlockPointerType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kBlockPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<BlockPointerType> e = BlockPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BlockPointerType> BlockPointerType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kBlockPointerTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<BlockPointerType> e = BlockPointerType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BlockPointerType> BlockPointerType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::BLOCK_POINTER:
      return reinterpret_cast<const BlockPointerType &>(parent);
    default: return std::nullopt;
  }
}

Type BlockPointerType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool BlockPointerType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<BitIntType> BitIntType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BitIntType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BitIntType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BitIntType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BitIntType> BitIntType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return BitIntType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kBitIntTypeDerivedKinds[] = {
    BitIntType::static_kind(),
};

gap::generator<BitIntType> BitIntType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kBitIntTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<BitIntType> e = BitIntType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BitIntType> BitIntType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kBitIntTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<BitIntType> e = BitIntType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BitIntType> BitIntType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::BIT_INT:
      return reinterpret_cast<const BitIntType &>(parent);
    default: return std::nullopt;
  }
}

Type BitIntType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool BitIntType::is_signed(void) const {
  return impl->reader.getVal293();
}

bool BitIntType::is_sugared(void) const {
  return impl->reader.getVal294();
}

bool BitIntType::is_unsigned(void) const {
  return impl->reader.getVal295();
}

gap::generator<BTFTagAttributedType> BTFTagAttributedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BTFTagAttributedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BTFTagAttributedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BTFTagAttributedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<BTFTagAttributedType> BTFTagAttributedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return BTFTagAttributedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kBTFTagAttributedTypeDerivedKinds[] = {
    BTFTagAttributedType::static_kind(),
};

gap::generator<BTFTagAttributedType> BTFTagAttributedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kBTFTagAttributedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<BTFTagAttributedType> e = BTFTagAttributedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BTFTagAttributedType> BTFTagAttributedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kBTFTagAttributedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<BTFTagAttributedType> e = BTFTagAttributedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BTFTagAttributedType> BTFTagAttributedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::BTF_TAG_ATTRIBUTED:
      return reinterpret_cast<const BTFTagAttributedType &>(parent);
    default: return std::nullopt;
  }
}

Type BTFTagAttributedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

BTFTypeTagAttr BTFTagAttributedType::attribute(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return BTFTypeTagAttr::from(Attr(impl->ep->AttrFor(impl->ep, eid))).value();
}

Type BTFTagAttributedType::wrapped_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool BTFTagAttributedType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<AttributedType> AttributedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AttributedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AttributedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AttributedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AttributedType> AttributedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return AttributedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kAttributedTypeDerivedKinds[] = {
    AttributedType::static_kind(),
};

gap::generator<AttributedType> AttributedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kAttributedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<AttributedType> e = AttributedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AttributedType> AttributedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kAttributedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<AttributedType> e = AttributedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AttributedType> AttributedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ATTRIBUTED:
      return reinterpret_cast<const AttributedType &>(parent);
    default: return std::nullopt;
  }
}

Type AttributedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

AttrKind AttributedType::attribute_kind(void) const {
  return static_cast<AttrKind>(impl->reader.getVal326());
}

Type AttributedType::equivalent_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<NullabilityKind> AttributedType::immediate_nullability(void) const {
  if (!impl->reader.getVal293()) {
    return std::nullopt;
  } else {
    return static_cast<NullabilityKind>(impl->reader.getVal316());
  }
  return std::nullopt;
}

Type AttributedType::modified_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool AttributedType::is_calling_conv(void) const {
  return impl->reader.getVal294();
}

bool AttributedType::is_ms_type_spec(void) const {
  return impl->reader.getVal295();
}

bool AttributedType::is_qualifier(void) const {
  return impl->reader.getVal301();
}

bool AttributedType::is_sugared(void) const {
  return impl->reader.getVal302();
}

gap::generator<AtomicType> AtomicType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AtomicType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AtomicType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AtomicType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AtomicType> AtomicType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return AtomicType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kAtomicTypeDerivedKinds[] = {
    AtomicType::static_kind(),
};

gap::generator<AtomicType> AtomicType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kAtomicTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<AtomicType> e = AtomicType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AtomicType> AtomicType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kAtomicTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<AtomicType> e = AtomicType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AtomicType> AtomicType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ATOMIC:
      return reinterpret_cast<const AtomicType &>(parent);
    default: return std::nullopt;
  }
}

Type AtomicType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type AtomicType::value_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool AtomicType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ArrayType> ArrayType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArrayType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArrayType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArrayType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ArrayType> ArrayType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ArrayType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kArrayTypeDerivedKinds[] = {
    ConstantArrayType::static_kind(),
    DependentSizedArrayType::static_kind(),
    IncompleteArrayType::static_kind(),
    VariableArrayType::static_kind(),
};

gap::generator<ArrayType> ArrayType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ArrayType> e = ArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArrayType> ArrayType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ArrayType> e = ArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArrayType> ArrayType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::VARIABLE_ARRAY:
    case mx::TypeKind::INCOMPLETE_ARRAY:
    case mx::TypeKind::DEPENDENT_SIZED_ARRAY:
    case mx::TypeKind::CONSTANT_ARRAY:
      return reinterpret_cast<const ArrayType &>(parent);
    default: return std::nullopt;
  }
}

Type ArrayType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ArrayTypeArraySizeModifier ArrayType::size_modifier(void) const {
  return static_cast<ArrayTypeArraySizeModifier>(impl->reader.getVal316());
}

gap::generator<VariableArrayType> VariableArrayType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VariableArrayType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VariableArrayType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VariableArrayType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VariableArrayType> VariableArrayType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return VariableArrayType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kVariableArrayTypeDerivedKinds[] = {
    VariableArrayType::static_kind(),
};

gap::generator<VariableArrayType> VariableArrayType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kVariableArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<VariableArrayType> e = VariableArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VariableArrayType> VariableArrayType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kVariableArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<VariableArrayType> e = VariableArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VariableArrayType> VariableArrayType::from(const ArrayType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<VariableArrayType> VariableArrayType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::VARIABLE_ARRAY:
      return reinterpret_cast<const VariableArrayType &>(parent);
    default: return std::nullopt;
  }
}

Type VariableArrayType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TokenRange VariableArrayType::brackets_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal297(), impl->reader.getVal299());
}

Token VariableArrayType::l_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal312());
}

Token VariableArrayType::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal313());
}

Expr VariableArrayType::size_expression(void) const {
  RawEntityId eid = impl->reader.getVal319();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool VariableArrayType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<IncompleteArrayType> IncompleteArrayType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IncompleteArrayType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IncompleteArrayType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IncompleteArrayType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<IncompleteArrayType> IncompleteArrayType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return IncompleteArrayType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kIncompleteArrayTypeDerivedKinds[] = {
    IncompleteArrayType::static_kind(),
};

gap::generator<IncompleteArrayType> IncompleteArrayType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kIncompleteArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<IncompleteArrayType> e = IncompleteArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IncompleteArrayType> IncompleteArrayType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kIncompleteArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<IncompleteArrayType> e = IncompleteArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IncompleteArrayType> IncompleteArrayType::from(const ArrayType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<IncompleteArrayType> IncompleteArrayType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::INCOMPLETE_ARRAY:
      return reinterpret_cast<const IncompleteArrayType &>(parent);
    default: return std::nullopt;
  }
}

Type IncompleteArrayType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool IncompleteArrayType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DependentSizedArrayType> DependentSizedArrayType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentSizedArrayType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentSizedArrayType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentSizedArrayType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentSizedArrayType> DependentSizedArrayType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentSizedArrayType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentSizedArrayTypeDerivedKinds[] = {
    DependentSizedArrayType::static_kind(),
};

gap::generator<DependentSizedArrayType> DependentSizedArrayType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentSizedArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentSizedArrayType> e = DependentSizedArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentSizedArrayType> DependentSizedArrayType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentSizedArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentSizedArrayType> e = DependentSizedArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentSizedArrayType> DependentSizedArrayType::from(const ArrayType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DependentSizedArrayType> DependentSizedArrayType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_SIZED_ARRAY:
      return reinterpret_cast<const DependentSizedArrayType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentSizedArrayType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TokenRange DependentSizedArrayType::brackets_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal297(), impl->reader.getVal299());
}

Token DependentSizedArrayType::l_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal312());
}

Token DependentSizedArrayType::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal313());
}

Expr DependentSizedArrayType::size_expression(void) const {
  RawEntityId eid = impl->reader.getVal319();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool DependentSizedArrayType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ConstantArrayType> ConstantArrayType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstantArrayType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstantArrayType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstantArrayType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ConstantArrayType> ConstantArrayType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ConstantArrayType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kConstantArrayTypeDerivedKinds[] = {
    ConstantArrayType::static_kind(),
};

gap::generator<ConstantArrayType> ConstantArrayType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kConstantArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ConstantArrayType> e = ConstantArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstantArrayType> ConstantArrayType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kConstantArrayTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ConstantArrayType> e = ConstantArrayType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstantArrayType> ConstantArrayType::from(const ArrayType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<ConstantArrayType> ConstantArrayType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::CONSTANT_ARRAY:
      return reinterpret_cast<const ConstantArrayType &>(parent);
    default: return std::nullopt;
  }
}

Type ConstantArrayType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Expr> ConstantArrayType::size_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal297();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool ConstantArrayType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<AdjustedType> AdjustedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AdjustedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AdjustedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AdjustedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<AdjustedType> AdjustedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return AdjustedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kAdjustedTypeDerivedKinds[] = {
    AdjustedType::static_kind(),
    DecayedType::static_kind(),
};

gap::generator<AdjustedType> AdjustedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kAdjustedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<AdjustedType> e = AdjustedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AdjustedType> AdjustedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kAdjustedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<AdjustedType> e = AdjustedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AdjustedType> AdjustedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ADJUSTED:
    case mx::TypeKind::DECAYED:
      return reinterpret_cast<const AdjustedType &>(parent);
    default: return std::nullopt;
  }
}

Type AdjustedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type AdjustedType::resolved_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type AdjustedType::original_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool AdjustedType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DecayedType> DecayedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DecayedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DecayedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DecayedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DecayedType> DecayedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DecayedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDecayedTypeDerivedKinds[] = {
    DecayedType::static_kind(),
};

gap::generator<DecayedType> DecayedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDecayedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DecayedType> e = DecayedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DecayedType> DecayedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDecayedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DecayedType> e = DecayedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DecayedType> DecayedType::from(const AdjustedType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DecayedType> DecayedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DECAYED:
      return reinterpret_cast<const DecayedType &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeWithKeyword> TypeWithKeyword::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeWithKeyword::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeWithKeyword::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeWithKeyword::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeWithKeyword> TypeWithKeyword::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TypeWithKeyword::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTypeWithKeywordDerivedKinds[] = {
    DependentNameType::static_kind(),
    DependentTemplateSpecializationType::static_kind(),
    ElaboratedType::static_kind(),
};

gap::generator<TypeWithKeyword> TypeWithKeyword::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTypeWithKeywordDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TypeWithKeyword> e = TypeWithKeyword::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeWithKeyword> TypeWithKeyword::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTypeWithKeywordDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TypeWithKeyword> e = TypeWithKeyword::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeWithKeyword> TypeWithKeyword::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ELABORATED:
    case mx::TypeKind::DEPENDENT_TEMPLATE_SPECIALIZATION:
    case mx::TypeKind::DEPENDENT_NAME:
      return reinterpret_cast<const TypeWithKeyword &>(parent);
    default: return std::nullopt;
  }
}

ElaboratedTypeKeyword TypeWithKeyword::keyword(void) const {
  return static_cast<ElaboratedTypeKeyword>(impl->reader.getVal316());
}

gap::generator<ElaboratedType> ElaboratedType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ElaboratedType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ElaboratedType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ElaboratedType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ElaboratedType> ElaboratedType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ElaboratedType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kElaboratedTypeDerivedKinds[] = {
    ElaboratedType::static_kind(),
};

gap::generator<ElaboratedType> ElaboratedType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kElaboratedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ElaboratedType> e = ElaboratedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ElaboratedType> ElaboratedType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kElaboratedTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ElaboratedType> e = ElaboratedType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ElaboratedType> ElaboratedType::from(const TypeWithKeyword &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<ElaboratedType> ElaboratedType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::ELABORATED:
      return reinterpret_cast<const ElaboratedType &>(parent);
    default: return std::nullopt;
  }
}

Type ElaboratedType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ElaboratedType::named_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<TagDecl> ElaboratedType::owned_tag_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal297();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TagDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool ElaboratedType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<DependentTemplateSpecializationType> DependentTemplateSpecializationType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentTemplateSpecializationType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentTemplateSpecializationType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentTemplateSpecializationType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentTemplateSpecializationType> DependentTemplateSpecializationType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentTemplateSpecializationType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentTemplateSpecializationTypeDerivedKinds[] = {
    DependentTemplateSpecializationType::static_kind(),
};

gap::generator<DependentTemplateSpecializationType> DependentTemplateSpecializationType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentTemplateSpecializationType> e = DependentTemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentTemplateSpecializationType> DependentTemplateSpecializationType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentTemplateSpecializationTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentTemplateSpecializationType> e = DependentTemplateSpecializationType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentTemplateSpecializationType> DependentTemplateSpecializationType::from(const TypeWithKeyword &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DependentTemplateSpecializationType> DependentTemplateSpecializationType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_TEMPLATE_SPECIALIZATION:
      return reinterpret_cast<const DependentTemplateSpecializationType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentTemplateSpecializationType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool DependentTemplateSpecializationType::is_sugared(void) const {
  return impl->reader.getVal293();
}

std::optional<TemplateArgument> DependentTemplateSpecializationType::nth_template_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> DependentTemplateSpecializationType::template_arguments(void) const {
  auto list = impl->reader.getVal296();
  for (auto v : list) {
    EntityId id(v);
    if (auto d296 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d296));
    }
  }
  co_return;
}

gap::generator<DependentNameType> DependentNameType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentNameType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentNameType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentNameType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<DependentNameType> DependentNameType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return DependentNameType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kDependentNameTypeDerivedKinds[] = {
    DependentNameType::static_kind(),
};

gap::generator<DependentNameType> DependentNameType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kDependentNameTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<DependentNameType> e = DependentNameType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentNameType> DependentNameType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kDependentNameTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<DependentNameType> e = DependentNameType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentNameType> DependentNameType::from(const TypeWithKeyword &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<DependentNameType> DependentNameType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::DEPENDENT_NAME:
      return reinterpret_cast<const DependentNameType &>(parent);
    default: return std::nullopt;
  }
}

Type DependentNameType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool DependentNameType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<VectorType> VectorType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VectorType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VectorType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VectorType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<VectorType> VectorType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return VectorType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kVectorTypeDerivedKinds[] = {
    VectorType::static_kind(),
    ExtVectorType::static_kind(),
};

gap::generator<VectorType> VectorType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<VectorType> e = VectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VectorType> VectorType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<VectorType> e = VectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VectorType> VectorType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::VECTOR:
    case mx::TypeKind::EXT_VECTOR:
      return reinterpret_cast<const VectorType &>(parent);
    default: return std::nullopt;
  }
}

Type VectorType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type VectorType::element_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

VectorTypeVectorKind VectorType::vector_kind(void) const {
  return static_cast<VectorTypeVectorKind>(impl->reader.getVal316());
}

bool VectorType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<ExtVectorType> ExtVectorType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExtVectorType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExtVectorType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExtVectorType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<ExtVectorType> ExtVectorType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return ExtVectorType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kExtVectorTypeDerivedKinds[] = {
    ExtVectorType::static_kind(),
};

gap::generator<ExtVectorType> ExtVectorType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kExtVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<ExtVectorType> e = ExtVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExtVectorType> ExtVectorType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kExtVectorTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<ExtVectorType> e = ExtVectorType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExtVectorType> ExtVectorType::from(const VectorType &parent) {
  return from(reinterpret_cast<const Type &>(parent));
}

std::optional<ExtVectorType> ExtVectorType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::EXT_VECTOR:
      return reinterpret_cast<const ExtVectorType &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<UsingType> UsingType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UsingType> UsingType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return UsingType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kUsingTypeDerivedKinds[] = {
    UsingType::static_kind(),
};

gap::generator<UsingType> UsingType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kUsingTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<UsingType> e = UsingType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingType> UsingType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kUsingTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<UsingType> e = UsingType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingType> UsingType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::USING:
      return reinterpret_cast<const UsingType &>(parent);
    default: return std::nullopt;
  }
}

Type UsingType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

UsingShadowDecl UsingType::found_declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return UsingShadowDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Type UsingType::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool UsingType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<UnresolvedUsingType> UnresolvedUsingType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedUsingType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedUsingType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedUsingType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UnresolvedUsingType> UnresolvedUsingType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return UnresolvedUsingType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kUnresolvedUsingTypeDerivedKinds[] = {
    UnresolvedUsingType::static_kind(),
};

gap::generator<UnresolvedUsingType> UnresolvedUsingType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kUnresolvedUsingTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<UnresolvedUsingType> e = UnresolvedUsingType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedUsingType> UnresolvedUsingType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kUnresolvedUsingTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedUsingType> e = UnresolvedUsingType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedUsingType> UnresolvedUsingType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::UNRESOLVED_USING:
      return reinterpret_cast<const UnresolvedUsingType &>(parent);
    default: return std::nullopt;
  }
}

Type UnresolvedUsingType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

UnresolvedUsingTypenameDecl UnresolvedUsingType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return UnresolvedUsingTypenameDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool UnresolvedUsingType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<UnaryTransformType> UnaryTransformType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnaryTransformType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnaryTransformType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnaryTransformType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<UnaryTransformType> UnaryTransformType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return UnaryTransformType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kUnaryTransformTypeDerivedKinds[] = {
    UnaryTransformType::static_kind(),
};

gap::generator<UnaryTransformType> UnaryTransformType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kUnaryTransformTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<UnaryTransformType> e = UnaryTransformType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnaryTransformType> UnaryTransformType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kUnaryTransformTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<UnaryTransformType> e = UnaryTransformType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnaryTransformType> UnaryTransformType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::UNARY_TRANSFORM:
      return reinterpret_cast<const UnaryTransformType &>(parent);
    default: return std::nullopt;
  }
}

Type UnaryTransformType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type UnaryTransformType::base_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

UnaryTransformTypeUTTKind UnaryTransformType::utt_kind(void) const {
  return static_cast<UnaryTransformTypeUTTKind>(impl->reader.getVal316());
}

Type UnaryTransformType::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal297();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool UnaryTransformType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<TypedefType> TypedefType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypedefType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypedefType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypedefType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypedefType> TypedefType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TypedefType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTypedefTypeDerivedKinds[] = {
    TypedefType::static_kind(),
};

gap::generator<TypedefType> TypedefType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTypedefTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TypedefType> e = TypedefType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypedefType> TypedefType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTypedefTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TypedefType> e = TypedefType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypedefType> TypedefType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::TYPEDEF:
      return reinterpret_cast<const TypedefType &>(parent);
    default: return std::nullopt;
  }
}

Type TypedefType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TypedefNameDecl TypedefType::declaration(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return TypedefNameDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool TypedefType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<TypeOfType> TypeOfType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeOfType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeOfType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeOfType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeOfType> TypeOfType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TypeOfType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTypeOfTypeDerivedKinds[] = {
    TypeOfType::static_kind(),
};

gap::generator<TypeOfType> TypeOfType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTypeOfTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TypeOfType> e = TypeOfType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeOfType> TypeOfType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTypeOfTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TypeOfType> e = TypeOfType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeOfType> TypeOfType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::TYPE_OF:
      return reinterpret_cast<const TypeOfType &>(parent);
    default: return std::nullopt;
  }
}

Type TypeOfType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type TypeOfType::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool TypeOfType::is_sugared(void) const {
  return impl->reader.getVal293();
}

gap::generator<TypeOfExprType> TypeOfExprType::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeOfExprType::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeOfExprType::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeOfExprType::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

std::optional<TypeOfExprType> TypeOfExprType::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<TypeId>(vid)) {
    return TypeOfExprType::from(index.type(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const TypeKind kTypeOfExprTypeDerivedKinds[] = {
    TypeOfExprType::static_kind(),
};

gap::generator<TypeOfExprType> TypeOfExprType::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (TypeKind k : kTypeOfExprTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k)) {
      if (std::optional<TypeOfExprType> e = TypeOfExprType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeOfExprType> TypeOfExprType::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (TypeKind k : kTypeOfExprTypeDerivedKinds) {
    for (TypeImplPtr eptr : ep->TypesFor(ep, k, frag_id)) {
      if (std::optional<TypeOfExprType> e = TypeOfExprType::from(Type(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeOfExprType> TypeOfExprType::from(const Type &parent) {
  switch (parent.kind()) {
    case mx::TypeKind::TYPE_OF_EXPR:
      return reinterpret_cast<const TypeOfExprType &>(parent);
    default: return std::nullopt;
  }
}

Type TypeOfExprType::desugar(void) const {
  RawEntityId eid = impl->reader.getVal291();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr TypeOfExprType::underlying_expression(void) const {
  RawEntityId eid = impl->reader.getVal292();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool TypeOfExprType::is_sugared(void) const {
  return impl->reader.getVal293();
}

std::optional<Decl> Stmt::parent_declaration(void) const {
  if (auto id = impl->reader.getVal0(); id != kInvalidEntityId) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, id)) {
      return Decl(std::move(eptr));
    }
    assert(false);
  }
  return std::nullopt;
}

std::optional<Stmt> Stmt::parent_statement(void) const {
  if (auto id = impl->reader.getVal1(); id != kInvalidEntityId) {
    if (auto eptr = impl->ep->StmtFor(impl->ep, id)) {
      return Stmt(std::move(eptr));
    }
    assert(false);
  }
  return std::nullopt;
}
inline const std::shared_ptr<EntityProvider> &Stmt::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Stmt::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

std::optional<PackedDeclId> Stmt::referenced_declaration_id(void) const {
  if (auto id = impl->reader.getVal2();
      id != kInvalidEntityId) {
    VariantId vid = EntityId(id).Unpack();
    if (std::holds_alternative<DeclId>(vid)) {
      return std::get<DeclId>(vid);
    }
    assert(false);
  }
  return std::nullopt;
}

std::optional<Decl> Stmt::referenced_declaration(void) const {
  if (auto id = impl->reader.getVal2();
      id != kInvalidEntityId) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, id)) {
      return Decl(std::move(eptr));
    }
    assert(false);
  }
  return std::nullopt;
}

gap::generator<Stmt> Stmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Stmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Stmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Stmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<Stmt> Stmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = Stmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Stmt> Stmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<Stmt> Stmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = Stmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Stmt> Stmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool Stmt::contains(const Decl &decl) {
  for (auto &parent : Stmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool Stmt::contains(const Stmt &stmt) {
  for (auto &parent : Stmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<Stmt> Stmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    index.statement(eid.Pack());
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

gap::generator<Stmt> Stmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtImplPtr eptr : ep->StmtsFor(ep)) {
    if (std::optional<Stmt> e = Stmt::from(Stmt(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Stmt> Stmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtImplPtr eptr : ep->StmtsFor(ep, frag_id)) {
    if (std::optional<Stmt> e = Stmt::from(Stmt(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Stmt> Stmt::in(const Index &index, std::span<StmtKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      co_yield Stmt(std::move(eptr));
    }
  }
}

gap::generator<Stmt> Stmt::in(const Fragment &frag, std::span<StmtKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      co_yield Stmt(std::move(eptr));
    }
  }
}

Stmt Stmt::ignore_containers(void) const {
  RawEntityId eid = impl->reader.getVal3();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<Stmt> Stmt::children(void) const {
  auto list = impl->reader.getVal4();
  for (auto v : list) {
    EntityId id(v);
    if (auto d4 = impl->ep->StmtFor(impl->ep, v)) {
      co_yield Stmt(std::move(d4));
    }
  }
  co_return;
}

TokenRange Stmt::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal5(), impl->reader.getVal6());
}

StmtKind Stmt::kind(void) const {
  return static_cast<StmtKind>(impl->reader.getVal7());
}

Stmt Stmt::strip_label_like_statements(void) const {
  RawEntityId eid = impl->reader.getVal8();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<SEHTryStmt> SEHTryStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SEHTryStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SEHTryStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SEHTryStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SEHTryStmt> SEHTryStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHTryStmt> SEHTryStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SEHTryStmt> SEHTryStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHTryStmt> SEHTryStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SEHTryStmt::contains(const Decl &decl) {
  for (auto &parent : SEHTryStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SEHTryStmt::contains(const Stmt &stmt) {
  for (auto &parent : SEHTryStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SEHTryStmt> SEHTryStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SEHTryStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSEHTryStmtDerivedKinds[] = {
    SEHTryStmt::static_kind(),
};

gap::generator<SEHTryStmt> SEHTryStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSEHTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SEHTryStmt> e = SEHTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SEHTryStmt> SEHTryStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSEHTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SEHTryStmt> e = SEHTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SEHTryStmt> SEHTryStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SEH_TRY_STMT:
      return reinterpret_cast<const SEHTryStmt &>(parent);
    default: return std::nullopt;
  }
}

SEHExceptStmt SEHTryStmt::except_handler(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return SEHExceptStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

SEHFinallyStmt SEHTryStmt::finally_handler(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return SEHFinallyStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt SEHTryStmt::handler(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

bool SEHTryStmt::is_cxx_try(void) const {
  return impl->reader.getVal12();
}

CompoundStmt SEHTryStmt::try_block(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token SEHTryStmt::try_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SEHLeaveStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SEHLeaveStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SEHLeaveStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHLeaveStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHLeaveStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SEHLeaveStmt::contains(const Decl &decl) {
  for (auto &parent : SEHLeaveStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SEHLeaveStmt::contains(const Stmt &stmt) {
  for (auto &parent : SEHLeaveStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SEHLeaveStmt> SEHLeaveStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SEHLeaveStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSEHLeaveStmtDerivedKinds[] = {
    SEHLeaveStmt::static_kind(),
};

gap::generator<SEHLeaveStmt> SEHLeaveStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSEHLeaveStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SEHLeaveStmt> e = SEHLeaveStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SEHLeaveStmt> SEHLeaveStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSEHLeaveStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SEHLeaveStmt> e = SEHLeaveStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SEHLeaveStmt> SEHLeaveStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SEH_LEAVE_STMT:
      return reinterpret_cast<const SEHLeaveStmt &>(parent);
    default: return std::nullopt;
  }
}

Token SEHLeaveStmt::leave_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SEHFinallyStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SEHFinallyStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SEHFinallyStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHFinallyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHFinallyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SEHFinallyStmt::contains(const Decl &decl) {
  for (auto &parent : SEHFinallyStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SEHFinallyStmt::contains(const Stmt &stmt) {
  for (auto &parent : SEHFinallyStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SEHFinallyStmt> SEHFinallyStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SEHFinallyStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSEHFinallyStmtDerivedKinds[] = {
    SEHFinallyStmt::static_kind(),
};

gap::generator<SEHFinallyStmt> SEHFinallyStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSEHFinallyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SEHFinallyStmt> e = SEHFinallyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SEHFinallyStmt> SEHFinallyStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSEHFinallyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SEHFinallyStmt> e = SEHFinallyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SEHFinallyStmt> SEHFinallyStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SEH_FINALLY_STMT:
      return reinterpret_cast<const SEHFinallyStmt &>(parent);
    default: return std::nullopt;
  }
}

CompoundStmt SEHFinallyStmt::block(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token SEHFinallyStmt::finally_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

gap::generator<SEHExceptStmt> SEHExceptStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SEHExceptStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SEHExceptStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SEHExceptStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SEHExceptStmt> SEHExceptStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHExceptStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHExceptStmt> SEHExceptStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SEHExceptStmt> SEHExceptStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SEHExceptStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SEHExceptStmt> SEHExceptStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SEHExceptStmt::contains(const Decl &decl) {
  for (auto &parent : SEHExceptStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SEHExceptStmt::contains(const Stmt &stmt) {
  for (auto &parent : SEHExceptStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SEHExceptStmt> SEHExceptStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SEHExceptStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSEHExceptStmtDerivedKinds[] = {
    SEHExceptStmt::static_kind(),
};

gap::generator<SEHExceptStmt> SEHExceptStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSEHExceptStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SEHExceptStmt> e = SEHExceptStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SEHExceptStmt> SEHExceptStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSEHExceptStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SEHExceptStmt> e = SEHExceptStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SEHExceptStmt> SEHExceptStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SEH_EXCEPT_STMT:
      return reinterpret_cast<const SEHExceptStmt &>(parent);
    default: return std::nullopt;
  }
}

CompoundStmt SEHExceptStmt::block(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token SEHExceptStmt::except_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

Expr SEHExceptStmt::filter_expression(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ReturnStmt> ReturnStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ReturnStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ReturnStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ReturnStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ReturnStmt> ReturnStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ReturnStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ReturnStmt> ReturnStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ReturnStmt> ReturnStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ReturnStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ReturnStmt> ReturnStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ReturnStmt::contains(const Decl &decl) {
  for (auto &parent : ReturnStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ReturnStmt::contains(const Stmt &stmt) {
  for (auto &parent : ReturnStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ReturnStmt> ReturnStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ReturnStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kReturnStmtDerivedKinds[] = {
    ReturnStmt::static_kind(),
};

gap::generator<ReturnStmt> ReturnStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kReturnStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ReturnStmt> e = ReturnStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ReturnStmt> ReturnStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kReturnStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ReturnStmt> e = ReturnStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ReturnStmt> ReturnStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::RETURN_STMT:
      return reinterpret_cast<const ReturnStmt &>(parent);
    default: return std::nullopt;
  }
}

std::optional<VarDecl> ReturnStmt::nrvo_candidate(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Expr> ReturnStmt::return_value(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal10();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token ReturnStmt::return_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCForCollectionStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCForCollectionStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCForCollectionStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCForCollectionStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCForCollectionStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCForCollectionStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCForCollectionStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCForCollectionStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCForCollectionStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCForCollectionStmt> ObjCForCollectionStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCForCollectionStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCForCollectionStmtDerivedKinds[] = {
    ObjCForCollectionStmt::static_kind(),
};

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCForCollectionStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCForCollectionStmt> e = ObjCForCollectionStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCForCollectionStmt> ObjCForCollectionStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCForCollectionStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCForCollectionStmt> e = ObjCForCollectionStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCForCollectionStmt> ObjCForCollectionStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_FOR_COLLECTION_STMT:
      return reinterpret_cast<const ObjCForCollectionStmt &>(parent);
    default: return std::nullopt;
  }
}

Stmt ObjCForCollectionStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr ObjCForCollectionStmt::collection(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt ObjCForCollectionStmt::element(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Token ObjCForCollectionStmt::for_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal13());
}

Token ObjCForCollectionStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAutoreleasePoolStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAutoreleasePoolStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAutoreleasePoolStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAutoreleasePoolStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAutoreleasePoolStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAutoreleasePoolStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAutoreleasePoolStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAutoreleasePoolStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAutoreleasePoolStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAutoreleasePoolStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAutoreleasePoolStmtDerivedKinds[] = {
    ObjCAutoreleasePoolStmt::static_kind(),
};

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAutoreleasePoolStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAutoreleasePoolStmt> e = ObjCAutoreleasePoolStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAutoreleasePoolStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAutoreleasePoolStmt> e = ObjCAutoreleasePoolStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAutoreleasePoolStmt> ObjCAutoreleasePoolStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AUTORELEASE_POOL_STMT:
      return reinterpret_cast<const ObjCAutoreleasePoolStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCAutoreleasePoolStmt::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Stmt ObjCAutoreleasePoolStmt::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtTryStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtTryStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtTryStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtTryStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAtTryStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtTryStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtTryStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAtTryStmt> ObjCAtTryStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAtTryStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAtTryStmtDerivedKinds[] = {
    ObjCAtTryStmt::static_kind(),
};

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAtTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAtTryStmt> e = ObjCAtTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtTryStmt> ObjCAtTryStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAtTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtTryStmt> e = ObjCAtTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtTryStmt> ObjCAtTryStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AT_TRY_STMT:
      return reinterpret_cast<const ObjCAtTryStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCAtTryStmt::at_try_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

ObjCAtFinallyStmt ObjCAtTryStmt::finally_statement(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return ObjCAtFinallyStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt ObjCAtTryStmt::try_body(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

std::optional<ObjCAtCatchStmt> ObjCAtTryStmt::nth_catch_statement(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : catch_statements()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCAtCatchStmt> ObjCAtTryStmt::catch_statements(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = ObjCAtCatchStmt::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtThrowStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtThrowStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtThrowStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtThrowStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtThrowStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtThrowStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAtThrowStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtThrowStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtThrowStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAtThrowStmt> ObjCAtThrowStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAtThrowStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAtThrowStmtDerivedKinds[] = {
    ObjCAtThrowStmt::static_kind(),
};

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAtThrowStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAtThrowStmt> e = ObjCAtThrowStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtThrowStmt> ObjCAtThrowStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAtThrowStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtThrowStmt> e = ObjCAtThrowStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtThrowStmt> ObjCAtThrowStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AT_THROW_STMT:
      return reinterpret_cast<const ObjCAtThrowStmt &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCAtThrowStmt::throw_expression(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ObjCAtThrowStmt::throw_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtSynchronizedStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtSynchronizedStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtSynchronizedStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtSynchronizedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtSynchronizedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtSynchronizedStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAtSynchronizedStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtSynchronizedStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtSynchronizedStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAtSynchronizedStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAtSynchronizedStmtDerivedKinds[] = {
    ObjCAtSynchronizedStmt::static_kind(),
};

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAtSynchronizedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAtSynchronizedStmt> e = ObjCAtSynchronizedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAtSynchronizedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtSynchronizedStmt> e = ObjCAtSynchronizedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtSynchronizedStmt> ObjCAtSynchronizedStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AT_SYNCHRONIZED_STMT:
      return reinterpret_cast<const ObjCAtSynchronizedStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCAtSynchronizedStmt::at_synchronized_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

CompoundStmt ObjCAtSynchronizedStmt::synch_body(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ObjCAtSynchronizedStmt::synch_expression(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtFinallyStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtFinallyStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtFinallyStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtFinallyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtFinallyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtFinallyStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAtFinallyStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtFinallyStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtFinallyStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAtFinallyStmt> ObjCAtFinallyStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAtFinallyStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAtFinallyStmtDerivedKinds[] = {
    ObjCAtFinallyStmt::static_kind(),
};

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAtFinallyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAtFinallyStmt> e = ObjCAtFinallyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtFinallyStmt> ObjCAtFinallyStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAtFinallyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtFinallyStmt> e = ObjCAtFinallyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtFinallyStmt> ObjCAtFinallyStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AT_FINALLY_STMT:
      return reinterpret_cast<const ObjCAtFinallyStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCAtFinallyStmt::at_finally_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Stmt ObjCAtFinallyStmt::finally_body(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtCatchStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtCatchStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtCatchStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtCatchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAtCatchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtCatchStmt::contains(const Decl &decl) {
  for (auto &parent : ObjCAtCatchStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtCatchStmt::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtCatchStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAtCatchStmt> ObjCAtCatchStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAtCatchStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAtCatchStmtDerivedKinds[] = {
    ObjCAtCatchStmt::static_kind(),
};

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAtCatchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAtCatchStmt> e = ObjCAtCatchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtCatchStmt> ObjCAtCatchStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAtCatchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtCatchStmt> e = ObjCAtCatchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtCatchStmt> ObjCAtCatchStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AT_CATCH_STMT:
      return reinterpret_cast<const ObjCAtCatchStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCAtCatchStmt::at_catch_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Stmt ObjCAtCatchStmt::catch_body(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

VarDecl ObjCAtCatchStmt::catch_parameter_declaration(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCAtCatchStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal13());
}

bool ObjCAtCatchStmt::has_ellipsis(void) const {
  return impl->reader.getVal12();
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPExecutableDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPExecutableDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPExecutableDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPExecutableDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPExecutableDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPExecutableDirective::contains(const Decl &decl) {
  for (auto &parent : OMPExecutableDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPExecutableDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPExecutableDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPExecutableDirective> OMPExecutableDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPExecutableDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPExecutableDirectiveDerivedKinds[] = {
    OMPFlushDirective::static_kind(),
    OMPInteropDirective::static_kind(),
    OMPMaskedDirective::static_kind(),
    OMPMasterDirective::static_kind(),
    OMPMetaDirective::static_kind(),
    OMPOrderedDirective::static_kind(),
    OMPParallelDirective::static_kind(),
    OMPParallelMaskedDirective::static_kind(),
    OMPParallelMasterDirective::static_kind(),
    OMPParallelSectionsDirective::static_kind(),
    OMPScanDirective::static_kind(),
    OMPSectionDirective::static_kind(),
    OMPSectionsDirective::static_kind(),
    OMPSingleDirective::static_kind(),
    OMPTargetDataDirective::static_kind(),
    OMPTargetDirective::static_kind(),
    OMPTargetEnterDataDirective::static_kind(),
    OMPTargetExitDataDirective::static_kind(),
    OMPTargetParallelDirective::static_kind(),
    OMPTargetTeamsDirective::static_kind(),
    OMPTargetUpdateDirective::static_kind(),
    OMPTaskDirective::static_kind(),
    OMPTaskgroupDirective::static_kind(),
    OMPTaskwaitDirective::static_kind(),
    OMPTaskyieldDirective::static_kind(),
    OMPTeamsDirective::static_kind(),
    OMPAtomicDirective::static_kind(),
    OMPBarrierDirective::static_kind(),
    OMPCancelDirective::static_kind(),
    OMPCancellationPointDirective::static_kind(),
    OMPCriticalDirective::static_kind(),
    OMPDepobjDirective::static_kind(),
    OMPDispatchDirective::static_kind(),
    OMPMaskedTaskLoopDirective::static_kind(),
    OMPMaskedTaskLoopSimdDirective::static_kind(),
    OMPMasterTaskLoopDirective::static_kind(),
    OMPMasterTaskLoopSimdDirective::static_kind(),
    OMPParallelForDirective::static_kind(),
    OMPParallelForSimdDirective::static_kind(),
    OMPParallelGenericLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopSimdDirective::static_kind(),
    OMPParallelMasterTaskLoopDirective::static_kind(),
    OMPParallelMasterTaskLoopSimdDirective::static_kind(),
    OMPSimdDirective::static_kind(),
    OMPTargetParallelForDirective::static_kind(),
    OMPTargetParallelForSimdDirective::static_kind(),
    OMPTargetParallelGenericLoopDirective::static_kind(),
    OMPTargetSimdDirective::static_kind(),
    OMPTargetTeamsDistributeDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTargetTeamsDistributeSimdDirective::static_kind(),
    OMPTargetTeamsGenericLoopDirective::static_kind(),
    OMPTaskLoopDirective::static_kind(),
    OMPTaskLoopSimdDirective::static_kind(),
    OMPTeamsDistributeDirective::static_kind(),
    OMPTeamsDistributeParallelForDirective::static_kind(),
    OMPTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTeamsDistributeSimdDirective::static_kind(),
    OMPTeamsGenericLoopDirective::static_kind(),
    OMPDistributeDirective::static_kind(),
    OMPDistributeParallelForDirective::static_kind(),
    OMPDistributeParallelForSimdDirective::static_kind(),
    OMPDistributeSimdDirective::static_kind(),
    OMPForDirective::static_kind(),
    OMPForSimdDirective::static_kind(),
    OMPGenericLoopDirective::static_kind(),
    OMPTileDirective::static_kind(),
    OMPUnrollDirective::static_kind(),
};

gap::generator<OMPExecutableDirective> OMPExecutableDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPExecutableDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPExecutableDirective> e = OMPExecutableDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPExecutableDirective> OMPExecutableDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPExecutableDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPExecutableDirective> e = OMPExecutableDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPExecutableDirective> OMPExecutableDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISPATCH_DIRECTIVE:
    case mx::StmtKind::OMP_DEPOBJ_DIRECTIVE:
    case mx::StmtKind::OMP_CRITICAL_DIRECTIVE:
    case mx::StmtKind::OMP_CANCELLATION_POINT_DIRECTIVE:
    case mx::StmtKind::OMP_CANCEL_DIRECTIVE:
    case mx::StmtKind::OMP_BARRIER_DIRECTIVE:
    case mx::StmtKind::OMP_ATOMIC_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DIRECTIVE:
    case mx::StmtKind::OMP_TASKYIELD_DIRECTIVE:
    case mx::StmtKind::OMP_TASKWAIT_DIRECTIVE:
    case mx::StmtKind::OMP_TASKGROUP_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_UPDATE_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_EXIT_DATA_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_ENTER_DATA_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_DATA_DIRECTIVE:
    case mx::StmtKind::OMP_SINGLE_DIRECTIVE:
    case mx::StmtKind::OMP_SECTIONS_DIRECTIVE:
    case mx::StmtKind::OMP_SECTION_DIRECTIVE:
    case mx::StmtKind::OMP_SCAN_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_SECTIONS_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_DIRECTIVE:
    case mx::StmtKind::OMP_ORDERED_DIRECTIVE:
    case mx::StmtKind::OMP_META_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_DIRECTIVE:
    case mx::StmtKind::OMP_UNROLL_DIRECTIVE:
    case mx::StmtKind::OMP_TILE_DIRECTIVE:
    case mx::StmtKind::OMP_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_INTEROP_DIRECTIVE:
    case mx::StmtKind::OMP_FLUSH_DIRECTIVE:
      return reinterpret_cast<const OMPExecutableDirective &>(parent);
    default: return std::nullopt;
  }
}

Stmt OMPExecutableDirective::associated_statement(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

CapturedStmt OMPExecutableDirective::innermost_captured_statement(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return CapturedStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt OMPExecutableDirective::raw_statement(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt OMPExecutableDirective::structured_block(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

bool OMPExecutableDirective::has_associated_statement(void) const {
  return impl->reader.getVal12();
}

bool OMPExecutableDirective::is_standalone_directive(void) const {
  return impl->reader.getVal16();
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDispatchDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDispatchDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDispatchDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDispatchDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDispatchDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDispatchDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDispatchDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDispatchDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDispatchDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDispatchDirective> OMPDispatchDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDispatchDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDispatchDirectiveDerivedKinds[] = {
    OMPDispatchDirective::static_kind(),
};

gap::generator<OMPDispatchDirective> OMPDispatchDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDispatchDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDispatchDirective> e = OMPDispatchDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDispatchDirective> OMPDispatchDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDispatchDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDispatchDirective> e = OMPDispatchDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDispatchDirective> OMPDispatchDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDispatchDirective> OMPDispatchDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISPATCH_DIRECTIVE:
      return reinterpret_cast<const OMPDispatchDirective &>(parent);
    default: return std::nullopt;
  }
}

Token OMPDispatchDirective::target_call_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDepobjDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDepobjDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDepobjDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDepobjDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDepobjDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDepobjDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDepobjDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDepobjDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDepobjDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDepobjDirective> OMPDepobjDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDepobjDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDepobjDirectiveDerivedKinds[] = {
    OMPDepobjDirective::static_kind(),
};

gap::generator<OMPDepobjDirective> OMPDepobjDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDepobjDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDepobjDirective> e = OMPDepobjDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDepobjDirective> OMPDepobjDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDepobjDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDepobjDirective> e = OMPDepobjDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDepobjDirective> OMPDepobjDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDepobjDirective> OMPDepobjDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DEPOBJ_DIRECTIVE:
      return reinterpret_cast<const OMPDepobjDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCriticalDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCriticalDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCriticalDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCriticalDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCriticalDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPCriticalDirective::contains(const Decl &decl) {
  for (auto &parent : OMPCriticalDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPCriticalDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPCriticalDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPCriticalDirective> OMPCriticalDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPCriticalDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPCriticalDirectiveDerivedKinds[] = {
    OMPCriticalDirective::static_kind(),
};

gap::generator<OMPCriticalDirective> OMPCriticalDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPCriticalDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPCriticalDirective> e = OMPCriticalDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCriticalDirective> OMPCriticalDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPCriticalDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPCriticalDirective> e = OMPCriticalDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCriticalDirective> OMPCriticalDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPCriticalDirective> OMPCriticalDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_CRITICAL_DIRECTIVE:
      return reinterpret_cast<const OMPCriticalDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCancellationPointDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCancellationPointDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCancellationPointDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCancellationPointDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCancellationPointDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPCancellationPointDirective::contains(const Decl &decl) {
  for (auto &parent : OMPCancellationPointDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPCancellationPointDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPCancellationPointDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPCancellationPointDirective> OMPCancellationPointDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPCancellationPointDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPCancellationPointDirectiveDerivedKinds[] = {
    OMPCancellationPointDirective::static_kind(),
};

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPCancellationPointDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPCancellationPointDirective> e = OMPCancellationPointDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCancellationPointDirective> OMPCancellationPointDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPCancellationPointDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPCancellationPointDirective> e = OMPCancellationPointDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCancellationPointDirective> OMPCancellationPointDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPCancellationPointDirective> OMPCancellationPointDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_CANCELLATION_POINT_DIRECTIVE:
      return reinterpret_cast<const OMPCancellationPointDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPCancelDirective> OMPCancelDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCancelDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCancelDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCancelDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPCancelDirective> OMPCancelDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCancelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCancelDirective> OMPCancelDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPCancelDirective> OMPCancelDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCancelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCancelDirective> OMPCancelDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPCancelDirective::contains(const Decl &decl) {
  for (auto &parent : OMPCancelDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPCancelDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPCancelDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPCancelDirective> OMPCancelDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPCancelDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPCancelDirectiveDerivedKinds[] = {
    OMPCancelDirective::static_kind(),
};

gap::generator<OMPCancelDirective> OMPCancelDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPCancelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPCancelDirective> e = OMPCancelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCancelDirective> OMPCancelDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPCancelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPCancelDirective> e = OMPCancelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCancelDirective> OMPCancelDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPCancelDirective> OMPCancelDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_CANCEL_DIRECTIVE:
      return reinterpret_cast<const OMPCancelDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPBarrierDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPBarrierDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPBarrierDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPBarrierDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPBarrierDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPBarrierDirective::contains(const Decl &decl) {
  for (auto &parent : OMPBarrierDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPBarrierDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPBarrierDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPBarrierDirective> OMPBarrierDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPBarrierDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPBarrierDirectiveDerivedKinds[] = {
    OMPBarrierDirective::static_kind(),
};

gap::generator<OMPBarrierDirective> OMPBarrierDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPBarrierDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPBarrierDirective> e = OMPBarrierDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPBarrierDirective> OMPBarrierDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPBarrierDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPBarrierDirective> e = OMPBarrierDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPBarrierDirective> OMPBarrierDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPBarrierDirective> OMPBarrierDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_BARRIER_DIRECTIVE:
      return reinterpret_cast<const OMPBarrierDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPAtomicDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPAtomicDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPAtomicDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPAtomicDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPAtomicDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPAtomicDirective::contains(const Decl &decl) {
  for (auto &parent : OMPAtomicDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPAtomicDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPAtomicDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPAtomicDirective> OMPAtomicDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPAtomicDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPAtomicDirectiveDerivedKinds[] = {
    OMPAtomicDirective::static_kind(),
};

gap::generator<OMPAtomicDirective> OMPAtomicDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPAtomicDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPAtomicDirective> e = OMPAtomicDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPAtomicDirective> OMPAtomicDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPAtomicDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPAtomicDirective> e = OMPAtomicDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPAtomicDirective> OMPAtomicDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPAtomicDirective> OMPAtomicDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_ATOMIC_DIRECTIVE:
      return reinterpret_cast<const OMPAtomicDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPAtomicDirective::condition_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::d(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::expression(void) const {
  RawEntityId eid = impl->reader.getVal18();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::r(void) const {
  RawEntityId eid = impl->reader.getVal19();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::update_expression(void) const {
  RawEntityId eid = impl->reader.getVal20();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::v(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPAtomicDirective::x(void) const {
  RawEntityId eid = impl->reader.getVal22();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPAtomicDirective::is_fail_only(void) const {
  return impl->reader.getVal23();
}

bool OMPAtomicDirective::is_postfix_update(void) const {
  return impl->reader.getVal24();
}

bool OMPAtomicDirective::is_xlhs_in_rhs_part(void) const {
  return impl->reader.getVal25();
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsDirective> OMPTeamsDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsDirectiveDerivedKinds[] = {
    OMPTeamsDirective::static_kind(),
};

gap::generator<OMPTeamsDirective> OMPTeamsDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsDirective> e = OMPTeamsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsDirective> OMPTeamsDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsDirective> e = OMPTeamsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsDirective> OMPTeamsDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDirective> OMPTeamsDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskyieldDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskyieldDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskyieldDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskyieldDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskyieldDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskyieldDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskyieldDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskyieldDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskyieldDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskyieldDirective> OMPTaskyieldDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskyieldDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskyieldDirectiveDerivedKinds[] = {
    OMPTaskyieldDirective::static_kind(),
};

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskyieldDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskyieldDirective> e = OMPTaskyieldDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskyieldDirective> OMPTaskyieldDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskyieldDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskyieldDirective> e = OMPTaskyieldDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskyieldDirective> OMPTaskyieldDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskyieldDirective> OMPTaskyieldDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASKYIELD_DIRECTIVE:
      return reinterpret_cast<const OMPTaskyieldDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskwaitDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskwaitDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskwaitDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskwaitDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskwaitDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskwaitDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskwaitDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskwaitDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskwaitDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskwaitDirective> OMPTaskwaitDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskwaitDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskwaitDirectiveDerivedKinds[] = {
    OMPTaskwaitDirective::static_kind(),
};

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskwaitDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskwaitDirective> e = OMPTaskwaitDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskwaitDirective> OMPTaskwaitDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskwaitDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskwaitDirective> e = OMPTaskwaitDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskwaitDirective> OMPTaskwaitDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskwaitDirective> OMPTaskwaitDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASKWAIT_DIRECTIVE:
      return reinterpret_cast<const OMPTaskwaitDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskgroupDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskgroupDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskgroupDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskgroupDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskgroupDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskgroupDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskgroupDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskgroupDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskgroupDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskgroupDirective> OMPTaskgroupDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskgroupDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskgroupDirectiveDerivedKinds[] = {
    OMPTaskgroupDirective::static_kind(),
};

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskgroupDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskgroupDirective> e = OMPTaskgroupDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskgroupDirective> OMPTaskgroupDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskgroupDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskgroupDirective> e = OMPTaskgroupDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskgroupDirective> OMPTaskgroupDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskgroupDirective> OMPTaskgroupDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASKGROUP_DIRECTIVE:
      return reinterpret_cast<const OMPTaskgroupDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPTaskgroupDirective::reduction_reference(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPTaskDirective> OMPTaskDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskDirective> OMPTaskDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskDirective> OMPTaskDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskDirective> OMPTaskDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskDirective> OMPTaskDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskDirective> OMPTaskDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskDirectiveDerivedKinds[] = {
    OMPTaskDirective::static_kind(),
};

gap::generator<OMPTaskDirective> OMPTaskDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskDirective> e = OMPTaskDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskDirective> OMPTaskDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskDirective> e = OMPTaskDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskDirective> OMPTaskDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskDirective> OMPTaskDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASK_DIRECTIVE:
      return reinterpret_cast<const OMPTaskDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPTaskDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetUpdateDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetUpdateDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetUpdateDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetUpdateDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetUpdateDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetUpdateDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetUpdateDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetUpdateDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetUpdateDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetUpdateDirective> OMPTargetUpdateDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetUpdateDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetUpdateDirectiveDerivedKinds[] = {
    OMPTargetUpdateDirective::static_kind(),
};

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetUpdateDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetUpdateDirective> e = OMPTargetUpdateDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetUpdateDirective> OMPTargetUpdateDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetUpdateDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetUpdateDirective> e = OMPTargetUpdateDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetUpdateDirective> OMPTargetUpdateDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetUpdateDirective> OMPTargetUpdateDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_UPDATE_DIRECTIVE:
      return reinterpret_cast<const OMPTargetUpdateDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsDirective> OMPTargetTeamsDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsDirectiveDerivedKinds[] = {
    OMPTargetTeamsDirective::static_kind(),
};

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsDirective> e = OMPTargetTeamsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsDirective> OMPTargetTeamsDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsDirective> e = OMPTargetTeamsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsDirective> OMPTargetTeamsDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDirective> OMPTargetTeamsDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetParallelDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetParallelDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetParallelDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetParallelDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetParallelDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetParallelDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetParallelDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetParallelDirective> OMPTargetParallelDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetParallelDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetParallelDirectiveDerivedKinds[] = {
    OMPTargetParallelDirective::static_kind(),
};

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetParallelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetParallelDirective> e = OMPTargetParallelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetParallelDirective> OMPTargetParallelDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetParallelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetParallelDirective> e = OMPTargetParallelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetParallelDirective> OMPTargetParallelDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelDirective> OMPTargetParallelDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_PARALLEL_DIRECTIVE:
      return reinterpret_cast<const OMPTargetParallelDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPTargetParallelDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPTargetParallelDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetExitDataDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetExitDataDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetExitDataDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetExitDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetExitDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetExitDataDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetExitDataDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetExitDataDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetExitDataDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetExitDataDirective> OMPTargetExitDataDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetExitDataDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetExitDataDirectiveDerivedKinds[] = {
    OMPTargetExitDataDirective::static_kind(),
};

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetExitDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetExitDataDirective> e = OMPTargetExitDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetExitDataDirective> OMPTargetExitDataDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetExitDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetExitDataDirective> e = OMPTargetExitDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetExitDataDirective> OMPTargetExitDataDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetExitDataDirective> OMPTargetExitDataDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_EXIT_DATA_DIRECTIVE:
      return reinterpret_cast<const OMPTargetExitDataDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetEnterDataDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetEnterDataDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetEnterDataDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetEnterDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetEnterDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetEnterDataDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetEnterDataDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetEnterDataDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetEnterDataDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetEnterDataDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetEnterDataDirectiveDerivedKinds[] = {
    OMPTargetEnterDataDirective::static_kind(),
};

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetEnterDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetEnterDataDirective> e = OMPTargetEnterDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetEnterDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetEnterDataDirective> e = OMPTargetEnterDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetEnterDataDirective> OMPTargetEnterDataDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_ENTER_DATA_DIRECTIVE:
      return reinterpret_cast<const OMPTargetEnterDataDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetDirective> OMPTargetDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetDirective> OMPTargetDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetDirective> OMPTargetDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetDirective> OMPTargetDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetDirective> OMPTargetDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetDirective> OMPTargetDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetDirectiveDerivedKinds[] = {
    OMPTargetDirective::static_kind(),
};

gap::generator<OMPTargetDirective> OMPTargetDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetDirective> e = OMPTargetDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetDirective> OMPTargetDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetDirective> e = OMPTargetDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetDirective> OMPTargetDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetDirective> OMPTargetDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_DIRECTIVE:
      return reinterpret_cast<const OMPTargetDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetDataDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetDataDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetDataDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetDataDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetDataDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetDataDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetDataDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetDataDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetDataDirective> OMPTargetDataDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetDataDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetDataDirectiveDerivedKinds[] = {
    OMPTargetDataDirective::static_kind(),
};

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetDataDirective> e = OMPTargetDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetDataDirective> OMPTargetDataDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetDataDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetDataDirective> e = OMPTargetDataDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetDataDirective> OMPTargetDataDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetDataDirective> OMPTargetDataDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_DATA_DIRECTIVE:
      return reinterpret_cast<const OMPTargetDataDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPSingleDirective> OMPSingleDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPSingleDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPSingleDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPSingleDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPSingleDirective> OMPSingleDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSingleDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSingleDirective> OMPSingleDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPSingleDirective> OMPSingleDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSingleDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSingleDirective> OMPSingleDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPSingleDirective::contains(const Decl &decl) {
  for (auto &parent : OMPSingleDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPSingleDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPSingleDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPSingleDirective> OMPSingleDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPSingleDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPSingleDirectiveDerivedKinds[] = {
    OMPSingleDirective::static_kind(),
};

gap::generator<OMPSingleDirective> OMPSingleDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPSingleDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPSingleDirective> e = OMPSingleDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPSingleDirective> OMPSingleDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPSingleDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPSingleDirective> e = OMPSingleDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPSingleDirective> OMPSingleDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSingleDirective> OMPSingleDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_SINGLE_DIRECTIVE:
      return reinterpret_cast<const OMPSingleDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPSectionsDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPSectionsDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPSectionsDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSectionsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSectionsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPSectionsDirective::contains(const Decl &decl) {
  for (auto &parent : OMPSectionsDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPSectionsDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPSectionsDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPSectionsDirective> OMPSectionsDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPSectionsDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPSectionsDirectiveDerivedKinds[] = {
    OMPSectionsDirective::static_kind(),
};

gap::generator<OMPSectionsDirective> OMPSectionsDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPSectionsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPSectionsDirective> e = OMPSectionsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPSectionsDirective> OMPSectionsDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPSectionsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPSectionsDirective> e = OMPSectionsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPSectionsDirective> OMPSectionsDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSectionsDirective> OMPSectionsDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_SECTIONS_DIRECTIVE:
      return reinterpret_cast<const OMPSectionsDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPSectionsDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPSectionsDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPSectionDirective> OMPSectionDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPSectionDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPSectionDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPSectionDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPSectionDirective> OMPSectionDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSectionDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSectionDirective> OMPSectionDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPSectionDirective> OMPSectionDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSectionDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSectionDirective> OMPSectionDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPSectionDirective::contains(const Decl &decl) {
  for (auto &parent : OMPSectionDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPSectionDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPSectionDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPSectionDirective> OMPSectionDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPSectionDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPSectionDirectiveDerivedKinds[] = {
    OMPSectionDirective::static_kind(),
};

gap::generator<OMPSectionDirective> OMPSectionDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPSectionDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPSectionDirective> e = OMPSectionDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPSectionDirective> OMPSectionDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPSectionDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPSectionDirective> e = OMPSectionDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPSectionDirective> OMPSectionDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSectionDirective> OMPSectionDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_SECTION_DIRECTIVE:
      return reinterpret_cast<const OMPSectionDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPSectionDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPScanDirective> OMPScanDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPScanDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPScanDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPScanDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPScanDirective> OMPScanDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPScanDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPScanDirective> OMPScanDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPScanDirective> OMPScanDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPScanDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPScanDirective> OMPScanDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPScanDirective::contains(const Decl &decl) {
  for (auto &parent : OMPScanDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPScanDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPScanDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPScanDirective> OMPScanDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPScanDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPScanDirectiveDerivedKinds[] = {
    OMPScanDirective::static_kind(),
};

gap::generator<OMPScanDirective> OMPScanDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPScanDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPScanDirective> e = OMPScanDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPScanDirective> OMPScanDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPScanDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPScanDirective> e = OMPScanDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPScanDirective> OMPScanDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPScanDirective> OMPScanDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_SCAN_DIRECTIVE:
      return reinterpret_cast<const OMPScanDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelSectionsDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelSectionsDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelSectionsDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelSectionsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelSectionsDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelSectionsDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelSectionsDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelSectionsDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelSectionsDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelSectionsDirective> OMPParallelSectionsDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelSectionsDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelSectionsDirectiveDerivedKinds[] = {
    OMPParallelSectionsDirective::static_kind(),
};

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelSectionsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelSectionsDirective> e = OMPParallelSectionsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelSectionsDirective> OMPParallelSectionsDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelSectionsDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelSectionsDirective> e = OMPParallelSectionsDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelSectionsDirective> OMPParallelSectionsDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelSectionsDirective> OMPParallelSectionsDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_SECTIONS_DIRECTIVE:
      return reinterpret_cast<const OMPParallelSectionsDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPParallelSectionsDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPParallelSectionsDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMasterDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMasterDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMasterDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMasterDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMasterDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMasterDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMasterDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMasterDirective> OMPParallelMasterDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMasterDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMasterDirectiveDerivedKinds[] = {
    OMPParallelMasterDirective::static_kind(),
};

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMasterDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMasterDirective> e = OMPParallelMasterDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMasterDirective> OMPParallelMasterDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMasterDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMasterDirective> e = OMPParallelMasterDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMasterDirective> OMPParallelMasterDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterDirective> OMPParallelMasterDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASTER_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMasterDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPParallelMasterDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMaskedDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMaskedDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMaskedDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMaskedDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMaskedDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMaskedDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMaskedDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMaskedDirective> OMPParallelMaskedDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMaskedDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMaskedDirectiveDerivedKinds[] = {
    OMPParallelMaskedDirective::static_kind(),
};

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMaskedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMaskedDirective> e = OMPParallelMaskedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMaskedDirective> OMPParallelMaskedDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMaskedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMaskedDirective> e = OMPParallelMaskedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMaskedDirective> OMPParallelMaskedDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedDirective> OMPParallelMaskedDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASKED_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMaskedDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPParallelMaskedDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OMPParallelDirective> OMPParallelDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelDirective> OMPParallelDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelDirective> OMPParallelDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelDirective> OMPParallelDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelDirective> OMPParallelDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelDirective> OMPParallelDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelDirectiveDerivedKinds[] = {
    OMPParallelDirective::static_kind(),
};

gap::generator<OMPParallelDirective> OMPParallelDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelDirective> e = OMPParallelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelDirective> OMPParallelDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelDirective> e = OMPParallelDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelDirective> OMPParallelDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelDirective> OMPParallelDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_DIRECTIVE:
      return reinterpret_cast<const OMPParallelDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPParallelDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPParallelDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPOrderedDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPOrderedDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPOrderedDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPOrderedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPOrderedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPOrderedDirective::contains(const Decl &decl) {
  for (auto &parent : OMPOrderedDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPOrderedDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPOrderedDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPOrderedDirective> OMPOrderedDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPOrderedDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPOrderedDirectiveDerivedKinds[] = {
    OMPOrderedDirective::static_kind(),
};

gap::generator<OMPOrderedDirective> OMPOrderedDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPOrderedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPOrderedDirective> e = OMPOrderedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPOrderedDirective> OMPOrderedDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPOrderedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPOrderedDirective> e = OMPOrderedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPOrderedDirective> OMPOrderedDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPOrderedDirective> OMPOrderedDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_ORDERED_DIRECTIVE:
      return reinterpret_cast<const OMPOrderedDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPMetaDirective> OMPMetaDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMetaDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMetaDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMetaDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMetaDirective> OMPMetaDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMetaDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMetaDirective> OMPMetaDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMetaDirective> OMPMetaDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMetaDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMetaDirective> OMPMetaDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMetaDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMetaDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMetaDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMetaDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMetaDirective> OMPMetaDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMetaDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMetaDirectiveDerivedKinds[] = {
    OMPMetaDirective::static_kind(),
};

gap::generator<OMPMetaDirective> OMPMetaDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMetaDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMetaDirective> e = OMPMetaDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMetaDirective> OMPMetaDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMetaDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMetaDirective> e = OMPMetaDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMetaDirective> OMPMetaDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMetaDirective> OMPMetaDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_META_DIRECTIVE:
      return reinterpret_cast<const OMPMetaDirective &>(parent);
    default: return std::nullopt;
  }
}

Stmt OMPMetaDirective::if_statement(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<OMPMasterDirective> OMPMasterDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMasterDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMasterDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMasterDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMasterDirective> OMPMasterDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterDirective> OMPMasterDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMasterDirective> OMPMasterDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterDirective> OMPMasterDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMasterDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMasterDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMasterDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMasterDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMasterDirective> OMPMasterDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMasterDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMasterDirectiveDerivedKinds[] = {
    OMPMasterDirective::static_kind(),
};

gap::generator<OMPMasterDirective> OMPMasterDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMasterDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMasterDirective> e = OMPMasterDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMasterDirective> OMPMasterDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMasterDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMasterDirective> e = OMPMasterDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMasterDirective> OMPMasterDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterDirective> OMPMasterDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASTER_DIRECTIVE:
      return reinterpret_cast<const OMPMasterDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMaskedDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMaskedDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMaskedDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMaskedDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMaskedDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMaskedDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMaskedDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMaskedDirective> OMPMaskedDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMaskedDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMaskedDirectiveDerivedKinds[] = {
    OMPMaskedDirective::static_kind(),
};

gap::generator<OMPMaskedDirective> OMPMaskedDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMaskedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMaskedDirective> e = OMPMaskedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMaskedDirective> OMPMaskedDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMaskedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMaskedDirective> e = OMPMaskedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMaskedDirective> OMPMaskedDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedDirective> OMPMaskedDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASKED_DIRECTIVE:
      return reinterpret_cast<const OMPMaskedDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPLoopBasedDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPLoopBasedDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPLoopBasedDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopBasedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopBasedDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPLoopBasedDirective::contains(const Decl &decl) {
  for (auto &parent : OMPLoopBasedDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPLoopBasedDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPLoopBasedDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPLoopBasedDirective> OMPLoopBasedDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPLoopBasedDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPLoopBasedDirectiveDerivedKinds[] = {
    OMPMaskedTaskLoopDirective::static_kind(),
    OMPMaskedTaskLoopSimdDirective::static_kind(),
    OMPMasterTaskLoopDirective::static_kind(),
    OMPMasterTaskLoopSimdDirective::static_kind(),
    OMPParallelForDirective::static_kind(),
    OMPParallelForSimdDirective::static_kind(),
    OMPParallelGenericLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopSimdDirective::static_kind(),
    OMPParallelMasterTaskLoopDirective::static_kind(),
    OMPParallelMasterTaskLoopSimdDirective::static_kind(),
    OMPSimdDirective::static_kind(),
    OMPTargetParallelForDirective::static_kind(),
    OMPTargetParallelForSimdDirective::static_kind(),
    OMPTargetParallelGenericLoopDirective::static_kind(),
    OMPTargetSimdDirective::static_kind(),
    OMPTargetTeamsDistributeDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTargetTeamsDistributeSimdDirective::static_kind(),
    OMPTargetTeamsGenericLoopDirective::static_kind(),
    OMPTaskLoopDirective::static_kind(),
    OMPTaskLoopSimdDirective::static_kind(),
    OMPTeamsDistributeDirective::static_kind(),
    OMPTeamsDistributeParallelForDirective::static_kind(),
    OMPTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTeamsDistributeSimdDirective::static_kind(),
    OMPTeamsGenericLoopDirective::static_kind(),
    OMPDistributeDirective::static_kind(),
    OMPDistributeParallelForDirective::static_kind(),
    OMPDistributeParallelForSimdDirective::static_kind(),
    OMPDistributeSimdDirective::static_kind(),
    OMPForDirective::static_kind(),
    OMPForSimdDirective::static_kind(),
    OMPGenericLoopDirective::static_kind(),
    OMPTileDirective::static_kind(),
    OMPUnrollDirective::static_kind(),
};

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPLoopBasedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPLoopBasedDirective> e = OMPLoopBasedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPLoopBasedDirective> OMPLoopBasedDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPLoopBasedDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPLoopBasedDirective> e = OMPLoopBasedDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPLoopBasedDirective> OMPLoopBasedDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPLoopBasedDirective> OMPLoopBasedDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_UNROLL_DIRECTIVE:
    case mx::StmtKind::OMP_TILE_DIRECTIVE:
    case mx::StmtKind::OMP_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPLoopBasedDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPLoopTransformationDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPLoopTransformationDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPLoopTransformationDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopTransformationDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopTransformationDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPLoopTransformationDirective::contains(const Decl &decl) {
  for (auto &parent : OMPLoopTransformationDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPLoopTransformationDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPLoopTransformationDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPLoopTransformationDirective> OMPLoopTransformationDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPLoopTransformationDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPLoopTransformationDirectiveDerivedKinds[] = {
    OMPTileDirective::static_kind(),
    OMPUnrollDirective::static_kind(),
};

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPLoopTransformationDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPLoopTransformationDirective> e = OMPLoopTransformationDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPLoopTransformationDirective> OMPLoopTransformationDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPLoopTransformationDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPLoopTransformationDirective> e = OMPLoopTransformationDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPLoopTransformationDirective> OMPLoopTransformationDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPLoopTransformationDirective> OMPLoopTransformationDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPLoopTransformationDirective> OMPLoopTransformationDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_UNROLL_DIRECTIVE:
    case mx::StmtKind::OMP_TILE_DIRECTIVE:
      return reinterpret_cast<const OMPLoopTransformationDirective &>(parent);
    default: return std::nullopt;
  }
}

Stmt OMPLoopTransformationDirective::pre_initializers(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt OMPLoopTransformationDirective::transformed_statement(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPUnrollDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPUnrollDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPUnrollDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPUnrollDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPUnrollDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPUnrollDirective::contains(const Decl &decl) {
  for (auto &parent : OMPUnrollDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPUnrollDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPUnrollDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPUnrollDirective> OMPUnrollDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPUnrollDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPUnrollDirectiveDerivedKinds[] = {
    OMPUnrollDirective::static_kind(),
};

gap::generator<OMPUnrollDirective> OMPUnrollDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPUnrollDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPUnrollDirective> e = OMPUnrollDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPUnrollDirective> OMPUnrollDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPUnrollDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPUnrollDirective> e = OMPUnrollDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPUnrollDirective> OMPUnrollDirective::from(const OMPLoopTransformationDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPUnrollDirective> OMPUnrollDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPUnrollDirective> OMPUnrollDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPUnrollDirective> OMPUnrollDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_UNROLL_DIRECTIVE:
      return reinterpret_cast<const OMPUnrollDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTileDirective> OMPTileDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTileDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTileDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTileDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTileDirective> OMPTileDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTileDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTileDirective> OMPTileDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTileDirective> OMPTileDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTileDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTileDirective> OMPTileDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTileDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTileDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTileDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTileDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTileDirective> OMPTileDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTileDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTileDirectiveDerivedKinds[] = {
    OMPTileDirective::static_kind(),
};

gap::generator<OMPTileDirective> OMPTileDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTileDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTileDirective> e = OMPTileDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTileDirective> OMPTileDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTileDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTileDirective> e = OMPTileDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTileDirective> OMPTileDirective::from(const OMPLoopTransformationDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTileDirective> OMPTileDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTileDirective> OMPTileDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTileDirective> OMPTileDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TILE_DIRECTIVE:
      return reinterpret_cast<const OMPTileDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPLoopDirective> OMPLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPLoopDirective> OMPLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopDirective> OMPLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPLoopDirective> OMPLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPLoopDirective> OMPLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPLoopDirective> OMPLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPLoopDirectiveDerivedKinds[] = {
    OMPMaskedTaskLoopDirective::static_kind(),
    OMPMaskedTaskLoopSimdDirective::static_kind(),
    OMPMasterTaskLoopDirective::static_kind(),
    OMPMasterTaskLoopSimdDirective::static_kind(),
    OMPParallelForDirective::static_kind(),
    OMPParallelForSimdDirective::static_kind(),
    OMPParallelGenericLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopDirective::static_kind(),
    OMPParallelMaskedTaskLoopSimdDirective::static_kind(),
    OMPParallelMasterTaskLoopDirective::static_kind(),
    OMPParallelMasterTaskLoopSimdDirective::static_kind(),
    OMPSimdDirective::static_kind(),
    OMPTargetParallelForDirective::static_kind(),
    OMPTargetParallelForSimdDirective::static_kind(),
    OMPTargetParallelGenericLoopDirective::static_kind(),
    OMPTargetSimdDirective::static_kind(),
    OMPTargetTeamsDistributeDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForDirective::static_kind(),
    OMPTargetTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTargetTeamsDistributeSimdDirective::static_kind(),
    OMPTargetTeamsGenericLoopDirective::static_kind(),
    OMPTaskLoopDirective::static_kind(),
    OMPTaskLoopSimdDirective::static_kind(),
    OMPTeamsDistributeDirective::static_kind(),
    OMPTeamsDistributeParallelForDirective::static_kind(),
    OMPTeamsDistributeParallelForSimdDirective::static_kind(),
    OMPTeamsDistributeSimdDirective::static_kind(),
    OMPTeamsGenericLoopDirective::static_kind(),
    OMPDistributeDirective::static_kind(),
    OMPDistributeParallelForDirective::static_kind(),
    OMPDistributeParallelForSimdDirective::static_kind(),
    OMPDistributeSimdDirective::static_kind(),
    OMPForDirective::static_kind(),
    OMPForSimdDirective::static_kind(),
    OMPGenericLoopDirective::static_kind(),
};

gap::generator<OMPLoopDirective> OMPLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPLoopDirective> e = OMPLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPLoopDirective> OMPLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPLoopDirective> e = OMPLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPLoopDirective> OMPLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPLoopDirective> OMPLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPLoopDirective> OMPLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_PARALLEL_FOR_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> OMPLoopDirective::nth_counter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : counters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::counters(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_dependent_counter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : dependent_counters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::dependent_counters(void) const {
  auto list = impl->reader.getVal26();
  for (auto v : list) {
    EntityId id(v);
    if (auto d26 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d26)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_dependent_initializer(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : dependent_initializers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::dependent_initializers(void) const {
  auto list = impl->reader.getVal27();
  for (auto v : list) {
    EntityId id(v);
    if (auto d27 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d27)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_final(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : finals()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::finals(void) const {
  auto list = impl->reader.getVal28();
  for (auto v : list) {
    EntityId id(v);
    if (auto d28 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d28)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_finals_condition(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : finals_conditions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::finals_conditions(void) const {
  auto list = impl->reader.getVal29();
  for (auto v : list) {
    EntityId id(v);
    if (auto d29 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d29)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Stmt OMPLoopDirective::body(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr OMPLoopDirective::calculate_last_iteration(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_condition(void) const {
  RawEntityId eid = impl->reader.getVal18();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_distance_condition(void) const {
  RawEntityId eid = impl->reader.getVal19();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_ensure_upper_bound(void) const {
  RawEntityId eid = impl->reader.getVal20();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_initializer(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_lower_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal22();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_next_lower_bound(void) const {
  RawEntityId eid = impl->reader.getVal30();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_next_upper_bound(void) const {
  RawEntityId eid = impl->reader.getVal31();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_parallel_for_in_distance_condition(void) const {
  RawEntityId eid = impl->reader.getVal32();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::combined_upper_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal33();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::condition(void) const {
  RawEntityId eid = impl->reader.getVal34();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::distance_increment(void) const {
  RawEntityId eid = impl->reader.getVal35();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::ensure_upper_bound(void) const {
  RawEntityId eid = impl->reader.getVal36();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::increment(void) const {
  RawEntityId eid = impl->reader.getVal37();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::initializer(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::is_last_iteration_variable(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::iteration_variable(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::last_iteration(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::lower_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::next_lower_bound(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::next_upper_bound(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::num_iterations(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::pre_condition(void) const {
  RawEntityId eid = impl->reader.getVal46();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt OMPLoopDirective::pre_initializers(void) const {
  RawEntityId eid = impl->reader.getVal47();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr OMPLoopDirective::prev_ensure_upper_bound(void) const {
  RawEntityId eid = impl->reader.getVal48();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::prev_lower_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal49();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::prev_upper_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal50();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::stride_variable(void) const {
  RawEntityId eid = impl->reader.getVal51();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPLoopDirective::upper_bound_variable(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> OMPLoopDirective::nth_initializer(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : initializers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::initializers(void) const {
  auto list = impl->reader.getVal53();
  for (auto v : list) {
    EntityId id(v);
    if (auto d53 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d53)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_private_counter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : private_counters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::private_counters(void) const {
  auto list = impl->reader.getVal54();
  for (auto v : list) {
    EntityId id(v);
    if (auto d54 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d54)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> OMPLoopDirective::nth_update(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : updates()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPLoopDirective::updates(void) const {
  auto list = impl->reader.getVal55();
  for (auto v : list) {
    EntityId id(v);
    if (auto d55 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d55)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPGenericLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPGenericLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPGenericLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPGenericLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPGenericLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPGenericLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPGenericLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPGenericLoopDirective> OMPGenericLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPGenericLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPGenericLoopDirectiveDerivedKinds[] = {
    OMPGenericLoopDirective::static_kind(),
};

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPGenericLoopDirective> e = OMPGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPGenericLoopDirective> OMPGenericLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPGenericLoopDirective> e = OMPGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPGenericLoopDirective> OMPGenericLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPGenericLoopDirective> OMPGenericLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPGenericLoopDirective> OMPGenericLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPGenericLoopDirective> OMPGenericLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_GENERIC_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPGenericLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPForSimdDirective> OMPForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPForSimdDirectiveDerivedKinds[] = {
    OMPForSimdDirective::static_kind(),
};

gap::generator<OMPForSimdDirective> OMPForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPForSimdDirective> e = OMPForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPForSimdDirective> OMPForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPForSimdDirective> e = OMPForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPForSimdDirective> OMPForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForSimdDirective> OMPForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForSimdDirective> OMPForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForSimdDirective> OMPForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPForDirective> OMPForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPForDirective> OMPForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPForDirective> OMPForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPForDirective> OMPForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPForDirective> OMPForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPForDirective> OMPForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPForDirectiveDerivedKinds[] = {
    OMPForDirective::static_kind(),
};

gap::generator<OMPForDirective> OMPForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPForDirective> e = OMPForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPForDirective> OMPForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPForDirective> e = OMPForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPForDirective> OMPForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForDirective> OMPForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForDirective> OMPForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPForDirective> OMPForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDistributeSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDistributeSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDistributeSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDistributeSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDistributeSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDistributeSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDistributeSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDistributeSimdDirective> OMPDistributeSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDistributeSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDistributeSimdDirectiveDerivedKinds[] = {
    OMPDistributeSimdDirective::static_kind(),
};

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDistributeSimdDirective> e = OMPDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDistributeSimdDirective> OMPDistributeSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDistributeSimdDirective> e = OMPDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDistributeSimdDirective> OMPDistributeSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeSimdDirective> OMPDistributeSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeSimdDirective> OMPDistributeSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeSimdDirective> OMPDistributeSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPDistributeSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDistributeParallelForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDistributeParallelForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDistributeParallelForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDistributeParallelForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDistributeParallelForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDistributeParallelForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDistributeParallelForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDistributeParallelForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDistributeParallelForSimdDirectiveDerivedKinds[] = {
    OMPDistributeParallelForSimdDirective::static_kind(),
};

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDistributeParallelForSimdDirective> e = OMPDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDistributeParallelForSimdDirective> e = OMPDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForSimdDirective> OMPDistributeParallelForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPDistributeParallelForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDistributeParallelForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDistributeParallelForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDistributeParallelForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDistributeParallelForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDistributeParallelForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDistributeParallelForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDistributeParallelForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDistributeParallelForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDistributeParallelForDirectiveDerivedKinds[] = {
    OMPDistributeParallelForDirective::static_kind(),
};

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDistributeParallelForDirective> e = OMPDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDistributeParallelForDirective> e = OMPDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeParallelForDirective> OMPDistributeParallelForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPDistributeParallelForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPDistributeParallelForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPDistributeParallelForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDistributeDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDistributeDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDistributeDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDistributeDirective::contains(const Decl &decl) {
  for (auto &parent : OMPDistributeDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDistributeDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPDistributeDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPDistributeDirective> OMPDistributeDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPDistributeDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPDistributeDirectiveDerivedKinds[] = {
    OMPDistributeDirective::static_kind(),
};

gap::generator<OMPDistributeDirective> OMPDistributeDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPDistributeDirective> e = OMPDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDistributeDirective> OMPDistributeDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPDistributeDirective> e = OMPDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDistributeDirective> OMPDistributeDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeDirective> OMPDistributeDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeDirective> OMPDistributeDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPDistributeDirective> OMPDistributeDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_DISTRIBUTE_DIRECTIVE:
      return reinterpret_cast<const OMPDistributeDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsGenericLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsGenericLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsGenericLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsGenericLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsGenericLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsGenericLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsGenericLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsGenericLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsGenericLoopDirectiveDerivedKinds[] = {
    OMPTeamsGenericLoopDirective::static_kind(),
};

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsGenericLoopDirective> e = OMPTeamsGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsGenericLoopDirective> e = OMPTeamsGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsGenericLoopDirective> OMPTeamsGenericLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_GENERIC_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsGenericLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsDistributeSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsDistributeSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsDistributeSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsDistributeSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsDistributeSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsDistributeSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsDistributeSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsDistributeSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsDistributeSimdDirectiveDerivedKinds[] = {
    OMPTeamsDistributeSimdDirective::static_kind(),
};

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsDistributeSimdDirective> e = OMPTeamsDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsDistributeSimdDirective> e = OMPTeamsDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeSimdDirective> OMPTeamsDistributeSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsDistributeSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsDistributeParallelForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsDistributeParallelForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsDistributeParallelForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsDistributeParallelForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsDistributeParallelForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsDistributeParallelForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsDistributeParallelForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsDistributeParallelForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsDistributeParallelForSimdDirectiveDerivedKinds[] = {
    OMPTeamsDistributeParallelForSimdDirective::static_kind(),
};

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsDistributeParallelForSimdDirective> e = OMPTeamsDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsDistributeParallelForSimdDirective> e = OMPTeamsDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForSimdDirective> OMPTeamsDistributeParallelForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsDistributeParallelForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsDistributeParallelForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsDistributeParallelForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsDistributeParallelForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsDistributeParallelForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsDistributeParallelForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsDistributeParallelForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsDistributeParallelForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsDistributeParallelForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsDistributeParallelForDirectiveDerivedKinds[] = {
    OMPTeamsDistributeParallelForDirective::static_kind(),
};

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsDistributeParallelForDirective> e = OMPTeamsDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsDistributeParallelForDirective> e = OMPTeamsDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeParallelForDirective> OMPTeamsDistributeParallelForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsDistributeParallelForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPTeamsDistributeParallelForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPTeamsDistributeParallelForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTeamsDistributeDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTeamsDistributeDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTeamsDistributeDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTeamsDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTeamsDistributeDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTeamsDistributeDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTeamsDistributeDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTeamsDistributeDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTeamsDistributeDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTeamsDistributeDirectiveDerivedKinds[] = {
    OMPTeamsDistributeDirective::static_kind(),
};

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTeamsDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTeamsDistributeDirective> e = OMPTeamsDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTeamsDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTeamsDistributeDirective> e = OMPTeamsDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTeamsDistributeDirective> OMPTeamsDistributeDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE:
      return reinterpret_cast<const OMPTeamsDistributeDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskLoopSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskLoopSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskLoopSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskLoopSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskLoopSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskLoopSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskLoopSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskLoopSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskLoopSimdDirectiveDerivedKinds[] = {
    OMPTaskLoopSimdDirective::static_kind(),
};

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskLoopSimdDirective> e = OMPTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskLoopSimdDirective> e = OMPTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopSimdDirective> OMPTaskLoopSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTaskLoopSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTaskLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTaskLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTaskLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTaskLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTaskLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTaskLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTaskLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTaskLoopDirective> OMPTaskLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTaskLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTaskLoopDirectiveDerivedKinds[] = {
    OMPTaskLoopDirective::static_kind(),
};

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTaskLoopDirective> e = OMPTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTaskLoopDirective> OMPTaskLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTaskLoopDirective> e = OMPTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTaskLoopDirective> OMPTaskLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopDirective> OMPTaskLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopDirective> OMPTaskLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTaskLoopDirective> OMPTaskLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPTaskLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPTaskLoopDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsGenericLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsGenericLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsGenericLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsGenericLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsGenericLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsGenericLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsGenericLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsGenericLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsGenericLoopDirectiveDerivedKinds[] = {
    OMPTargetTeamsGenericLoopDirective::static_kind(),
};

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsGenericLoopDirective> e = OMPTargetTeamsGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsGenericLoopDirective> e = OMPTargetTeamsGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsGenericLoopDirective> OMPTargetTeamsGenericLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsGenericLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsDistributeSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsDistributeSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsDistributeSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsDistributeSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsDistributeSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsDistributeSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsDistributeSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsDistributeSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsDistributeSimdDirectiveDerivedKinds[] = {
    OMPTargetTeamsDistributeSimdDirective::static_kind(),
};

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsDistributeSimdDirective> e = OMPTargetTeamsDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsDistributeSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsDistributeSimdDirective> e = OMPTargetTeamsDistributeSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeSimdDirective> OMPTargetTeamsDistributeSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsDistributeSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsDistributeParallelForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsDistributeParallelForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsDistributeParallelForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsDistributeParallelForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsDistributeParallelForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsDistributeParallelForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsDistributeParallelForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsDistributeParallelForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsDistributeParallelForSimdDirectiveDerivedKinds[] = {
    OMPTargetTeamsDistributeParallelForSimdDirective::static_kind(),
};

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> e = OMPTargetTeamsDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsDistributeParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> e = OMPTargetTeamsDistributeParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> OMPTargetTeamsDistributeParallelForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsDistributeParallelForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsDistributeParallelForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsDistributeParallelForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsDistributeParallelForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsDistributeParallelForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsDistributeParallelForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsDistributeParallelForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsDistributeParallelForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsDistributeParallelForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsDistributeParallelForDirectiveDerivedKinds[] = {
    OMPTargetTeamsDistributeParallelForDirective::static_kind(),
};

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsDistributeParallelForDirective> e = OMPTargetTeamsDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsDistributeParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsDistributeParallelForDirective> e = OMPTargetTeamsDistributeParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeParallelForDirective> OMPTargetTeamsDistributeParallelForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsDistributeParallelForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPTargetTeamsDistributeParallelForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPTargetTeamsDistributeParallelForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetTeamsDistributeDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetTeamsDistributeDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetTeamsDistributeDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetTeamsDistributeDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetTeamsDistributeDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetTeamsDistributeDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetTeamsDistributeDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetTeamsDistributeDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetTeamsDistributeDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetTeamsDistributeDirectiveDerivedKinds[] = {
    OMPTargetTeamsDistributeDirective::static_kind(),
};

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetTeamsDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetTeamsDistributeDirective> e = OMPTargetTeamsDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetTeamsDistributeDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetTeamsDistributeDirective> e = OMPTargetTeamsDistributeDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetTeamsDistributeDirective> OMPTargetTeamsDistributeDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE:
      return reinterpret_cast<const OMPTargetTeamsDistributeDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetSimdDirective> OMPTargetSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetSimdDirectiveDerivedKinds[] = {
    OMPTargetSimdDirective::static_kind(),
};

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetSimdDirective> e = OMPTargetSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetSimdDirective> OMPTargetSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetSimdDirective> e = OMPTargetSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetSimdDirective> OMPTargetSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetSimdDirective> OMPTargetSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetSimdDirective> OMPTargetSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetSimdDirective> OMPTargetSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTargetSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetParallelGenericLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetParallelGenericLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetParallelGenericLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetParallelGenericLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetParallelGenericLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetParallelGenericLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetParallelGenericLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetParallelGenericLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetParallelGenericLoopDirectiveDerivedKinds[] = {
    OMPTargetParallelGenericLoopDirective::static_kind(),
};

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetParallelGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetParallelGenericLoopDirective> e = OMPTargetParallelGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetParallelGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetParallelGenericLoopDirective> e = OMPTargetParallelGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelGenericLoopDirective> OMPTargetParallelGenericLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPTargetParallelGenericLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetParallelForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetParallelForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetParallelForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetParallelForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetParallelForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetParallelForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetParallelForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetParallelForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetParallelForSimdDirectiveDerivedKinds[] = {
    OMPTargetParallelForSimdDirective::static_kind(),
};

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetParallelForSimdDirective> e = OMPTargetParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetParallelForSimdDirective> e = OMPTargetParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForSimdDirective> OMPTargetParallelForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPTargetParallelForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPTargetParallelForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPTargetParallelForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPTargetParallelForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPTargetParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPTargetParallelForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPTargetParallelForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPTargetParallelForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPTargetParallelForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPTargetParallelForDirective> OMPTargetParallelForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPTargetParallelForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPTargetParallelForDirectiveDerivedKinds[] = {
    OMPTargetParallelForDirective::static_kind(),
};

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPTargetParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPTargetParallelForDirective> e = OMPTargetParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPTargetParallelForDirective> OMPTargetParallelForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPTargetParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPTargetParallelForDirective> e = OMPTargetParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPTargetParallelForDirective> OMPTargetParallelForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForDirective> OMPTargetParallelForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForDirective> OMPTargetParallelForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPTargetParallelForDirective> OMPTargetParallelForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPTargetParallelForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPTargetParallelForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPTargetParallelForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPSimdDirective> OMPSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPSimdDirective> OMPSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSimdDirective> OMPSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPSimdDirective> OMPSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPSimdDirective> OMPSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPSimdDirective> OMPSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPSimdDirectiveDerivedKinds[] = {
    OMPSimdDirective::static_kind(),
};

gap::generator<OMPSimdDirective> OMPSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPSimdDirective> e = OMPSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPSimdDirective> OMPSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPSimdDirective> e = OMPSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPSimdDirective> OMPSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSimdDirective> OMPSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSimdDirective> OMPSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPSimdDirective> OMPSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMasterTaskLoopSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMasterTaskLoopSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMasterTaskLoopSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMasterTaskLoopSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMasterTaskLoopSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMasterTaskLoopSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMasterTaskLoopSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMasterTaskLoopSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMasterTaskLoopSimdDirectiveDerivedKinds[] = {
    OMPParallelMasterTaskLoopSimdDirective::static_kind(),
};

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMasterTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMasterTaskLoopSimdDirective> e = OMPParallelMasterTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMasterTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMasterTaskLoopSimdDirective> e = OMPParallelMasterTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopSimdDirective> OMPParallelMasterTaskLoopSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMasterTaskLoopSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMasterTaskLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMasterTaskLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMasterTaskLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMasterTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMasterTaskLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMasterTaskLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMasterTaskLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMasterTaskLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMasterTaskLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMasterTaskLoopDirectiveDerivedKinds[] = {
    OMPParallelMasterTaskLoopDirective::static_kind(),
};

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMasterTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMasterTaskLoopDirective> e = OMPParallelMasterTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMasterTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMasterTaskLoopDirective> e = OMPParallelMasterTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMasterTaskLoopDirective> OMPParallelMasterTaskLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMasterTaskLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPParallelMasterTaskLoopDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMaskedTaskLoopSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMaskedTaskLoopSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMaskedTaskLoopSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMaskedTaskLoopSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMaskedTaskLoopSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMaskedTaskLoopSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMaskedTaskLoopSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMaskedTaskLoopSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMaskedTaskLoopSimdDirectiveDerivedKinds[] = {
    OMPParallelMaskedTaskLoopSimdDirective::static_kind(),
};

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMaskedTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMaskedTaskLoopSimdDirective> e = OMPParallelMaskedTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMaskedTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMaskedTaskLoopSimdDirective> e = OMPParallelMaskedTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopSimdDirective> OMPParallelMaskedTaskLoopSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMaskedTaskLoopSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelMaskedTaskLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelMaskedTaskLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelMaskedTaskLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelMaskedTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelMaskedTaskLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelMaskedTaskLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelMaskedTaskLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelMaskedTaskLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelMaskedTaskLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelMaskedTaskLoopDirectiveDerivedKinds[] = {
    OMPParallelMaskedTaskLoopDirective::static_kind(),
};

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelMaskedTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelMaskedTaskLoopDirective> e = OMPParallelMaskedTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelMaskedTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelMaskedTaskLoopDirective> e = OMPParallelMaskedTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelMaskedTaskLoopDirective> OMPParallelMaskedTaskLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPParallelMaskedTaskLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPParallelMaskedTaskLoopDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelGenericLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelGenericLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelGenericLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelGenericLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelGenericLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelGenericLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelGenericLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelGenericLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelGenericLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelGenericLoopDirectiveDerivedKinds[] = {
    OMPParallelGenericLoopDirective::static_kind(),
};

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelGenericLoopDirective> e = OMPParallelGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelGenericLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelGenericLoopDirective> e = OMPParallelGenericLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelGenericLoopDirective> OMPParallelGenericLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPParallelGenericLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelForSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelForSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelForSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelForSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelForSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelForSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelForSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelForSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelForSimdDirective> OMPParallelForSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelForSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelForSimdDirectiveDerivedKinds[] = {
    OMPParallelForSimdDirective::static_kind(),
};

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelForSimdDirective> e = OMPParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelForSimdDirective> OMPParallelForSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelForSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelForSimdDirective> e = OMPParallelForSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelForSimdDirective> OMPParallelForSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForSimdDirective> OMPParallelForSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForSimdDirective> OMPParallelForSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForSimdDirective> OMPParallelForSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPParallelForSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPParallelForDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPParallelForDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPParallelForDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPParallelForDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPParallelForDirective::contains(const Decl &decl) {
  for (auto &parent : OMPParallelForDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPParallelForDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPParallelForDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPParallelForDirective> OMPParallelForDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPParallelForDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPParallelForDirectiveDerivedKinds[] = {
    OMPParallelForDirective::static_kind(),
};

gap::generator<OMPParallelForDirective> OMPParallelForDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPParallelForDirective> e = OMPParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPParallelForDirective> OMPParallelForDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPParallelForDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPParallelForDirective> e = OMPParallelForDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPParallelForDirective> OMPParallelForDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForDirective> OMPParallelForDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForDirective> OMPParallelForDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPParallelForDirective> OMPParallelForDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_PARALLEL_FOR_DIRECTIVE:
      return reinterpret_cast<const OMPParallelForDirective &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPParallelForDirective::task_reduction_reference_expression(void) const {
  RawEntityId eid = impl->reader.getVal56();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OMPParallelForDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMasterTaskLoopSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMasterTaskLoopSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMasterTaskLoopSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMasterTaskLoopSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMasterTaskLoopSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMasterTaskLoopSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMasterTaskLoopSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMasterTaskLoopSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMasterTaskLoopSimdDirectiveDerivedKinds[] = {
    OMPMasterTaskLoopSimdDirective::static_kind(),
};

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMasterTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMasterTaskLoopSimdDirective> e = OMPMasterTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMasterTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMasterTaskLoopSimdDirective> e = OMPMasterTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopSimdDirective> OMPMasterTaskLoopSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPMasterTaskLoopSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMasterTaskLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMasterTaskLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMasterTaskLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMasterTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMasterTaskLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMasterTaskLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMasterTaskLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMasterTaskLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMasterTaskLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMasterTaskLoopDirectiveDerivedKinds[] = {
    OMPMasterTaskLoopDirective::static_kind(),
};

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMasterTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMasterTaskLoopDirective> e = OMPMasterTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMasterTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMasterTaskLoopDirective> e = OMPMasterTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMasterTaskLoopDirective> OMPMasterTaskLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPMasterTaskLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPMasterTaskLoopDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMaskedTaskLoopSimdDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMaskedTaskLoopSimdDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMaskedTaskLoopSimdDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedTaskLoopSimdDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMaskedTaskLoopSimdDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMaskedTaskLoopSimdDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMaskedTaskLoopSimdDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMaskedTaskLoopSimdDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMaskedTaskLoopSimdDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMaskedTaskLoopSimdDirectiveDerivedKinds[] = {
    OMPMaskedTaskLoopSimdDirective::static_kind(),
};

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMaskedTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMaskedTaskLoopSimdDirective> e = OMPMaskedTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMaskedTaskLoopSimdDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMaskedTaskLoopSimdDirective> e = OMPMaskedTaskLoopSimdDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopSimdDirective> OMPMaskedTaskLoopSimdDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE:
      return reinterpret_cast<const OMPMaskedTaskLoopSimdDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPMaskedTaskLoopDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPMaskedTaskLoopDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPMaskedTaskLoopDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPMaskedTaskLoopDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPMaskedTaskLoopDirective::contains(const Decl &decl) {
  for (auto &parent : OMPMaskedTaskLoopDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPMaskedTaskLoopDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPMaskedTaskLoopDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPMaskedTaskLoopDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPMaskedTaskLoopDirectiveDerivedKinds[] = {
    OMPMaskedTaskLoopDirective::static_kind(),
};

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPMaskedTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPMaskedTaskLoopDirective> e = OMPMaskedTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPMaskedTaskLoopDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPMaskedTaskLoopDirective> e = OMPMaskedTaskLoopDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::from(const OMPLoopDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::from(const OMPLoopBasedDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPMaskedTaskLoopDirective> OMPMaskedTaskLoopDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_MASKED_TASK_LOOP_DIRECTIVE:
      return reinterpret_cast<const OMPMaskedTaskLoopDirective &>(parent);
    default: return std::nullopt;
  }
}

bool OMPMaskedTaskLoopDirective::has_cancel(void) const {
  return impl->reader.getVal23();
}

gap::generator<OMPInteropDirective> OMPInteropDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPInteropDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPInteropDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPInteropDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPInteropDirective> OMPInteropDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPInteropDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPInteropDirective> OMPInteropDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPInteropDirective> OMPInteropDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPInteropDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPInteropDirective> OMPInteropDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPInteropDirective::contains(const Decl &decl) {
  for (auto &parent : OMPInteropDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPInteropDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPInteropDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPInteropDirective> OMPInteropDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPInteropDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPInteropDirectiveDerivedKinds[] = {
    OMPInteropDirective::static_kind(),
};

gap::generator<OMPInteropDirective> OMPInteropDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPInteropDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPInteropDirective> e = OMPInteropDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPInteropDirective> OMPInteropDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPInteropDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPInteropDirective> e = OMPInteropDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPInteropDirective> OMPInteropDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPInteropDirective> OMPInteropDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_INTEROP_DIRECTIVE:
      return reinterpret_cast<const OMPInteropDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPFlushDirective> OMPFlushDirective::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPFlushDirective::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPFlushDirective::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPFlushDirective::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPFlushDirective> OMPFlushDirective::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPFlushDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPFlushDirective> OMPFlushDirective::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPFlushDirective> OMPFlushDirective::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPFlushDirective::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPFlushDirective> OMPFlushDirective::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPFlushDirective::contains(const Decl &decl) {
  for (auto &parent : OMPFlushDirective::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPFlushDirective::contains(const Stmt &stmt) {
  for (auto &parent : OMPFlushDirective::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPFlushDirective> OMPFlushDirective::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPFlushDirective::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPFlushDirectiveDerivedKinds[] = {
    OMPFlushDirective::static_kind(),
};

gap::generator<OMPFlushDirective> OMPFlushDirective::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPFlushDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPFlushDirective> e = OMPFlushDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPFlushDirective> OMPFlushDirective::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPFlushDirectiveDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPFlushDirective> e = OMPFlushDirective::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPFlushDirective> OMPFlushDirective::from(const OMPExecutableDirective &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPFlushDirective> OMPFlushDirective::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_FLUSH_DIRECTIVE:
      return reinterpret_cast<const OMPFlushDirective &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCanonicalLoop::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCanonicalLoop::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCanonicalLoop::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCanonicalLoop::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPCanonicalLoop::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPCanonicalLoop::contains(const Decl &decl) {
  for (auto &parent : OMPCanonicalLoop::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPCanonicalLoop::contains(const Stmt &stmt) {
  for (auto &parent : OMPCanonicalLoop::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPCanonicalLoop> OMPCanonicalLoop::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPCanonicalLoop::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPCanonicalLoopDerivedKinds[] = {
    OMPCanonicalLoop::static_kind(),
};

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPCanonicalLoopDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPCanonicalLoop> e = OMPCanonicalLoop::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCanonicalLoop> OMPCanonicalLoop::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPCanonicalLoopDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPCanonicalLoop> e = OMPCanonicalLoop::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCanonicalLoop> OMPCanonicalLoop::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_CANONICAL_LOOP:
      return reinterpret_cast<const OMPCanonicalLoop &>(parent);
    default: return std::nullopt;
  }
}

CapturedStmt OMPCanonicalLoop::distance_func(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return CapturedStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt OMPCanonicalLoop::loop_statement(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

CapturedStmt OMPCanonicalLoop::loop_variable_func(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return CapturedStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

DeclRefExpr OMPCanonicalLoop::loop_variable_reference(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return DeclRefExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<NullStmt> NullStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NullStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NullStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NullStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NullStmt> NullStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = NullStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NullStmt> NullStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NullStmt> NullStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = NullStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NullStmt> NullStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NullStmt::contains(const Decl &decl) {
  for (auto &parent : NullStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NullStmt::contains(const Stmt &stmt) {
  for (auto &parent : NullStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<NullStmt> NullStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return NullStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kNullStmtDerivedKinds[] = {
    NullStmt::static_kind(),
};

gap::generator<NullStmt> NullStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kNullStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<NullStmt> e = NullStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NullStmt> NullStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kNullStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<NullStmt> e = NullStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NullStmt> NullStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::NULL_STMT:
      return reinterpret_cast<const NullStmt &>(parent);
    default: return std::nullopt;
  }
}

Token NullStmt::semi_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

bool NullStmt::has_leading_empty_macro(void) const {
  return impl->reader.getVal12();
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSDependentExistsStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSDependentExistsStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSDependentExistsStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSDependentExistsStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSDependentExistsStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSDependentExistsStmt::contains(const Decl &decl) {
  for (auto &parent : MSDependentExistsStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSDependentExistsStmt::contains(const Stmt &stmt) {
  for (auto &parent : MSDependentExistsStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MSDependentExistsStmt> MSDependentExistsStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MSDependentExistsStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMSDependentExistsStmtDerivedKinds[] = {
    MSDependentExistsStmt::static_kind(),
};

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMSDependentExistsStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MSDependentExistsStmt> e = MSDependentExistsStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSDependentExistsStmt> MSDependentExistsStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMSDependentExistsStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MSDependentExistsStmt> e = MSDependentExistsStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSDependentExistsStmt> MSDependentExistsStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MS_DEPENDENT_EXISTS_STMT:
      return reinterpret_cast<const MSDependentExistsStmt &>(parent);
    default: return std::nullopt;
  }
}

Token MSDependentExistsStmt::keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

CompoundStmt MSDependentExistsStmt::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool MSDependentExistsStmt::is_if_exists(void) const {
  return impl->reader.getVal12();
}

bool MSDependentExistsStmt::is_if_not_exists(void) const {
  return impl->reader.getVal16();
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IndirectGotoStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IndirectGotoStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IndirectGotoStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IndirectGotoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IndirectGotoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool IndirectGotoStmt::contains(const Decl &decl) {
  for (auto &parent : IndirectGotoStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool IndirectGotoStmt::contains(const Stmt &stmt) {
  for (auto &parent : IndirectGotoStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<IndirectGotoStmt> IndirectGotoStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return IndirectGotoStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kIndirectGotoStmtDerivedKinds[] = {
    IndirectGotoStmt::static_kind(),
};

gap::generator<IndirectGotoStmt> IndirectGotoStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kIndirectGotoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<IndirectGotoStmt> e = IndirectGotoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IndirectGotoStmt> IndirectGotoStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kIndirectGotoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<IndirectGotoStmt> e = IndirectGotoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IndirectGotoStmt> IndirectGotoStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::INDIRECT_GOTO_STMT:
      return reinterpret_cast<const IndirectGotoStmt &>(parent);
    default: return std::nullopt;
  }
}

std::optional<LabelDecl> IndirectGotoStmt::constant_target(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return LabelDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token IndirectGotoStmt::goto_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

Token IndirectGotoStmt::star_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

Expr IndirectGotoStmt::target(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<IfStmt> IfStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IfStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IfStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IfStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IfStmt> IfStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IfStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IfStmt> IfStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<IfStmt> IfStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IfStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IfStmt> IfStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool IfStmt::contains(const Decl &decl) {
  for (auto &parent : IfStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool IfStmt::contains(const Stmt &stmt) {
  for (auto &parent : IfStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<IfStmt> IfStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return IfStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kIfStmtDerivedKinds[] = {
    IfStmt::static_kind(),
};

gap::generator<IfStmt> IfStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kIfStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<IfStmt> e = IfStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IfStmt> IfStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kIfStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<IfStmt> e = IfStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IfStmt> IfStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::IF_STMT:
      return reinterpret_cast<const IfStmt &>(parent);
    default: return std::nullopt;
  }
}

Expr IfStmt::condition(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<VarDecl> IfStmt::condition_variable(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal10();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<DeclStmt> IfStmt::condition_variable_declaration_statement(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return DeclStmt::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Stmt> IfStmt::else_(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal13();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token IfStmt::else_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

Token IfStmt::if_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal17());
}

std::optional<Stmt> IfStmt::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal18();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token IfStmt::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal19());
}

Token IfStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal20());
}

IfStatementKind IfStmt::statement_kind(void) const {
  return static_cast<IfStatementKind>(impl->reader.getVal57());
}

Stmt IfStmt::then(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

bool IfStmt::has_else_storage(void) const {
  return impl->reader.getVal12();
}

bool IfStmt::has_initializer_storage(void) const {
  return impl->reader.getVal16();
}

bool IfStmt::has_variable_storage(void) const {
  return impl->reader.getVal23();
}

bool IfStmt::is_consteval(void) const {
  return impl->reader.getVal24();
}

bool IfStmt::is_constexpr(void) const {
  return impl->reader.getVal25();
}

bool IfStmt::is_negated_consteval(void) const {
  return impl->reader.getVal58();
}

bool IfStmt::is_non_negated_consteval(void) const {
  return impl->reader.getVal59();
}

bool IfStmt::is_obj_c_availability_check(void) const {
  return impl->reader.getVal60();
}

gap::generator<GotoStmt> GotoStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GotoStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GotoStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GotoStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<GotoStmt> GotoStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GotoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GotoStmt> GotoStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<GotoStmt> GotoStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GotoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GotoStmt> GotoStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool GotoStmt::contains(const Decl &decl) {
  for (auto &parent : GotoStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool GotoStmt::contains(const Stmt &stmt) {
  for (auto &parent : GotoStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<GotoStmt> GotoStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return GotoStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kGotoStmtDerivedKinds[] = {
    GotoStmt::static_kind(),
};

gap::generator<GotoStmt> GotoStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kGotoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<GotoStmt> e = GotoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GotoStmt> GotoStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kGotoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<GotoStmt> e = GotoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GotoStmt> GotoStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::GOTO_STMT:
      return reinterpret_cast<const GotoStmt &>(parent);
    default: return std::nullopt;
  }
}

Token GotoStmt::goto_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

LabelDecl GotoStmt::label(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return LabelDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token GotoStmt::label_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

gap::generator<ForStmt> ForStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ForStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ForStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ForStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ForStmt> ForStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ForStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ForStmt> ForStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ForStmt> ForStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ForStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ForStmt> ForStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ForStmt::contains(const Decl &decl) {
  for (auto &parent : ForStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ForStmt::contains(const Stmt &stmt) {
  for (auto &parent : ForStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ForStmt> ForStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ForStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kForStmtDerivedKinds[] = {
    ForStmt::static_kind(),
};

gap::generator<ForStmt> ForStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kForStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ForStmt> e = ForStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ForStmt> ForStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kForStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ForStmt> e = ForStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ForStmt> ForStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::FOR_STMT:
      return reinterpret_cast<const ForStmt &>(parent);
    default: return std::nullopt;
  }
}

Stmt ForStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

std::optional<Expr> ForStmt::condition(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal10();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<VarDecl> ForStmt::condition_variable(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<DeclStmt> ForStmt::condition_variable_declaration_statement(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal13();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return DeclStmt::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token ForStmt::for_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

std::optional<Expr> ForStmt::increment(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal17();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Stmt> ForStmt::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal18();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token ForStmt::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal19());
}

Token ForStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal20());
}

gap::generator<DoStmt> DoStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DoStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DoStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DoStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DoStmt> DoStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DoStmt> DoStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DoStmt> DoStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DoStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DoStmt> DoStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DoStmt::contains(const Decl &decl) {
  for (auto &parent : DoStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DoStmt::contains(const Stmt &stmt) {
  for (auto &parent : DoStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DoStmt> DoStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DoStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDoStmtDerivedKinds[] = {
    DoStmt::static_kind(),
};

gap::generator<DoStmt> DoStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DoStmt> e = DoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DoStmt> DoStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDoStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DoStmt> e = DoStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DoStmt> DoStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DO_STMT:
      return reinterpret_cast<const DoStmt &>(parent);
    default: return std::nullopt;
  }
}

Stmt DoStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr DoStmt::condition(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token DoStmt::do_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

Token DoStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal13());
}

Token DoStmt::while_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

gap::generator<DeclStmt> DeclStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeclStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeclStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeclStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DeclStmt> DeclStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DeclStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclStmt> DeclStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DeclStmt> DeclStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DeclStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclStmt> DeclStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DeclStmt::contains(const Decl &decl) {
  for (auto &parent : DeclStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DeclStmt::contains(const Stmt &stmt) {
  for (auto &parent : DeclStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DeclStmt> DeclStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DeclStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDeclStmtDerivedKinds[] = {
    DeclStmt::static_kind(),
};

gap::generator<DeclStmt> DeclStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDeclStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DeclStmt> e = DeclStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeclStmt> DeclStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDeclStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DeclStmt> e = DeclStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeclStmt> DeclStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DECL_STMT:
      return reinterpret_cast<const DeclStmt &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Decl> DeclStmt::nth_declaration(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : declarations()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Decl> DeclStmt::declarations(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->DeclFor(impl->ep, v)) {
      co_yield Decl(std::move(d15));
    }
  }
  co_return;
}

std::optional<Decl> DeclStmt::single_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool DeclStmt::is_single_declaration(void) const {
  return impl->reader.getVal12();
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CoroutineBodyStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CoroutineBodyStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CoroutineBodyStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoroutineBodyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoroutineBodyStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CoroutineBodyStmt::contains(const Decl &decl) {
  for (auto &parent : CoroutineBodyStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CoroutineBodyStmt::contains(const Stmt &stmt) {
  for (auto &parent : CoroutineBodyStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CoroutineBodyStmt> CoroutineBodyStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CoroutineBodyStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCoroutineBodyStmtDerivedKinds[] = {
    CoroutineBodyStmt::static_kind(),
};

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCoroutineBodyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CoroutineBodyStmt> e = CoroutineBodyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CoroutineBodyStmt> CoroutineBodyStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCoroutineBodyStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CoroutineBodyStmt> e = CoroutineBodyStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CoroutineBodyStmt> CoroutineBodyStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COROUTINE_BODY_STMT:
      return reinterpret_cast<const CoroutineBodyStmt &>(parent);
    default: return std::nullopt;
  }
}

Expr CoroutineBodyStmt::allocate(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt CoroutineBodyStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr CoroutineBodyStmt::deallocate(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt CoroutineBodyStmt::exception_handler(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt CoroutineBodyStmt::fallthrough_handler(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt CoroutineBodyStmt::final_suspend_statement(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt CoroutineBodyStmt::initializer_suspend_statement(void) const {
  RawEntityId eid = impl->reader.getVal18();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

std::optional<Stmt> CoroutineBodyStmt::nth_parameter_move(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameter_moves()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Stmt> CoroutineBodyStmt::parameter_moves(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      co_yield Stmt(std::move(d15));
    }
  }
  co_return;
}

VarDecl CoroutineBodyStmt::promise_declaration(void) const {
  RawEntityId eid = impl->reader.getVal19();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Stmt CoroutineBodyStmt::promise_declaration_statement(void) const {
  RawEntityId eid = impl->reader.getVal20();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt CoroutineBodyStmt::return_statement(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Stmt CoroutineBodyStmt::return_statement_on_alloc_failure(void) const {
  RawEntityId eid = impl->reader.getVal22();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr CoroutineBodyStmt::return_value(void) const {
  RawEntityId eid = impl->reader.getVal30();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoroutineBodyStmt::return_value_initializer(void) const {
  RawEntityId eid = impl->reader.getVal31();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool CoroutineBodyStmt::has_dependent_promise_type(void) const {
  return impl->reader.getVal12();
}

gap::generator<CoreturnStmt> CoreturnStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CoreturnStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CoreturnStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CoreturnStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CoreturnStmt> CoreturnStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoreturnStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoreturnStmt> CoreturnStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CoreturnStmt> CoreturnStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoreturnStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoreturnStmt> CoreturnStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CoreturnStmt::contains(const Decl &decl) {
  for (auto &parent : CoreturnStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CoreturnStmt::contains(const Stmt &stmt) {
  for (auto &parent : CoreturnStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CoreturnStmt> CoreturnStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CoreturnStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCoreturnStmtDerivedKinds[] = {
    CoreturnStmt::static_kind(),
};

gap::generator<CoreturnStmt> CoreturnStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCoreturnStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CoreturnStmt> e = CoreturnStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CoreturnStmt> CoreturnStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCoreturnStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CoreturnStmt> e = CoreturnStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CoreturnStmt> CoreturnStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CORETURN_STMT:
      return reinterpret_cast<const CoreturnStmt &>(parent);
    default: return std::nullopt;
  }
}

Token CoreturnStmt::keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Expr CoreturnStmt::operand(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoreturnStmt::promise_call(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool CoreturnStmt::is_implicit(void) const {
  return impl->reader.getVal12();
}

gap::generator<ContinueStmt> ContinueStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ContinueStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ContinueStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ContinueStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ContinueStmt> ContinueStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ContinueStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ContinueStmt> ContinueStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ContinueStmt> ContinueStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ContinueStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ContinueStmt> ContinueStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ContinueStmt::contains(const Decl &decl) {
  for (auto &parent : ContinueStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ContinueStmt::contains(const Stmt &stmt) {
  for (auto &parent : ContinueStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ContinueStmt> ContinueStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ContinueStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kContinueStmtDerivedKinds[] = {
    ContinueStmt::static_kind(),
};

gap::generator<ContinueStmt> ContinueStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kContinueStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ContinueStmt> e = ContinueStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ContinueStmt> ContinueStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kContinueStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ContinueStmt> e = ContinueStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ContinueStmt> ContinueStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONTINUE_STMT:
      return reinterpret_cast<const ContinueStmt &>(parent);
    default: return std::nullopt;
  }
}

Token ContinueStmt::continue_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

gap::generator<CompoundStmt> CompoundStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CompoundStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CompoundStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CompoundStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CompoundStmt> CompoundStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundStmt> CompoundStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CompoundStmt> CompoundStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundStmt> CompoundStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CompoundStmt::contains(const Decl &decl) {
  for (auto &parent : CompoundStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CompoundStmt::contains(const Stmt &stmt) {
  for (auto &parent : CompoundStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CompoundStmt> CompoundStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CompoundStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCompoundStmtDerivedKinds[] = {
    CompoundStmt::static_kind(),
};

gap::generator<CompoundStmt> CompoundStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCompoundStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CompoundStmt> e = CompoundStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CompoundStmt> CompoundStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCompoundStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CompoundStmt> e = CompoundStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CompoundStmt> CompoundStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COMPOUND_STMT:
      return reinterpret_cast<const CompoundStmt &>(parent);
    default: return std::nullopt;
  }
}

Token CompoundStmt::left_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Token CompoundStmt::right_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

std::optional<Stmt> CompoundStmt::statement_expression_result(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool CompoundStmt::has_stored_fp_features(void) const {
  return impl->reader.getVal12();
}

gap::generator<CapturedStmt> CapturedStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CapturedStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CapturedStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CapturedStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CapturedStmt> CapturedStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CapturedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CapturedStmt> CapturedStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CapturedStmt> CapturedStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CapturedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CapturedStmt> CapturedStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CapturedStmt::contains(const Decl &decl) {
  for (auto &parent : CapturedStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CapturedStmt::contains(const Stmt &stmt) {
  for (auto &parent : CapturedStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CapturedStmt> CapturedStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CapturedStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCapturedStmtDerivedKinds[] = {
    CapturedStmt::static_kind(),
};

gap::generator<CapturedStmt> CapturedStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCapturedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CapturedStmt> e = CapturedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CapturedStmt> CapturedStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCapturedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CapturedStmt> e = CapturedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CapturedStmt> CapturedStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CAPTURED_STMT:
      return reinterpret_cast<const CapturedStmt &>(parent);
    default: return std::nullopt;
  }
}

CapturedDecl CapturedStmt::captured_declaration(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return CapturedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

RecordDecl CapturedStmt::captured_record_declaration(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return RecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

CapturedRegionKind CapturedStmt::captured_region_kind(void) const {
  return static_cast<CapturedRegionKind>(impl->reader.getVal57());
}

Stmt CapturedStmt::captured_statement(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<CXXTryStmt> CXXTryStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXTryStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXTryStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXTryStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXTryStmt> CXXTryStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTryStmt> CXXTryStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXTryStmt> CXXTryStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTryStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTryStmt> CXXTryStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXTryStmt::contains(const Decl &decl) {
  for (auto &parent : CXXTryStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXTryStmt::contains(const Stmt &stmt) {
  for (auto &parent : CXXTryStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXTryStmt> CXXTryStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXTryStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXTryStmtDerivedKinds[] = {
    CXXTryStmt::static_kind(),
};

gap::generator<CXXTryStmt> CXXTryStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXTryStmt> e = CXXTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXTryStmt> CXXTryStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXTryStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXTryStmt> e = CXXTryStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXTryStmt> CXXTryStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_TRY_STMT:
      return reinterpret_cast<const CXXTryStmt &>(parent);
    default: return std::nullopt;
  }
}

CompoundStmt CXXTryStmt::try_block(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXTryStmt::try_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

std::optional<CXXCatchStmt> CXXTryStmt::nth_handler(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : handlers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<CXXCatchStmt> CXXTryStmt::handlers(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = CXXCatchStmt::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXForRangeStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXForRangeStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXForRangeStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXForRangeStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXForRangeStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXForRangeStmt::contains(const Decl &decl) {
  for (auto &parent : CXXForRangeStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXForRangeStmt::contains(const Stmt &stmt) {
  for (auto &parent : CXXForRangeStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXForRangeStmt> CXXForRangeStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXForRangeStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXForRangeStmtDerivedKinds[] = {
    CXXForRangeStmt::static_kind(),
};

gap::generator<CXXForRangeStmt> CXXForRangeStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXForRangeStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXForRangeStmt> e = CXXForRangeStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXForRangeStmt> CXXForRangeStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXForRangeStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXForRangeStmt> e = CXXForRangeStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXForRangeStmt> CXXForRangeStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_FOR_RANGE_STMT:
      return reinterpret_cast<const CXXForRangeStmt &>(parent);
    default: return std::nullopt;
  }
}

DeclStmt CXXForRangeStmt::begin_statement(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return DeclStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Stmt CXXForRangeStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Token CXXForRangeStmt::coawait_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

Token CXXForRangeStmt::colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal13());
}

Expr CXXForRangeStmt::condition(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

DeclStmt CXXForRangeStmt::end_statement(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return DeclStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXForRangeStmt::for_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal18());
}

Expr CXXForRangeStmt::increment(void) const {
  RawEntityId eid = impl->reader.getVal19();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Stmt> CXXForRangeStmt::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal20();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

DeclStmt CXXForRangeStmt::loop_variable_statement(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return DeclStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

VarDecl CXXForRangeStmt::loop_variable(void) const {
  RawEntityId eid = impl->reader.getVal22();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token CXXForRangeStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal30());
}

Expr CXXForRangeStmt::range_initializer(void) const {
  RawEntityId eid = impl->reader.getVal31();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

DeclStmt CXXForRangeStmt::range_statement(void) const {
  RawEntityId eid = impl->reader.getVal32();
  return DeclStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<CXXCatchStmt> CXXCatchStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXCatchStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXCatchStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXCatchStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXCatchStmt> CXXCatchStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXCatchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXCatchStmt> CXXCatchStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXCatchStmt> CXXCatchStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXCatchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXCatchStmt> CXXCatchStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXCatchStmt::contains(const Decl &decl) {
  for (auto &parent : CXXCatchStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXCatchStmt::contains(const Stmt &stmt) {
  for (auto &parent : CXXCatchStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXCatchStmt> CXXCatchStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXCatchStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXCatchStmtDerivedKinds[] = {
    CXXCatchStmt::static_kind(),
};

gap::generator<CXXCatchStmt> CXXCatchStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXCatchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXCatchStmt> e = CXXCatchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXCatchStmt> CXXCatchStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXCatchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXCatchStmt> e = CXXCatchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXCatchStmt> CXXCatchStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_CATCH_STMT:
      return reinterpret_cast<const CXXCatchStmt &>(parent);
    default: return std::nullopt;
  }
}

Token CXXCatchStmt::catch_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Type CXXCatchStmt::caught_type(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<VarDecl> CXXCatchStmt::exception_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Stmt CXXCatchStmt::handler_block(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<BreakStmt> BreakStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BreakStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BreakStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BreakStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BreakStmt> BreakStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BreakStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BreakStmt> BreakStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BreakStmt> BreakStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BreakStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BreakStmt> BreakStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BreakStmt::contains(const Decl &decl) {
  for (auto &parent : BreakStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BreakStmt::contains(const Stmt &stmt) {
  for (auto &parent : BreakStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<BreakStmt> BreakStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return BreakStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kBreakStmtDerivedKinds[] = {
    BreakStmt::static_kind(),
};

gap::generator<BreakStmt> BreakStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kBreakStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<BreakStmt> e = BreakStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BreakStmt> BreakStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kBreakStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<BreakStmt> e = BreakStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BreakStmt> BreakStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::BREAK_STMT:
      return reinterpret_cast<const BreakStmt &>(parent);
    default: return std::nullopt;
  }
}

Token BreakStmt::break_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

gap::generator<AsmStmt> AsmStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AsmStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AsmStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AsmStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AsmStmt> AsmStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AsmStmt> AsmStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AsmStmt> AsmStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AsmStmt> AsmStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AsmStmt::contains(const Decl &decl) {
  for (auto &parent : AsmStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AsmStmt::contains(const Stmt &stmt) {
  for (auto &parent : AsmStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AsmStmt> AsmStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AsmStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAsmStmtDerivedKinds[] = {
    GCCAsmStmt::static_kind(),
    MSAsmStmt::static_kind(),
};

gap::generator<AsmStmt> AsmStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AsmStmt> e = AsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AsmStmt> AsmStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AsmStmt> e = AsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AsmStmt> AsmStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MS_ASM_STMT:
    case mx::StmtKind::GCC_ASM_STMT:
      return reinterpret_cast<const AsmStmt &>(parent);
    default: return std::nullopt;
  }
}

std::string_view AsmStmt::generate_assembly_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

Token AsmStmt::assembly_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

std::optional<Expr> AsmStmt::nth_input(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : inputs()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> AsmStmt::inputs(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

bool AsmStmt::is_simple(void) const {
  return impl->reader.getVal12();
}

bool AsmStmt::is_volatile(void) const {
  return impl->reader.getVal16();
}

std::optional<Expr> AsmStmt::nth_output(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : outputs()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> AsmStmt::outputs(void) const {
  auto list = impl->reader.getVal26();
  for (auto v : list) {
    EntityId id(v);
    if (auto d26 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d26)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> AsmStmt::nth_output_constraint(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : output_constraints()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> AsmStmt::output_constraints(void) const {
  auto list = impl->reader.getVal62();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

std::optional<Expr> AsmStmt::nth_output_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : output_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> AsmStmt::output_expressions(void) const {
  auto list = impl->reader.getVal27();
  for (auto v : list) {
    EntityId id(v);
    if (auto d27 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d27)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> AsmStmt::nth_input_constraint(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : input_constraints()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> AsmStmt::input_constraints(void) const {
  auto list = impl->reader.getVal63();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

std::optional<Expr> AsmStmt::nth_input_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : input_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> AsmStmt::input_expressions(void) const {
  auto list = impl->reader.getVal28();
  for (auto v : list) {
    EntityId id(v);
    if (auto d28 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d28)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> AsmStmt::nth_clobber(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : clobbers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> AsmStmt::clobbers(void) const {
  auto list = impl->reader.getVal64();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

gap::generator<MSAsmStmt> MSAsmStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSAsmStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSAsmStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSAsmStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSAsmStmt> MSAsmStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSAsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSAsmStmt> MSAsmStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSAsmStmt> MSAsmStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSAsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSAsmStmt> MSAsmStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSAsmStmt::contains(const Decl &decl) {
  for (auto &parent : MSAsmStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSAsmStmt::contains(const Stmt &stmt) {
  for (auto &parent : MSAsmStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MSAsmStmt> MSAsmStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MSAsmStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMSAsmStmtDerivedKinds[] = {
    MSAsmStmt::static_kind(),
};

gap::generator<MSAsmStmt> MSAsmStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMSAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MSAsmStmt> e = MSAsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSAsmStmt> MSAsmStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMSAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MSAsmStmt> e = MSAsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSAsmStmt> MSAsmStmt::from(const AsmStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MSAsmStmt> MSAsmStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MS_ASM_STMT:
      return reinterpret_cast<const MSAsmStmt &>(parent);
    default: return std::nullopt;
  }
}

std::optional<std::string_view> MSAsmStmt::nth_all_constraint(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : all_constraints()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> MSAsmStmt::all_constraints(void) const {
  auto list = impl->reader.getVal65();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

std::optional<Expr> MSAsmStmt::nth_all_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : all_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> MSAsmStmt::all_expressions(void) const {
  auto list = impl->reader.getVal29();
  for (auto v : list) {
    EntityId id(v);
    if (auto d29 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d29)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::string_view MSAsmStmt::assembly_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal66();
  return std::string_view(data.cStr(), data.size());
}

Token MSAsmStmt::l_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

bool MSAsmStmt::has_braces(void) const {
  return impl->reader.getVal23();
}

gap::generator<GCCAsmStmt> GCCAsmStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GCCAsmStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GCCAsmStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GCCAsmStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<GCCAsmStmt> GCCAsmStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GCCAsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GCCAsmStmt> GCCAsmStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<GCCAsmStmt> GCCAsmStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GCCAsmStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GCCAsmStmt> GCCAsmStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool GCCAsmStmt::contains(const Decl &decl) {
  for (auto &parent : GCCAsmStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool GCCAsmStmt::contains(const Stmt &stmt) {
  for (auto &parent : GCCAsmStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<GCCAsmStmt> GCCAsmStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return GCCAsmStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kGCCAsmStmtDerivedKinds[] = {
    GCCAsmStmt::static_kind(),
};

gap::generator<GCCAsmStmt> GCCAsmStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kGCCAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<GCCAsmStmt> e = GCCAsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GCCAsmStmt> GCCAsmStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kGCCAsmStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<GCCAsmStmt> e = GCCAsmStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GCCAsmStmt> GCCAsmStmt::from(const AsmStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<GCCAsmStmt> GCCAsmStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::GCC_ASM_STMT:
      return reinterpret_cast<const GCCAsmStmt &>(parent);
    default: return std::nullopt;
  }
}

StringLiteral GCCAsmStmt::assembly_string(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return StringLiteral::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token GCCAsmStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

bool GCCAsmStmt::is_assembly_goto(void) const {
  return impl->reader.getVal23();
}

std::optional<AddrLabelExpr> GCCAsmStmt::nth_label(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : labels()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<AddrLabelExpr> GCCAsmStmt::labels(void) const {
  auto list = impl->reader.getVal29();
  for (auto v : list) {
    EntityId id(v);
    if (auto d29 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = AddrLabelExpr::from(Stmt(std::move(d29)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<StringLiteral> GCCAsmStmt::nth_output_constraint_literal(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : output_constraint_literals()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<StringLiteral> GCCAsmStmt::output_constraint_literals(void) const {
  auto list = impl->reader.getVal53();
  for (auto v : list) {
    EntityId id(v);
    if (auto d53 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = StringLiteral::from(Stmt(std::move(d53)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> GCCAsmStmt::nth_output_name(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : output_names()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> GCCAsmStmt::output_names(void) const {
  auto list = impl->reader.getVal65();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

std::optional<StringLiteral> GCCAsmStmt::nth_input_constraint_literal(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : input_constraint_literals()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<StringLiteral> GCCAsmStmt::input_constraint_literals(void) const {
  auto list = impl->reader.getVal54();
  for (auto v : list) {
    EntityId id(v);
    if (auto d54 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = StringLiteral::from(Stmt(std::move(d54)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> GCCAsmStmt::nth_input_name(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : input_names()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> GCCAsmStmt::input_names(void) const {
  auto list = impl->reader.getVal67();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

std::optional<StringLiteral> GCCAsmStmt::nth_clobber_string_literal(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : clobber_string_literals()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<StringLiteral> GCCAsmStmt::clobber_string_literals(void) const {
  auto list = impl->reader.getVal55();
  for (auto v : list) {
    EntityId id(v);
    if (auto d55 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = StringLiteral::from(Stmt(std::move(d55)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<AddrLabelExpr> GCCAsmStmt::nth_label_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : label_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<AddrLabelExpr> GCCAsmStmt::label_expressions(void) const {
  auto list = impl->reader.getVal68();
  for (auto v : list) {
    EntityId id(v);
    if (auto d68 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = AddrLabelExpr::from(Stmt(std::move(d68)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::string_view> GCCAsmStmt::nth_label_name(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : label_names()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<std::string_view> GCCAsmStmt::label_names(void) const {
  auto list = impl->reader.getVal69();
  for (auto v : list) {
co_yield std::string_view(v.cStr(), v.size());
  }
  co_return;
}

gap::generator<WhileStmt> WhileStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = WhileStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool WhileStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : WhileStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<WhileStmt> WhileStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = WhileStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<WhileStmt> WhileStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<WhileStmt> WhileStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = WhileStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<WhileStmt> WhileStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool WhileStmt::contains(const Decl &decl) {
  for (auto &parent : WhileStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool WhileStmt::contains(const Stmt &stmt) {
  for (auto &parent : WhileStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<WhileStmt> WhileStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return WhileStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kWhileStmtDerivedKinds[] = {
    WhileStmt::static_kind(),
};

gap::generator<WhileStmt> WhileStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kWhileStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<WhileStmt> e = WhileStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<WhileStmt> WhileStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kWhileStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<WhileStmt> e = WhileStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<WhileStmt> WhileStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::WHILE_STMT:
      return reinterpret_cast<const WhileStmt &>(parent);
    default: return std::nullopt;
  }
}

Stmt WhileStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr WhileStmt::condition(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<VarDecl> WhileStmt::condition_variable(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<DeclStmt> WhileStmt::condition_variable_declaration_statement(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal13();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return DeclStmt::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token WhileStmt::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

Token WhileStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal17());
}

Token WhileStmt::while_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal18());
}

bool WhileStmt::has_variable_storage(void) const {
  return impl->reader.getVal12();
}

gap::generator<ValueStmt> ValueStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ValueStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ValueStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ValueStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ValueStmt> ValueStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ValueStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ValueStmt> ValueStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ValueStmt> ValueStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ValueStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ValueStmt> ValueStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ValueStmt::contains(const Decl &decl) {
  for (auto &parent : ValueStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ValueStmt::contains(const Stmt &stmt) {
  for (auto &parent : ValueStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ValueStmt> ValueStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ValueStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kValueStmtDerivedKinds[] = {
    AttributedStmt::static_kind(),
    LabelStmt::static_kind(),
    ExpressionTraitExpr::static_kind(),
    ExtVectorElementExpr::static_kind(),
    FixedPointLiteral::static_kind(),
    FloatingLiteral::static_kind(),
    FunctionParmPackExpr::static_kind(),
    GNUNullExpr::static_kind(),
    GenericSelectionExpr::static_kind(),
    ImaginaryLiteral::static_kind(),
    ImplicitValueInitExpr::static_kind(),
    InitListExpr::static_kind(),
    IntegerLiteral::static_kind(),
    LambdaExpr::static_kind(),
    MSPropertyRefExpr::static_kind(),
    MSPropertySubscriptExpr::static_kind(),
    MaterializeTemporaryExpr::static_kind(),
    MatrixSubscriptExpr::static_kind(),
    MemberExpr::static_kind(),
    NoInitExpr::static_kind(),
    OMPArraySectionExpr::static_kind(),
    OMPArrayShapingExpr::static_kind(),
    OMPIteratorExpr::static_kind(),
    ObjCArrayLiteral::static_kind(),
    ObjCAvailabilityCheckExpr::static_kind(),
    ObjCBoolLiteralExpr::static_kind(),
    ObjCBoxedExpr::static_kind(),
    ObjCDictionaryLiteral::static_kind(),
    ObjCEncodeExpr::static_kind(),
    ObjCIndirectCopyRestoreExpr::static_kind(),
    ObjCIsaExpr::static_kind(),
    ObjCIvarRefExpr::static_kind(),
    ObjCMessageExpr::static_kind(),
    ObjCPropertyRefExpr::static_kind(),
    ObjCProtocolExpr::static_kind(),
    ObjCSelectorExpr::static_kind(),
    ObjCStringLiteral::static_kind(),
    ObjCSubscriptRefExpr::static_kind(),
    OffsetOfExpr::static_kind(),
    OpaqueValueExpr::static_kind(),
    PackExpansionExpr::static_kind(),
    ParenExpr::static_kind(),
    ParenListExpr::static_kind(),
    PredefinedExpr::static_kind(),
    PseudoObjectExpr::static_kind(),
    RecoveryExpr::static_kind(),
    RequiresExpr::static_kind(),
    SYCLUniqueStableNameExpr::static_kind(),
    ShuffleVectorExpr::static_kind(),
    SizeOfPackExpr::static_kind(),
    SourceLocExpr::static_kind(),
    StmtExpr::static_kind(),
    StringLiteral::static_kind(),
    SubstNonTypeTemplateParmExpr::static_kind(),
    SubstNonTypeTemplateParmPackExpr::static_kind(),
    TypeTraitExpr::static_kind(),
    TypoExpr::static_kind(),
    UnaryExprOrTypeTraitExpr::static_kind(),
    UnaryOperator::static_kind(),
    VAArgExpr::static_kind(),
    AddrLabelExpr::static_kind(),
    ArrayInitIndexExpr::static_kind(),
    ArrayInitLoopExpr::static_kind(),
    ArraySubscriptExpr::static_kind(),
    ArrayTypeTraitExpr::static_kind(),
    AsTypeExpr::static_kind(),
    AtomicExpr::static_kind(),
    BinaryOperator::static_kind(),
    BlockExpr::static_kind(),
    CXXBindTemporaryExpr::static_kind(),
    CXXBoolLiteralExpr::static_kind(),
    CXXConstructExpr::static_kind(),
    CXXDefaultArgExpr::static_kind(),
    CXXDefaultInitExpr::static_kind(),
    CXXDeleteExpr::static_kind(),
    CXXDependentScopeMemberExpr::static_kind(),
    CXXFoldExpr::static_kind(),
    CXXInheritedCtorInitExpr::static_kind(),
    CXXNewExpr::static_kind(),
    CXXNoexceptExpr::static_kind(),
    CXXNullPtrLiteralExpr::static_kind(),
    CXXPseudoDestructorExpr::static_kind(),
    CXXRewrittenBinaryOperator::static_kind(),
    CXXScalarValueInitExpr::static_kind(),
    CXXStdInitializerListExpr::static_kind(),
    CXXThisExpr::static_kind(),
    CXXThrowExpr::static_kind(),
    CXXTypeidExpr::static_kind(),
    CXXUnresolvedConstructExpr::static_kind(),
    CXXUuidofExpr::static_kind(),
    CallExpr::static_kind(),
    CharacterLiteral::static_kind(),
    ChooseExpr::static_kind(),
    CompoundLiteralExpr::static_kind(),
    ConceptSpecializationExpr::static_kind(),
    ConvertVectorExpr::static_kind(),
    DeclRefExpr::static_kind(),
    DependentCoawaitExpr::static_kind(),
    DependentScopeDeclRefExpr::static_kind(),
    DesignatedInitExpr::static_kind(),
    DesignatedInitUpdateExpr::static_kind(),
    ConstantExpr::static_kind(),
    ExprWithCleanups::static_kind(),
    UnresolvedLookupExpr::static_kind(),
    UnresolvedMemberExpr::static_kind(),
    BinaryConditionalOperator::static_kind(),
    ConditionalOperator::static_kind(),
    CompoundAssignOperator::static_kind(),
    CXXTemporaryObjectExpr::static_kind(),
    UserDefinedLiteral::static_kind(),
    CUDAKernelCallExpr::static_kind(),
    CXXMemberCallExpr::static_kind(),
    CXXOperatorCallExpr::static_kind(),
    ImplicitCastExpr::static_kind(),
    CoyieldExpr::static_kind(),
    CoawaitExpr::static_kind(),
    ObjCBridgedCastExpr::static_kind(),
    BuiltinBitCastExpr::static_kind(),
    CStyleCastExpr::static_kind(),
    CXXFunctionalCastExpr::static_kind(),
    CXXReinterpretCastExpr::static_kind(),
    CXXStaticCastExpr::static_kind(),
    CXXAddrspaceCastExpr::static_kind(),
    CXXConstCastExpr::static_kind(),
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<ValueStmt> ValueStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kValueStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ValueStmt> e = ValueStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ValueStmt> ValueStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kValueStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ValueStmt> e = ValueStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ValueStmt> ValueStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::LABEL_STMT:
    case mx::StmtKind::DESIGNATED_INIT_UPDATE_EXPR:
    case mx::StmtKind::DESIGNATED_INIT_EXPR:
    case mx::StmtKind::DEPENDENT_SCOPE_DECL_REF_EXPR:
    case mx::StmtKind::DEPENDENT_COAWAIT_EXPR:
    case mx::StmtKind::DECL_REF_EXPR:
    case mx::StmtKind::COAWAIT_EXPR:
    case mx::StmtKind::COYIELD_EXPR:
    case mx::StmtKind::CONVERT_VECTOR_EXPR:
    case mx::StmtKind::CONCEPT_SPECIALIZATION_EXPR:
    case mx::StmtKind::COMPOUND_LITERAL_EXPR:
    case mx::StmtKind::CHOOSE_EXPR:
    case mx::StmtKind::CHARACTER_LITERAL:
    case mx::StmtKind::IMPLICIT_CAST_EXPR:
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
    case mx::StmtKind::CXX_FUNCTIONAL_CAST_EXPR:
    case mx::StmtKind::C_STYLE_CAST_EXPR:
    case mx::StmtKind::BUILTIN_BIT_CAST_EXPR:
    case mx::StmtKind::OBJ_C_BRIDGED_CAST_EXPR:
    case mx::StmtKind::CALL_EXPR:
    case mx::StmtKind::CXX_OPERATOR_CALL_EXPR:
    case mx::StmtKind::CXX_MEMBER_CALL_EXPR:
    case mx::StmtKind::CUDA_KERNEL_CALL_EXPR:
    case mx::StmtKind::USER_DEFINED_LITERAL:
    case mx::StmtKind::CXX_UUIDOF_EXPR:
    case mx::StmtKind::CXX_UNRESOLVED_CONSTRUCT_EXPR:
    case mx::StmtKind::CXX_TYPEID_EXPR:
    case mx::StmtKind::CXX_THROW_EXPR:
    case mx::StmtKind::CXX_THIS_EXPR:
    case mx::StmtKind::CXX_STD_INITIALIZER_LIST_EXPR:
    case mx::StmtKind::CXX_SCALAR_VALUE_INIT_EXPR:
    case mx::StmtKind::CXX_REWRITTEN_BINARY_OPERATOR:
    case mx::StmtKind::CXX_PSEUDO_DESTRUCTOR_EXPR:
    case mx::StmtKind::CXX_NULL_PTR_LITERAL_EXPR:
    case mx::StmtKind::CXX_NOEXCEPT_EXPR:
    case mx::StmtKind::CXX_NEW_EXPR:
    case mx::StmtKind::CXX_INHERITED_CTOR_INIT_EXPR:
    case mx::StmtKind::CXX_FOLD_EXPR:
    case mx::StmtKind::CXX_DEPENDENT_SCOPE_MEMBER_EXPR:
    case mx::StmtKind::CXX_DELETE_EXPR:
    case mx::StmtKind::CXX_DEFAULT_INIT_EXPR:
    case mx::StmtKind::CXX_DEFAULT_ARG_EXPR:
    case mx::StmtKind::CXX_CONSTRUCT_EXPR:
    case mx::StmtKind::CXX_TEMPORARY_OBJECT_EXPR:
    case mx::StmtKind::CXX_BOOL_LITERAL_EXPR:
    case mx::StmtKind::CXX_BIND_TEMPORARY_EXPR:
    case mx::StmtKind::BLOCK_EXPR:
    case mx::StmtKind::BINARY_OPERATOR:
    case mx::StmtKind::COMPOUND_ASSIGN_OPERATOR:
    case mx::StmtKind::ATOMIC_EXPR:
    case mx::StmtKind::AS_TYPE_EXPR:
    case mx::StmtKind::ARRAY_TYPE_TRAIT_EXPR:
    case mx::StmtKind::ARRAY_SUBSCRIPT_EXPR:
    case mx::StmtKind::ARRAY_INIT_LOOP_EXPR:
    case mx::StmtKind::ARRAY_INIT_INDEX_EXPR:
    case mx::StmtKind::ADDR_LABEL_EXPR:
    case mx::StmtKind::CONDITIONAL_OPERATOR:
    case mx::StmtKind::BINARY_CONDITIONAL_OPERATOR:
    case mx::StmtKind::VA_ARG_EXPR:
    case mx::StmtKind::UNARY_OPERATOR:
    case mx::StmtKind::UNARY_EXPR_OR_TYPE_TRAIT_EXPR:
    case mx::StmtKind::TYPO_EXPR:
    case mx::StmtKind::TYPE_TRAIT_EXPR:
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR:
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_EXPR:
    case mx::StmtKind::STRING_LITERAL:
    case mx::StmtKind::STMT_EXPR:
    case mx::StmtKind::SOURCE_LOC_EXPR:
    case mx::StmtKind::SIZE_OF_PACK_EXPR:
    case mx::StmtKind::SHUFFLE_VECTOR_EXPR:
    case mx::StmtKind::SYCL_UNIQUE_STABLE_NAME_EXPR:
    case mx::StmtKind::REQUIRES_EXPR:
    case mx::StmtKind::RECOVERY_EXPR:
    case mx::StmtKind::PSEUDO_OBJECT_EXPR:
    case mx::StmtKind::PREDEFINED_EXPR:
    case mx::StmtKind::PAREN_LIST_EXPR:
    case mx::StmtKind::PAREN_EXPR:
    case mx::StmtKind::PACK_EXPANSION_EXPR:
    case mx::StmtKind::UNRESOLVED_MEMBER_EXPR:
    case mx::StmtKind::UNRESOLVED_LOOKUP_EXPR:
    case mx::StmtKind::OPAQUE_VALUE_EXPR:
    case mx::StmtKind::OFFSET_OF_EXPR:
    case mx::StmtKind::OBJ_C_SUBSCRIPT_REF_EXPR:
    case mx::StmtKind::OBJ_C_STRING_LITERAL:
    case mx::StmtKind::OBJ_C_SELECTOR_EXPR:
    case mx::StmtKind::OBJ_C_PROTOCOL_EXPR:
    case mx::StmtKind::OBJ_C_PROPERTY_REF_EXPR:
    case mx::StmtKind::OBJ_C_MESSAGE_EXPR:
    case mx::StmtKind::OBJ_C_IVAR_REF_EXPR:
    case mx::StmtKind::OBJ_C_ISA_EXPR:
    case mx::StmtKind::OBJ_C_INDIRECT_COPY_RESTORE_EXPR:
    case mx::StmtKind::OBJ_C_ENCODE_EXPR:
    case mx::StmtKind::OBJ_C_DICTIONARY_LITERAL:
    case mx::StmtKind::OBJ_C_BOXED_EXPR:
    case mx::StmtKind::OBJ_C_BOOL_LITERAL_EXPR:
    case mx::StmtKind::OBJ_C_AVAILABILITY_CHECK_EXPR:
    case mx::StmtKind::OBJ_C_ARRAY_LITERAL:
    case mx::StmtKind::OMP_ITERATOR_EXPR:
    case mx::StmtKind::OMP_ARRAY_SHAPING_EXPR:
    case mx::StmtKind::OMP_ARRAY_SECTION_EXPR:
    case mx::StmtKind::NO_INIT_EXPR:
    case mx::StmtKind::MEMBER_EXPR:
    case mx::StmtKind::MATRIX_SUBSCRIPT_EXPR:
    case mx::StmtKind::MATERIALIZE_TEMPORARY_EXPR:
    case mx::StmtKind::MS_PROPERTY_SUBSCRIPT_EXPR:
    case mx::StmtKind::MS_PROPERTY_REF_EXPR:
    case mx::StmtKind::LAMBDA_EXPR:
    case mx::StmtKind::INTEGER_LITERAL:
    case mx::StmtKind::INIT_LIST_EXPR:
    case mx::StmtKind::IMPLICIT_VALUE_INIT_EXPR:
    case mx::StmtKind::IMAGINARY_LITERAL:
    case mx::StmtKind::GENERIC_SELECTION_EXPR:
    case mx::StmtKind::GNU_NULL_EXPR:
    case mx::StmtKind::FUNCTION_PARM_PACK_EXPR:
    case mx::StmtKind::EXPR_WITH_CLEANUPS:
    case mx::StmtKind::CONSTANT_EXPR:
    case mx::StmtKind::FLOATING_LITERAL:
    case mx::StmtKind::FIXED_POINT_LITERAL:
    case mx::StmtKind::EXT_VECTOR_ELEMENT_EXPR:
    case mx::StmtKind::EXPRESSION_TRAIT_EXPR:
    case mx::StmtKind::ATTRIBUTED_STMT:
      return reinterpret_cast<const ValueStmt &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> ValueStmt::expression_statement(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<LabelStmt> LabelStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LabelStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LabelStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LabelStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<LabelStmt> LabelStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = LabelStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LabelStmt> LabelStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<LabelStmt> LabelStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = LabelStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LabelStmt> LabelStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool LabelStmt::contains(const Decl &decl) {
  for (auto &parent : LabelStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool LabelStmt::contains(const Stmt &stmt) {
  for (auto &parent : LabelStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<LabelStmt> LabelStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return LabelStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kLabelStmtDerivedKinds[] = {
    LabelStmt::static_kind(),
};

gap::generator<LabelStmt> LabelStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kLabelStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<LabelStmt> e = LabelStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LabelStmt> LabelStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kLabelStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<LabelStmt> e = LabelStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LabelStmt> LabelStmt::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<LabelStmt> LabelStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::LABEL_STMT:
      return reinterpret_cast<const LabelStmt &>(parent);
    default: return std::nullopt;
  }
}

LabelDecl LabelStmt::declaration(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return LabelDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token LabelStmt::identifier_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal11());
}

std::string_view LabelStmt::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

Stmt LabelStmt::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

bool LabelStmt::is_side_entry(void) const {
  return impl->reader.getVal12();
}

gap::generator<Expr> Expr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Expr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Expr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Expr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<Expr> Expr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = Expr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Expr> Expr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<Expr> Expr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = Expr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Expr> Expr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool Expr::contains(const Decl &decl) {
  for (auto &parent : Expr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool Expr::contains(const Stmt &stmt) {
  for (auto &parent : Expr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<Expr> Expr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return Expr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kExprDerivedKinds[] = {
    ExpressionTraitExpr::static_kind(),
    ExtVectorElementExpr::static_kind(),
    FixedPointLiteral::static_kind(),
    FloatingLiteral::static_kind(),
    FunctionParmPackExpr::static_kind(),
    GNUNullExpr::static_kind(),
    GenericSelectionExpr::static_kind(),
    ImaginaryLiteral::static_kind(),
    ImplicitValueInitExpr::static_kind(),
    InitListExpr::static_kind(),
    IntegerLiteral::static_kind(),
    LambdaExpr::static_kind(),
    MSPropertyRefExpr::static_kind(),
    MSPropertySubscriptExpr::static_kind(),
    MaterializeTemporaryExpr::static_kind(),
    MatrixSubscriptExpr::static_kind(),
    MemberExpr::static_kind(),
    NoInitExpr::static_kind(),
    OMPArraySectionExpr::static_kind(),
    OMPArrayShapingExpr::static_kind(),
    OMPIteratorExpr::static_kind(),
    ObjCArrayLiteral::static_kind(),
    ObjCAvailabilityCheckExpr::static_kind(),
    ObjCBoolLiteralExpr::static_kind(),
    ObjCBoxedExpr::static_kind(),
    ObjCDictionaryLiteral::static_kind(),
    ObjCEncodeExpr::static_kind(),
    ObjCIndirectCopyRestoreExpr::static_kind(),
    ObjCIsaExpr::static_kind(),
    ObjCIvarRefExpr::static_kind(),
    ObjCMessageExpr::static_kind(),
    ObjCPropertyRefExpr::static_kind(),
    ObjCProtocolExpr::static_kind(),
    ObjCSelectorExpr::static_kind(),
    ObjCStringLiteral::static_kind(),
    ObjCSubscriptRefExpr::static_kind(),
    OffsetOfExpr::static_kind(),
    OpaqueValueExpr::static_kind(),
    PackExpansionExpr::static_kind(),
    ParenExpr::static_kind(),
    ParenListExpr::static_kind(),
    PredefinedExpr::static_kind(),
    PseudoObjectExpr::static_kind(),
    RecoveryExpr::static_kind(),
    RequiresExpr::static_kind(),
    SYCLUniqueStableNameExpr::static_kind(),
    ShuffleVectorExpr::static_kind(),
    SizeOfPackExpr::static_kind(),
    SourceLocExpr::static_kind(),
    StmtExpr::static_kind(),
    StringLiteral::static_kind(),
    SubstNonTypeTemplateParmExpr::static_kind(),
    SubstNonTypeTemplateParmPackExpr::static_kind(),
    TypeTraitExpr::static_kind(),
    TypoExpr::static_kind(),
    UnaryExprOrTypeTraitExpr::static_kind(),
    UnaryOperator::static_kind(),
    VAArgExpr::static_kind(),
    AddrLabelExpr::static_kind(),
    ArrayInitIndexExpr::static_kind(),
    ArrayInitLoopExpr::static_kind(),
    ArraySubscriptExpr::static_kind(),
    ArrayTypeTraitExpr::static_kind(),
    AsTypeExpr::static_kind(),
    AtomicExpr::static_kind(),
    BinaryOperator::static_kind(),
    BlockExpr::static_kind(),
    CXXBindTemporaryExpr::static_kind(),
    CXXBoolLiteralExpr::static_kind(),
    CXXConstructExpr::static_kind(),
    CXXDefaultArgExpr::static_kind(),
    CXXDefaultInitExpr::static_kind(),
    CXXDeleteExpr::static_kind(),
    CXXDependentScopeMemberExpr::static_kind(),
    CXXFoldExpr::static_kind(),
    CXXInheritedCtorInitExpr::static_kind(),
    CXXNewExpr::static_kind(),
    CXXNoexceptExpr::static_kind(),
    CXXNullPtrLiteralExpr::static_kind(),
    CXXPseudoDestructorExpr::static_kind(),
    CXXRewrittenBinaryOperator::static_kind(),
    CXXScalarValueInitExpr::static_kind(),
    CXXStdInitializerListExpr::static_kind(),
    CXXThisExpr::static_kind(),
    CXXThrowExpr::static_kind(),
    CXXTypeidExpr::static_kind(),
    CXXUnresolvedConstructExpr::static_kind(),
    CXXUuidofExpr::static_kind(),
    CallExpr::static_kind(),
    CharacterLiteral::static_kind(),
    ChooseExpr::static_kind(),
    CompoundLiteralExpr::static_kind(),
    ConceptSpecializationExpr::static_kind(),
    ConvertVectorExpr::static_kind(),
    DeclRefExpr::static_kind(),
    DependentCoawaitExpr::static_kind(),
    DependentScopeDeclRefExpr::static_kind(),
    DesignatedInitExpr::static_kind(),
    DesignatedInitUpdateExpr::static_kind(),
    ConstantExpr::static_kind(),
    ExprWithCleanups::static_kind(),
    UnresolvedLookupExpr::static_kind(),
    UnresolvedMemberExpr::static_kind(),
    BinaryConditionalOperator::static_kind(),
    ConditionalOperator::static_kind(),
    CompoundAssignOperator::static_kind(),
    CXXTemporaryObjectExpr::static_kind(),
    UserDefinedLiteral::static_kind(),
    CUDAKernelCallExpr::static_kind(),
    CXXMemberCallExpr::static_kind(),
    CXXOperatorCallExpr::static_kind(),
    ImplicitCastExpr::static_kind(),
    CoyieldExpr::static_kind(),
    CoawaitExpr::static_kind(),
    ObjCBridgedCastExpr::static_kind(),
    BuiltinBitCastExpr::static_kind(),
    CStyleCastExpr::static_kind(),
    CXXFunctionalCastExpr::static_kind(),
    CXXReinterpretCastExpr::static_kind(),
    CXXStaticCastExpr::static_kind(),
    CXXAddrspaceCastExpr::static_kind(),
    CXXConstCastExpr::static_kind(),
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<Expr> Expr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<Expr> e = Expr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<Expr> Expr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<Expr> e = Expr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<Expr> Expr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<Expr> Expr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DESIGNATED_INIT_UPDATE_EXPR:
    case mx::StmtKind::DESIGNATED_INIT_EXPR:
    case mx::StmtKind::DEPENDENT_SCOPE_DECL_REF_EXPR:
    case mx::StmtKind::DEPENDENT_COAWAIT_EXPR:
    case mx::StmtKind::DECL_REF_EXPR:
    case mx::StmtKind::COAWAIT_EXPR:
    case mx::StmtKind::COYIELD_EXPR:
    case mx::StmtKind::CONVERT_VECTOR_EXPR:
    case mx::StmtKind::CONCEPT_SPECIALIZATION_EXPR:
    case mx::StmtKind::COMPOUND_LITERAL_EXPR:
    case mx::StmtKind::CHOOSE_EXPR:
    case mx::StmtKind::CHARACTER_LITERAL:
    case mx::StmtKind::IMPLICIT_CAST_EXPR:
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
    case mx::StmtKind::CXX_FUNCTIONAL_CAST_EXPR:
    case mx::StmtKind::C_STYLE_CAST_EXPR:
    case mx::StmtKind::BUILTIN_BIT_CAST_EXPR:
    case mx::StmtKind::OBJ_C_BRIDGED_CAST_EXPR:
    case mx::StmtKind::CALL_EXPR:
    case mx::StmtKind::CXX_OPERATOR_CALL_EXPR:
    case mx::StmtKind::CXX_MEMBER_CALL_EXPR:
    case mx::StmtKind::CUDA_KERNEL_CALL_EXPR:
    case mx::StmtKind::USER_DEFINED_LITERAL:
    case mx::StmtKind::CXX_UUIDOF_EXPR:
    case mx::StmtKind::CXX_UNRESOLVED_CONSTRUCT_EXPR:
    case mx::StmtKind::CXX_TYPEID_EXPR:
    case mx::StmtKind::CXX_THROW_EXPR:
    case mx::StmtKind::CXX_THIS_EXPR:
    case mx::StmtKind::CXX_STD_INITIALIZER_LIST_EXPR:
    case mx::StmtKind::CXX_SCALAR_VALUE_INIT_EXPR:
    case mx::StmtKind::CXX_REWRITTEN_BINARY_OPERATOR:
    case mx::StmtKind::CXX_PSEUDO_DESTRUCTOR_EXPR:
    case mx::StmtKind::CXX_NULL_PTR_LITERAL_EXPR:
    case mx::StmtKind::CXX_NOEXCEPT_EXPR:
    case mx::StmtKind::CXX_NEW_EXPR:
    case mx::StmtKind::CXX_INHERITED_CTOR_INIT_EXPR:
    case mx::StmtKind::CXX_FOLD_EXPR:
    case mx::StmtKind::CXX_DEPENDENT_SCOPE_MEMBER_EXPR:
    case mx::StmtKind::CXX_DELETE_EXPR:
    case mx::StmtKind::CXX_DEFAULT_INIT_EXPR:
    case mx::StmtKind::CXX_DEFAULT_ARG_EXPR:
    case mx::StmtKind::CXX_CONSTRUCT_EXPR:
    case mx::StmtKind::CXX_TEMPORARY_OBJECT_EXPR:
    case mx::StmtKind::CXX_BOOL_LITERAL_EXPR:
    case mx::StmtKind::CXX_BIND_TEMPORARY_EXPR:
    case mx::StmtKind::BLOCK_EXPR:
    case mx::StmtKind::BINARY_OPERATOR:
    case mx::StmtKind::COMPOUND_ASSIGN_OPERATOR:
    case mx::StmtKind::ATOMIC_EXPR:
    case mx::StmtKind::AS_TYPE_EXPR:
    case mx::StmtKind::ARRAY_TYPE_TRAIT_EXPR:
    case mx::StmtKind::ARRAY_SUBSCRIPT_EXPR:
    case mx::StmtKind::ARRAY_INIT_LOOP_EXPR:
    case mx::StmtKind::ARRAY_INIT_INDEX_EXPR:
    case mx::StmtKind::ADDR_LABEL_EXPR:
    case mx::StmtKind::CONDITIONAL_OPERATOR:
    case mx::StmtKind::BINARY_CONDITIONAL_OPERATOR:
    case mx::StmtKind::VA_ARG_EXPR:
    case mx::StmtKind::UNARY_OPERATOR:
    case mx::StmtKind::UNARY_EXPR_OR_TYPE_TRAIT_EXPR:
    case mx::StmtKind::TYPO_EXPR:
    case mx::StmtKind::TYPE_TRAIT_EXPR:
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR:
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_EXPR:
    case mx::StmtKind::STRING_LITERAL:
    case mx::StmtKind::STMT_EXPR:
    case mx::StmtKind::SOURCE_LOC_EXPR:
    case mx::StmtKind::SIZE_OF_PACK_EXPR:
    case mx::StmtKind::SHUFFLE_VECTOR_EXPR:
    case mx::StmtKind::SYCL_UNIQUE_STABLE_NAME_EXPR:
    case mx::StmtKind::REQUIRES_EXPR:
    case mx::StmtKind::RECOVERY_EXPR:
    case mx::StmtKind::PSEUDO_OBJECT_EXPR:
    case mx::StmtKind::PREDEFINED_EXPR:
    case mx::StmtKind::PAREN_LIST_EXPR:
    case mx::StmtKind::PAREN_EXPR:
    case mx::StmtKind::PACK_EXPANSION_EXPR:
    case mx::StmtKind::UNRESOLVED_MEMBER_EXPR:
    case mx::StmtKind::UNRESOLVED_LOOKUP_EXPR:
    case mx::StmtKind::OPAQUE_VALUE_EXPR:
    case mx::StmtKind::OFFSET_OF_EXPR:
    case mx::StmtKind::OBJ_C_SUBSCRIPT_REF_EXPR:
    case mx::StmtKind::OBJ_C_STRING_LITERAL:
    case mx::StmtKind::OBJ_C_SELECTOR_EXPR:
    case mx::StmtKind::OBJ_C_PROTOCOL_EXPR:
    case mx::StmtKind::OBJ_C_PROPERTY_REF_EXPR:
    case mx::StmtKind::OBJ_C_MESSAGE_EXPR:
    case mx::StmtKind::OBJ_C_IVAR_REF_EXPR:
    case mx::StmtKind::OBJ_C_ISA_EXPR:
    case mx::StmtKind::OBJ_C_INDIRECT_COPY_RESTORE_EXPR:
    case mx::StmtKind::OBJ_C_ENCODE_EXPR:
    case mx::StmtKind::OBJ_C_DICTIONARY_LITERAL:
    case mx::StmtKind::OBJ_C_BOXED_EXPR:
    case mx::StmtKind::OBJ_C_BOOL_LITERAL_EXPR:
    case mx::StmtKind::OBJ_C_AVAILABILITY_CHECK_EXPR:
    case mx::StmtKind::OBJ_C_ARRAY_LITERAL:
    case mx::StmtKind::OMP_ITERATOR_EXPR:
    case mx::StmtKind::OMP_ARRAY_SHAPING_EXPR:
    case mx::StmtKind::OMP_ARRAY_SECTION_EXPR:
    case mx::StmtKind::NO_INIT_EXPR:
    case mx::StmtKind::MEMBER_EXPR:
    case mx::StmtKind::MATRIX_SUBSCRIPT_EXPR:
    case mx::StmtKind::MATERIALIZE_TEMPORARY_EXPR:
    case mx::StmtKind::MS_PROPERTY_SUBSCRIPT_EXPR:
    case mx::StmtKind::MS_PROPERTY_REF_EXPR:
    case mx::StmtKind::LAMBDA_EXPR:
    case mx::StmtKind::INTEGER_LITERAL:
    case mx::StmtKind::INIT_LIST_EXPR:
    case mx::StmtKind::IMPLICIT_VALUE_INIT_EXPR:
    case mx::StmtKind::IMAGINARY_LITERAL:
    case mx::StmtKind::GENERIC_SELECTION_EXPR:
    case mx::StmtKind::GNU_NULL_EXPR:
    case mx::StmtKind::FUNCTION_PARM_PACK_EXPR:
    case mx::StmtKind::EXPR_WITH_CLEANUPS:
    case mx::StmtKind::CONSTANT_EXPR:
    case mx::StmtKind::FLOATING_LITERAL:
    case mx::StmtKind::FIXED_POINT_LITERAL:
    case mx::StmtKind::EXT_VECTOR_ELEMENT_EXPR:
    case mx::StmtKind::EXPRESSION_TRAIT_EXPR:
      return reinterpret_cast<const Expr &>(parent);
    default: return std::nullopt;
  }
}

bool Expr::has_side_effects(void) const {
  return impl->reader.getVal12();
}

Expr Expr::ignore_casts(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_conversion_operator_single_step(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_implicit_casts(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_implicit(void) const {
  RawEntityId eid = impl->reader.getVal14();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_implicit_as_written(void) const {
  RawEntityId eid = impl->reader.getVal17();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parenthesis_base_casts(void) const {
  RawEntityId eid = impl->reader.getVal18();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parenthesis_casts(void) const {
  RawEntityId eid = impl->reader.getVal19();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parenthesis_implicit_casts(void) const {
  RawEntityId eid = impl->reader.getVal20();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parenthesis_l_value_casts(void) const {
  RawEntityId eid = impl->reader.getVal21();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parenthesis_noop_casts(void) const {
  RawEntityId eid = impl->reader.getVal22();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_parentheses(void) const {
  RawEntityId eid = impl->reader.getVal30();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr Expr::ignore_unless_spelled_in_source(void) const {
  RawEntityId eid = impl->reader.getVal31();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool Expr::contains_errors(void) const {
  return impl->reader.getVal16();
}

bool Expr::contains_unexpanded_parameter_pack(void) const {
  return impl->reader.getVal23();
}

Expr Expr::best_dynamic_class_type_expression(void) const {
  RawEntityId eid = impl->reader.getVal32();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token Expr::expression_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal33());
}

std::optional<ObjCPropertyRefExpr> Expr::obj_c_property(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal34();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return ObjCPropertyRefExpr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

ExprObjectKind Expr::object_kind(void) const {
  return static_cast<ExprObjectKind>(impl->reader.getVal57());
}

std::optional<Decl> Expr::referenced_declaration_of_callee(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal35();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<FieldDecl> Expr::source_bit_field(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal36();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FieldDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> Expr::type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal37();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

ExprValueKind Expr::value_kind(void) const {
  return static_cast<ExprValueKind>(impl->reader.getVal70());
}

bool Expr::has_non_trivial_call(void) const {
  return impl->reader.getVal24();
}

std::optional<bool> Expr::is_cxx98_integral_constant_expression(void) const {
  if (!impl->reader.getVal58()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal25());
  }
  return std::nullopt;
}

bool Expr::is_default_argument(void) const {
  return impl->reader.getVal59();
}

bool Expr::is_gl_value(void) const {
  return impl->reader.getVal60();
}

bool Expr::is_implicit_cxx_this(void) const {
  return impl->reader.getVal71();
}

bool Expr::is_instantiation_dependent(void) const {
  return impl->reader.getVal72();
}

std::optional<bool> Expr::is_integer_constant_expression(void) const {
  if (!impl->reader.getVal74()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal73());
  }
  return std::nullopt;
}

bool Expr::is_known_to_have_boolean_value(void) const {
  return impl->reader.getVal75();
}

bool Expr::is_l_value(void) const {
  return impl->reader.getVal76();
}

bool Expr::is_objcgc_candidate(void) const {
  return impl->reader.getVal77();
}

bool Expr::is_obj_c_self_expression(void) const {
  return impl->reader.getVal78();
}

bool Expr::is_ordinary_or_bit_field_object(void) const {
  return impl->reader.getVal79();
}

bool Expr::is_pr_value(void) const {
  return impl->reader.getVal80();
}

bool Expr::is_read_if_discarded_in_c_plus_plus11(void) const {
  return impl->reader.getVal81();
}

bool Expr::is_type_dependent(void) const {
  return impl->reader.getVal82();
}

bool Expr::is_value_dependent(void) const {
  return impl->reader.getVal83();
}

bool Expr::is_x_value(void) const {
  return impl->reader.getVal84();
}

bool Expr::refers_to_bit_field(void) const {
  return impl->reader.getVal85();
}

bool Expr::refers_to_global_register_variable(void) const {
  return impl->reader.getVal86();
}

bool Expr::refers_to_matrix_element(void) const {
  return impl->reader.getVal87();
}

bool Expr::refers_to_vector_element(void) const {
  return impl->reader.getVal88();
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DesignatedInitUpdateExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DesignatedInitUpdateExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DesignatedInitUpdateExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DesignatedInitUpdateExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DesignatedInitUpdateExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DesignatedInitUpdateExpr::contains(const Decl &decl) {
  for (auto &parent : DesignatedInitUpdateExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DesignatedInitUpdateExpr::contains(const Stmt &stmt) {
  for (auto &parent : DesignatedInitUpdateExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DesignatedInitUpdateExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDesignatedInitUpdateExprDerivedKinds[] = {
    DesignatedInitUpdateExpr::static_kind(),
};

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDesignatedInitUpdateExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DesignatedInitUpdateExpr> e = DesignatedInitUpdateExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDesignatedInitUpdateExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DesignatedInitUpdateExpr> e = DesignatedInitUpdateExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DesignatedInitUpdateExpr> DesignatedInitUpdateExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DESIGNATED_INIT_UPDATE_EXPR:
      return reinterpret_cast<const DesignatedInitUpdateExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr DesignatedInitUpdateExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

InitListExpr DesignatedInitUpdateExpr::updater(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return InitListExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DesignatedInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DesignatedInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DesignatedInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DesignatedInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DesignatedInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DesignatedInitExpr::contains(const Decl &decl) {
  for (auto &parent : DesignatedInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DesignatedInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : DesignatedInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DesignatedInitExpr> DesignatedInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DesignatedInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDesignatedInitExprDerivedKinds[] = {
    DesignatedInitExpr::static_kind(),
};

gap::generator<DesignatedInitExpr> DesignatedInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDesignatedInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DesignatedInitExpr> e = DesignatedInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DesignatedInitExpr> DesignatedInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDesignatedInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DesignatedInitExpr> e = DesignatedInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DesignatedInitExpr> DesignatedInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DesignatedInitExpr> DesignatedInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DesignatedInitExpr> DesignatedInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DESIGNATED_INIT_EXPR:
      return reinterpret_cast<const DesignatedInitExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Designator> DesignatedInitExpr::nth_designator(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : designators()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Designator> DesignatedInitExpr::designators(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->DesignatorFor(impl->ep, v)) {
      co_yield Designator(std::move(d15));
    }
  }
  co_return;
}

TokenRange DesignatedInitExpr::designators_source_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal38(), impl->reader.getVal39());
}

Token DesignatedInitExpr::equal_or_colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Expr DesignatedInitExpr::initializer(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool DesignatedInitExpr::is_direct_initializer(void) const {
  return impl->reader.getVal89();
}

bool DesignatedInitExpr::uses_gnu_syntax(void) const {
  return impl->reader.getVal90();
}

std::optional<Expr> DesignatedInitExpr::nth_sub_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : sub_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> DesignatedInitExpr::sub_expressions(void) const {
  auto list = impl->reader.getVal26();
  for (auto v : list) {
    EntityId id(v);
    if (auto d26 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d26)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentScopeDeclRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentScopeDeclRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentScopeDeclRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DependentScopeDeclRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DependentScopeDeclRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DependentScopeDeclRefExpr::contains(const Decl &decl) {
  for (auto &parent : DependentScopeDeclRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DependentScopeDeclRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : DependentScopeDeclRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DependentScopeDeclRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDependentScopeDeclRefExprDerivedKinds[] = {
    DependentScopeDeclRefExpr::static_kind(),
};

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDependentScopeDeclRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DependentScopeDeclRefExpr> e = DependentScopeDeclRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDependentScopeDeclRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DependentScopeDeclRefExpr> e = DependentScopeDeclRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DependentScopeDeclRefExpr> DependentScopeDeclRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DEPENDENT_SCOPE_DECL_REF_EXPR:
      return reinterpret_cast<const DependentScopeDeclRefExpr &>(parent);
    default: return std::nullopt;
  }
}

Token DependentScopeDeclRefExpr::l_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token DependentScopeDeclRefExpr::r_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token DependentScopeDeclRefExpr::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

bool DependentScopeDeclRefExpr::has_explicit_template_arguments(void) const {
  return impl->reader.getVal89();
}

bool DependentScopeDeclRefExpr::has_template_keyword(void) const {
  return impl->reader.getVal90();
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DependentCoawaitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DependentCoawaitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DependentCoawaitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DependentCoawaitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DependentCoawaitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DependentCoawaitExpr::contains(const Decl &decl) {
  for (auto &parent : DependentCoawaitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DependentCoawaitExpr::contains(const Stmt &stmt) {
  for (auto &parent : DependentCoawaitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DependentCoawaitExpr> DependentCoawaitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DependentCoawaitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDependentCoawaitExprDerivedKinds[] = {
    DependentCoawaitExpr::static_kind(),
};

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDependentCoawaitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DependentCoawaitExpr> e = DependentCoawaitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DependentCoawaitExpr> DependentCoawaitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDependentCoawaitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DependentCoawaitExpr> e = DependentCoawaitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DependentCoawaitExpr> DependentCoawaitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DependentCoawaitExpr> DependentCoawaitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DependentCoawaitExpr> DependentCoawaitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DEPENDENT_COAWAIT_EXPR:
      return reinterpret_cast<const DependentCoawaitExpr &>(parent);
    default: return std::nullopt;
  }
}

Token DependentCoawaitExpr::keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr DependentCoawaitExpr::operand(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

UnresolvedLookupExpr DependentCoawaitExpr::operator_coawait_lookup(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return UnresolvedLookupExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<DeclRefExpr> DeclRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeclRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeclRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeclRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DeclRefExpr> DeclRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DeclRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclRefExpr> DeclRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DeclRefExpr> DeclRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DeclRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclRefExpr> DeclRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DeclRefExpr::contains(const Decl &decl) {
  for (auto &parent : DeclRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DeclRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : DeclRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DeclRefExpr> DeclRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DeclRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDeclRefExprDerivedKinds[] = {
    DeclRefExpr::static_kind(),
};

gap::generator<DeclRefExpr> DeclRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDeclRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DeclRefExpr> e = DeclRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeclRefExpr> DeclRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDeclRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DeclRefExpr> e = DeclRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeclRefExpr> DeclRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DeclRefExpr> DeclRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DeclRefExpr> DeclRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DECL_REF_EXPR:
      return reinterpret_cast<const DeclRefExpr &>(parent);
    default: return std::nullopt;
  }
}

ValueDecl DeclRefExpr::declaration(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return ValueDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

NamedDecl DeclRefExpr::found_declaration(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token DeclRefExpr::l_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token DeclRefExpr::r_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Token DeclRefExpr::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

bool DeclRefExpr::had_multiple_candidates(void) const {
  return impl->reader.getVal89();
}

bool DeclRefExpr::has_explicit_template_arguments(void) const {
  return impl->reader.getVal90();
}

bool DeclRefExpr::has_qualifier(void) const {
  return impl->reader.getVal91();
}

bool DeclRefExpr::has_template_keyword_and_arguments_info(void) const {
  return impl->reader.getVal92();
}

bool DeclRefExpr::has_template_keyword(void) const {
  return impl->reader.getVal93();
}

NonOdrUseReason DeclRefExpr::is_non_odr_use(void) const {
  return static_cast<NonOdrUseReason>(impl->reader.getVal94());
}

bool DeclRefExpr::refers_to_enclosing_variable_or_capture(void) const {
  return impl->reader.getVal95();
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CoroutineSuspendExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CoroutineSuspendExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CoroutineSuspendExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoroutineSuspendExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoroutineSuspendExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CoroutineSuspendExpr::contains(const Decl &decl) {
  for (auto &parent : CoroutineSuspendExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CoroutineSuspendExpr::contains(const Stmt &stmt) {
  for (auto &parent : CoroutineSuspendExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CoroutineSuspendExpr> CoroutineSuspendExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CoroutineSuspendExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCoroutineSuspendExprDerivedKinds[] = {
    CoyieldExpr::static_kind(),
    CoawaitExpr::static_kind(),
};

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCoroutineSuspendExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CoroutineSuspendExpr> e = CoroutineSuspendExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CoroutineSuspendExpr> CoroutineSuspendExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCoroutineSuspendExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CoroutineSuspendExpr> e = CoroutineSuspendExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CoroutineSuspendExpr> CoroutineSuspendExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoroutineSuspendExpr> CoroutineSuspendExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoroutineSuspendExpr> CoroutineSuspendExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COAWAIT_EXPR:
    case mx::StmtKind::COYIELD_EXPR:
      return reinterpret_cast<const CoroutineSuspendExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CoroutineSuspendExpr::common_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CoroutineSuspendExpr::keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

OpaqueValueExpr CoroutineSuspendExpr::opaque_value(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return OpaqueValueExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoroutineSuspendExpr::operand(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoroutineSuspendExpr::ready_expression(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoroutineSuspendExpr::resume_expression(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CoroutineSuspendExpr::suspend_expression(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<CoawaitExpr> CoawaitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CoawaitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CoawaitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CoawaitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CoawaitExpr> CoawaitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoawaitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoawaitExpr> CoawaitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CoawaitExpr> CoawaitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoawaitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoawaitExpr> CoawaitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CoawaitExpr::contains(const Decl &decl) {
  for (auto &parent : CoawaitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CoawaitExpr::contains(const Stmt &stmt) {
  for (auto &parent : CoawaitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CoawaitExpr> CoawaitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CoawaitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCoawaitExprDerivedKinds[] = {
    CoawaitExpr::static_kind(),
};

gap::generator<CoawaitExpr> CoawaitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCoawaitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CoawaitExpr> e = CoawaitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CoawaitExpr> CoawaitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCoawaitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CoawaitExpr> e = CoawaitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CoawaitExpr> CoawaitExpr::from(const CoroutineSuspendExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoawaitExpr> CoawaitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoawaitExpr> CoawaitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoawaitExpr> CoawaitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COAWAIT_EXPR:
      return reinterpret_cast<const CoawaitExpr &>(parent);
    default: return std::nullopt;
  }
}

bool CoawaitExpr::is_implicit(void) const {
  return impl->reader.getVal89();
}

gap::generator<CoyieldExpr> CoyieldExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CoyieldExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CoyieldExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CoyieldExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CoyieldExpr> CoyieldExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoyieldExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoyieldExpr> CoyieldExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CoyieldExpr> CoyieldExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CoyieldExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CoyieldExpr> CoyieldExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CoyieldExpr::contains(const Decl &decl) {
  for (auto &parent : CoyieldExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CoyieldExpr::contains(const Stmt &stmt) {
  for (auto &parent : CoyieldExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CoyieldExpr> CoyieldExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CoyieldExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCoyieldExprDerivedKinds[] = {
    CoyieldExpr::static_kind(),
};

gap::generator<CoyieldExpr> CoyieldExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCoyieldExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CoyieldExpr> e = CoyieldExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CoyieldExpr> CoyieldExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCoyieldExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CoyieldExpr> e = CoyieldExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CoyieldExpr> CoyieldExpr::from(const CoroutineSuspendExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoyieldExpr> CoyieldExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoyieldExpr> CoyieldExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CoyieldExpr> CoyieldExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COYIELD_EXPR:
      return reinterpret_cast<const CoyieldExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConvertVectorExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConvertVectorExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConvertVectorExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConvertVectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConvertVectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConvertVectorExpr::contains(const Decl &decl) {
  for (auto &parent : ConvertVectorExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConvertVectorExpr::contains(const Stmt &stmt) {
  for (auto &parent : ConvertVectorExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ConvertVectorExpr> ConvertVectorExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ConvertVectorExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kConvertVectorExprDerivedKinds[] = {
    ConvertVectorExpr::static_kind(),
};

gap::generator<ConvertVectorExpr> ConvertVectorExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kConvertVectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ConvertVectorExpr> e = ConvertVectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConvertVectorExpr> ConvertVectorExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kConvertVectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ConvertVectorExpr> e = ConvertVectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConvertVectorExpr> ConvertVectorExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConvertVectorExpr> ConvertVectorExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConvertVectorExpr> ConvertVectorExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONVERT_VECTOR_EXPR:
      return reinterpret_cast<const ConvertVectorExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ConvertVectorExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token ConvertVectorExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr ConvertVectorExpr::src_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConceptSpecializationExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConceptSpecializationExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConceptSpecializationExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConceptSpecializationExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConceptSpecializationExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConceptSpecializationExpr::contains(const Decl &decl) {
  for (auto &parent : ConceptSpecializationExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConceptSpecializationExpr::contains(const Stmt &stmt) {
  for (auto &parent : ConceptSpecializationExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ConceptSpecializationExpr> ConceptSpecializationExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ConceptSpecializationExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kConceptSpecializationExprDerivedKinds[] = {
    ConceptSpecializationExpr::static_kind(),
};

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kConceptSpecializationExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ConceptSpecializationExpr> e = ConceptSpecializationExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConceptSpecializationExpr> ConceptSpecializationExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kConceptSpecializationExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ConceptSpecializationExpr> e = ConceptSpecializationExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConceptSpecializationExpr> ConceptSpecializationExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConceptSpecializationExpr> ConceptSpecializationExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConceptSpecializationExpr> ConceptSpecializationExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONCEPT_SPECIALIZATION_EXPR:
      return reinterpret_cast<const ConceptSpecializationExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<TemplateArgument> ConceptSpecializationExpr::nth_template_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> ConceptSpecializationExpr::template_arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d15));
    }
  }
  co_return;
}

bool ConceptSpecializationExpr::is_satisfied(void) const {
  return impl->reader.getVal89();
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CompoundLiteralExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CompoundLiteralExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CompoundLiteralExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CompoundLiteralExpr::contains(const Decl &decl) {
  for (auto &parent : CompoundLiteralExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CompoundLiteralExpr::contains(const Stmt &stmt) {
  for (auto &parent : CompoundLiteralExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CompoundLiteralExpr> CompoundLiteralExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CompoundLiteralExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCompoundLiteralExprDerivedKinds[] = {
    CompoundLiteralExpr::static_kind(),
};

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCompoundLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CompoundLiteralExpr> e = CompoundLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CompoundLiteralExpr> CompoundLiteralExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCompoundLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CompoundLiteralExpr> e = CompoundLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CompoundLiteralExpr> CompoundLiteralExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CompoundLiteralExpr> CompoundLiteralExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CompoundLiteralExpr> CompoundLiteralExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COMPOUND_LITERAL_EXPR:
      return reinterpret_cast<const CompoundLiteralExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CompoundLiteralExpr::initializer(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CompoundLiteralExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

bool CompoundLiteralExpr::is_file_scope(void) const {
  return impl->reader.getVal89();
}

gap::generator<ChooseExpr> ChooseExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ChooseExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ChooseExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ChooseExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ChooseExpr> ChooseExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ChooseExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ChooseExpr> ChooseExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ChooseExpr> ChooseExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ChooseExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ChooseExpr> ChooseExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ChooseExpr::contains(const Decl &decl) {
  for (auto &parent : ChooseExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ChooseExpr::contains(const Stmt &stmt) {
  for (auto &parent : ChooseExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ChooseExpr> ChooseExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ChooseExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kChooseExprDerivedKinds[] = {
    ChooseExpr::static_kind(),
};

gap::generator<ChooseExpr> ChooseExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kChooseExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ChooseExpr> e = ChooseExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ChooseExpr> ChooseExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kChooseExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ChooseExpr> e = ChooseExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ChooseExpr> ChooseExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ChooseExpr> ChooseExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ChooseExpr> ChooseExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CHOOSE_EXPR:
      return reinterpret_cast<const ChooseExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ChooseExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr ChooseExpr::chosen_sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ChooseExpr::condition(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ChooseExpr::lhs(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ChooseExpr::rhs(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ChooseExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

bool ChooseExpr::is_condition_dependent(void) const {
  return impl->reader.getVal89();
}

bool ChooseExpr::is_condition_true(void) const {
  return impl->reader.getVal90();
}

gap::generator<CharacterLiteral> CharacterLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CharacterLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CharacterLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CharacterLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CharacterLiteral> CharacterLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CharacterLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CharacterLiteral> CharacterLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CharacterLiteral> CharacterLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CharacterLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CharacterLiteral> CharacterLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CharacterLiteral::contains(const Decl &decl) {
  for (auto &parent : CharacterLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CharacterLiteral::contains(const Stmt &stmt) {
  for (auto &parent : CharacterLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CharacterLiteral> CharacterLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CharacterLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCharacterLiteralDerivedKinds[] = {
    CharacterLiteral::static_kind(),
};

gap::generator<CharacterLiteral> CharacterLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCharacterLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CharacterLiteral> e = CharacterLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CharacterLiteral> CharacterLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCharacterLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CharacterLiteral> e = CharacterLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CharacterLiteral> CharacterLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CharacterLiteral> CharacterLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CharacterLiteral> CharacterLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CHARACTER_LITERAL:
      return reinterpret_cast<const CharacterLiteral &>(parent);
    default: return std::nullopt;
  }
}

CharacterLiteralCharacterKind CharacterLiteral::character_kind(void) const {
  return static_cast<CharacterLiteralCharacterKind>(impl->reader.getVal94());
}

Token CharacterLiteral::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<CastExpr> CastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CastExpr> CastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CastExpr> CastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CastExpr> CastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CastExpr> CastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CastExpr::contains(const Decl &decl) {
  for (auto &parent : CastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CastExpr> CastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCastExprDerivedKinds[] = {
    ImplicitCastExpr::static_kind(),
    ObjCBridgedCastExpr::static_kind(),
    BuiltinBitCastExpr::static_kind(),
    CStyleCastExpr::static_kind(),
    CXXFunctionalCastExpr::static_kind(),
    CXXReinterpretCastExpr::static_kind(),
    CXXStaticCastExpr::static_kind(),
    CXXAddrspaceCastExpr::static_kind(),
    CXXConstCastExpr::static_kind(),
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<CastExpr> CastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CastExpr> e = CastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CastExpr> CastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CastExpr> e = CastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CastExpr> CastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CastExpr> CastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CastExpr> CastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::IMPLICIT_CAST_EXPR:
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
    case mx::StmtKind::CXX_FUNCTIONAL_CAST_EXPR:
    case mx::StmtKind::C_STYLE_CAST_EXPR:
    case mx::StmtKind::BUILTIN_BIT_CAST_EXPR:
    case mx::StmtKind::OBJ_C_BRIDGED_CAST_EXPR:
      return reinterpret_cast<const CastExpr &>(parent);
    default: return std::nullopt;
  }
}

CastKind CastExpr::cast_kind(void) const {
  return static_cast<CastKind>(impl->reader.getVal94());
}

std::string_view CastExpr::cast_kind_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

std::optional<NamedDecl> CastExpr::conversion_function(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return NamedDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Expr CastExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CastExpr::sub_expression_as_written(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<FieldDecl> CastExpr::target_union_field(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal41();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FieldDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool CastExpr::has_stored_fp_features(void) const {
  return impl->reader.getVal89();
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ImplicitCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ImplicitCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ImplicitCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImplicitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImplicitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ImplicitCastExpr::contains(const Decl &decl) {
  for (auto &parent : ImplicitCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ImplicitCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : ImplicitCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ImplicitCastExpr> ImplicitCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ImplicitCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kImplicitCastExprDerivedKinds[] = {
    ImplicitCastExpr::static_kind(),
};

gap::generator<ImplicitCastExpr> ImplicitCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kImplicitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ImplicitCastExpr> e = ImplicitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImplicitCastExpr> ImplicitCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kImplicitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ImplicitCastExpr> e = ImplicitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImplicitCastExpr> ImplicitCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImplicitCastExpr> ImplicitCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImplicitCastExpr> ImplicitCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImplicitCastExpr> ImplicitCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::IMPLICIT_CAST_EXPR:
      return reinterpret_cast<const ImplicitCastExpr &>(parent);
    default: return std::nullopt;
  }
}

bool ImplicitCastExpr::is_part_of_explicit_cast(void) const {
  return impl->reader.getVal90();
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExplicitCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExplicitCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExplicitCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExplicitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExplicitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExplicitCastExpr::contains(const Decl &decl) {
  for (auto &parent : ExplicitCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExplicitCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : ExplicitCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ExplicitCastExpr> ExplicitCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ExplicitCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kExplicitCastExprDerivedKinds[] = {
    ObjCBridgedCastExpr::static_kind(),
    BuiltinBitCastExpr::static_kind(),
    CStyleCastExpr::static_kind(),
    CXXFunctionalCastExpr::static_kind(),
    CXXReinterpretCastExpr::static_kind(),
    CXXStaticCastExpr::static_kind(),
    CXXAddrspaceCastExpr::static_kind(),
    CXXConstCastExpr::static_kind(),
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<ExplicitCastExpr> ExplicitCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kExplicitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ExplicitCastExpr> e = ExplicitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExplicitCastExpr> ExplicitCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kExplicitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ExplicitCastExpr> e = ExplicitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExplicitCastExpr> ExplicitCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExplicitCastExpr> ExplicitCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExplicitCastExpr> ExplicitCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExplicitCastExpr> ExplicitCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
    case mx::StmtKind::CXX_FUNCTIONAL_CAST_EXPR:
    case mx::StmtKind::C_STYLE_CAST_EXPR:
    case mx::StmtKind::BUILTIN_BIT_CAST_EXPR:
    case mx::StmtKind::OBJ_C_BRIDGED_CAST_EXPR:
      return reinterpret_cast<const ExplicitCastExpr &>(parent);
    default: return std::nullopt;
  }
}

Type ExplicitCastExpr::type_as_written(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXNamedCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXNamedCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXNamedCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNamedCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNamedCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXNamedCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXNamedCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXNamedCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXNamedCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXNamedCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXNamedCastExprDerivedKinds[] = {
    CXXReinterpretCastExpr::static_kind(),
    CXXStaticCastExpr::static_kind(),
    CXXAddrspaceCastExpr::static_kind(),
    CXXConstCastExpr::static_kind(),
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXNamedCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXNamedCastExpr> e = CXXNamedCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXNamedCastExpr> CXXNamedCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXNamedCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXNamedCastExpr> e = CXXNamedCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNamedCastExpr> CXXNamedCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
      return reinterpret_cast<const CXXNamedCastExpr &>(parent);
    default: return std::nullopt;
  }
}

TokenRange CXXNamedCastExpr::angle_brackets(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal43(), impl->reader.getVal44());
}

std::string_view CXXNamedCastExpr::cast_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal66();
  return std::string_view(data.cStr(), data.size());
}

Token CXXNamedCastExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

Token CXXNamedCastExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal46());
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDynamicCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDynamicCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDynamicCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDynamicCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDynamicCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDynamicCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXDynamicCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDynamicCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXDynamicCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXDynamicCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXDynamicCastExprDerivedKinds[] = {
    CXXDynamicCastExpr::static_kind(),
};

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXDynamicCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXDynamicCastExpr> e = CXXDynamicCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDynamicCastExpr> CXXDynamicCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXDynamicCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXDynamicCastExpr> e = CXXDynamicCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const CXXNamedCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDynamicCastExpr> CXXDynamicCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DYNAMIC_CAST_EXPR:
      return reinterpret_cast<const CXXDynamicCastExpr &>(parent);
    default: return std::nullopt;
  }
}

bool CXXDynamicCastExpr::is_always_null(void) const {
  return impl->reader.getVal90();
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXConstCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXConstCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXConstCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXConstCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXConstCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXConstCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXConstCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXConstCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXConstCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXConstCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXConstCastExprDerivedKinds[] = {
    CXXConstCastExpr::static_kind(),
};

gap::generator<CXXConstCastExpr> CXXConstCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXConstCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXConstCastExpr> e = CXXConstCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXConstCastExpr> CXXConstCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXConstCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXConstCastExpr> e = CXXConstCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const CXXNamedCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstCastExpr> CXXConstCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_CONST_CAST_EXPR:
      return reinterpret_cast<const CXXConstCastExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXAddrspaceCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXAddrspaceCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXAddrspaceCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXAddrspaceCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXAddrspaceCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXAddrspaceCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXAddrspaceCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXAddrspaceCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXAddrspaceCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXAddrspaceCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXAddrspaceCastExprDerivedKinds[] = {
    CXXAddrspaceCastExpr::static_kind(),
};

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXAddrspaceCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXAddrspaceCastExpr> e = CXXAddrspaceCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXAddrspaceCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXAddrspaceCastExpr> e = CXXAddrspaceCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const CXXNamedCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXAddrspaceCastExpr> CXXAddrspaceCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_ADDRSPACE_CAST_EXPR:
      return reinterpret_cast<const CXXAddrspaceCastExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXStaticCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXStaticCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXStaticCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXStaticCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXStaticCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXStaticCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXStaticCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXStaticCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXStaticCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXStaticCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXStaticCastExprDerivedKinds[] = {
    CXXStaticCastExpr::static_kind(),
};

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXStaticCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXStaticCastExpr> e = CXXStaticCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXStaticCastExpr> CXXStaticCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXStaticCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXStaticCastExpr> e = CXXStaticCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const CXXNamedCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStaticCastExpr> CXXStaticCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_STATIC_CAST_EXPR:
      return reinterpret_cast<const CXXStaticCastExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXReinterpretCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXReinterpretCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXReinterpretCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXReinterpretCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXReinterpretCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXReinterpretCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXReinterpretCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXReinterpretCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXReinterpretCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXReinterpretCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXReinterpretCastExprDerivedKinds[] = {
    CXXReinterpretCastExpr::static_kind(),
};

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXReinterpretCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXReinterpretCastExpr> e = CXXReinterpretCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXReinterpretCastExpr> CXXReinterpretCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXReinterpretCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXReinterpretCastExpr> e = CXXReinterpretCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const CXXNamedCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXReinterpretCastExpr> CXXReinterpretCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_REINTERPRET_CAST_EXPR:
      return reinterpret_cast<const CXXReinterpretCastExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXFunctionalCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXFunctionalCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXFunctionalCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXFunctionalCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXFunctionalCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXFunctionalCastExpr::contains(const Decl &decl) {
  for (auto &parent : CXXFunctionalCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXFunctionalCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXFunctionalCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXFunctionalCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXFunctionalCastExprDerivedKinds[] = {
    CXXFunctionalCastExpr::static_kind(),
};

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXFunctionalCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXFunctionalCastExpr> e = CXXFunctionalCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXFunctionalCastExpr> CXXFunctionalCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXFunctionalCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXFunctionalCastExpr> e = CXXFunctionalCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFunctionalCastExpr> CXXFunctionalCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_FUNCTIONAL_CAST_EXPR:
      return reinterpret_cast<const CXXFunctionalCastExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CXXFunctionalCastExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Token CXXFunctionalCastExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

bool CXXFunctionalCastExpr::is_list_initialization(void) const {
  return impl->reader.getVal90();
}

gap::generator<CStyleCastExpr> CStyleCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CStyleCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CStyleCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CStyleCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CStyleCastExpr> CStyleCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CStyleCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CStyleCastExpr> CStyleCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CStyleCastExpr> CStyleCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CStyleCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CStyleCastExpr> CStyleCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CStyleCastExpr::contains(const Decl &decl) {
  for (auto &parent : CStyleCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CStyleCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : CStyleCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CStyleCastExpr> CStyleCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CStyleCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCStyleCastExprDerivedKinds[] = {
    CStyleCastExpr::static_kind(),
};

gap::generator<CStyleCastExpr> CStyleCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCStyleCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CStyleCastExpr> e = CStyleCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CStyleCastExpr> CStyleCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCStyleCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CStyleCastExpr> e = CStyleCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CStyleCastExpr> CStyleCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CStyleCastExpr> CStyleCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CStyleCastExpr> CStyleCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CStyleCastExpr> CStyleCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CStyleCastExpr> CStyleCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::C_STYLE_CAST_EXPR:
      return reinterpret_cast<const CStyleCastExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CStyleCastExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Token CStyleCastExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BuiltinBitCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BuiltinBitCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BuiltinBitCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BuiltinBitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BuiltinBitCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BuiltinBitCastExpr::contains(const Decl &decl) {
  for (auto &parent : BuiltinBitCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BuiltinBitCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : BuiltinBitCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return BuiltinBitCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kBuiltinBitCastExprDerivedKinds[] = {
    BuiltinBitCastExpr::static_kind(),
};

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kBuiltinBitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<BuiltinBitCastExpr> e = BuiltinBitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BuiltinBitCastExpr> BuiltinBitCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kBuiltinBitCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<BuiltinBitCastExpr> e = BuiltinBitCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BuiltinBitCastExpr> BuiltinBitCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::BUILTIN_BIT_CAST_EXPR:
      return reinterpret_cast<const BuiltinBitCastExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBridgedCastExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBridgedCastExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBridgedCastExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBridgedCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBridgedCastExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCBridgedCastExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCBridgedCastExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCBridgedCastExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCBridgedCastExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCBridgedCastExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCBridgedCastExprDerivedKinds[] = {
    ObjCBridgedCastExpr::static_kind(),
};

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCBridgedCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCBridgedCastExpr> e = ObjCBridgedCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBridgedCastExpr> ObjCBridgedCastExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCBridgedCastExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBridgedCastExpr> e = ObjCBridgedCastExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::from(const ExplicitCastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::from(const CastExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBridgedCastExpr> ObjCBridgedCastExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_BRIDGED_CAST_EXPR:
      return reinterpret_cast<const ObjCBridgedCastExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCBridgedCastExpr::bridge_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

ObjCBridgeCastKind ObjCBridgedCastExpr::bridge_kind(void) const {
  return static_cast<ObjCBridgeCastKind>(impl->reader.getVal96());
}

std::string_view ObjCBridgedCastExpr::bridge_kind_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal66();
  return std::string_view(data.cStr(), data.size());
}

Token ObjCBridgedCastExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

gap::generator<CallExpr> CallExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CallExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CallExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CallExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CallExpr> CallExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CallExpr> CallExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CallExpr> CallExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CallExpr> CallExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CallExpr::contains(const Decl &decl) {
  for (auto &parent : CallExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CallExpr::contains(const Stmt &stmt) {
  for (auto &parent : CallExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CallExpr> CallExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CallExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCallExprDerivedKinds[] = {
    CallExpr::static_kind(),
    UserDefinedLiteral::static_kind(),
    CUDAKernelCallExpr::static_kind(),
    CXXMemberCallExpr::static_kind(),
    CXXOperatorCallExpr::static_kind(),
};

gap::generator<CallExpr> CallExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CallExpr> e = CallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CallExpr> CallExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CallExpr> e = CallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CallExpr> CallExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CallExpr> CallExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CallExpr> CallExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CALL_EXPR:
    case mx::StmtKind::CXX_OPERATOR_CALL_EXPR:
    case mx::StmtKind::CXX_MEMBER_CALL_EXPR:
    case mx::StmtKind::CUDA_KERNEL_CALL_EXPR:
    case mx::StmtKind::USER_DEFINED_LITERAL:
      return reinterpret_cast<const CallExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CallExpr::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> CallExpr::arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

CallExprADLCallKind CallExpr::adl_call_kind(void) const {
  return static_cast<CallExprADLCallKind>(impl->reader.getVal94());
}

Type CallExpr::call_return_type(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr CallExpr::callee(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Decl> CallExpr::callee_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal40();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<FunctionDecl> CallExpr::direct_callee(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal41();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token CallExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

std::optional<Attr> CallExpr::unused_result_attribute(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal43();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->AttrFor(impl->ep, eid)) {
      return Attr(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool CallExpr::has_stored_fp_features(void) const {
  return impl->reader.getVal89();
}

bool CallExpr::has_unused_result_attribute(void) const {
  return impl->reader.getVal90();
}

bool CallExpr::is_builtin_assume_false(void) const {
  return impl->reader.getVal91();
}

bool CallExpr::is_call_to_std_move(void) const {
  return impl->reader.getVal92();
}

bool CallExpr::is_unevaluated_builtin_call(void) const {
  return impl->reader.getVal93();
}

bool CallExpr::uses_adl(void) const {
  return impl->reader.getVal95();
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXOperatorCallExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXOperatorCallExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXOperatorCallExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXOperatorCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXOperatorCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXOperatorCallExpr::contains(const Decl &decl) {
  for (auto &parent : CXXOperatorCallExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXOperatorCallExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXOperatorCallExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXOperatorCallExpr> CXXOperatorCallExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXOperatorCallExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXOperatorCallExprDerivedKinds[] = {
    CXXOperatorCallExpr::static_kind(),
};

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXOperatorCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXOperatorCallExpr> e = CXXOperatorCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXOperatorCallExpr> CXXOperatorCallExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXOperatorCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXOperatorCallExpr> e = CXXOperatorCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXOperatorCallExpr> CXXOperatorCallExpr::from(const CallExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXOperatorCallExpr> CXXOperatorCallExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXOperatorCallExpr> CXXOperatorCallExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXOperatorCallExpr> CXXOperatorCallExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_OPERATOR_CALL_EXPR:
      return reinterpret_cast<const CXXOperatorCallExpr &>(parent);
    default: return std::nullopt;
  }
}

OverloadedOperatorKind CXXOperatorCallExpr::operator_(void) const {
  return static_cast<OverloadedOperatorKind>(impl->reader.getVal96());
}

Token CXXOperatorCallExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

bool CXXOperatorCallExpr::is_assignment_operation(void) const {
  return impl->reader.getVal97();
}

bool CXXOperatorCallExpr::is_comparison_operation(void) const {
  return impl->reader.getVal98();
}

bool CXXOperatorCallExpr::is_infix_binary_operation(void) const {
  return impl->reader.getVal99();
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXMemberCallExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXMemberCallExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXMemberCallExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXMemberCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXMemberCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXMemberCallExpr::contains(const Decl &decl) {
  for (auto &parent : CXXMemberCallExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXMemberCallExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXMemberCallExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXMemberCallExpr> CXXMemberCallExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXMemberCallExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXMemberCallExprDerivedKinds[] = {
    CXXMemberCallExpr::static_kind(),
};

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXMemberCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXMemberCallExpr> e = CXXMemberCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXMemberCallExpr> CXXMemberCallExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXMemberCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXMemberCallExpr> e = CXXMemberCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXMemberCallExpr> CXXMemberCallExpr::from(const CallExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXMemberCallExpr> CXXMemberCallExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXMemberCallExpr> CXXMemberCallExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXMemberCallExpr> CXXMemberCallExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_MEMBER_CALL_EXPR:
      return reinterpret_cast<const CXXMemberCallExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXMemberCallExpr::implicit_object_argument(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<CXXMethodDecl> CXXMemberCallExpr::method_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal45();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXMethodDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type CXXMemberCallExpr::object_type(void) const {
  RawEntityId eid = impl->reader.getVal46();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

CXXRecordDecl CXXMemberCallExpr::record_declaration(void) const {
  RawEntityId eid = impl->reader.getVal47();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CUDAKernelCallExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CUDAKernelCallExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CUDAKernelCallExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CUDAKernelCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CUDAKernelCallExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CUDAKernelCallExpr::contains(const Decl &decl) {
  for (auto &parent : CUDAKernelCallExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CUDAKernelCallExpr::contains(const Stmt &stmt) {
  for (auto &parent : CUDAKernelCallExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CUDAKernelCallExpr> CUDAKernelCallExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CUDAKernelCallExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCUDAKernelCallExprDerivedKinds[] = {
    CUDAKernelCallExpr::static_kind(),
};

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCUDAKernelCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CUDAKernelCallExpr> e = CUDAKernelCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CUDAKernelCallExpr> CUDAKernelCallExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCUDAKernelCallExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CUDAKernelCallExpr> e = CUDAKernelCallExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CUDAKernelCallExpr> CUDAKernelCallExpr::from(const CallExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CUDAKernelCallExpr> CUDAKernelCallExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CUDAKernelCallExpr> CUDAKernelCallExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CUDAKernelCallExpr> CUDAKernelCallExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CUDA_KERNEL_CALL_EXPR:
      return reinterpret_cast<const CUDAKernelCallExpr &>(parent);
    default: return std::nullopt;
  }
}

CallExpr CUDAKernelCallExpr::config(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return CallExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UserDefinedLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UserDefinedLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UserDefinedLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UserDefinedLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UserDefinedLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UserDefinedLiteral::contains(const Decl &decl) {
  for (auto &parent : UserDefinedLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UserDefinedLiteral::contains(const Stmt &stmt) {
  for (auto &parent : UserDefinedLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<UserDefinedLiteral> UserDefinedLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return UserDefinedLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kUserDefinedLiteralDerivedKinds[] = {
    UserDefinedLiteral::static_kind(),
};

gap::generator<UserDefinedLiteral> UserDefinedLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kUserDefinedLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<UserDefinedLiteral> e = UserDefinedLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UserDefinedLiteral> UserDefinedLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kUserDefinedLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<UserDefinedLiteral> e = UserDefinedLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UserDefinedLiteral> UserDefinedLiteral::from(const CallExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UserDefinedLiteral> UserDefinedLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UserDefinedLiteral> UserDefinedLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UserDefinedLiteral> UserDefinedLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::USER_DEFINED_LITERAL:
      return reinterpret_cast<const UserDefinedLiteral &>(parent);
    default: return std::nullopt;
  }
}

Expr UserDefinedLiteral::cooked_literal(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

UserDefinedLiteralLiteralOperatorKind UserDefinedLiteral::literal_operator_kind(void) const {
  return static_cast<UserDefinedLiteralLiteralOperatorKind>(impl->reader.getVal96());
}

Token UserDefinedLiteral::ud_suffix_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXUuidofExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXUuidofExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXUuidofExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXUuidofExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXUuidofExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXUuidofExpr::contains(const Decl &decl) {
  for (auto &parent : CXXUuidofExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXUuidofExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXUuidofExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXUuidofExpr> CXXUuidofExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXUuidofExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXUuidofExprDerivedKinds[] = {
    CXXUuidofExpr::static_kind(),
};

gap::generator<CXXUuidofExpr> CXXUuidofExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXUuidofExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXUuidofExpr> e = CXXUuidofExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXUuidofExpr> CXXUuidofExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXUuidofExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXUuidofExpr> e = CXXUuidofExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXUuidofExpr> CXXUuidofExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXUuidofExpr> CXXUuidofExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXUuidofExpr> CXXUuidofExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_UUIDOF_EXPR:
      return reinterpret_cast<const CXXUuidofExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXUuidofExpr::expression_operand(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

MSGuidDecl CXXUuidofExpr::guid_declaration(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return MSGuidDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Type CXXUuidofExpr::type_operand(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type CXXUuidofExpr::type_operand_source_info(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool CXXUuidofExpr::is_type_operand(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXUnresolvedConstructExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXUnresolvedConstructExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXUnresolvedConstructExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXUnresolvedConstructExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXUnresolvedConstructExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXUnresolvedConstructExpr::contains(const Decl &decl) {
  for (auto &parent : CXXUnresolvedConstructExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXUnresolvedConstructExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXUnresolvedConstructExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXUnresolvedConstructExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXUnresolvedConstructExprDerivedKinds[] = {
    CXXUnresolvedConstructExpr::static_kind(),
};

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXUnresolvedConstructExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXUnresolvedConstructExpr> e = CXXUnresolvedConstructExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXUnresolvedConstructExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXUnresolvedConstructExpr> e = CXXUnresolvedConstructExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXUnresolvedConstructExpr> CXXUnresolvedConstructExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_UNRESOLVED_CONSTRUCT_EXPR:
      return reinterpret_cast<const CXXUnresolvedConstructExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXUnresolvedConstructExpr::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> CXXUnresolvedConstructExpr::arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Token CXXUnresolvedConstructExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token CXXUnresolvedConstructExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Type CXXUnresolvedConstructExpr::type_as_written(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool CXXUnresolvedConstructExpr::is_list_initialization(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXTypeidExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXTypeidExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXTypeidExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTypeidExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTypeidExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXTypeidExpr::contains(const Decl &decl) {
  for (auto &parent : CXXTypeidExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXTypeidExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXTypeidExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXTypeidExpr> CXXTypeidExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXTypeidExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXTypeidExprDerivedKinds[] = {
    CXXTypeidExpr::static_kind(),
};

gap::generator<CXXTypeidExpr> CXXTypeidExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXTypeidExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXTypeidExpr> e = CXXTypeidExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXTypeidExpr> CXXTypeidExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXTypeidExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXTypeidExpr> e = CXXTypeidExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXTypeidExpr> CXXTypeidExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXTypeidExpr> CXXTypeidExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXTypeidExpr> CXXTypeidExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_TYPEID_EXPR:
      return reinterpret_cast<const CXXTypeidExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXTypeidExpr::expression_operand(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type CXXTypeidExpr::type_operand(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type CXXTypeidExpr::type_operand_source_info(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<bool> CXXTypeidExpr::is_most_derived(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal89());
  }
  return std::nullopt;
}

bool CXXTypeidExpr::is_potentially_evaluated(void) const {
  return impl->reader.getVal91();
}

bool CXXTypeidExpr::is_type_operand(void) const {
  return impl->reader.getVal92();
}

gap::generator<CXXThrowExpr> CXXThrowExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXThrowExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXThrowExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXThrowExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXThrowExpr> CXXThrowExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXThrowExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXThrowExpr> CXXThrowExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXThrowExpr> CXXThrowExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXThrowExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXThrowExpr> CXXThrowExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXThrowExpr::contains(const Decl &decl) {
  for (auto &parent : CXXThrowExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXThrowExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXThrowExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXThrowExpr> CXXThrowExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXThrowExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXThrowExprDerivedKinds[] = {
    CXXThrowExpr::static_kind(),
};

gap::generator<CXXThrowExpr> CXXThrowExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXThrowExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXThrowExpr> e = CXXThrowExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXThrowExpr> CXXThrowExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXThrowExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXThrowExpr> e = CXXThrowExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXThrowExpr> CXXThrowExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXThrowExpr> CXXThrowExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXThrowExpr> CXXThrowExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_THROW_EXPR:
      return reinterpret_cast<const CXXThrowExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXThrowExpr::sub_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token CXXThrowExpr::throw_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

bool CXXThrowExpr::is_thrown_variable_in_scope(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXThisExpr> CXXThisExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXThisExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXThisExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXThisExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXThisExpr> CXXThisExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXThisExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXThisExpr> CXXThisExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXThisExpr> CXXThisExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXThisExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXThisExpr> CXXThisExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXThisExpr::contains(const Decl &decl) {
  for (auto &parent : CXXThisExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXThisExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXThisExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXThisExpr> CXXThisExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXThisExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXThisExprDerivedKinds[] = {
    CXXThisExpr::static_kind(),
};

gap::generator<CXXThisExpr> CXXThisExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXThisExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXThisExpr> e = CXXThisExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXThisExpr> CXXThisExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXThisExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXThisExpr> e = CXXThisExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXThisExpr> CXXThisExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXThisExpr> CXXThisExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXThisExpr> CXXThisExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_THIS_EXPR:
      return reinterpret_cast<const CXXThisExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CXXThisExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

bool CXXThisExpr::is_implicit(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXStdInitializerListExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXStdInitializerListExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXStdInitializerListExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXStdInitializerListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXStdInitializerListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXStdInitializerListExpr::contains(const Decl &decl) {
  for (auto &parent : CXXStdInitializerListExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXStdInitializerListExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXStdInitializerListExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXStdInitializerListExpr> CXXStdInitializerListExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXStdInitializerListExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXStdInitializerListExprDerivedKinds[] = {
    CXXStdInitializerListExpr::static_kind(),
};

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXStdInitializerListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXStdInitializerListExpr> e = CXXStdInitializerListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXStdInitializerListExpr> CXXStdInitializerListExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXStdInitializerListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXStdInitializerListExpr> e = CXXStdInitializerListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXStdInitializerListExpr> CXXStdInitializerListExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStdInitializerListExpr> CXXStdInitializerListExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXStdInitializerListExpr> CXXStdInitializerListExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_STD_INITIALIZER_LIST_EXPR:
      return reinterpret_cast<const CXXStdInitializerListExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXStdInitializerListExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXScalarValueInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXScalarValueInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXScalarValueInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXScalarValueInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXScalarValueInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXScalarValueInitExpr::contains(const Decl &decl) {
  for (auto &parent : CXXScalarValueInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXScalarValueInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXScalarValueInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXScalarValueInitExpr> CXXScalarValueInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXScalarValueInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXScalarValueInitExprDerivedKinds[] = {
    CXXScalarValueInitExpr::static_kind(),
};

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXScalarValueInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXScalarValueInitExpr> e = CXXScalarValueInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXScalarValueInitExpr> CXXScalarValueInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXScalarValueInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXScalarValueInitExpr> e = CXXScalarValueInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXScalarValueInitExpr> CXXScalarValueInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXScalarValueInitExpr> CXXScalarValueInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXScalarValueInitExpr> CXXScalarValueInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_SCALAR_VALUE_INIT_EXPR:
      return reinterpret_cast<const CXXScalarValueInitExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CXXScalarValueInitExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXRewrittenBinaryOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXRewrittenBinaryOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXRewrittenBinaryOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXRewrittenBinaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXRewrittenBinaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXRewrittenBinaryOperator::contains(const Decl &decl) {
  for (auto &parent : CXXRewrittenBinaryOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXRewrittenBinaryOperator::contains(const Stmt &stmt) {
  for (auto &parent : CXXRewrittenBinaryOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXRewrittenBinaryOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXRewrittenBinaryOperatorDerivedKinds[] = {
    CXXRewrittenBinaryOperator::static_kind(),
};

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXRewrittenBinaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXRewrittenBinaryOperator> e = CXXRewrittenBinaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXRewrittenBinaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXRewrittenBinaryOperator> e = CXXRewrittenBinaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXRewrittenBinaryOperator> CXXRewrittenBinaryOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_REWRITTEN_BINARY_OPERATOR:
      return reinterpret_cast<const CXXRewrittenBinaryOperator &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXRewrittenBinaryOperator::lhs(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

BinaryOperatorKind CXXRewrittenBinaryOperator::opcode(void) const {
  return static_cast<BinaryOperatorKind>(impl->reader.getVal94());
}

std::string_view CXXRewrittenBinaryOperator::opcode_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

BinaryOperatorKind CXXRewrittenBinaryOperator::operator_(void) const {
  return static_cast<BinaryOperatorKind>(impl->reader.getVal96());
}

Token CXXRewrittenBinaryOperator::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr CXXRewrittenBinaryOperator::rhs(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CXXRewrittenBinaryOperator::semantic_form(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool CXXRewrittenBinaryOperator::is_assignment_operation(void) const {
  return impl->reader.getVal89();
}

bool CXXRewrittenBinaryOperator::is_comparison_operation(void) const {
  return impl->reader.getVal90();
}

bool CXXRewrittenBinaryOperator::is_reversed(void) const {
  return impl->reader.getVal91();
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXPseudoDestructorExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXPseudoDestructorExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXPseudoDestructorExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXPseudoDestructorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXPseudoDestructorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXPseudoDestructorExpr::contains(const Decl &decl) {
  for (auto &parent : CXXPseudoDestructorExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXPseudoDestructorExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXPseudoDestructorExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXPseudoDestructorExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXPseudoDestructorExprDerivedKinds[] = {
    CXXPseudoDestructorExpr::static_kind(),
};

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXPseudoDestructorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXPseudoDestructorExpr> e = CXXPseudoDestructorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXPseudoDestructorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXPseudoDestructorExpr> e = CXXPseudoDestructorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXPseudoDestructorExpr> CXXPseudoDestructorExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_PSEUDO_DESTRUCTOR_EXPR:
      return reinterpret_cast<const CXXPseudoDestructorExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXPseudoDestructorExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXPseudoDestructorExpr::colon_colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Type CXXPseudoDestructorExpr::destroyed_type(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token CXXPseudoDestructorExpr::destroyed_type_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Token CXXPseudoDestructorExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

std::optional<Type> CXXPseudoDestructorExpr::scope_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal43();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token CXXPseudoDestructorExpr::tilde_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

bool CXXPseudoDestructorExpr::has_qualifier(void) const {
  return impl->reader.getVal89();
}

bool CXXPseudoDestructorExpr::is_arrow(void) const {
  return impl->reader.getVal90();
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXNullPtrLiteralExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXNullPtrLiteralExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXNullPtrLiteralExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNullPtrLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNullPtrLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXNullPtrLiteralExpr::contains(const Decl &decl) {
  for (auto &parent : CXXNullPtrLiteralExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXNullPtrLiteralExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXNullPtrLiteralExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXNullPtrLiteralExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXNullPtrLiteralExprDerivedKinds[] = {
    CXXNullPtrLiteralExpr::static_kind(),
};

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXNullPtrLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXNullPtrLiteralExpr> e = CXXNullPtrLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXNullPtrLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXNullPtrLiteralExpr> e = CXXNullPtrLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNullPtrLiteralExpr> CXXNullPtrLiteralExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_NULL_PTR_LITERAL_EXPR:
      return reinterpret_cast<const CXXNullPtrLiteralExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CXXNullPtrLiteralExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXNoexceptExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXNoexceptExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXNoexceptExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNoexceptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNoexceptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXNoexceptExpr::contains(const Decl &decl) {
  for (auto &parent : CXXNoexceptExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXNoexceptExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXNoexceptExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXNoexceptExpr> CXXNoexceptExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXNoexceptExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXNoexceptExprDerivedKinds[] = {
    CXXNoexceptExpr::static_kind(),
};

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXNoexceptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXNoexceptExpr> e = CXXNoexceptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXNoexceptExpr> CXXNoexceptExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXNoexceptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXNoexceptExpr> e = CXXNoexceptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXNoexceptExpr> CXXNoexceptExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNoexceptExpr> CXXNoexceptExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNoexceptExpr> CXXNoexceptExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_NOEXCEPT_EXPR:
      return reinterpret_cast<const CXXNoexceptExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXNoexceptExpr::operand(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool CXXNoexceptExpr::value(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXNewExpr> CXXNewExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXNewExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXNewExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXNewExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXNewExpr> CXXNewExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNewExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNewExpr> CXXNewExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXNewExpr> CXXNewExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXNewExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXNewExpr> CXXNewExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXNewExpr::contains(const Decl &decl) {
  for (auto &parent : CXXNewExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXNewExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXNewExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXNewExpr> CXXNewExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXNewExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXNewExprDerivedKinds[] = {
    CXXNewExpr::static_kind(),
};

gap::generator<CXXNewExpr> CXXNewExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXNewExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXNewExpr> e = CXXNewExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXNewExpr> CXXNewExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXNewExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXNewExpr> e = CXXNewExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXNewExpr> CXXNewExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNewExpr> CXXNewExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXNewExpr> CXXNewExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_NEW_EXPR:
      return reinterpret_cast<const CXXNewExpr &>(parent);
    default: return std::nullopt;
  }
}

bool CXXNewExpr::does_usual_array_delete_want_size(void) const {
  return impl->reader.getVal89();
}

Type CXXNewExpr::allocated_type(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Expr> CXXNewExpr::array_size(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal39();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<CXXConstructExpr> CXXNewExpr::construct_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal40();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return CXXConstructExpr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TokenRange CXXNewExpr::direct_initializer_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal41(), impl->reader.getVal42());
}

CXXNewExprInitializationStyle CXXNewExpr::initialization_style(void) const {
  return static_cast<CXXNewExprInitializationStyle>(impl->reader.getVal94());
}

std::optional<Expr> CXXNewExpr::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal43();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

FunctionDecl CXXNewExpr::operator_delete(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return FunctionDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

FunctionDecl CXXNewExpr::operator_new(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return FunctionDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

TokenRange CXXNewExpr::type_id_parentheses(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal46(), impl->reader.getVal47());
}

bool CXXNewExpr::has_initializer(void) const {
  return impl->reader.getVal90();
}

bool CXXNewExpr::is_array(void) const {
  return impl->reader.getVal91();
}

bool CXXNewExpr::is_global_new(void) const {
  return impl->reader.getVal92();
}

bool CXXNewExpr::is_parenthesis_type_id(void) const {
  return impl->reader.getVal93();
}

bool CXXNewExpr::pass_alignment(void) const {
  return impl->reader.getVal95();
}

std::optional<Expr> CXXNewExpr::nth_placement_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : placement_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> CXXNewExpr::placement_arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

bool CXXNewExpr::should_null_check_allocation(void) const {
  return impl->reader.getVal97();
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXInheritedCtorInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXInheritedCtorInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXInheritedCtorInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXInheritedCtorInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXInheritedCtorInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXInheritedCtorInitExpr::contains(const Decl &decl) {
  for (auto &parent : CXXInheritedCtorInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXInheritedCtorInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXInheritedCtorInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXInheritedCtorInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXInheritedCtorInitExprDerivedKinds[] = {
    CXXInheritedCtorInitExpr::static_kind(),
};

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXInheritedCtorInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXInheritedCtorInitExpr> e = CXXInheritedCtorInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXInheritedCtorInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXInheritedCtorInitExpr> e = CXXInheritedCtorInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXInheritedCtorInitExpr> CXXInheritedCtorInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_INHERITED_CTOR_INIT_EXPR:
      return reinterpret_cast<const CXXInheritedCtorInitExpr &>(parent);
    default: return std::nullopt;
  }
}

bool CXXInheritedCtorInitExpr::constructs_virtual_base(void) const {
  return impl->reader.getVal89();
}

CXXConstructExprConstructionKind CXXInheritedCtorInitExpr::construction_kind(void) const {
  return static_cast<CXXConstructExprConstructionKind>(impl->reader.getVal94());
}

CXXConstructorDecl CXXInheritedCtorInitExpr::constructor(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return CXXConstructorDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token CXXInheritedCtorInitExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

bool CXXInheritedCtorInitExpr::inherited_from_virtual_base(void) const {
  return impl->reader.getVal90();
}

gap::generator<CXXFoldExpr> CXXFoldExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXFoldExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXFoldExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXFoldExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXFoldExpr> CXXFoldExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXFoldExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXFoldExpr> CXXFoldExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXFoldExpr> CXXFoldExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXFoldExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXFoldExpr> CXXFoldExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXFoldExpr::contains(const Decl &decl) {
  for (auto &parent : CXXFoldExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXFoldExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXFoldExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXFoldExpr> CXXFoldExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXFoldExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXFoldExprDerivedKinds[] = {
    CXXFoldExpr::static_kind(),
};

gap::generator<CXXFoldExpr> CXXFoldExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXFoldExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXFoldExpr> e = CXXFoldExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXFoldExpr> CXXFoldExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXFoldExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXFoldExpr> e = CXXFoldExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXFoldExpr> CXXFoldExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFoldExpr> CXXFoldExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXFoldExpr> CXXFoldExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_FOLD_EXPR:
      return reinterpret_cast<const CXXFoldExpr &>(parent);
    default: return std::nullopt;
  }
}

UnresolvedLookupExpr CXXFoldExpr::callee(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return UnresolvedLookupExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXFoldExpr::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr CXXFoldExpr::initializer(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CXXFoldExpr::lhs(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXFoldExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

std::optional<unsigned> CXXFoldExpr::num_expansions(void) const {
  if (!impl->reader.getVal89()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal100());
  }
  return std::nullopt;
}

BinaryOperatorKind CXXFoldExpr::operator_(void) const {
  return static_cast<BinaryOperatorKind>(impl->reader.getVal94());
}

Expr CXXFoldExpr::pattern(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr CXXFoldExpr::rhs(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token CXXFoldExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

bool CXXFoldExpr::is_left_fold(void) const {
  return impl->reader.getVal90();
}

bool CXXFoldExpr::is_right_fold(void) const {
  return impl->reader.getVal91();
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDependentScopeMemberExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDependentScopeMemberExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDependentScopeMemberExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDependentScopeMemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDependentScopeMemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDependentScopeMemberExpr::contains(const Decl &decl) {
  for (auto &parent : CXXDependentScopeMemberExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDependentScopeMemberExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXDependentScopeMemberExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXDependentScopeMemberExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXDependentScopeMemberExprDerivedKinds[] = {
    CXXDependentScopeMemberExpr::static_kind(),
};

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXDependentScopeMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXDependentScopeMemberExpr> e = CXXDependentScopeMemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXDependentScopeMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXDependentScopeMemberExpr> e = CXXDependentScopeMemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDependentScopeMemberExpr> CXXDependentScopeMemberExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DEPENDENT_SCOPE_MEMBER_EXPR:
      return reinterpret_cast<const CXXDependentScopeMemberExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXDependentScopeMemberExpr::base(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type CXXDependentScopeMemberExpr::base_type(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<NamedDecl> CXXDependentScopeMemberExpr::first_qualifier_found_in_scope(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal40();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return NamedDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token CXXDependentScopeMemberExpr::l_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Token CXXDependentScopeMemberExpr::member_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

Token CXXDependentScopeMemberExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Token CXXDependentScopeMemberExpr::r_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

Token CXXDependentScopeMemberExpr::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

bool CXXDependentScopeMemberExpr::has_explicit_template_arguments(void) const {
  return impl->reader.getVal89();
}

bool CXXDependentScopeMemberExpr::has_template_keyword(void) const {
  return impl->reader.getVal90();
}

bool CXXDependentScopeMemberExpr::is_arrow(void) const {
  return impl->reader.getVal91();
}

bool CXXDependentScopeMemberExpr::is_implicit_access(void) const {
  return impl->reader.getVal92();
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDeleteExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDeleteExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDeleteExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDeleteExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDeleteExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDeleteExpr::contains(const Decl &decl) {
  for (auto &parent : CXXDeleteExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDeleteExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXDeleteExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXDeleteExpr> CXXDeleteExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXDeleteExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXDeleteExprDerivedKinds[] = {
    CXXDeleteExpr::static_kind(),
};

gap::generator<CXXDeleteExpr> CXXDeleteExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXDeleteExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXDeleteExpr> e = CXXDeleteExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDeleteExpr> CXXDeleteExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXDeleteExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXDeleteExpr> e = CXXDeleteExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDeleteExpr> CXXDeleteExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDeleteExpr> CXXDeleteExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDeleteExpr> CXXDeleteExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DELETE_EXPR:
      return reinterpret_cast<const CXXDeleteExpr &>(parent);
    default: return std::nullopt;
  }
}

bool CXXDeleteExpr::does_usual_array_delete_want_size(void) const {
  return impl->reader.getVal89();
}

Expr CXXDeleteExpr::argument(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type CXXDeleteExpr::destroyed_type(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

FunctionDecl CXXDeleteExpr::operator_delete(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return FunctionDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool CXXDeleteExpr::is_array_form(void) const {
  return impl->reader.getVal90();
}

bool CXXDeleteExpr::is_array_form_as_written(void) const {
  return impl->reader.getVal91();
}

bool CXXDeleteExpr::is_global_delete(void) const {
  return impl->reader.getVal92();
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDefaultInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDefaultInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDefaultInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDefaultInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDefaultInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDefaultInitExpr::contains(const Decl &decl) {
  for (auto &parent : CXXDefaultInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDefaultInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXDefaultInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXDefaultInitExpr> CXXDefaultInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXDefaultInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXDefaultInitExprDerivedKinds[] = {
    CXXDefaultInitExpr::static_kind(),
};

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXDefaultInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXDefaultInitExpr> e = CXXDefaultInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDefaultInitExpr> CXXDefaultInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXDefaultInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXDefaultInitExpr> e = CXXDefaultInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDefaultInitExpr> CXXDefaultInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDefaultInitExpr> CXXDefaultInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDefaultInitExpr> CXXDefaultInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DEFAULT_INIT_EXPR:
      return reinterpret_cast<const CXXDefaultInitExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXDefaultInitExpr::expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

FieldDecl CXXDefaultInitExpr::field(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return FieldDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token CXXDefaultInitExpr::used_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDefaultArgExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDefaultArgExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDefaultArgExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDefaultArgExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXDefaultArgExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDefaultArgExpr::contains(const Decl &decl) {
  for (auto &parent : CXXDefaultArgExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDefaultArgExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXDefaultArgExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXDefaultArgExpr> CXXDefaultArgExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXDefaultArgExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXDefaultArgExprDerivedKinds[] = {
    CXXDefaultArgExpr::static_kind(),
};

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXDefaultArgExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXDefaultArgExpr> e = CXXDefaultArgExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDefaultArgExpr> CXXDefaultArgExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXDefaultArgExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXDefaultArgExpr> e = CXXDefaultArgExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDefaultArgExpr> CXXDefaultArgExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDefaultArgExpr> CXXDefaultArgExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXDefaultArgExpr> CXXDefaultArgExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_DEFAULT_ARG_EXPR:
      return reinterpret_cast<const CXXDefaultArgExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXDefaultArgExpr::expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ParmVarDecl CXXDefaultArgExpr::parameter(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return ParmVarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token CXXDefaultArgExpr::used_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<CXXConstructExpr> CXXConstructExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXConstructExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXConstructExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXConstructExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXConstructExpr> CXXConstructExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXConstructExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstructExpr> CXXConstructExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXConstructExpr> CXXConstructExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXConstructExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstructExpr> CXXConstructExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXConstructExpr::contains(const Decl &decl) {
  for (auto &parent : CXXConstructExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXConstructExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXConstructExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXConstructExpr> CXXConstructExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXConstructExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXConstructExprDerivedKinds[] = {
    CXXConstructExpr::static_kind(),
    CXXTemporaryObjectExpr::static_kind(),
};

gap::generator<CXXConstructExpr> CXXConstructExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXConstructExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXConstructExpr> e = CXXConstructExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXConstructExpr> CXXConstructExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXConstructExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXConstructExpr> e = CXXConstructExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXConstructExpr> CXXConstructExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstructExpr> CXXConstructExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXConstructExpr> CXXConstructExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_CONSTRUCT_EXPR:
    case mx::StmtKind::CXX_TEMPORARY_OBJECT_EXPR:
      return reinterpret_cast<const CXXConstructExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> CXXConstructExpr::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> CXXConstructExpr::arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

CXXConstructExprConstructionKind CXXConstructExpr::construction_kind(void) const {
  return static_cast<CXXConstructExprConstructionKind>(impl->reader.getVal94());
}

CXXConstructorDecl CXXConstructExpr::constructor(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return CXXConstructorDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token CXXConstructExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

TokenRange CXXConstructExpr::parenthesis_or_brace_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal40(), impl->reader.getVal41());
}

bool CXXConstructExpr::had_multiple_candidates(void) const {
  return impl->reader.getVal89();
}

bool CXXConstructExpr::is_elidable(void) const {
  return impl->reader.getVal90();
}

bool CXXConstructExpr::is_list_initialization(void) const {
  return impl->reader.getVal91();
}

bool CXXConstructExpr::is_std_initializer_list_initialization(void) const {
  return impl->reader.getVal92();
}

bool CXXConstructExpr::requires_zero_initialization(void) const {
  return impl->reader.getVal93();
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXTemporaryObjectExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXTemporaryObjectExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXTemporaryObjectExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTemporaryObjectExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXTemporaryObjectExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXTemporaryObjectExpr::contains(const Decl &decl) {
  for (auto &parent : CXXTemporaryObjectExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXTemporaryObjectExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXTemporaryObjectExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXTemporaryObjectExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXTemporaryObjectExprDerivedKinds[] = {
    CXXTemporaryObjectExpr::static_kind(),
};

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXTemporaryObjectExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXTemporaryObjectExpr> e = CXXTemporaryObjectExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXTemporaryObjectExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXTemporaryObjectExpr> e = CXXTemporaryObjectExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::from(const CXXConstructExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXTemporaryObjectExpr> CXXTemporaryObjectExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_TEMPORARY_OBJECT_EXPR:
      return reinterpret_cast<const CXXTemporaryObjectExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXBoolLiteralExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXBoolLiteralExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXBoolLiteralExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXBoolLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXBoolLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXBoolLiteralExpr::contains(const Decl &decl) {
  for (auto &parent : CXXBoolLiteralExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXBoolLiteralExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXBoolLiteralExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXBoolLiteralExpr> CXXBoolLiteralExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXBoolLiteralExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXBoolLiteralExprDerivedKinds[] = {
    CXXBoolLiteralExpr::static_kind(),
};

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXBoolLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXBoolLiteralExpr> e = CXXBoolLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXBoolLiteralExpr> CXXBoolLiteralExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXBoolLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXBoolLiteralExpr> e = CXXBoolLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXBoolLiteralExpr> CXXBoolLiteralExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXBoolLiteralExpr> CXXBoolLiteralExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXBoolLiteralExpr> CXXBoolLiteralExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_BOOL_LITERAL_EXPR:
      return reinterpret_cast<const CXXBoolLiteralExpr &>(parent);
    default: return std::nullopt;
  }
}

Token CXXBoolLiteralExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

bool CXXBoolLiteralExpr::value(void) const {
  return impl->reader.getVal89();
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXBindTemporaryExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXBindTemporaryExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXBindTemporaryExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXBindTemporaryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CXXBindTemporaryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXBindTemporaryExpr::contains(const Decl &decl) {
  for (auto &parent : CXXBindTemporaryExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXBindTemporaryExpr::contains(const Stmt &stmt) {
  for (auto &parent : CXXBindTemporaryExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CXXBindTemporaryExpr> CXXBindTemporaryExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CXXBindTemporaryExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCXXBindTemporaryExprDerivedKinds[] = {
    CXXBindTemporaryExpr::static_kind(),
};

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCXXBindTemporaryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CXXBindTemporaryExpr> e = CXXBindTemporaryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXBindTemporaryExpr> CXXBindTemporaryExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCXXBindTemporaryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CXXBindTemporaryExpr> e = CXXBindTemporaryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXBindTemporaryExpr> CXXBindTemporaryExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXBindTemporaryExpr> CXXBindTemporaryExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CXXBindTemporaryExpr> CXXBindTemporaryExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CXX_BIND_TEMPORARY_EXPR:
      return reinterpret_cast<const CXXBindTemporaryExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr CXXBindTemporaryExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<BlockExpr> BlockExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BlockExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BlockExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BlockExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BlockExpr> BlockExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BlockExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BlockExpr> BlockExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BlockExpr> BlockExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BlockExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BlockExpr> BlockExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BlockExpr::contains(const Decl &decl) {
  for (auto &parent : BlockExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BlockExpr::contains(const Stmt &stmt) {
  for (auto &parent : BlockExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<BlockExpr> BlockExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return BlockExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kBlockExprDerivedKinds[] = {
    BlockExpr::static_kind(),
};

gap::generator<BlockExpr> BlockExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kBlockExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<BlockExpr> e = BlockExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BlockExpr> BlockExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kBlockExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<BlockExpr> e = BlockExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BlockExpr> BlockExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BlockExpr> BlockExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BlockExpr> BlockExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::BLOCK_EXPR:
      return reinterpret_cast<const BlockExpr &>(parent);
    default: return std::nullopt;
  }
}

BlockDecl BlockExpr::block_declaration(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return BlockDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Stmt BlockExpr::body(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Token BlockExpr::caret_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

FunctionProtoType BlockExpr::function_type(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return FunctionProtoType::from(Type(impl->ep->TypeFor(impl->ep, eid))).value();
}

gap::generator<BinaryOperator> BinaryOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BinaryOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BinaryOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BinaryOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BinaryOperator> BinaryOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BinaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BinaryOperator> BinaryOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BinaryOperator> BinaryOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BinaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BinaryOperator> BinaryOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BinaryOperator::contains(const Decl &decl) {
  for (auto &parent : BinaryOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BinaryOperator::contains(const Stmt &stmt) {
  for (auto &parent : BinaryOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<BinaryOperator> BinaryOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return BinaryOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kBinaryOperatorDerivedKinds[] = {
    BinaryOperator::static_kind(),
    CompoundAssignOperator::static_kind(),
};

gap::generator<BinaryOperator> BinaryOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kBinaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<BinaryOperator> e = BinaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BinaryOperator> BinaryOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kBinaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<BinaryOperator> e = BinaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BinaryOperator> BinaryOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BinaryOperator> BinaryOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BinaryOperator> BinaryOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::BINARY_OPERATOR:
    case mx::StmtKind::COMPOUND_ASSIGN_OPERATOR:
      return reinterpret_cast<const BinaryOperator &>(parent);
    default: return std::nullopt;
  }
}

Expr BinaryOperator::lhs(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

BinaryOperatorKind BinaryOperator::opcode(void) const {
  return static_cast<BinaryOperatorKind>(impl->reader.getVal94());
}

std::string_view BinaryOperator::opcode_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

Token BinaryOperator::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr BinaryOperator::rhs(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool BinaryOperator::has_stored_fp_features(void) const {
  return impl->reader.getVal89();
}

bool BinaryOperator::is_additive_operation(void) const {
  return impl->reader.getVal90();
}

bool BinaryOperator::is_assignment_operation(void) const {
  return impl->reader.getVal91();
}

bool BinaryOperator::is_bitwise_operation(void) const {
  return impl->reader.getVal92();
}

bool BinaryOperator::is_comma_operation(void) const {
  return impl->reader.getVal93();
}

bool BinaryOperator::is_comparison_operation(void) const {
  return impl->reader.getVal95();
}

bool BinaryOperator::is_compound_assignment_operation(void) const {
  return impl->reader.getVal97();
}

bool BinaryOperator::is_equality_operation(void) const {
  return impl->reader.getVal98();
}

bool BinaryOperator::is_logical_operation(void) const {
  return impl->reader.getVal99();
}

bool BinaryOperator::is_multiplicative_operation(void) const {
  return impl->reader.getVal101();
}

bool BinaryOperator::is_pointer_memory_operation(void) const {
  return impl->reader.getVal102();
}

bool BinaryOperator::is_relational_operation(void) const {
  return impl->reader.getVal103();
}

bool BinaryOperator::is_shift_assign_operation(void) const {
  return impl->reader.getVal104();
}

bool BinaryOperator::is_shift_operation(void) const {
  return impl->reader.getVal105();
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CompoundAssignOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CompoundAssignOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CompoundAssignOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundAssignOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CompoundAssignOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CompoundAssignOperator::contains(const Decl &decl) {
  for (auto &parent : CompoundAssignOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CompoundAssignOperator::contains(const Stmt &stmt) {
  for (auto &parent : CompoundAssignOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CompoundAssignOperator> CompoundAssignOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CompoundAssignOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCompoundAssignOperatorDerivedKinds[] = {
    CompoundAssignOperator::static_kind(),
};

gap::generator<CompoundAssignOperator> CompoundAssignOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCompoundAssignOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CompoundAssignOperator> e = CompoundAssignOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CompoundAssignOperator> CompoundAssignOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCompoundAssignOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CompoundAssignOperator> e = CompoundAssignOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CompoundAssignOperator> CompoundAssignOperator::from(const BinaryOperator &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CompoundAssignOperator> CompoundAssignOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CompoundAssignOperator> CompoundAssignOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CompoundAssignOperator> CompoundAssignOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::COMPOUND_ASSIGN_OPERATOR:
      return reinterpret_cast<const CompoundAssignOperator &>(parent);
    default: return std::nullopt;
  }
}

Type CompoundAssignOperator::computation_lhs_type(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type CompoundAssignOperator::computation_result_type(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

gap::generator<AtomicExpr> AtomicExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AtomicExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AtomicExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AtomicExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AtomicExpr> AtomicExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AtomicExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AtomicExpr> AtomicExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AtomicExpr> AtomicExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AtomicExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AtomicExpr> AtomicExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AtomicExpr::contains(const Decl &decl) {
  for (auto &parent : AtomicExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AtomicExpr::contains(const Stmt &stmt) {
  for (auto &parent : AtomicExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AtomicExpr> AtomicExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AtomicExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAtomicExprDerivedKinds[] = {
    AtomicExpr::static_kind(),
};

gap::generator<AtomicExpr> AtomicExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAtomicExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AtomicExpr> e = AtomicExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AtomicExpr> AtomicExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAtomicExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AtomicExpr> e = AtomicExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AtomicExpr> AtomicExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AtomicExpr> AtomicExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AtomicExpr> AtomicExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ATOMIC_EXPR:
      return reinterpret_cast<const AtomicExpr &>(parent);
    default: return std::nullopt;
  }
}

Token AtomicExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

AtomicExprAtomicOp AtomicExpr::operation(void) const {
  return static_cast<AtomicExprAtomicOp>(impl->reader.getVal94());
}

Expr AtomicExpr::order(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> AtomicExpr::order_fail(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal40();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Expr AtomicExpr::pointer(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token AtomicExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

std::optional<Expr> AtomicExpr::scope(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal43();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Expr> AtomicExpr::value1(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal44();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Expr> AtomicExpr::value2(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal45();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type AtomicExpr::value_type(void) const {
  RawEntityId eid = impl->reader.getVal46();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Expr> AtomicExpr::weak(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal47();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool AtomicExpr::is_cmp_x_chg(void) const {
  return impl->reader.getVal89();
}

bool AtomicExpr::is_open_cl(void) const {
  return impl->reader.getVal90();
}

bool AtomicExpr::is_volatile(void) const {
  return impl->reader.getVal91();
}

std::optional<Expr> AtomicExpr::nth_sub_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : sub_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> AtomicExpr::sub_expressions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<AsTypeExpr> AsTypeExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AsTypeExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AsTypeExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AsTypeExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AsTypeExpr> AsTypeExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AsTypeExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AsTypeExpr> AsTypeExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AsTypeExpr> AsTypeExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AsTypeExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AsTypeExpr> AsTypeExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AsTypeExpr::contains(const Decl &decl) {
  for (auto &parent : AsTypeExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AsTypeExpr::contains(const Stmt &stmt) {
  for (auto &parent : AsTypeExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AsTypeExpr> AsTypeExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AsTypeExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAsTypeExprDerivedKinds[] = {
    AsTypeExpr::static_kind(),
};

gap::generator<AsTypeExpr> AsTypeExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAsTypeExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AsTypeExpr> e = AsTypeExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AsTypeExpr> AsTypeExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAsTypeExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AsTypeExpr> e = AsTypeExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AsTypeExpr> AsTypeExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AsTypeExpr> AsTypeExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AsTypeExpr> AsTypeExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::AS_TYPE_EXPR:
      return reinterpret_cast<const AsTypeExpr &>(parent);
    default: return std::nullopt;
  }
}

Token AsTypeExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token AsTypeExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr AsTypeExpr::src_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArrayTypeTraitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArrayTypeTraitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArrayTypeTraitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayTypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayTypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ArrayTypeTraitExpr::contains(const Decl &decl) {
  for (auto &parent : ArrayTypeTraitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ArrayTypeTraitExpr::contains(const Stmt &stmt) {
  for (auto &parent : ArrayTypeTraitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ArrayTypeTraitExpr> ArrayTypeTraitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ArrayTypeTraitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kArrayTypeTraitExprDerivedKinds[] = {
    ArrayTypeTraitExpr::static_kind(),
};

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kArrayTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ArrayTypeTraitExpr> e = ArrayTypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArrayTypeTraitExpr> ArrayTypeTraitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kArrayTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ArrayTypeTraitExpr> e = ArrayTypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArrayTypeTraitExpr> ArrayTypeTraitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayTypeTraitExpr> ArrayTypeTraitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayTypeTraitExpr> ArrayTypeTraitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ARRAY_TYPE_TRAIT_EXPR:
      return reinterpret_cast<const ArrayTypeTraitExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ArrayTypeTraitExpr::dimension_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type ArrayTypeTraitExpr::queried_type(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ArrayTypeTrait ArrayTypeTraitExpr::trait(void) const {
  return static_cast<ArrayTypeTrait>(impl->reader.getVal94());
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArraySubscriptExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArraySubscriptExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArraySubscriptExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArraySubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArraySubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ArraySubscriptExpr::contains(const Decl &decl) {
  for (auto &parent : ArraySubscriptExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ArraySubscriptExpr::contains(const Stmt &stmt) {
  for (auto &parent : ArraySubscriptExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ArraySubscriptExpr> ArraySubscriptExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ArraySubscriptExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kArraySubscriptExprDerivedKinds[] = {
    ArraySubscriptExpr::static_kind(),
};

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kArraySubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ArraySubscriptExpr> e = ArraySubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArraySubscriptExpr> ArraySubscriptExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kArraySubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ArraySubscriptExpr> e = ArraySubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArraySubscriptExpr> ArraySubscriptExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArraySubscriptExpr> ArraySubscriptExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArraySubscriptExpr> ArraySubscriptExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ARRAY_SUBSCRIPT_EXPR:
      return reinterpret_cast<const ArraySubscriptExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ArraySubscriptExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ArraySubscriptExpr::index(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ArraySubscriptExpr::lhs(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ArraySubscriptExpr::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Expr ArraySubscriptExpr::rhs(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArrayInitLoopExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArrayInitLoopExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArrayInitLoopExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayInitLoopExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayInitLoopExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ArrayInitLoopExpr::contains(const Decl &decl) {
  for (auto &parent : ArrayInitLoopExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ArrayInitLoopExpr::contains(const Stmt &stmt) {
  for (auto &parent : ArrayInitLoopExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ArrayInitLoopExpr> ArrayInitLoopExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ArrayInitLoopExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kArrayInitLoopExprDerivedKinds[] = {
    ArrayInitLoopExpr::static_kind(),
};

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kArrayInitLoopExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ArrayInitLoopExpr> e = ArrayInitLoopExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArrayInitLoopExpr> ArrayInitLoopExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kArrayInitLoopExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ArrayInitLoopExpr> e = ArrayInitLoopExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArrayInitLoopExpr> ArrayInitLoopExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayInitLoopExpr> ArrayInitLoopExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayInitLoopExpr> ArrayInitLoopExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ARRAY_INIT_LOOP_EXPR:
      return reinterpret_cast<const ArrayInitLoopExpr &>(parent);
    default: return std::nullopt;
  }
}

OpaqueValueExpr ArrayInitLoopExpr::common_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return OpaqueValueExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ArrayInitLoopExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ArrayInitIndexExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ArrayInitIndexExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ArrayInitIndexExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayInitIndexExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ArrayInitIndexExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ArrayInitIndexExpr::contains(const Decl &decl) {
  for (auto &parent : ArrayInitIndexExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ArrayInitIndexExpr::contains(const Stmt &stmt) {
  for (auto &parent : ArrayInitIndexExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ArrayInitIndexExpr> ArrayInitIndexExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ArrayInitIndexExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kArrayInitIndexExprDerivedKinds[] = {
    ArrayInitIndexExpr::static_kind(),
};

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kArrayInitIndexExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ArrayInitIndexExpr> e = ArrayInitIndexExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ArrayInitIndexExpr> ArrayInitIndexExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kArrayInitIndexExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ArrayInitIndexExpr> e = ArrayInitIndexExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ArrayInitIndexExpr> ArrayInitIndexExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayInitIndexExpr> ArrayInitIndexExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ArrayInitIndexExpr> ArrayInitIndexExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ARRAY_INIT_INDEX_EXPR:
      return reinterpret_cast<const ArrayInitIndexExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<AddrLabelExpr> AddrLabelExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AddrLabelExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AddrLabelExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AddrLabelExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AddrLabelExpr> AddrLabelExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AddrLabelExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AddrLabelExpr> AddrLabelExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AddrLabelExpr> AddrLabelExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AddrLabelExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AddrLabelExpr> AddrLabelExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AddrLabelExpr::contains(const Decl &decl) {
  for (auto &parent : AddrLabelExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AddrLabelExpr::contains(const Stmt &stmt) {
  for (auto &parent : AddrLabelExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AddrLabelExpr> AddrLabelExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AddrLabelExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAddrLabelExprDerivedKinds[] = {
    AddrLabelExpr::static_kind(),
};

gap::generator<AddrLabelExpr> AddrLabelExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAddrLabelExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AddrLabelExpr> e = AddrLabelExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AddrLabelExpr> AddrLabelExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAddrLabelExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AddrLabelExpr> e = AddrLabelExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AddrLabelExpr> AddrLabelExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AddrLabelExpr> AddrLabelExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AddrLabelExpr> AddrLabelExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ADDR_LABEL_EXPR:
      return reinterpret_cast<const AddrLabelExpr &>(parent);
    default: return std::nullopt;
  }
}

Token AddrLabelExpr::amp_amp_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

LabelDecl AddrLabelExpr::label(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return LabelDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token AddrLabelExpr::label_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AbstractConditionalOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AbstractConditionalOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AbstractConditionalOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AbstractConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AbstractConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AbstractConditionalOperator::contains(const Decl &decl) {
  for (auto &parent : AbstractConditionalOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AbstractConditionalOperator::contains(const Stmt &stmt) {
  for (auto &parent : AbstractConditionalOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AbstractConditionalOperator> AbstractConditionalOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AbstractConditionalOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAbstractConditionalOperatorDerivedKinds[] = {
    BinaryConditionalOperator::static_kind(),
    ConditionalOperator::static_kind(),
};

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAbstractConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AbstractConditionalOperator> e = AbstractConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AbstractConditionalOperator> AbstractConditionalOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAbstractConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AbstractConditionalOperator> e = AbstractConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AbstractConditionalOperator> AbstractConditionalOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AbstractConditionalOperator> AbstractConditionalOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AbstractConditionalOperator> AbstractConditionalOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONDITIONAL_OPERATOR:
    case mx::StmtKind::BINARY_CONDITIONAL_OPERATOR:
      return reinterpret_cast<const AbstractConditionalOperator &>(parent);
    default: return std::nullopt;
  }
}

Token AbstractConditionalOperator::colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr AbstractConditionalOperator::condition(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr AbstractConditionalOperator::false_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token AbstractConditionalOperator::question_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Expr AbstractConditionalOperator::true_expression(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ConditionalOperator> ConditionalOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConditionalOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConditionalOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConditionalOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConditionalOperator> ConditionalOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConditionalOperator> ConditionalOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConditionalOperator> ConditionalOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConditionalOperator> ConditionalOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConditionalOperator::contains(const Decl &decl) {
  for (auto &parent : ConditionalOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConditionalOperator::contains(const Stmt &stmt) {
  for (auto &parent : ConditionalOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ConditionalOperator> ConditionalOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ConditionalOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kConditionalOperatorDerivedKinds[] = {
    ConditionalOperator::static_kind(),
};

gap::generator<ConditionalOperator> ConditionalOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ConditionalOperator> e = ConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConditionalOperator> ConditionalOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ConditionalOperator> e = ConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConditionalOperator> ConditionalOperator::from(const AbstractConditionalOperator &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConditionalOperator> ConditionalOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConditionalOperator> ConditionalOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConditionalOperator> ConditionalOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONDITIONAL_OPERATOR:
      return reinterpret_cast<const ConditionalOperator &>(parent);
    default: return std::nullopt;
  }
}

Expr ConditionalOperator::lhs(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ConditionalOperator::rhs(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BinaryConditionalOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BinaryConditionalOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BinaryConditionalOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BinaryConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = BinaryConditionalOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BinaryConditionalOperator::contains(const Decl &decl) {
  for (auto &parent : BinaryConditionalOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BinaryConditionalOperator::contains(const Stmt &stmt) {
  for (auto &parent : BinaryConditionalOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<BinaryConditionalOperator> BinaryConditionalOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return BinaryConditionalOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kBinaryConditionalOperatorDerivedKinds[] = {
    BinaryConditionalOperator::static_kind(),
};

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kBinaryConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<BinaryConditionalOperator> e = BinaryConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BinaryConditionalOperator> BinaryConditionalOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kBinaryConditionalOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<BinaryConditionalOperator> e = BinaryConditionalOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BinaryConditionalOperator> BinaryConditionalOperator::from(const AbstractConditionalOperator &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BinaryConditionalOperator> BinaryConditionalOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BinaryConditionalOperator> BinaryConditionalOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<BinaryConditionalOperator> BinaryConditionalOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::BINARY_CONDITIONAL_OPERATOR:
      return reinterpret_cast<const BinaryConditionalOperator &>(parent);
    default: return std::nullopt;
  }
}

Expr BinaryConditionalOperator::common(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

OpaqueValueExpr BinaryConditionalOperator::opaque_value(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return OpaqueValueExpr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<VAArgExpr> VAArgExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VAArgExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VAArgExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VAArgExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<VAArgExpr> VAArgExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = VAArgExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VAArgExpr> VAArgExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<VAArgExpr> VAArgExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = VAArgExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VAArgExpr> VAArgExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool VAArgExpr::contains(const Decl &decl) {
  for (auto &parent : VAArgExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool VAArgExpr::contains(const Stmt &stmt) {
  for (auto &parent : VAArgExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<VAArgExpr> VAArgExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return VAArgExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kVAArgExprDerivedKinds[] = {
    VAArgExpr::static_kind(),
};

gap::generator<VAArgExpr> VAArgExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kVAArgExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<VAArgExpr> e = VAArgExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VAArgExpr> VAArgExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kVAArgExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<VAArgExpr> e = VAArgExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VAArgExpr> VAArgExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<VAArgExpr> VAArgExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<VAArgExpr> VAArgExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::VA_ARG_EXPR:
      return reinterpret_cast<const VAArgExpr &>(parent);
    default: return std::nullopt;
  }
}

Token VAArgExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token VAArgExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr VAArgExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type VAArgExpr::written_type(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool VAArgExpr::is_microsoft_abi(void) const {
  return impl->reader.getVal89();
}

gap::generator<UnaryOperator> UnaryOperator::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnaryOperator::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnaryOperator::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnaryOperator::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnaryOperator> UnaryOperator::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnaryOperator> UnaryOperator::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnaryOperator> UnaryOperator::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnaryOperator::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnaryOperator> UnaryOperator::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnaryOperator::contains(const Decl &decl) {
  for (auto &parent : UnaryOperator::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnaryOperator::contains(const Stmt &stmt) {
  for (auto &parent : UnaryOperator::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<UnaryOperator> UnaryOperator::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return UnaryOperator::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kUnaryOperatorDerivedKinds[] = {
    UnaryOperator::static_kind(),
};

gap::generator<UnaryOperator> UnaryOperator::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kUnaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<UnaryOperator> e = UnaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnaryOperator> UnaryOperator::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kUnaryOperatorDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<UnaryOperator> e = UnaryOperator::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnaryOperator> UnaryOperator::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnaryOperator> UnaryOperator::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnaryOperator> UnaryOperator::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::UNARY_OPERATOR:
      return reinterpret_cast<const UnaryOperator &>(parent);
    default: return std::nullopt;
  }
}

bool UnaryOperator::can_overflow(void) const {
  return impl->reader.getVal89();
}

UnaryOperatorKind UnaryOperator::opcode(void) const {
  return static_cast<UnaryOperatorKind>(impl->reader.getVal94());
}

Token UnaryOperator::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr UnaryOperator::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool UnaryOperator::has_stored_fp_features(void) const {
  return impl->reader.getVal90();
}

bool UnaryOperator::is_arithmetic_operation(void) const {
  return impl->reader.getVal91();
}

bool UnaryOperator::is_decrement_operation(void) const {
  return impl->reader.getVal92();
}

bool UnaryOperator::is_increment_decrement_operation(void) const {
  return impl->reader.getVal93();
}

bool UnaryOperator::is_increment_operation(void) const {
  return impl->reader.getVal95();
}

bool UnaryOperator::is_postfix(void) const {
  return impl->reader.getVal97();
}

bool UnaryOperator::is_prefix(void) const {
  return impl->reader.getVal98();
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnaryExprOrTypeTraitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnaryExprOrTypeTraitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnaryExprOrTypeTraitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnaryExprOrTypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnaryExprOrTypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnaryExprOrTypeTraitExpr::contains(const Decl &decl) {
  for (auto &parent : UnaryExprOrTypeTraitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnaryExprOrTypeTraitExpr::contains(const Stmt &stmt) {
  for (auto &parent : UnaryExprOrTypeTraitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return UnaryExprOrTypeTraitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kUnaryExprOrTypeTraitExprDerivedKinds[] = {
    UnaryExprOrTypeTraitExpr::static_kind(),
};

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kUnaryExprOrTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<UnaryExprOrTypeTraitExpr> e = UnaryExprOrTypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kUnaryExprOrTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<UnaryExprOrTypeTraitExpr> e = UnaryExprOrTypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnaryExprOrTypeTraitExpr> UnaryExprOrTypeTraitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::UNARY_EXPR_OR_TYPE_TRAIT_EXPR:
      return reinterpret_cast<const UnaryExprOrTypeTraitExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> UnaryExprOrTypeTraitExpr::argument_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> UnaryExprOrTypeTraitExpr::argument_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal39();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

UnaryExprOrTypeTrait UnaryExprOrTypeTraitExpr::expression_or_trait_kind(void) const {
  return static_cast<UnaryExprOrTypeTrait>(impl->reader.getVal94());
}

Token UnaryExprOrTypeTraitExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token UnaryExprOrTypeTraitExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Type UnaryExprOrTypeTraitExpr::type_of_argument(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool UnaryExprOrTypeTraitExpr::is_argument_type(void) const {
  return impl->reader.getVal89();
}

gap::generator<TypoExpr> TypoExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypoExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypoExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypoExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypoExpr> TypoExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = TypoExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypoExpr> TypoExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypoExpr> TypoExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = TypoExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypoExpr> TypoExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypoExpr::contains(const Decl &decl) {
  for (auto &parent : TypoExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypoExpr::contains(const Stmt &stmt) {
  for (auto &parent : TypoExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<TypoExpr> TypoExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return TypoExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kTypoExprDerivedKinds[] = {
    TypoExpr::static_kind(),
};

gap::generator<TypoExpr> TypoExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kTypoExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<TypoExpr> e = TypoExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypoExpr> TypoExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kTypoExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<TypoExpr> e = TypoExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypoExpr> TypoExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<TypoExpr> TypoExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<TypoExpr> TypoExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::TYPO_EXPR:
      return reinterpret_cast<const TypoExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeTraitExpr> TypeTraitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeTraitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeTraitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeTraitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypeTraitExpr> TypeTraitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = TypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeTraitExpr> TypeTraitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypeTraitExpr> TypeTraitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = TypeTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeTraitExpr> TypeTraitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypeTraitExpr::contains(const Decl &decl) {
  for (auto &parent : TypeTraitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypeTraitExpr::contains(const Stmt &stmt) {
  for (auto &parent : TypeTraitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<TypeTraitExpr> TypeTraitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return TypeTraitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kTypeTraitExprDerivedKinds[] = {
    TypeTraitExpr::static_kind(),
};

gap::generator<TypeTraitExpr> TypeTraitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<TypeTraitExpr> e = TypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeTraitExpr> TypeTraitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kTypeTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<TypeTraitExpr> e = TypeTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeTraitExpr> TypeTraitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<TypeTraitExpr> TypeTraitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<TypeTraitExpr> TypeTraitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::TYPE_TRAIT_EXPR:
      return reinterpret_cast<const TypeTraitExpr &>(parent);
    default: return std::nullopt;
  }
}

TypeTrait TypeTraitExpr::trait(void) const {
  return static_cast<TypeTrait>(impl->reader.getVal94());
}

std::optional<bool> TypeTraitExpr::value(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal89());
  }
  return std::nullopt;
}

std::optional<Type> TypeTraitExpr::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> TypeTraitExpr::arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d15));
    }
  }
  co_return;
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SubstNonTypeTemplateParmPackExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SubstNonTypeTemplateParmPackExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SubstNonTypeTemplateParmPackExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SubstNonTypeTemplateParmPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SubstNonTypeTemplateParmPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SubstNonTypeTemplateParmPackExpr::contains(const Decl &decl) {
  for (auto &parent : SubstNonTypeTemplateParmPackExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SubstNonTypeTemplateParmPackExpr::contains(const Stmt &stmt) {
  for (auto &parent : SubstNonTypeTemplateParmPackExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SubstNonTypeTemplateParmPackExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSubstNonTypeTemplateParmPackExprDerivedKinds[] = {
    SubstNonTypeTemplateParmPackExpr::static_kind(),
};

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSubstNonTypeTemplateParmPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SubstNonTypeTemplateParmPackExpr> e = SubstNonTypeTemplateParmPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSubstNonTypeTemplateParmPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SubstNonTypeTemplateParmPackExpr> e = SubstNonTypeTemplateParmPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SubstNonTypeTemplateParmPackExpr> SubstNonTypeTemplateParmPackExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR:
      return reinterpret_cast<const SubstNonTypeTemplateParmPackExpr &>(parent);
    default: return std::nullopt;
  }
}

NonTypeTemplateParmDecl SubstNonTypeTemplateParmPackExpr::parameter_pack(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return NonTypeTemplateParmDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token SubstNonTypeTemplateParmPackExpr::parameter_pack_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SubstNonTypeTemplateParmExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SubstNonTypeTemplateParmExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SubstNonTypeTemplateParmExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SubstNonTypeTemplateParmExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SubstNonTypeTemplateParmExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SubstNonTypeTemplateParmExpr::contains(const Decl &decl) {
  for (auto &parent : SubstNonTypeTemplateParmExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SubstNonTypeTemplateParmExpr::contains(const Stmt &stmt) {
  for (auto &parent : SubstNonTypeTemplateParmExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SubstNonTypeTemplateParmExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSubstNonTypeTemplateParmExprDerivedKinds[] = {
    SubstNonTypeTemplateParmExpr::static_kind(),
};

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSubstNonTypeTemplateParmExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SubstNonTypeTemplateParmExpr> e = SubstNonTypeTemplateParmExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSubstNonTypeTemplateParmExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SubstNonTypeTemplateParmExpr> e = SubstNonTypeTemplateParmExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SubstNonTypeTemplateParmExpr> SubstNonTypeTemplateParmExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_EXPR:
      return reinterpret_cast<const SubstNonTypeTemplateParmExpr &>(parent);
    default: return std::nullopt;
  }
}

Token SubstNonTypeTemplateParmExpr::name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

NonTypeTemplateParmDecl SubstNonTypeTemplateParmExpr::parameter(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return NonTypeTemplateParmDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Type SubstNonTypeTemplateParmExpr::parameter_type(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr SubstNonTypeTemplateParmExpr::replacement(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool SubstNonTypeTemplateParmExpr::is_reference_parameter(void) const {
  return impl->reader.getVal89();
}

gap::generator<StringLiteral> StringLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StringLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StringLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StringLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<StringLiteral> StringLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = StringLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StringLiteral> StringLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<StringLiteral> StringLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = StringLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StringLiteral> StringLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool StringLiteral::contains(const Decl &decl) {
  for (auto &parent : StringLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool StringLiteral::contains(const Stmt &stmt) {
  for (auto &parent : StringLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<StringLiteral> StringLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return StringLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kStringLiteralDerivedKinds[] = {
    StringLiteral::static_kind(),
};

gap::generator<StringLiteral> StringLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kStringLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<StringLiteral> e = StringLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StringLiteral> StringLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kStringLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<StringLiteral> e = StringLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StringLiteral> StringLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<StringLiteral> StringLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<StringLiteral> StringLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::STRING_LITERAL:
      return reinterpret_cast<const StringLiteral &>(parent);
    default: return std::nullopt;
  }
}

std::optional<bool> StringLiteral::contains_non_ascii(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal89());
  }
  return std::nullopt;
}

std::optional<bool> StringLiteral::contains_non_ascii_or_null(void) const {
  if (!impl->reader.getVal92()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal91());
  }
  return std::nullopt;
}

std::string_view StringLiteral::bytes(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

StringLiteralStringKind StringLiteral::string_kind(void) const {
  return static_cast<StringLiteralStringKind>(impl->reader.getVal94());
}

std::optional<std::string_view> StringLiteral::string(void) const {
  if (!impl->reader.getVal93()) {
    return std::nullopt;
  } else {
    capnp::Text::Reader data = impl->reader.getVal66();
    return std::string_view(data.cStr(), data.size());
  }
  return std::nullopt;
}

bool StringLiteral::is_ordinary(void) const {
  return impl->reader.getVal95();
}

bool StringLiteral::is_pascal(void) const {
  return impl->reader.getVal97();
}

bool StringLiteral::is_utf16(void) const {
  return impl->reader.getVal98();
}

bool StringLiteral::is_utf32(void) const {
  return impl->reader.getVal99();
}

bool StringLiteral::is_utf8(void) const {
  return impl->reader.getVal101();
}

bool StringLiteral::is_wide(void) const {
  return impl->reader.getVal102();
}

gap::generator<StmtExpr> StmtExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StmtExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StmtExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StmtExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<StmtExpr> StmtExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = StmtExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StmtExpr> StmtExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<StmtExpr> StmtExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = StmtExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StmtExpr> StmtExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool StmtExpr::contains(const Decl &decl) {
  for (auto &parent : StmtExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool StmtExpr::contains(const Stmt &stmt) {
  for (auto &parent : StmtExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<StmtExpr> StmtExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return StmtExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kStmtExprDerivedKinds[] = {
    StmtExpr::static_kind(),
};

gap::generator<StmtExpr> StmtExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kStmtExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<StmtExpr> e = StmtExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StmtExpr> StmtExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kStmtExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<StmtExpr> e = StmtExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StmtExpr> StmtExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<StmtExpr> StmtExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<StmtExpr> StmtExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::STMT_EXPR:
      return reinterpret_cast<const StmtExpr &>(parent);
    default: return std::nullopt;
  }
}

Token StmtExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token StmtExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

CompoundStmt StmtExpr::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<SourceLocExpr> SourceLocExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SourceLocExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SourceLocExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SourceLocExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SourceLocExpr> SourceLocExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SourceLocExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SourceLocExpr> SourceLocExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SourceLocExpr> SourceLocExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SourceLocExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SourceLocExpr> SourceLocExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SourceLocExpr::contains(const Decl &decl) {
  for (auto &parent : SourceLocExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SourceLocExpr::contains(const Stmt &stmt) {
  for (auto &parent : SourceLocExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SourceLocExpr> SourceLocExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SourceLocExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSourceLocExprDerivedKinds[] = {
    SourceLocExpr::static_kind(),
};

gap::generator<SourceLocExpr> SourceLocExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSourceLocExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SourceLocExpr> e = SourceLocExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SourceLocExpr> SourceLocExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSourceLocExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SourceLocExpr> e = SourceLocExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SourceLocExpr> SourceLocExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SourceLocExpr> SourceLocExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SourceLocExpr> SourceLocExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SOURCE_LOC_EXPR:
      return reinterpret_cast<const SourceLocExpr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SourceLocExpr::builtin_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

SourceLocExprIdentKind SourceLocExpr::identifier_kind(void) const {
  return static_cast<SourceLocExprIdentKind>(impl->reader.getVal94());
}

Token SourceLocExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

bool SourceLocExpr::is_int_type(void) const {
  return impl->reader.getVal89();
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SizeOfPackExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SizeOfPackExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SizeOfPackExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SizeOfPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SizeOfPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SizeOfPackExpr::contains(const Decl &decl) {
  for (auto &parent : SizeOfPackExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SizeOfPackExpr::contains(const Stmt &stmt) {
  for (auto &parent : SizeOfPackExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SizeOfPackExpr> SizeOfPackExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SizeOfPackExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSizeOfPackExprDerivedKinds[] = {
    SizeOfPackExpr::static_kind(),
};

gap::generator<SizeOfPackExpr> SizeOfPackExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSizeOfPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SizeOfPackExpr> e = SizeOfPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SizeOfPackExpr> SizeOfPackExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSizeOfPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SizeOfPackExpr> e = SizeOfPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SizeOfPackExpr> SizeOfPackExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SizeOfPackExpr> SizeOfPackExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SizeOfPackExpr> SizeOfPackExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SIZE_OF_PACK_EXPR:
      return reinterpret_cast<const SizeOfPackExpr &>(parent);
    default: return std::nullopt;
  }
}

Token SizeOfPackExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

NamedDecl SizeOfPackExpr::pack(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<unsigned> SizeOfPackExpr::pack_length(void) const {
  if (!impl->reader.getVal89()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal100());
  }
  return std::nullopt;
}

Token SizeOfPackExpr::pack_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

std::optional<std::vector<TemplateArgument>> SizeOfPackExpr::partial_arguments(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal15();
  std::vector<TemplateArgument> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      vec.emplace_back(std::move(d15));
    }
  }
  return vec;
}

Token SizeOfPackExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

bool SizeOfPackExpr::is_partially_substituted(void) const {
  return impl->reader.getVal91();
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ShuffleVectorExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ShuffleVectorExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ShuffleVectorExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ShuffleVectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ShuffleVectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ShuffleVectorExpr::contains(const Decl &decl) {
  for (auto &parent : ShuffleVectorExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ShuffleVectorExpr::contains(const Stmt &stmt) {
  for (auto &parent : ShuffleVectorExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ShuffleVectorExpr> ShuffleVectorExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ShuffleVectorExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kShuffleVectorExprDerivedKinds[] = {
    ShuffleVectorExpr::static_kind(),
};

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kShuffleVectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ShuffleVectorExpr> e = ShuffleVectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ShuffleVectorExpr> ShuffleVectorExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kShuffleVectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ShuffleVectorExpr> e = ShuffleVectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ShuffleVectorExpr> ShuffleVectorExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ShuffleVectorExpr> ShuffleVectorExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ShuffleVectorExpr> ShuffleVectorExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SHUFFLE_VECTOR_EXPR:
      return reinterpret_cast<const ShuffleVectorExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ShuffleVectorExpr::builtin_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token ShuffleVectorExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SYCLUniqueStableNameExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SYCLUniqueStableNameExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SYCLUniqueStableNameExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SYCLUniqueStableNameExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SYCLUniqueStableNameExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SYCLUniqueStableNameExpr::contains(const Decl &decl) {
  for (auto &parent : SYCLUniqueStableNameExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SYCLUniqueStableNameExpr::contains(const Stmt &stmt) {
  for (auto &parent : SYCLUniqueStableNameExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SYCLUniqueStableNameExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSYCLUniqueStableNameExprDerivedKinds[] = {
    SYCLUniqueStableNameExpr::static_kind(),
};

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSYCLUniqueStableNameExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SYCLUniqueStableNameExpr> e = SYCLUniqueStableNameExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSYCLUniqueStableNameExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SYCLUniqueStableNameExpr> e = SYCLUniqueStableNameExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<SYCLUniqueStableNameExpr> SYCLUniqueStableNameExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SYCL_UNIQUE_STABLE_NAME_EXPR:
      return reinterpret_cast<const SYCLUniqueStableNameExpr &>(parent);
    default: return std::nullopt;
  }
}

std::string_view SYCLUniqueStableNameExpr::compute_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

Token SYCLUniqueStableNameExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token SYCLUniqueStableNameExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token SYCLUniqueStableNameExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<RequiresExpr> RequiresExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RequiresExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RequiresExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RequiresExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<RequiresExpr> RequiresExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = RequiresExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RequiresExpr> RequiresExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<RequiresExpr> RequiresExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = RequiresExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RequiresExpr> RequiresExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool RequiresExpr::contains(const Decl &decl) {
  for (auto &parent : RequiresExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool RequiresExpr::contains(const Stmt &stmt) {
  for (auto &parent : RequiresExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<RequiresExpr> RequiresExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return RequiresExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kRequiresExprDerivedKinds[] = {
    RequiresExpr::static_kind(),
};

gap::generator<RequiresExpr> RequiresExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kRequiresExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<RequiresExpr> e = RequiresExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RequiresExpr> RequiresExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kRequiresExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<RequiresExpr> e = RequiresExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RequiresExpr> RequiresExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<RequiresExpr> RequiresExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<RequiresExpr> RequiresExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::REQUIRES_EXPR:
      return reinterpret_cast<const RequiresExpr &>(parent);
    default: return std::nullopt;
  }
}

RequiresExprBodyDecl RequiresExpr::body(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return RequiresExprBodyDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<ParmVarDecl> RequiresExpr::nth_local_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : local_parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ParmVarDecl> RequiresExpr::local_parameters(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ParmVarDecl::from(Decl(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Token RequiresExpr::r_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token RequiresExpr::requires_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

bool RequiresExpr::is_satisfied(void) const {
  return impl->reader.getVal89();
}

gap::generator<RecoveryExpr> RecoveryExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RecoveryExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RecoveryExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RecoveryExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<RecoveryExpr> RecoveryExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = RecoveryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RecoveryExpr> RecoveryExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<RecoveryExpr> RecoveryExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = RecoveryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RecoveryExpr> RecoveryExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool RecoveryExpr::contains(const Decl &decl) {
  for (auto &parent : RecoveryExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool RecoveryExpr::contains(const Stmt &stmt) {
  for (auto &parent : RecoveryExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<RecoveryExpr> RecoveryExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return RecoveryExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kRecoveryExprDerivedKinds[] = {
    RecoveryExpr::static_kind(),
};

gap::generator<RecoveryExpr> RecoveryExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kRecoveryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<RecoveryExpr> e = RecoveryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RecoveryExpr> RecoveryExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kRecoveryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<RecoveryExpr> e = RecoveryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RecoveryExpr> RecoveryExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<RecoveryExpr> RecoveryExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<RecoveryExpr> RecoveryExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::RECOVERY_EXPR:
      return reinterpret_cast<const RecoveryExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> RecoveryExpr::nth_sub_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : sub_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> RecoveryExpr::sub_expressions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PseudoObjectExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PseudoObjectExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PseudoObjectExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PseudoObjectExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PseudoObjectExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool PseudoObjectExpr::contains(const Decl &decl) {
  for (auto &parent : PseudoObjectExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool PseudoObjectExpr::contains(const Stmt &stmt) {
  for (auto &parent : PseudoObjectExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<PseudoObjectExpr> PseudoObjectExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return PseudoObjectExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kPseudoObjectExprDerivedKinds[] = {
    PseudoObjectExpr::static_kind(),
};

gap::generator<PseudoObjectExpr> PseudoObjectExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kPseudoObjectExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<PseudoObjectExpr> e = PseudoObjectExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PseudoObjectExpr> PseudoObjectExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kPseudoObjectExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<PseudoObjectExpr> e = PseudoObjectExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PseudoObjectExpr> PseudoObjectExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PseudoObjectExpr> PseudoObjectExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PseudoObjectExpr> PseudoObjectExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::PSEUDO_OBJECT_EXPR:
      return reinterpret_cast<const PseudoObjectExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr PseudoObjectExpr::result_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr PseudoObjectExpr::syntactic_form(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> PseudoObjectExpr::nth_semantic(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : semantics()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> PseudoObjectExpr::semantics(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Expr> PseudoObjectExpr::nth_semantic_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : semantic_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> PseudoObjectExpr::semantic_expressions(void) const {
  auto list = impl->reader.getVal26();
  for (auto v : list) {
    EntityId id(v);
    if (auto d26 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d26)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<PredefinedExpr> PredefinedExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PredefinedExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PredefinedExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PredefinedExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PredefinedExpr> PredefinedExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PredefinedExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PredefinedExpr> PredefinedExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<PredefinedExpr> PredefinedExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PredefinedExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PredefinedExpr> PredefinedExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool PredefinedExpr::contains(const Decl &decl) {
  for (auto &parent : PredefinedExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool PredefinedExpr::contains(const Stmt &stmt) {
  for (auto &parent : PredefinedExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<PredefinedExpr> PredefinedExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return PredefinedExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kPredefinedExprDerivedKinds[] = {
    PredefinedExpr::static_kind(),
};

gap::generator<PredefinedExpr> PredefinedExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kPredefinedExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<PredefinedExpr> e = PredefinedExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PredefinedExpr> PredefinedExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kPredefinedExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<PredefinedExpr> e = PredefinedExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PredefinedExpr> PredefinedExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PredefinedExpr> PredefinedExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PredefinedExpr> PredefinedExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::PREDEFINED_EXPR:
      return reinterpret_cast<const PredefinedExpr &>(parent);
    default: return std::nullopt;
  }
}

StringLiteral PredefinedExpr::function_name(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return StringLiteral::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

PredefinedExprIdentKind PredefinedExpr::identifier_kind(void) const {
  return static_cast<PredefinedExprIdentKind>(impl->reader.getVal94());
}

std::string_view PredefinedExpr::identifier_kind_name(void) const {
  capnp::Text::Reader data = impl->reader.getVal61();
  return std::string_view(data.cStr(), data.size());
}

Token PredefinedExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

gap::generator<ParenListExpr> ParenListExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParenListExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParenListExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParenListExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ParenListExpr> ParenListExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ParenListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParenListExpr> ParenListExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ParenListExpr> ParenListExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ParenListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParenListExpr> ParenListExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ParenListExpr::contains(const Decl &decl) {
  for (auto &parent : ParenListExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ParenListExpr::contains(const Stmt &stmt) {
  for (auto &parent : ParenListExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ParenListExpr> ParenListExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ParenListExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kParenListExprDerivedKinds[] = {
    ParenListExpr::static_kind(),
};

gap::generator<ParenListExpr> ParenListExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kParenListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ParenListExpr> e = ParenListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParenListExpr> ParenListExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kParenListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ParenListExpr> e = ParenListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParenListExpr> ParenListExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ParenListExpr> ParenListExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ParenListExpr> ParenListExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::PAREN_LIST_EXPR:
      return reinterpret_cast<const ParenListExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ParenListExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token ParenListExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

std::optional<Expr> ParenListExpr::nth_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> ParenListExpr::expressions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ParenExpr> ParenExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParenExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParenExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParenExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ParenExpr> ParenExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ParenExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParenExpr> ParenExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ParenExpr> ParenExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ParenExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParenExpr> ParenExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ParenExpr::contains(const Decl &decl) {
  for (auto &parent : ParenExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ParenExpr::contains(const Stmt &stmt) {
  for (auto &parent : ParenExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ParenExpr> ParenExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ParenExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kParenExprDerivedKinds[] = {
    ParenExpr::static_kind(),
};

gap::generator<ParenExpr> ParenExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kParenExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ParenExpr> e = ParenExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParenExpr> ParenExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kParenExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ParenExpr> e = ParenExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParenExpr> ParenExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ParenExpr> ParenExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ParenExpr> ParenExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::PAREN_EXPR:
      return reinterpret_cast<const ParenExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ParenExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token ParenExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Expr ParenExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<PackExpansionExpr> PackExpansionExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PackExpansionExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PackExpansionExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PackExpansionExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PackExpansionExpr> PackExpansionExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PackExpansionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PackExpansionExpr> PackExpansionExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<PackExpansionExpr> PackExpansionExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = PackExpansionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PackExpansionExpr> PackExpansionExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool PackExpansionExpr::contains(const Decl &decl) {
  for (auto &parent : PackExpansionExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool PackExpansionExpr::contains(const Stmt &stmt) {
  for (auto &parent : PackExpansionExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<PackExpansionExpr> PackExpansionExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return PackExpansionExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kPackExpansionExprDerivedKinds[] = {
    PackExpansionExpr::static_kind(),
};

gap::generator<PackExpansionExpr> PackExpansionExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kPackExpansionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<PackExpansionExpr> e = PackExpansionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PackExpansionExpr> PackExpansionExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kPackExpansionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<PackExpansionExpr> e = PackExpansionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PackExpansionExpr> PackExpansionExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PackExpansionExpr> PackExpansionExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<PackExpansionExpr> PackExpansionExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::PACK_EXPANSION_EXPR:
      return reinterpret_cast<const PackExpansionExpr &>(parent);
    default: return std::nullopt;
  }
}

Token PackExpansionExpr::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

std::optional<unsigned> PackExpansionExpr::num_expansions(void) const {
  if (!impl->reader.getVal89()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal100());
  }
  return std::nullopt;
}

Expr PackExpansionExpr::pattern(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<OverloadExpr> OverloadExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OverloadExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OverloadExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OverloadExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OverloadExpr> OverloadExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OverloadExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OverloadExpr> OverloadExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OverloadExpr> OverloadExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OverloadExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OverloadExpr> OverloadExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OverloadExpr::contains(const Decl &decl) {
  for (auto &parent : OverloadExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OverloadExpr::contains(const Stmt &stmt) {
  for (auto &parent : OverloadExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OverloadExpr> OverloadExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OverloadExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOverloadExprDerivedKinds[] = {
    UnresolvedLookupExpr::static_kind(),
    UnresolvedMemberExpr::static_kind(),
};

gap::generator<OverloadExpr> OverloadExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOverloadExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OverloadExpr> e = OverloadExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OverloadExpr> OverloadExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOverloadExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OverloadExpr> e = OverloadExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OverloadExpr> OverloadExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OverloadExpr> OverloadExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OverloadExpr> OverloadExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::UNRESOLVED_MEMBER_EXPR:
    case mx::StmtKind::UNRESOLVED_LOOKUP_EXPR:
      return reinterpret_cast<const OverloadExpr &>(parent);
    default: return std::nullopt;
  }
}

Token OverloadExpr::l_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token OverloadExpr::name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

std::optional<CXXRecordDecl> OverloadExpr::naming_class(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal40();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXRecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token OverloadExpr::r_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Token OverloadExpr::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

bool OverloadExpr::has_explicit_template_arguments(void) const {
  return impl->reader.getVal89();
}

bool OverloadExpr::has_template_keyword(void) const {
  return impl->reader.getVal90();
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedMemberExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedMemberExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedMemberExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnresolvedMemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnresolvedMemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnresolvedMemberExpr::contains(const Decl &decl) {
  for (auto &parent : UnresolvedMemberExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnresolvedMemberExpr::contains(const Stmt &stmt) {
  for (auto &parent : UnresolvedMemberExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<UnresolvedMemberExpr> UnresolvedMemberExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return UnresolvedMemberExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kUnresolvedMemberExprDerivedKinds[] = {
    UnresolvedMemberExpr::static_kind(),
};

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kUnresolvedMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<UnresolvedMemberExpr> e = UnresolvedMemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedMemberExpr> UnresolvedMemberExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kUnresolvedMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedMemberExpr> e = UnresolvedMemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedMemberExpr> UnresolvedMemberExpr::from(const OverloadExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedMemberExpr> UnresolvedMemberExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedMemberExpr> UnresolvedMemberExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedMemberExpr> UnresolvedMemberExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::UNRESOLVED_MEMBER_EXPR:
      return reinterpret_cast<const UnresolvedMemberExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr UnresolvedMemberExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type UnresolvedMemberExpr::base_type(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token UnresolvedMemberExpr::member_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

Token UnresolvedMemberExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal46());
}

bool UnresolvedMemberExpr::has_unresolved_using(void) const {
  return impl->reader.getVal91();
}

bool UnresolvedMemberExpr::is_arrow(void) const {
  return impl->reader.getVal92();
}

bool UnresolvedMemberExpr::is_implicit_access(void) const {
  return impl->reader.getVal93();
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedLookupExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedLookupExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedLookupExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnresolvedLookupExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = UnresolvedLookupExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnresolvedLookupExpr::contains(const Decl &decl) {
  for (auto &parent : UnresolvedLookupExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnresolvedLookupExpr::contains(const Stmt &stmt) {
  for (auto &parent : UnresolvedLookupExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<UnresolvedLookupExpr> UnresolvedLookupExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return UnresolvedLookupExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kUnresolvedLookupExprDerivedKinds[] = {
    UnresolvedLookupExpr::static_kind(),
};

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kUnresolvedLookupExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<UnresolvedLookupExpr> e = UnresolvedLookupExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedLookupExpr> UnresolvedLookupExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kUnresolvedLookupExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedLookupExpr> e = UnresolvedLookupExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedLookupExpr> UnresolvedLookupExpr::from(const OverloadExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedLookupExpr> UnresolvedLookupExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedLookupExpr> UnresolvedLookupExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<UnresolvedLookupExpr> UnresolvedLookupExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::UNRESOLVED_LOOKUP_EXPR:
      return reinterpret_cast<const UnresolvedLookupExpr &>(parent);
    default: return std::nullopt;
  }
}

bool UnresolvedLookupExpr::is_overloaded(void) const {
  return impl->reader.getVal91();
}

bool UnresolvedLookupExpr::requires_adl(void) const {
  return impl->reader.getVal92();
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OpaqueValueExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OpaqueValueExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OpaqueValueExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OpaqueValueExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OpaqueValueExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OpaqueValueExpr::contains(const Decl &decl) {
  for (auto &parent : OpaqueValueExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OpaqueValueExpr::contains(const Stmt &stmt) {
  for (auto &parent : OpaqueValueExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OpaqueValueExpr> OpaqueValueExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OpaqueValueExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOpaqueValueExprDerivedKinds[] = {
    OpaqueValueExpr::static_kind(),
};

gap::generator<OpaqueValueExpr> OpaqueValueExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOpaqueValueExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OpaqueValueExpr> e = OpaqueValueExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OpaqueValueExpr> OpaqueValueExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOpaqueValueExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OpaqueValueExpr> e = OpaqueValueExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OpaqueValueExpr> OpaqueValueExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OpaqueValueExpr> OpaqueValueExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OpaqueValueExpr> OpaqueValueExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OPAQUE_VALUE_EXPR:
      return reinterpret_cast<const OpaqueValueExpr &>(parent);
    default: return std::nullopt;
  }
}

Token OpaqueValueExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr OpaqueValueExpr::source_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool OpaqueValueExpr::is_unique(void) const {
  return impl->reader.getVal89();
}

gap::generator<OffsetOfExpr> OffsetOfExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OffsetOfExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OffsetOfExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OffsetOfExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OffsetOfExpr> OffsetOfExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OffsetOfExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OffsetOfExpr> OffsetOfExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OffsetOfExpr> OffsetOfExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OffsetOfExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OffsetOfExpr> OffsetOfExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OffsetOfExpr::contains(const Decl &decl) {
  for (auto &parent : OffsetOfExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OffsetOfExpr::contains(const Stmt &stmt) {
  for (auto &parent : OffsetOfExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OffsetOfExpr> OffsetOfExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OffsetOfExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOffsetOfExprDerivedKinds[] = {
    OffsetOfExpr::static_kind(),
};

gap::generator<OffsetOfExpr> OffsetOfExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOffsetOfExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OffsetOfExpr> e = OffsetOfExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OffsetOfExpr> OffsetOfExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOffsetOfExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OffsetOfExpr> e = OffsetOfExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OffsetOfExpr> OffsetOfExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OffsetOfExpr> OffsetOfExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OffsetOfExpr> OffsetOfExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OFFSET_OF_EXPR:
      return reinterpret_cast<const OffsetOfExpr &>(parent);
    default: return std::nullopt;
  }
}

Token OffsetOfExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token OffsetOfExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCSubscriptRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCSubscriptRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCSubscriptRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCSubscriptRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCSubscriptRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCSubscriptRefExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCSubscriptRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCSubscriptRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCSubscriptRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCSubscriptRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCSubscriptRefExprDerivedKinds[] = {
    ObjCSubscriptRefExpr::static_kind(),
};

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCSubscriptRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCSubscriptRefExpr> e = ObjCSubscriptRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCSubscriptRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCSubscriptRefExpr> e = ObjCSubscriptRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCSubscriptRefExpr> ObjCSubscriptRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_SUBSCRIPT_REF_EXPR:
      return reinterpret_cast<const ObjCSubscriptRefExpr &>(parent);
    default: return std::nullopt;
  }
}

ObjCMethodDecl ObjCSubscriptRefExpr::at_index_method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Expr ObjCSubscriptRefExpr::base_expression(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr ObjCSubscriptRefExpr::key_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ObjCSubscriptRefExpr::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

bool ObjCSubscriptRefExpr::is_array_subscript_reference_expression(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCStringLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCStringLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCStringLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCStringLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCStringLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCStringLiteral::contains(const Decl &decl) {
  for (auto &parent : ObjCStringLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCStringLiteral::contains(const Stmt &stmt) {
  for (auto &parent : ObjCStringLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCStringLiteral> ObjCStringLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCStringLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCStringLiteralDerivedKinds[] = {
    ObjCStringLiteral::static_kind(),
};

gap::generator<ObjCStringLiteral> ObjCStringLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCStringLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCStringLiteral> e = ObjCStringLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCStringLiteral> ObjCStringLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCStringLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCStringLiteral> e = ObjCStringLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCStringLiteral> ObjCStringLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCStringLiteral> ObjCStringLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCStringLiteral> ObjCStringLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_STRING_LITERAL:
      return reinterpret_cast<const ObjCStringLiteral &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCStringLiteral::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

StringLiteral ObjCStringLiteral::string(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return StringLiteral::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCSelectorExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCSelectorExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCSelectorExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCSelectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCSelectorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCSelectorExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCSelectorExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCSelectorExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCSelectorExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCSelectorExpr> ObjCSelectorExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCSelectorExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCSelectorExprDerivedKinds[] = {
    ObjCSelectorExpr::static_kind(),
};

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCSelectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCSelectorExpr> e = ObjCSelectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCSelectorExpr> ObjCSelectorExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCSelectorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCSelectorExpr> e = ObjCSelectorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCSelectorExpr> ObjCSelectorExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCSelectorExpr> ObjCSelectorExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCSelectorExpr> ObjCSelectorExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_SELECTOR_EXPR:
      return reinterpret_cast<const ObjCSelectorExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCSelectorExpr::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token ObjCSelectorExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCProtocolExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCProtocolExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCProtocolExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCProtocolExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCProtocolExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCProtocolExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCProtocolExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCProtocolExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCProtocolExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCProtocolExpr> ObjCProtocolExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCProtocolExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCProtocolExprDerivedKinds[] = {
    ObjCProtocolExpr::static_kind(),
};

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCProtocolExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCProtocolExpr> e = ObjCProtocolExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCProtocolExpr> ObjCProtocolExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCProtocolExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCProtocolExpr> e = ObjCProtocolExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCProtocolExpr> ObjCProtocolExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCProtocolExpr> ObjCProtocolExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCProtocolExpr> ObjCProtocolExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_PROTOCOL_EXPR:
      return reinterpret_cast<const ObjCProtocolExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCProtocolExpr::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

ObjCProtocolDecl ObjCProtocolExpr::protocol(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return ObjCProtocolDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCProtocolExpr::protocol_id_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token ObjCProtocolExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCPropertyRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCPropertyRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCPropertyRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCPropertyRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCPropertyRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCPropertyRefExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCPropertyRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCPropertyRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCPropertyRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCPropertyRefExpr> ObjCPropertyRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCPropertyRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCPropertyRefExprDerivedKinds[] = {
    ObjCPropertyRefExpr::static_kind(),
};

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCPropertyRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCPropertyRefExpr> e = ObjCPropertyRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCPropertyRefExpr> ObjCPropertyRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCPropertyRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCPropertyRefExpr> e = ObjCPropertyRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCPropertyRefExpr> ObjCPropertyRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCPropertyRefExpr> ObjCPropertyRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCPropertyRefExpr> ObjCPropertyRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_PROPERTY_REF_EXPR:
      return reinterpret_cast<const ObjCPropertyRefExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCPropertyRefExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ObjCInterfaceDecl ObjCPropertyRefExpr::class_receiver(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCPropertyDecl ObjCPropertyRefExpr::explicit_property(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return ObjCPropertyDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCMethodDecl ObjCPropertyRefExpr::implicit_property_getter(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCMethodDecl ObjCPropertyRefExpr::implicit_property_setter(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCPropertyRefExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Token ObjCPropertyRefExpr::receiver_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

Type ObjCPropertyRefExpr::receiver_type(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ObjCPropertyRefExpr::super_receiver_type(void) const {
  RawEntityId eid = impl->reader.getVal46();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ObjCPropertyRefExpr::is_class_receiver(void) const {
  return impl->reader.getVal89();
}

bool ObjCPropertyRefExpr::is_explicit_property(void) const {
  return impl->reader.getVal90();
}

bool ObjCPropertyRefExpr::is_implicit_property(void) const {
  return impl->reader.getVal91();
}

bool ObjCPropertyRefExpr::is_messaging_getter(void) const {
  return impl->reader.getVal92();
}

bool ObjCPropertyRefExpr::is_messaging_setter(void) const {
  return impl->reader.getVal93();
}

bool ObjCPropertyRefExpr::is_object_receiver(void) const {
  return impl->reader.getVal95();
}

bool ObjCPropertyRefExpr::is_super_receiver(void) const {
  return impl->reader.getVal97();
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCMessageExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCMessageExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCMessageExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCMessageExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCMessageExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCMessageExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCMessageExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCMessageExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCMessageExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCMessageExpr> ObjCMessageExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCMessageExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCMessageExprDerivedKinds[] = {
    ObjCMessageExpr::static_kind(),
};

gap::generator<ObjCMessageExpr> ObjCMessageExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCMessageExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCMessageExpr> e = ObjCMessageExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCMessageExpr> ObjCMessageExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCMessageExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCMessageExpr> e = ObjCMessageExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCMessageExpr> ObjCMessageExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCMessageExpr> ObjCMessageExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCMessageExpr> ObjCMessageExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_MESSAGE_EXPR:
      return reinterpret_cast<const ObjCMessageExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> ObjCMessageExpr::nth_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> ObjCMessageExpr::arguments(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Type ObjCMessageExpr::call_return_type(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ObjCMessageExpr::class_receiver(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Type ObjCMessageExpr::class_receiver_type(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Expr ObjCMessageExpr::instance_receiver(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ObjCMessageExpr::left_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

ObjCMethodDecl ObjCMessageExpr::method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal43();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCMethodFamily ObjCMessageExpr::method_family(void) const {
  return static_cast<ObjCMethodFamily>(impl->reader.getVal94());
}

ObjCInterfaceDecl ObjCMessageExpr::receiver_interface(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCMessageExprReceiverKind ObjCMessageExpr::receiver_kind(void) const {
  return static_cast<ObjCMessageExprReceiverKind>(impl->reader.getVal96());
}

TokenRange ObjCMessageExpr::receiver_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal45(), impl->reader.getVal46());
}

Type ObjCMessageExpr::receiver_type(void) const {
  RawEntityId eid = impl->reader.getVal47();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token ObjCMessageExpr::right_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal48());
}

Token ObjCMessageExpr::selector_start_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal49());
}

Token ObjCMessageExpr::super_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal50());
}

Type ObjCMessageExpr::super_type(void) const {
  RawEntityId eid = impl->reader.getVal51();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ObjCMessageExpr::is_class_message(void) const {
  return impl->reader.getVal89();
}

bool ObjCMessageExpr::is_delegate_initializer_call(void) const {
  return impl->reader.getVal90();
}

bool ObjCMessageExpr::is_implicit(void) const {
  return impl->reader.getVal91();
}

bool ObjCMessageExpr::is_instance_message(void) const {
  return impl->reader.getVal92();
}

std::optional<Token> ObjCMessageExpr::nth_selector_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : selector_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ObjCMessageExpr::selector_tokens(void) const {
  auto list = impl->reader.getVal26();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t26 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t26;
    }
  }
  co_return;
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCIvarRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCIvarRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCIvarRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIvarRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIvarRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCIvarRefExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCIvarRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCIvarRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCIvarRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCIvarRefExpr> ObjCIvarRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCIvarRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCIvarRefExprDerivedKinds[] = {
    ObjCIvarRefExpr::static_kind(),
};

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCIvarRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCIvarRefExpr> e = ObjCIvarRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCIvarRefExpr> ObjCIvarRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCIvarRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCIvarRefExpr> e = ObjCIvarRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCIvarRefExpr> ObjCIvarRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIvarRefExpr> ObjCIvarRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIvarRefExpr> ObjCIvarRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_IVAR_REF_EXPR:
      return reinterpret_cast<const ObjCIvarRefExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCIvarRefExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ObjCIvarDecl ObjCIvarRefExpr::declaration(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return ObjCIvarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCIvarRefExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token ObjCIvarRefExpr::operation_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

bool ObjCIvarRefExpr::is_arrow(void) const {
  return impl->reader.getVal89();
}

bool ObjCIvarRefExpr::is_free_instance_variable(void) const {
  return impl->reader.getVal90();
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCIsaExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCIsaExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCIsaExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIsaExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIsaExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCIsaExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCIsaExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCIsaExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCIsaExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCIsaExpr> ObjCIsaExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCIsaExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCIsaExprDerivedKinds[] = {
    ObjCIsaExpr::static_kind(),
};

gap::generator<ObjCIsaExpr> ObjCIsaExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCIsaExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCIsaExpr> e = ObjCIsaExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCIsaExpr> ObjCIsaExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCIsaExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCIsaExpr> e = ObjCIsaExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCIsaExpr> ObjCIsaExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIsaExpr> ObjCIsaExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIsaExpr> ObjCIsaExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_ISA_EXPR:
      return reinterpret_cast<const ObjCIsaExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCIsaExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token ObjCIsaExpr::base_token_end(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token ObjCIsaExpr::isa_member_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token ObjCIsaExpr::operation_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

bool ObjCIsaExpr::is_arrow(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCIndirectCopyRestoreExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCIndirectCopyRestoreExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCIndirectCopyRestoreExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIndirectCopyRestoreExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCIndirectCopyRestoreExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCIndirectCopyRestoreExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCIndirectCopyRestoreExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCIndirectCopyRestoreExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCIndirectCopyRestoreExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCIndirectCopyRestoreExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCIndirectCopyRestoreExprDerivedKinds[] = {
    ObjCIndirectCopyRestoreExpr::static_kind(),
};

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCIndirectCopyRestoreExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCIndirectCopyRestoreExpr> e = ObjCIndirectCopyRestoreExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCIndirectCopyRestoreExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCIndirectCopyRestoreExpr> e = ObjCIndirectCopyRestoreExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCIndirectCopyRestoreExpr> ObjCIndirectCopyRestoreExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_INDIRECT_COPY_RESTORE_EXPR:
      return reinterpret_cast<const ObjCIndirectCopyRestoreExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCIndirectCopyRestoreExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool ObjCIndirectCopyRestoreExpr::should_copy(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCEncodeExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCEncodeExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCEncodeExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCEncodeExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCEncodeExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCEncodeExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCEncodeExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCEncodeExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCEncodeExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCEncodeExpr> ObjCEncodeExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCEncodeExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCEncodeExprDerivedKinds[] = {
    ObjCEncodeExpr::static_kind(),
};

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCEncodeExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCEncodeExpr> e = ObjCEncodeExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCEncodeExpr> ObjCEncodeExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCEncodeExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCEncodeExpr> e = ObjCEncodeExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCEncodeExpr> ObjCEncodeExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCEncodeExpr> ObjCEncodeExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCEncodeExpr> ObjCEncodeExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_ENCODE_EXPR:
      return reinterpret_cast<const ObjCEncodeExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCEncodeExpr::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Type ObjCEncodeExpr::encoded_type(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

Token ObjCEncodeExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCDictionaryLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCDictionaryLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCDictionaryLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCDictionaryLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCDictionaryLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCDictionaryLiteral::contains(const Decl &decl) {
  for (auto &parent : ObjCDictionaryLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCDictionaryLiteral::contains(const Stmt &stmt) {
  for (auto &parent : ObjCDictionaryLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCDictionaryLiteral> ObjCDictionaryLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCDictionaryLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCDictionaryLiteralDerivedKinds[] = {
    ObjCDictionaryLiteral::static_kind(),
};

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCDictionaryLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCDictionaryLiteral> e = ObjCDictionaryLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCDictionaryLiteral> ObjCDictionaryLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCDictionaryLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCDictionaryLiteral> e = ObjCDictionaryLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCDictionaryLiteral> ObjCDictionaryLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCDictionaryLiteral> ObjCDictionaryLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCDictionaryLiteral> ObjCDictionaryLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_DICTIONARY_LITERAL:
      return reinterpret_cast<const ObjCDictionaryLiteral &>(parent);
    default: return std::nullopt;
  }
}

ObjCMethodDecl ObjCDictionaryLiteral::dictionary_with_objects_method(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBoxedExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBoxedExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBoxedExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBoxedExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBoxedExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCBoxedExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCBoxedExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCBoxedExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCBoxedExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCBoxedExpr> ObjCBoxedExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCBoxedExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCBoxedExprDerivedKinds[] = {
    ObjCBoxedExpr::static_kind(),
};

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCBoxedExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCBoxedExpr> e = ObjCBoxedExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBoxedExpr> ObjCBoxedExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCBoxedExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBoxedExpr> e = ObjCBoxedExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBoxedExpr> ObjCBoxedExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBoxedExpr> ObjCBoxedExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBoxedExpr> ObjCBoxedExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_BOXED_EXPR:
      return reinterpret_cast<const ObjCBoxedExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCBoxedExpr::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

ObjCMethodDecl ObjCBoxedExpr::boxing_method(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Expr ObjCBoxedExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool ObjCBoxedExpr::is_expressible_as_constant_initializer(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCBoolLiteralExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCBoolLiteralExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCBoolLiteralExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBoolLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCBoolLiteralExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCBoolLiteralExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCBoolLiteralExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCBoolLiteralExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCBoolLiteralExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCBoolLiteralExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCBoolLiteralExprDerivedKinds[] = {
    ObjCBoolLiteralExpr::static_kind(),
};

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCBoolLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCBoolLiteralExpr> e = ObjCBoolLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCBoolLiteralExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCBoolLiteralExpr> e = ObjCBoolLiteralExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCBoolLiteralExpr> ObjCBoolLiteralExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_BOOL_LITERAL_EXPR:
      return reinterpret_cast<const ObjCBoolLiteralExpr &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCBoolLiteralExpr::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

bool ObjCBoolLiteralExpr::value(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAvailabilityCheckExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAvailabilityCheckExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAvailabilityCheckExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAvailabilityCheckExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCAvailabilityCheckExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAvailabilityCheckExpr::contains(const Decl &decl) {
  for (auto &parent : ObjCAvailabilityCheckExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAvailabilityCheckExpr::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAvailabilityCheckExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCAvailabilityCheckExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCAvailabilityCheckExprDerivedKinds[] = {
    ObjCAvailabilityCheckExpr::static_kind(),
};

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCAvailabilityCheckExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCAvailabilityCheckExpr> e = ObjCAvailabilityCheckExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCAvailabilityCheckExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAvailabilityCheckExpr> e = ObjCAvailabilityCheckExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCAvailabilityCheckExpr> ObjCAvailabilityCheckExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_AVAILABILITY_CHECK_EXPR:
      return reinterpret_cast<const ObjCAvailabilityCheckExpr &>(parent);
    default: return std::nullopt;
  }
}

bool ObjCAvailabilityCheckExpr::has_version(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCArrayLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCArrayLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCArrayLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCArrayLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ObjCArrayLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCArrayLiteral::contains(const Decl &decl) {
  for (auto &parent : ObjCArrayLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCArrayLiteral::contains(const Stmt &stmt) {
  for (auto &parent : ObjCArrayLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ObjCArrayLiteral> ObjCArrayLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ObjCArrayLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kObjCArrayLiteralDerivedKinds[] = {
    ObjCArrayLiteral::static_kind(),
};

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kObjCArrayLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ObjCArrayLiteral> e = ObjCArrayLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCArrayLiteral> ObjCArrayLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kObjCArrayLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ObjCArrayLiteral> e = ObjCArrayLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCArrayLiteral> ObjCArrayLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCArrayLiteral> ObjCArrayLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ObjCArrayLiteral> ObjCArrayLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OBJ_C_ARRAY_LITERAL:
      return reinterpret_cast<const ObjCArrayLiteral &>(parent);
    default: return std::nullopt;
  }
}

ObjCMethodDecl ObjCArrayLiteral::array_with_objects_method(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<Expr> ObjCArrayLiteral::nth_element(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : elements()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> ObjCArrayLiteral::elements(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPIteratorExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPIteratorExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPIteratorExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPIteratorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPIteratorExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPIteratorExpr::contains(const Decl &decl) {
  for (auto &parent : OMPIteratorExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPIteratorExpr::contains(const Stmt &stmt) {
  for (auto &parent : OMPIteratorExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPIteratorExpr> OMPIteratorExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPIteratorExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPIteratorExprDerivedKinds[] = {
    OMPIteratorExpr::static_kind(),
};

gap::generator<OMPIteratorExpr> OMPIteratorExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPIteratorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPIteratorExpr> e = OMPIteratorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPIteratorExpr> OMPIteratorExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPIteratorExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPIteratorExpr> e = OMPIteratorExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPIteratorExpr> OMPIteratorExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPIteratorExpr> OMPIteratorExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPIteratorExpr> OMPIteratorExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_ITERATOR_EXPR:
      return reinterpret_cast<const OMPIteratorExpr &>(parent);
    default: return std::nullopt;
  }
}

Token OMPIteratorExpr::iterator_kw_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Token OMPIteratorExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token OMPIteratorExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPArrayShapingExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPArrayShapingExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPArrayShapingExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPArrayShapingExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPArrayShapingExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPArrayShapingExpr::contains(const Decl &decl) {
  for (auto &parent : OMPArrayShapingExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPArrayShapingExpr::contains(const Stmt &stmt) {
  for (auto &parent : OMPArrayShapingExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPArrayShapingExpr> OMPArrayShapingExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPArrayShapingExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPArrayShapingExprDerivedKinds[] = {
    OMPArrayShapingExpr::static_kind(),
};

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPArrayShapingExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPArrayShapingExpr> e = OMPArrayShapingExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPArrayShapingExpr> OMPArrayShapingExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPArrayShapingExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPArrayShapingExpr> e = OMPArrayShapingExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPArrayShapingExpr> OMPArrayShapingExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPArrayShapingExpr> OMPArrayShapingExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPArrayShapingExpr> OMPArrayShapingExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_ARRAY_SHAPING_EXPR:
      return reinterpret_cast<const OMPArrayShapingExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPArrayShapingExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> OMPArrayShapingExpr::nth_dimension(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : dimensions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPArrayShapingExpr::dimensions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Token OMPArrayShapingExpr::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token OMPArrayShapingExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPArraySectionExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPArraySectionExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPArraySectionExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPArraySectionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = OMPArraySectionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPArraySectionExpr::contains(const Decl &decl) {
  for (auto &parent : OMPArraySectionExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPArraySectionExpr::contains(const Stmt &stmt) {
  for (auto &parent : OMPArraySectionExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<OMPArraySectionExpr> OMPArraySectionExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return OMPArraySectionExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kOMPArraySectionExprDerivedKinds[] = {
    OMPArraySectionExpr::static_kind(),
};

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kOMPArraySectionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<OMPArraySectionExpr> e = OMPArraySectionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPArraySectionExpr> OMPArraySectionExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kOMPArraySectionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<OMPArraySectionExpr> e = OMPArraySectionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPArraySectionExpr> OMPArraySectionExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPArraySectionExpr> OMPArraySectionExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<OMPArraySectionExpr> OMPArraySectionExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::OMP_ARRAY_SECTION_EXPR:
      return reinterpret_cast<const OMPArraySectionExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPArraySectionExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token OMPArraySectionExpr::first_colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token OMPArraySectionExpr::second_colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Expr OMPArraySectionExpr::length(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPArraySectionExpr::lower_bound(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token OMPArraySectionExpr::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Expr OMPArraySectionExpr::stride(void) const {
  RawEntityId eid = impl->reader.getVal44();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<NoInitExpr> NoInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NoInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NoInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NoInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NoInitExpr> NoInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = NoInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NoInitExpr> NoInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NoInitExpr> NoInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = NoInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NoInitExpr> NoInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NoInitExpr::contains(const Decl &decl) {
  for (auto &parent : NoInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NoInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : NoInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<NoInitExpr> NoInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return NoInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kNoInitExprDerivedKinds[] = {
    NoInitExpr::static_kind(),
};

gap::generator<NoInitExpr> NoInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kNoInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<NoInitExpr> e = NoInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NoInitExpr> NoInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kNoInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<NoInitExpr> e = NoInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NoInitExpr> NoInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<NoInitExpr> NoInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<NoInitExpr> NoInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::NO_INIT_EXPR:
      return reinterpret_cast<const NoInitExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<MemberExpr> MemberExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MemberExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MemberExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MemberExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MemberExpr> MemberExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MemberExpr> MemberExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MemberExpr> MemberExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MemberExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MemberExpr> MemberExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MemberExpr::contains(const Decl &decl) {
  for (auto &parent : MemberExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MemberExpr::contains(const Stmt &stmt) {
  for (auto &parent : MemberExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MemberExpr> MemberExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MemberExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMemberExprDerivedKinds[] = {
    MemberExpr::static_kind(),
};

gap::generator<MemberExpr> MemberExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MemberExpr> e = MemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MemberExpr> MemberExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMemberExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MemberExpr> e = MemberExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MemberExpr> MemberExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MemberExpr> MemberExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MemberExpr> MemberExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MEMBER_EXPR:
      return reinterpret_cast<const MemberExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr MemberExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token MemberExpr::l_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

ValueDecl MemberExpr::member_declaration(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return ValueDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token MemberExpr::member_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Token MemberExpr::operator_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

Token MemberExpr::r_angle_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal43());
}

Token MemberExpr::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal44());
}

bool MemberExpr::had_multiple_candidates(void) const {
  return impl->reader.getVal89();
}

bool MemberExpr::has_explicit_template_arguments(void) const {
  return impl->reader.getVal90();
}

bool MemberExpr::has_qualifier(void) const {
  return impl->reader.getVal91();
}

bool MemberExpr::has_template_keyword(void) const {
  return impl->reader.getVal92();
}

bool MemberExpr::is_arrow(void) const {
  return impl->reader.getVal93();
}

bool MemberExpr::is_implicit_access(void) const {
  return impl->reader.getVal95();
}

NonOdrUseReason MemberExpr::is_non_odr_use(void) const {
  return static_cast<NonOdrUseReason>(impl->reader.getVal94());
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MatrixSubscriptExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MatrixSubscriptExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MatrixSubscriptExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MatrixSubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MatrixSubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MatrixSubscriptExpr::contains(const Decl &decl) {
  for (auto &parent : MatrixSubscriptExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MatrixSubscriptExpr::contains(const Stmt &stmt) {
  for (auto &parent : MatrixSubscriptExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MatrixSubscriptExpr> MatrixSubscriptExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MatrixSubscriptExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMatrixSubscriptExprDerivedKinds[] = {
    MatrixSubscriptExpr::static_kind(),
};

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMatrixSubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MatrixSubscriptExpr> e = MatrixSubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MatrixSubscriptExpr> MatrixSubscriptExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMatrixSubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MatrixSubscriptExpr> e = MatrixSubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MatrixSubscriptExpr> MatrixSubscriptExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MatrixSubscriptExpr> MatrixSubscriptExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MatrixSubscriptExpr> MatrixSubscriptExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MATRIX_SUBSCRIPT_EXPR:
      return reinterpret_cast<const MatrixSubscriptExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr MatrixSubscriptExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr MatrixSubscriptExpr::column_index(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token MatrixSubscriptExpr::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Expr MatrixSubscriptExpr::row_index(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool MatrixSubscriptExpr::is_incomplete(void) const {
  return impl->reader.getVal89();
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MaterializeTemporaryExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MaterializeTemporaryExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MaterializeTemporaryExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MaterializeTemporaryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MaterializeTemporaryExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MaterializeTemporaryExpr::contains(const Decl &decl) {
  for (auto &parent : MaterializeTemporaryExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MaterializeTemporaryExpr::contains(const Stmt &stmt) {
  for (auto &parent : MaterializeTemporaryExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MaterializeTemporaryExpr> MaterializeTemporaryExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MaterializeTemporaryExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMaterializeTemporaryExprDerivedKinds[] = {
    MaterializeTemporaryExpr::static_kind(),
};

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMaterializeTemporaryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MaterializeTemporaryExpr> e = MaterializeTemporaryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MaterializeTemporaryExpr> MaterializeTemporaryExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMaterializeTemporaryExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MaterializeTemporaryExpr> e = MaterializeTemporaryExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MaterializeTemporaryExpr> MaterializeTemporaryExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MaterializeTemporaryExpr> MaterializeTemporaryExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MaterializeTemporaryExpr> MaterializeTemporaryExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MATERIALIZE_TEMPORARY_EXPR:
      return reinterpret_cast<const MaterializeTemporaryExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<ValueDecl> MaterializeTemporaryExpr::extending_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ValueDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<LifetimeExtendedTemporaryDecl> MaterializeTemporaryExpr::lifetime_extended_temporary_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal39();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return LifetimeExtendedTemporaryDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

StorageDuration MaterializeTemporaryExpr::storage_duration(void) const {
  return static_cast<StorageDuration>(impl->reader.getVal94());
}

Expr MaterializeTemporaryExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool MaterializeTemporaryExpr::is_bound_to_lvalue_reference(void) const {
  return impl->reader.getVal89();
}

bool MaterializeTemporaryExpr::is_usable_in_constant_expressions(void) const {
  return impl->reader.getVal90();
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSPropertySubscriptExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSPropertySubscriptExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSPropertySubscriptExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSPropertySubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSPropertySubscriptExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSPropertySubscriptExpr::contains(const Decl &decl) {
  for (auto &parent : MSPropertySubscriptExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSPropertySubscriptExpr::contains(const Stmt &stmt) {
  for (auto &parent : MSPropertySubscriptExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MSPropertySubscriptExpr> MSPropertySubscriptExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MSPropertySubscriptExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMSPropertySubscriptExprDerivedKinds[] = {
    MSPropertySubscriptExpr::static_kind(),
};

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMSPropertySubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MSPropertySubscriptExpr> e = MSPropertySubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSPropertySubscriptExpr> MSPropertySubscriptExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMSPropertySubscriptExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MSPropertySubscriptExpr> e = MSPropertySubscriptExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSPropertySubscriptExpr> MSPropertySubscriptExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MSPropertySubscriptExpr> MSPropertySubscriptExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MSPropertySubscriptExpr> MSPropertySubscriptExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MS_PROPERTY_SUBSCRIPT_EXPR:
      return reinterpret_cast<const MSPropertySubscriptExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr MSPropertySubscriptExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr MSPropertySubscriptExpr::index(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token MSPropertySubscriptExpr::r_bracket_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSPropertyRefExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSPropertyRefExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSPropertyRefExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSPropertyRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = MSPropertyRefExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSPropertyRefExpr::contains(const Decl &decl) {
  for (auto &parent : MSPropertyRefExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSPropertyRefExpr::contains(const Stmt &stmt) {
  for (auto &parent : MSPropertyRefExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<MSPropertyRefExpr> MSPropertyRefExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return MSPropertyRefExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kMSPropertyRefExprDerivedKinds[] = {
    MSPropertyRefExpr::static_kind(),
};

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kMSPropertyRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<MSPropertyRefExpr> e = MSPropertyRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSPropertyRefExpr> MSPropertyRefExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kMSPropertyRefExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<MSPropertyRefExpr> e = MSPropertyRefExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSPropertyRefExpr> MSPropertyRefExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MSPropertyRefExpr> MSPropertyRefExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<MSPropertyRefExpr> MSPropertyRefExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::MS_PROPERTY_REF_EXPR:
      return reinterpret_cast<const MSPropertyRefExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr MSPropertyRefExpr::base_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token MSPropertyRefExpr::member_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

MSPropertyDecl MSPropertyRefExpr::property_declaration(void) const {
  RawEntityId eid = impl->reader.getVal40();
  return MSPropertyDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool MSPropertyRefExpr::is_arrow(void) const {
  return impl->reader.getVal89();
}

bool MSPropertyRefExpr::is_implicit_access(void) const {
  return impl->reader.getVal90();
}

gap::generator<LambdaExpr> LambdaExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LambdaExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LambdaExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LambdaExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<LambdaExpr> LambdaExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = LambdaExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LambdaExpr> LambdaExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<LambdaExpr> LambdaExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = LambdaExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LambdaExpr> LambdaExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool LambdaExpr::contains(const Decl &decl) {
  for (auto &parent : LambdaExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool LambdaExpr::contains(const Stmt &stmt) {
  for (auto &parent : LambdaExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<LambdaExpr> LambdaExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return LambdaExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kLambdaExprDerivedKinds[] = {
    LambdaExpr::static_kind(),
};

gap::generator<LambdaExpr> LambdaExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kLambdaExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<LambdaExpr> e = LambdaExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LambdaExpr> LambdaExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kLambdaExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<LambdaExpr> e = LambdaExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LambdaExpr> LambdaExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<LambdaExpr> LambdaExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<LambdaExpr> LambdaExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::LAMBDA_EXPR:
      return reinterpret_cast<const LambdaExpr &>(parent);
    default: return std::nullopt;
  }
}

Stmt LambdaExpr::body(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

CXXMethodDecl LambdaExpr::call_operator(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return CXXMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

LambdaCaptureDefault LambdaExpr::capture_default(void) const {
  return static_cast<LambdaCaptureDefault>(impl->reader.getVal94());
}

Token LambdaExpr::capture_default_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

CompoundStmt LambdaExpr::compound_statement_body(void) const {
  RawEntityId eid = impl->reader.getVal41();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<FunctionTemplateDecl> LambdaExpr::dependent_call_operator(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal42();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<NamedDecl> LambdaExpr::nth_explicit_template_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : explicit_template_parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<NamedDecl> LambdaExpr::explicit_template_parameters(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = NamedDecl::from(Decl(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

TokenRange LambdaExpr::introducer_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal43(), impl->reader.getVal44());
}

CXXRecordDecl LambdaExpr::lambda_class(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<TemplateParameterList> LambdaExpr::template_parameter_list(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal46();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TemplateParameterListFor(impl->ep, eid)) {
      return TemplateParameterList(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Expr> LambdaExpr::trailing_requires_clause(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal47();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool LambdaExpr::has_explicit_parameters(void) const {
  return impl->reader.getVal89();
}

bool LambdaExpr::has_explicit_result_type(void) const {
  return impl->reader.getVal90();
}

bool LambdaExpr::is_generic_lambda(void) const {
  return impl->reader.getVal91();
}

bool LambdaExpr::is_mutable(void) const {
  return impl->reader.getVal92();
}

gap::generator<IntegerLiteral> IntegerLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IntegerLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IntegerLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IntegerLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IntegerLiteral> IntegerLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IntegerLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IntegerLiteral> IntegerLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<IntegerLiteral> IntegerLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = IntegerLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IntegerLiteral> IntegerLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool IntegerLiteral::contains(const Decl &decl) {
  for (auto &parent : IntegerLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool IntegerLiteral::contains(const Stmt &stmt) {
  for (auto &parent : IntegerLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<IntegerLiteral> IntegerLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return IntegerLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kIntegerLiteralDerivedKinds[] = {
    IntegerLiteral::static_kind(),
};

gap::generator<IntegerLiteral> IntegerLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kIntegerLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<IntegerLiteral> e = IntegerLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IntegerLiteral> IntegerLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kIntegerLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<IntegerLiteral> e = IntegerLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IntegerLiteral> IntegerLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<IntegerLiteral> IntegerLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<IntegerLiteral> IntegerLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::INTEGER_LITERAL:
      return reinterpret_cast<const IntegerLiteral &>(parent);
    default: return std::nullopt;
  }
}

Token IntegerLiteral::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<InitListExpr> InitListExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = InitListExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool InitListExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : InitListExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<InitListExpr> InitListExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = InitListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<InitListExpr> InitListExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<InitListExpr> InitListExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = InitListExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<InitListExpr> InitListExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool InitListExpr::contains(const Decl &decl) {
  for (auto &parent : InitListExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool InitListExpr::contains(const Stmt &stmt) {
  for (auto &parent : InitListExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<InitListExpr> InitListExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return InitListExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kInitListExprDerivedKinds[] = {
    InitListExpr::static_kind(),
};

gap::generator<InitListExpr> InitListExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kInitListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<InitListExpr> e = InitListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<InitListExpr> InitListExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kInitListExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<InitListExpr> e = InitListExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<InitListExpr> InitListExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<InitListExpr> InitListExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<InitListExpr> InitListExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::INIT_LIST_EXPR:
      return reinterpret_cast<const InitListExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> InitListExpr::array_filler(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal38();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<FieldDecl> InitListExpr::initialized_field_in_union(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal39();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FieldDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token InitListExpr::l_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token InitListExpr::r_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

std::optional<InitListExpr> InitListExpr::semantic_form(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal42();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return InitListExpr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<InitListExpr> InitListExpr::syntactic_form(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal43();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return InitListExpr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool InitListExpr::had_array_range_designator(void) const {
  return impl->reader.getVal89();
}

bool InitListExpr::has_array_filler(void) const {
  return impl->reader.getVal90();
}

std::optional<Expr> InitListExpr::nth_initializer(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : initializers()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> InitListExpr::initializers(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

bool InitListExpr::is_explicit(void) const {
  return impl->reader.getVal91();
}

bool InitListExpr::is_semantic_form(void) const {
  return impl->reader.getVal92();
}

bool InitListExpr::is_string_literal_initializer(void) const {
  return impl->reader.getVal93();
}

bool InitListExpr::is_syntactic_form(void) const {
  return impl->reader.getVal95();
}

std::optional<bool> InitListExpr::is_transparent(void) const {
  if (!impl->reader.getVal98()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal97());
  }
  return std::nullopt;
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ImplicitValueInitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ImplicitValueInitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ImplicitValueInitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImplicitValueInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImplicitValueInitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ImplicitValueInitExpr::contains(const Decl &decl) {
  for (auto &parent : ImplicitValueInitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ImplicitValueInitExpr::contains(const Stmt &stmt) {
  for (auto &parent : ImplicitValueInitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ImplicitValueInitExpr> ImplicitValueInitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ImplicitValueInitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kImplicitValueInitExprDerivedKinds[] = {
    ImplicitValueInitExpr::static_kind(),
};

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kImplicitValueInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ImplicitValueInitExpr> e = ImplicitValueInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImplicitValueInitExpr> ImplicitValueInitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kImplicitValueInitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ImplicitValueInitExpr> e = ImplicitValueInitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImplicitValueInitExpr> ImplicitValueInitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImplicitValueInitExpr> ImplicitValueInitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImplicitValueInitExpr> ImplicitValueInitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::IMPLICIT_VALUE_INIT_EXPR:
      return reinterpret_cast<const ImplicitValueInitExpr &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ImaginaryLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ImaginaryLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ImaginaryLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImaginaryLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ImaginaryLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ImaginaryLiteral::contains(const Decl &decl) {
  for (auto &parent : ImaginaryLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ImaginaryLiteral::contains(const Stmt &stmt) {
  for (auto &parent : ImaginaryLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ImaginaryLiteral> ImaginaryLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ImaginaryLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kImaginaryLiteralDerivedKinds[] = {
    ImaginaryLiteral::static_kind(),
};

gap::generator<ImaginaryLiteral> ImaginaryLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kImaginaryLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ImaginaryLiteral> e = ImaginaryLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImaginaryLiteral> ImaginaryLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kImaginaryLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ImaginaryLiteral> e = ImaginaryLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImaginaryLiteral> ImaginaryLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImaginaryLiteral> ImaginaryLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ImaginaryLiteral> ImaginaryLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::IMAGINARY_LITERAL:
      return reinterpret_cast<const ImaginaryLiteral &>(parent);
    default: return std::nullopt;
  }
}

Expr ImaginaryLiteral::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GenericSelectionExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GenericSelectionExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GenericSelectionExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GenericSelectionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GenericSelectionExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool GenericSelectionExpr::contains(const Decl &decl) {
  for (auto &parent : GenericSelectionExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool GenericSelectionExpr::contains(const Stmt &stmt) {
  for (auto &parent : GenericSelectionExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<GenericSelectionExpr> GenericSelectionExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return GenericSelectionExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kGenericSelectionExprDerivedKinds[] = {
    GenericSelectionExpr::static_kind(),
};

gap::generator<GenericSelectionExpr> GenericSelectionExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kGenericSelectionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<GenericSelectionExpr> e = GenericSelectionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GenericSelectionExpr> GenericSelectionExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kGenericSelectionExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<GenericSelectionExpr> e = GenericSelectionExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GenericSelectionExpr> GenericSelectionExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<GenericSelectionExpr> GenericSelectionExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<GenericSelectionExpr> GenericSelectionExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::GENERIC_SELECTION_EXPR:
      return reinterpret_cast<const GenericSelectionExpr &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> GenericSelectionExpr::nth_association_expression(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : association_expressions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> GenericSelectionExpr::association_expressions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

Expr GenericSelectionExpr::controlling_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token GenericSelectionExpr::default_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

Token GenericSelectionExpr::generic_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal40());
}

Token GenericSelectionExpr::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal41());
}

Expr GenericSelectionExpr::result_expression(void) const {
  RawEntityId eid = impl->reader.getVal42();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool GenericSelectionExpr::is_result_dependent(void) const {
  return impl->reader.getVal89();
}

gap::generator<GNUNullExpr> GNUNullExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = GNUNullExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool GNUNullExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : GNUNullExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<GNUNullExpr> GNUNullExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GNUNullExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GNUNullExpr> GNUNullExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<GNUNullExpr> GNUNullExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = GNUNullExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<GNUNullExpr> GNUNullExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool GNUNullExpr::contains(const Decl &decl) {
  for (auto &parent : GNUNullExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool GNUNullExpr::contains(const Stmt &stmt) {
  for (auto &parent : GNUNullExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<GNUNullExpr> GNUNullExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return GNUNullExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kGNUNullExprDerivedKinds[] = {
    GNUNullExpr::static_kind(),
};

gap::generator<GNUNullExpr> GNUNullExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kGNUNullExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<GNUNullExpr> e = GNUNullExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<GNUNullExpr> GNUNullExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kGNUNullExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<GNUNullExpr> e = GNUNullExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<GNUNullExpr> GNUNullExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<GNUNullExpr> GNUNullExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<GNUNullExpr> GNUNullExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::GNU_NULL_EXPR:
      return reinterpret_cast<const GNUNullExpr &>(parent);
    default: return std::nullopt;
  }
}

Token GNUNullExpr::token_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionParmPackExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionParmPackExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionParmPackExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FunctionParmPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FunctionParmPackExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FunctionParmPackExpr::contains(const Decl &decl) {
  for (auto &parent : FunctionParmPackExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FunctionParmPackExpr::contains(const Stmt &stmt) {
  for (auto &parent : FunctionParmPackExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<FunctionParmPackExpr> FunctionParmPackExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return FunctionParmPackExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kFunctionParmPackExprDerivedKinds[] = {
    FunctionParmPackExpr::static_kind(),
};

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kFunctionParmPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<FunctionParmPackExpr> e = FunctionParmPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionParmPackExpr> FunctionParmPackExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kFunctionParmPackExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<FunctionParmPackExpr> e = FunctionParmPackExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionParmPackExpr> FunctionParmPackExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FunctionParmPackExpr> FunctionParmPackExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FunctionParmPackExpr> FunctionParmPackExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::FUNCTION_PARM_PACK_EXPR:
      return reinterpret_cast<const FunctionParmPackExpr &>(parent);
    default: return std::nullopt;
  }
}

VarDecl FunctionParmPackExpr::parameter_pack(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token FunctionParmPackExpr::parameter_pack_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal39());
}

std::optional<VarDecl> FunctionParmPackExpr::nth_expansion(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : expansions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<VarDecl> FunctionParmPackExpr::expansions(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = VarDecl::from(Decl(std::move(d15)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<FullExpr> FullExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FullExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FullExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FullExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FullExpr> FullExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FullExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FullExpr> FullExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FullExpr> FullExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FullExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FullExpr> FullExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FullExpr::contains(const Decl &decl) {
  for (auto &parent : FullExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FullExpr::contains(const Stmt &stmt) {
  for (auto &parent : FullExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<FullExpr> FullExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return FullExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kFullExprDerivedKinds[] = {
    ConstantExpr::static_kind(),
    ExprWithCleanups::static_kind(),
};

gap::generator<FullExpr> FullExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kFullExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<FullExpr> e = FullExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FullExpr> FullExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kFullExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<FullExpr> e = FullExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FullExpr> FullExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FullExpr> FullExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FullExpr> FullExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::EXPR_WITH_CLEANUPS:
    case mx::StmtKind::CONSTANT_EXPR:
      return reinterpret_cast<const FullExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr FullExpr::sub_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ExprWithCleanups> ExprWithCleanups::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExprWithCleanups::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExprWithCleanups::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExprWithCleanups::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExprWithCleanups> ExprWithCleanups::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExprWithCleanups::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExprWithCleanups> ExprWithCleanups::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExprWithCleanups> ExprWithCleanups::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExprWithCleanups::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExprWithCleanups> ExprWithCleanups::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExprWithCleanups::contains(const Decl &decl) {
  for (auto &parent : ExprWithCleanups::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExprWithCleanups::contains(const Stmt &stmt) {
  for (auto &parent : ExprWithCleanups::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ExprWithCleanups> ExprWithCleanups::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ExprWithCleanups::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kExprWithCleanupsDerivedKinds[] = {
    ExprWithCleanups::static_kind(),
};

gap::generator<ExprWithCleanups> ExprWithCleanups::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kExprWithCleanupsDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ExprWithCleanups> e = ExprWithCleanups::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExprWithCleanups> ExprWithCleanups::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kExprWithCleanupsDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ExprWithCleanups> e = ExprWithCleanups::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExprWithCleanups> ExprWithCleanups::from(const FullExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExprWithCleanups> ExprWithCleanups::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExprWithCleanups> ExprWithCleanups::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExprWithCleanups> ExprWithCleanups::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::EXPR_WITH_CLEANUPS:
      return reinterpret_cast<const ExprWithCleanups &>(parent);
    default: return std::nullopt;
  }
}

bool ExprWithCleanups::cleanups_have_side_effects(void) const {
  return impl->reader.getVal89();
}

gap::generator<ConstantExpr> ConstantExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstantExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstantExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstantExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConstantExpr> ConstantExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConstantExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConstantExpr> ConstantExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConstantExpr> ConstantExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ConstantExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConstantExpr> ConstantExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConstantExpr::contains(const Decl &decl) {
  for (auto &parent : ConstantExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConstantExpr::contains(const Stmt &stmt) {
  for (auto &parent : ConstantExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ConstantExpr> ConstantExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ConstantExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kConstantExprDerivedKinds[] = {
    ConstantExpr::static_kind(),
};

gap::generator<ConstantExpr> ConstantExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kConstantExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ConstantExpr> e = ConstantExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstantExpr> ConstantExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kConstantExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ConstantExpr> e = ConstantExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstantExpr> ConstantExpr::from(const FullExpr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConstantExpr> ConstantExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConstantExpr> ConstantExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ConstantExpr> ConstantExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CONSTANT_EXPR:
      return reinterpret_cast<const ConstantExpr &>(parent);
    default: return std::nullopt;
  }
}

ConstantExprResultStorageKind ConstantExpr::result_storage_kind(void) const {
  return static_cast<ConstantExprResultStorageKind>(impl->reader.getVal94());
}

bool ConstantExpr::has_ap_value_result(void) const {
  return impl->reader.getVal89();
}

bool ConstantExpr::is_immediate_invocation(void) const {
  return impl->reader.getVal90();
}

gap::generator<FloatingLiteral> FloatingLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FloatingLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FloatingLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FloatingLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FloatingLiteral> FloatingLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FloatingLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FloatingLiteral> FloatingLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FloatingLiteral> FloatingLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FloatingLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FloatingLiteral> FloatingLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FloatingLiteral::contains(const Decl &decl) {
  for (auto &parent : FloatingLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FloatingLiteral::contains(const Stmt &stmt) {
  for (auto &parent : FloatingLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<FloatingLiteral> FloatingLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return FloatingLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kFloatingLiteralDerivedKinds[] = {
    FloatingLiteral::static_kind(),
};

gap::generator<FloatingLiteral> FloatingLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kFloatingLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<FloatingLiteral> e = FloatingLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FloatingLiteral> FloatingLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kFloatingLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<FloatingLiteral> e = FloatingLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FloatingLiteral> FloatingLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FloatingLiteral> FloatingLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FloatingLiteral> FloatingLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::FLOATING_LITERAL:
      return reinterpret_cast<const FloatingLiteral &>(parent);
    default: return std::nullopt;
  }
}

Token FloatingLiteral::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

bool FloatingLiteral::is_exact(void) const {
  return impl->reader.getVal89();
}

gap::generator<FixedPointLiteral> FixedPointLiteral::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FixedPointLiteral::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FixedPointLiteral::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FixedPointLiteral::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FixedPointLiteral> FixedPointLiteral::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FixedPointLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FixedPointLiteral> FixedPointLiteral::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FixedPointLiteral> FixedPointLiteral::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = FixedPointLiteral::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FixedPointLiteral> FixedPointLiteral::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FixedPointLiteral::contains(const Decl &decl) {
  for (auto &parent : FixedPointLiteral::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FixedPointLiteral::contains(const Stmt &stmt) {
  for (auto &parent : FixedPointLiteral::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<FixedPointLiteral> FixedPointLiteral::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return FixedPointLiteral::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kFixedPointLiteralDerivedKinds[] = {
    FixedPointLiteral::static_kind(),
};

gap::generator<FixedPointLiteral> FixedPointLiteral::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kFixedPointLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<FixedPointLiteral> e = FixedPointLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FixedPointLiteral> FixedPointLiteral::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kFixedPointLiteralDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<FixedPointLiteral> e = FixedPointLiteral::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FixedPointLiteral> FixedPointLiteral::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FixedPointLiteral> FixedPointLiteral::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<FixedPointLiteral> FixedPointLiteral::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::FIXED_POINT_LITERAL:
      return reinterpret_cast<const FixedPointLiteral &>(parent);
    default: return std::nullopt;
  }
}

Token FixedPointLiteral::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExtVectorElementExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExtVectorElementExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExtVectorElementExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExtVectorElementExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExtVectorElementExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExtVectorElementExpr::contains(const Decl &decl) {
  for (auto &parent : ExtVectorElementExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExtVectorElementExpr::contains(const Stmt &stmt) {
  for (auto &parent : ExtVectorElementExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ExtVectorElementExpr> ExtVectorElementExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ExtVectorElementExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kExtVectorElementExprDerivedKinds[] = {
    ExtVectorElementExpr::static_kind(),
};

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kExtVectorElementExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ExtVectorElementExpr> e = ExtVectorElementExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExtVectorElementExpr> ExtVectorElementExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kExtVectorElementExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ExtVectorElementExpr> e = ExtVectorElementExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExtVectorElementExpr> ExtVectorElementExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExtVectorElementExpr> ExtVectorElementExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExtVectorElementExpr> ExtVectorElementExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::EXT_VECTOR_ELEMENT_EXPR:
      return reinterpret_cast<const ExtVectorElementExpr &>(parent);
    default: return std::nullopt;
  }
}

bool ExtVectorElementExpr::contains_duplicate_elements(void) const {
  return impl->reader.getVal89();
}

Token ExtVectorElementExpr::accessor_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal38());
}

Expr ExtVectorElementExpr::base(void) const {
  RawEntityId eid = impl->reader.getVal39();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool ExtVectorElementExpr::is_arrow(void) const {
  return impl->reader.getVal90();
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExpressionTraitExpr::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExpressionTraitExpr::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExpressionTraitExpr::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExpressionTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = ExpressionTraitExpr::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExpressionTraitExpr::contains(const Decl &decl) {
  for (auto &parent : ExpressionTraitExpr::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExpressionTraitExpr::contains(const Stmt &stmt) {
  for (auto &parent : ExpressionTraitExpr::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<ExpressionTraitExpr> ExpressionTraitExpr::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return ExpressionTraitExpr::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kExpressionTraitExprDerivedKinds[] = {
    ExpressionTraitExpr::static_kind(),
};

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kExpressionTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<ExpressionTraitExpr> e = ExpressionTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExpressionTraitExpr> ExpressionTraitExpr::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kExpressionTraitExprDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<ExpressionTraitExpr> e = ExpressionTraitExpr::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExpressionTraitExpr> ExpressionTraitExpr::from(const Expr &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExpressionTraitExpr> ExpressionTraitExpr::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<ExpressionTraitExpr> ExpressionTraitExpr::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::EXPRESSION_TRAIT_EXPR:
      return reinterpret_cast<const ExpressionTraitExpr &>(parent);
    default: return std::nullopt;
  }
}

Expr ExpressionTraitExpr::queried_expression(void) const {
  RawEntityId eid = impl->reader.getVal38();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ExpressionTrait ExpressionTraitExpr::trait(void) const {
  return static_cast<ExpressionTrait>(impl->reader.getVal94());
}

bool ExpressionTraitExpr::value(void) const {
  return impl->reader.getVal89();
}

gap::generator<AttributedStmt> AttributedStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AttributedStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AttributedStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AttributedStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AttributedStmt> AttributedStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AttributedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AttributedStmt> AttributedStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AttributedStmt> AttributedStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = AttributedStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AttributedStmt> AttributedStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AttributedStmt::contains(const Decl &decl) {
  for (auto &parent : AttributedStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AttributedStmt::contains(const Stmt &stmt) {
  for (auto &parent : AttributedStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<AttributedStmt> AttributedStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return AttributedStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kAttributedStmtDerivedKinds[] = {
    AttributedStmt::static_kind(),
};

gap::generator<AttributedStmt> AttributedStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kAttributedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<AttributedStmt> e = AttributedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AttributedStmt> AttributedStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kAttributedStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<AttributedStmt> e = AttributedStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AttributedStmt> AttributedStmt::from(const ValueStmt &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<AttributedStmt> AttributedStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::ATTRIBUTED_STMT:
      return reinterpret_cast<const AttributedStmt &>(parent);
    default: return std::nullopt;
  }
}

Token AttributedStmt::attribute_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

std::optional<Attr> AttributedStmt::nth_attribute(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : attributes()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Attr> AttributedStmt::attributes(void) const {
  auto list = impl->reader.getVal15();
  for (auto v : list) {
    EntityId id(v);
    if (auto d15 = impl->ep->AttrFor(impl->ep, v)) {
      co_yield Attr(std::move(d15));
    }
  }
  co_return;
}

Stmt AttributedStmt::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal11();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<SwitchStmt> SwitchStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwitchStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwitchStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwitchStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SwitchStmt> SwitchStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SwitchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SwitchStmt> SwitchStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SwitchStmt> SwitchStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SwitchStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SwitchStmt> SwitchStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SwitchStmt::contains(const Decl &decl) {
  for (auto &parent : SwitchStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SwitchStmt::contains(const Stmt &stmt) {
  for (auto &parent : SwitchStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SwitchStmt> SwitchStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SwitchStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSwitchStmtDerivedKinds[] = {
    SwitchStmt::static_kind(),
};

gap::generator<SwitchStmt> SwitchStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSwitchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SwitchStmt> e = SwitchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwitchStmt> SwitchStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSwitchStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SwitchStmt> e = SwitchStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwitchStmt> SwitchStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::SWITCH_STMT:
      return reinterpret_cast<const SwitchStmt &>(parent);
    default: return std::nullopt;
  }
}

Stmt SwitchStmt::body(void) const {
  RawEntityId eid = impl->reader.getVal9();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

Expr SwitchStmt::condition(void) const {
  RawEntityId eid = impl->reader.getVal10();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<VarDecl> SwitchStmt::condition_variable(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<DeclStmt> SwitchStmt::condition_variable_declaration_statement(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal13();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return DeclStmt::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Stmt> SwitchStmt::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal14();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token SwitchStmt::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal17());
}

Token SwitchStmt::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal18());
}

std::optional<SwitchCase> SwitchStmt::first_switch_case(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal19();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return SwitchCase::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token SwitchStmt::switch_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal20());
}

bool SwitchStmt::has_initializer_storage(void) const {
  return impl->reader.getVal12();
}

bool SwitchStmt::has_variable_storage(void) const {
  return impl->reader.getVal16();
}

bool SwitchStmt::is_all_enum_cases_covered(void) const {
  return impl->reader.getVal23();
}

gap::generator<SwitchCase> SwitchCase::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = SwitchCase::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool SwitchCase::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : SwitchCase::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<SwitchCase> SwitchCase::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SwitchCase::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SwitchCase> SwitchCase::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<SwitchCase> SwitchCase::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = SwitchCase::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<SwitchCase> SwitchCase::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool SwitchCase::contains(const Decl &decl) {
  for (auto &parent : SwitchCase::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool SwitchCase::contains(const Stmt &stmt) {
  for (auto &parent : SwitchCase::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<SwitchCase> SwitchCase::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return SwitchCase::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kSwitchCaseDerivedKinds[] = {
    CaseStmt::static_kind(),
    DefaultStmt::static_kind(),
};

gap::generator<SwitchCase> SwitchCase::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kSwitchCaseDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<SwitchCase> e = SwitchCase::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<SwitchCase> SwitchCase::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kSwitchCaseDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<SwitchCase> e = SwitchCase::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<SwitchCase> SwitchCase::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DEFAULT_STMT:
    case mx::StmtKind::CASE_STMT:
      return reinterpret_cast<const SwitchCase &>(parent);
    default: return std::nullopt;
  }
}

Token SwitchCase::colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal9());
}

Token SwitchCase::keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal10());
}

std::optional<SwitchCase> SwitchCase::next_switch_case(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal11();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return SwitchCase::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Stmt SwitchCase::sub_statement(void) const {
  RawEntityId eid = impl->reader.getVal13();
  return Stmt(impl->ep->StmtFor(impl->ep, eid));
}

gap::generator<DefaultStmt> DefaultStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DefaultStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DefaultStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DefaultStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DefaultStmt> DefaultStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DefaultStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DefaultStmt> DefaultStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DefaultStmt> DefaultStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = DefaultStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DefaultStmt> DefaultStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DefaultStmt::contains(const Decl &decl) {
  for (auto &parent : DefaultStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DefaultStmt::contains(const Stmt &stmt) {
  for (auto &parent : DefaultStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<DefaultStmt> DefaultStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return DefaultStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kDefaultStmtDerivedKinds[] = {
    DefaultStmt::static_kind(),
};

gap::generator<DefaultStmt> DefaultStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kDefaultStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<DefaultStmt> e = DefaultStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DefaultStmt> DefaultStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kDefaultStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<DefaultStmt> e = DefaultStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DefaultStmt> DefaultStmt::from(const SwitchCase &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<DefaultStmt> DefaultStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::DEFAULT_STMT:
      return reinterpret_cast<const DefaultStmt &>(parent);
    default: return std::nullopt;
  }
}

Token DefaultStmt::default_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

gap::generator<CaseStmt> CaseStmt::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CaseStmt::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CaseStmt::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CaseStmt::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CaseStmt> CaseStmt::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CaseStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CaseStmt> CaseStmt::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CaseStmt> CaseStmt::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_statement(); ancestor.has_value(); ancestor = ancestor->parent_statement()) {
    if (auto d = CaseStmt::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CaseStmt> CaseStmt::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CaseStmt::contains(const Decl &decl) {
  for (auto &parent : CaseStmt::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CaseStmt::contains(const Stmt &stmt) {
  for (auto &parent : CaseStmt::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<CaseStmt> CaseStmt::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<StmtId>(vid)) {
    return CaseStmt::from(index.statement(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const StmtKind kCaseStmtDerivedKinds[] = {
    CaseStmt::static_kind(),
};

gap::generator<CaseStmt> CaseStmt::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (StmtKind k : kCaseStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k)) {
      if (std::optional<CaseStmt> e = CaseStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CaseStmt> CaseStmt::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (StmtKind k : kCaseStmtDerivedKinds) {
    for (StmtImplPtr eptr : ep->StmtsFor(ep, k, frag_id)) {
      if (std::optional<CaseStmt> e = CaseStmt::from(Stmt(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CaseStmt> CaseStmt::from(const SwitchCase &parent) {
  return from(reinterpret_cast<const Stmt &>(parent));
}

std::optional<CaseStmt> CaseStmt::from(const Stmt &parent) {
  switch (parent.kind()) {
    case mx::StmtKind::CASE_STMT:
      return reinterpret_cast<const CaseStmt &>(parent);
    default: return std::nullopt;
  }
}

bool CaseStmt::case_statement_is_gnu_range(void) const {
  return impl->reader.getVal12();
}

Token CaseStmt::case_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal14());
}

Token CaseStmt::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal17());
}

Expr CaseStmt::lhs(void) const {
  RawEntityId eid = impl->reader.getVal18();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

std::optional<Expr> CaseStmt::rhs(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal19();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool Decl::is_definition(void) const {
  return impl->reader.getVal2();
}

std::optional<Decl> Decl::parent_declaration(void) const {
  if (auto id = impl->reader.getVal0(); id != kInvalidEntityId) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, id)) {
      return Decl(std::move(eptr));
    }
    assert(false);
  }
  return std::nullopt;
}

std::optional<Stmt> Decl::parent_statement(void) const {
  if (auto id = impl->reader.getVal1(); id != kInvalidEntityId) {
    if (auto eptr = impl->ep->StmtFor(impl->ep, id)) {
      return Stmt(std::move(eptr));
    }
    assert(false);
  }
  return std::nullopt;
}
inline const std::shared_ptr<EntityProvider> &Decl::entity_provider_of(const Index &index_) {
  return index_.impl;
}

inline const std::shared_ptr<EntityProvider> &Decl::entity_provider_of(const Fragment &frag_) {
  return frag_.impl->ep;
}

gap::generator<Decl> Decl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = Decl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool Decl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : Decl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<Decl> Decl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = Decl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Decl> Decl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<Decl> Decl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = Decl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<Decl> Decl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool Decl::contains(const Decl &decl) {
  for (auto &parent : Decl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool Decl::contains(const Stmt &stmt) {
  for (auto &parent : Decl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

std::optional<Decl> Decl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    index.declaration(eid.Pack());
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

gap::generator<Decl> Decl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclImplPtr eptr : ep->DeclsFor(ep)) {
    if (std::optional<Decl> e = Decl::from(Decl(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Decl> Decl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclImplPtr eptr : ep->DeclsFor(ep, frag_id)) {
    if (std::optional<Decl> e = Decl::from(Decl(std::move(eptr)))) {
      co_yield std::move(e.value());
    }
  }
}

gap::generator<Decl> Decl::in(const Index &index, std::span<DeclKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      co_yield Decl(std::move(eptr));
    }
  }
}

gap::generator<Decl> Decl::in(const Fragment &frag, std::span<DeclKind> kinds) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      co_yield Decl(std::move(eptr));
    }
  }
}

std::optional<Attr> Decl::nth_attribute(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : attributes()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Attr> Decl::attributes(void) const {
  auto list = impl->reader.getVal3();
  for (auto v : list) {
    EntityId id(v);
    if (auto d3 = impl->ep->AttrFor(impl->ep, v)) {
      co_yield Attr(std::move(d3));
    }
  }
  co_return;
}

AccessSpecifier Decl::access(void) const {
  return static_cast<AccessSpecifier>(impl->reader.getVal4());
}

AvailabilityResult Decl::availability(void) const {
  return static_cast<AvailabilityResult>(impl->reader.getVal5());
}

std::optional<Attr> Decl::defining_attribute(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal6();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->AttrFor(impl->ep, eid)) {
      return Attr(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<TemplateDecl> Decl::described_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal7();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<TemplateParameterList> Decl::described_template_parameters(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal8();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TemplateParameterListFor(impl->ep, eid)) {
      return TemplateParameterList(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<ExternalSourceSymbolAttr> Decl::external_source_symbol_attribute(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal9();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->AttrFor(impl->ep, eid)) {
      return ExternalSourceSymbolAttr::from(Attr(std::move(eptr)));
    }
  }
  return std::nullopt;
}

DeclFriendObjectKind Decl::friend_object_kind(void) const {
  return static_cast<DeclFriendObjectKind>(impl->reader.getVal10());
}

DeclModuleOwnershipKind Decl::module_ownership_kind(void) const {
  return static_cast<DeclModuleOwnershipKind>(impl->reader.getVal11());
}

std::optional<Decl> Decl::non_closure_context(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal12();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool Decl::has_attributes(void) const {
  return impl->reader.getVal13();
}

bool Decl::has_owning_module(void) const {
  return impl->reader.getVal14();
}

bool Decl::has_tag_identifier_namespace(void) const {
  return impl->reader.getVal15();
}

bool Decl::is_defined_outside_function_or_method(void) const {
  return impl->reader.getVal16();
}

bool Decl::is_deprecated(void) const {
  return impl->reader.getVal17();
}

bool Decl::is_discarded_in_global_module_fragment(void) const {
  return impl->reader.getVal18();
}

bool Decl::is_function_or_function_template(void) const {
  return impl->reader.getVal19();
}

bool Decl::is_implicit(void) const {
  return impl->reader.getVal20();
}

bool Decl::is_in_anonymous_namespace(void) const {
  return impl->reader.getVal21();
}

bool Decl::is_in_export_declaration_context(void) const {
  return impl->reader.getVal22();
}

bool Decl::is_in_local_scope_for_instantiation(void) const {
  return impl->reader.getVal23();
}

bool Decl::is_in_std_namespace(void) const {
  return impl->reader.getVal24();
}

bool Decl::is_invalid_declaration(void) const {
  return impl->reader.getVal25();
}

bool Decl::is_invisible_outside_the_owning_module(void) const {
  return impl->reader.getVal26();
}

bool Decl::is_module_private(void) const {
  return impl->reader.getVal27();
}

bool Decl::is_out_of_line(void) const {
  return impl->reader.getVal28();
}

bool Decl::is_parameter_pack(void) const {
  return impl->reader.getVal29();
}

bool Decl::is_reachable(void) const {
  return impl->reader.getVal30();
}

bool Decl::is_template_declaration(void) const {
  return impl->reader.getVal31();
}

bool Decl::is_template_parameter(void) const {
  return impl->reader.getVal32();
}

bool Decl::is_template_parameter_pack(void) const {
  return impl->reader.getVal33();
}

bool Decl::is_templated(void) const {
  return impl->reader.getVal34();
}

bool Decl::is_this_declaration_referenced(void) const {
  return impl->reader.getVal35();
}

bool Decl::is_top_level_declaration_in_obj_c_container(void) const {
  return impl->reader.getVal36();
}

bool Decl::is_unavailable(void) const {
  return impl->reader.getVal37();
}

bool Decl::is_unconditionally_visible(void) const {
  return impl->reader.getVal38();
}

bool Decl::is_weak_imported(void) const {
  return impl->reader.getVal39();
}

DeclKind Decl::kind(void) const {
  return static_cast<DeclKind>(impl->reader.getVal40());
}

DeclCategory Decl::category(void) const {
  return static_cast<DeclCategory>(impl->reader.getVal41());
}

Token Decl::token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal42());
}

TokenRange Decl::tokens(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal43(), impl->reader.getVal44());
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ClassScopeFunctionSpecializationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ClassScopeFunctionSpecializationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ClassScopeFunctionSpecializationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassScopeFunctionSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassScopeFunctionSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ClassScopeFunctionSpecializationDecl::contains(const Decl &decl) {
  for (auto &parent : ClassScopeFunctionSpecializationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ClassScopeFunctionSpecializationDecl::contains(const Stmt &stmt) {
  for (auto &parent : ClassScopeFunctionSpecializationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ClassScopeFunctionSpecializationDecl> dr = ClassScopeFunctionSpecializationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ClassScopeFunctionSpecializationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kClassScopeFunctionSpecializationDeclDerivedKinds[] = {
    ClassScopeFunctionSpecializationDecl::static_kind(),
};

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kClassScopeFunctionSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ClassScopeFunctionSpecializationDecl> e = ClassScopeFunctionSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kClassScopeFunctionSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ClassScopeFunctionSpecializationDecl> e = ClassScopeFunctionSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ClassScopeFunctionSpecializationDecl> ClassScopeFunctionSpecializationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CLASS_SCOPE_FUNCTION_SPECIALIZATION:
      return reinterpret_cast<const ClassScopeFunctionSpecializationDecl &>(parent);
    default: return std::nullopt;
  }
}

CXXMethodDecl ClassScopeFunctionSpecializationDecl::specialization(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return CXXMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ClassScopeFunctionSpecializationDecl::has_explicit_template_arguments(void) const {
  return impl->reader.getVal46();
}

gap::generator<CapturedDecl> CapturedDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CapturedDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CapturedDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CapturedDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CapturedDecl> CapturedDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CapturedDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CapturedDecl> CapturedDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CapturedDecl> CapturedDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CapturedDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CapturedDecl> CapturedDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CapturedDecl::contains(const Decl &decl) {
  for (auto &parent : CapturedDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CapturedDecl::contains(const Stmt &stmt) {
  for (auto &parent : CapturedDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CapturedDecl> CapturedDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CapturedDecl> dr = CapturedDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CapturedDecl> CapturedDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CapturedDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCapturedDeclDerivedKinds[] = {
    CapturedDecl::static_kind(),
};

gap::generator<CapturedDecl> CapturedDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCapturedDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CapturedDecl> e = CapturedDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CapturedDecl> CapturedDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCapturedDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CapturedDecl> e = CapturedDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CapturedDecl> CapturedDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CAPTURED:
      return reinterpret_cast<const CapturedDecl &>(parent);
    default: return std::nullopt;
  }
}

ImplicitParamDecl CapturedDecl::context_parameter(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return ImplicitParamDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool CapturedDecl::is_nothrow(void) const {
  return impl->reader.getVal46();
}

std::optional<ImplicitParamDecl> CapturedDecl::nth_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ImplicitParamDecl> CapturedDecl::parameters(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ImplicitParamDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<Decl> CapturedDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<BlockDecl> BlockDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BlockDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BlockDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BlockDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BlockDecl> BlockDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BlockDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BlockDecl> BlockDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BlockDecl> BlockDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BlockDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BlockDecl> BlockDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BlockDecl::contains(const Decl &decl) {
  for (auto &parent : BlockDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BlockDecl::contains(const Stmt &stmt) {
  for (auto &parent : BlockDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<BlockDecl> BlockDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<BlockDecl> dr = BlockDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<BlockDecl> BlockDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return BlockDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kBlockDeclDerivedKinds[] = {
    BlockDecl::static_kind(),
};

gap::generator<BlockDecl> BlockDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kBlockDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<BlockDecl> e = BlockDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BlockDecl> BlockDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kBlockDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<BlockDecl> e = BlockDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BlockDecl> BlockDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::BLOCK:
      return reinterpret_cast<const BlockDecl &>(parent);
    default: return std::nullopt;
  }
}

bool BlockDecl::block_missing_return_type(void) const {
  return impl->reader.getVal46();
}

bool BlockDecl::can_avoid_copy_to_heap(void) const {
  return impl->reader.getVal49();
}

bool BlockDecl::captures_cxx_this(void) const {
  return impl->reader.getVal50();
}

bool BlockDecl::does_not_escape(void) const {
  return impl->reader.getVal51();
}

std::optional<Decl> BlockDecl::block_mangling_context_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal45();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token BlockDecl::caret_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

CompoundStmt BlockDecl::compound_body(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return CompoundStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Type BlockDecl::signature_as_written(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool BlockDecl::has_captures(void) const {
  return impl->reader.getVal55();
}

bool BlockDecl::is_conversion_from_lambda(void) const {
  return impl->reader.getVal56();
}

bool BlockDecl::is_variadic(void) const {
  return impl->reader.getVal57();
}

std::optional<ParmVarDecl> BlockDecl::nth_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ParmVarDecl> BlockDecl::parameters(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ParmVarDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ParmVarDecl> BlockDecl::nth_parameter_declaration(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameter_declarations()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ParmVarDecl> BlockDecl::parameter_declarations(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ParmVarDecl::from(Decl(std::move(d48)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<Decl> BlockDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<AccessSpecDecl> AccessSpecDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = AccessSpecDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool AccessSpecDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : AccessSpecDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<AccessSpecDecl> AccessSpecDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = AccessSpecDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AccessSpecDecl> AccessSpecDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<AccessSpecDecl> AccessSpecDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = AccessSpecDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<AccessSpecDecl> AccessSpecDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool AccessSpecDecl::contains(const Decl &decl) {
  for (auto &parent : AccessSpecDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool AccessSpecDecl::contains(const Stmt &stmt) {
  for (auto &parent : AccessSpecDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<AccessSpecDecl> AccessSpecDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<AccessSpecDecl> dr = AccessSpecDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<AccessSpecDecl> AccessSpecDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return AccessSpecDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kAccessSpecDeclDerivedKinds[] = {
    AccessSpecDecl::static_kind(),
};

gap::generator<AccessSpecDecl> AccessSpecDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kAccessSpecDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<AccessSpecDecl> e = AccessSpecDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<AccessSpecDecl> AccessSpecDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kAccessSpecDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<AccessSpecDecl> e = AccessSpecDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<AccessSpecDecl> AccessSpecDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::ACCESS_SPEC:
      return reinterpret_cast<const AccessSpecDecl &>(parent);
    default: return std::nullopt;
  }
}

Token AccessSpecDecl::access_specifier_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

Token AccessSpecDecl::colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclarativeDirectiveDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclarativeDirectiveDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclarativeDirectiveDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclarativeDirectiveDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclarativeDirectiveDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDeclarativeDirectiveDecl::contains(const Decl &decl) {
  for (auto &parent : OMPDeclarativeDirectiveDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDeclarativeDirectiveDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPDeclarativeDirectiveDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPDeclarativeDirectiveDecl> dr = OMPDeclarativeDirectiveDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPDeclarativeDirectiveDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPDeclarativeDirectiveDeclDerivedKinds[] = {
    OMPAllocateDecl::static_kind(),
    OMPRequiresDecl::static_kind(),
    OMPThreadPrivateDecl::static_kind(),
};

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPDeclarativeDirectiveDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPDeclarativeDirectiveDecl> e = OMPDeclarativeDirectiveDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPDeclarativeDirectiveDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclarativeDirectiveDecl> e = OMPDeclarativeDirectiveDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclarativeDirectiveDecl> OMPDeclarativeDirectiveDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_THREAD_PRIVATE:
    case mx::DeclKind::OMP_REQUIRES:
    case mx::DeclKind::OMP_ALLOCATE:
      return reinterpret_cast<const OMPDeclarativeDirectiveDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPThreadPrivateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPThreadPrivateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPThreadPrivateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPThreadPrivateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPThreadPrivateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPThreadPrivateDecl::contains(const Decl &decl) {
  for (auto &parent : OMPThreadPrivateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPThreadPrivateDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPThreadPrivateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPThreadPrivateDecl> dr = OMPThreadPrivateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPThreadPrivateDecl> OMPThreadPrivateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPThreadPrivateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPThreadPrivateDeclDerivedKinds[] = {
    OMPThreadPrivateDecl::static_kind(),
};

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPThreadPrivateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPThreadPrivateDecl> e = OMPThreadPrivateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPThreadPrivateDecl> OMPThreadPrivateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPThreadPrivateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPThreadPrivateDecl> e = OMPThreadPrivateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPThreadPrivateDecl> OMPThreadPrivateDecl::from(const OMPDeclarativeDirectiveDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPThreadPrivateDecl> OMPThreadPrivateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_THREAD_PRIVATE:
      return reinterpret_cast<const OMPThreadPrivateDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> OMPThreadPrivateDecl::nth_varlist(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : varlists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPThreadPrivateDecl::varlists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPRequiresDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPRequiresDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPRequiresDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPRequiresDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPRequiresDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPRequiresDecl::contains(const Decl &decl) {
  for (auto &parent : OMPRequiresDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPRequiresDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPRequiresDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPRequiresDecl> dr = OMPRequiresDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPRequiresDecl> OMPRequiresDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPRequiresDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPRequiresDeclDerivedKinds[] = {
    OMPRequiresDecl::static_kind(),
};

gap::generator<OMPRequiresDecl> OMPRequiresDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPRequiresDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPRequiresDecl> e = OMPRequiresDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPRequiresDecl> OMPRequiresDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPRequiresDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPRequiresDecl> e = OMPRequiresDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPRequiresDecl> OMPRequiresDecl::from(const OMPDeclarativeDirectiveDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPRequiresDecl> OMPRequiresDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_REQUIRES:
      return reinterpret_cast<const OMPRequiresDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPAllocateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPAllocateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPAllocateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPAllocateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPAllocateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPAllocateDecl::contains(const Decl &decl) {
  for (auto &parent : OMPAllocateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPAllocateDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPAllocateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPAllocateDecl> dr = OMPAllocateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPAllocateDecl> OMPAllocateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPAllocateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPAllocateDeclDerivedKinds[] = {
    OMPAllocateDecl::static_kind(),
};

gap::generator<OMPAllocateDecl> OMPAllocateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPAllocateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPAllocateDecl> e = OMPAllocateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPAllocateDecl> OMPAllocateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPAllocateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPAllocateDecl> e = OMPAllocateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPAllocateDecl> OMPAllocateDecl::from(const OMPDeclarativeDirectiveDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPAllocateDecl> OMPAllocateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_ALLOCATE:
      return reinterpret_cast<const OMPAllocateDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> OMPAllocateDecl::nth_varlist(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : varlists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Expr> OMPAllocateDecl::varlists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->StmtFor(impl->ep, v)) {
      if (auto e = Expr::from(Stmt(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TranslationUnitDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TranslationUnitDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TranslationUnitDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TranslationUnitDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TranslationUnitDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TranslationUnitDecl::contains(const Decl &decl) {
  for (auto &parent : TranslationUnitDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TranslationUnitDecl::contains(const Stmt &stmt) {
  for (auto &parent : TranslationUnitDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TranslationUnitDecl> dr = TranslationUnitDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TranslationUnitDecl> TranslationUnitDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TranslationUnitDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTranslationUnitDeclDerivedKinds[] = {
    TranslationUnitDecl::static_kind(),
};

gap::generator<TranslationUnitDecl> TranslationUnitDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTranslationUnitDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TranslationUnitDecl> e = TranslationUnitDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TranslationUnitDecl> TranslationUnitDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTranslationUnitDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TranslationUnitDecl> e = TranslationUnitDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TranslationUnitDecl> TranslationUnitDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TRANSLATION_UNIT:
      return reinterpret_cast<const TranslationUnitDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Decl> TranslationUnitDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<StaticAssertDecl> StaticAssertDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = StaticAssertDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool StaticAssertDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : StaticAssertDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<StaticAssertDecl> StaticAssertDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = StaticAssertDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StaticAssertDecl> StaticAssertDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<StaticAssertDecl> StaticAssertDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = StaticAssertDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<StaticAssertDecl> StaticAssertDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool StaticAssertDecl::contains(const Decl &decl) {
  for (auto &parent : StaticAssertDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool StaticAssertDecl::contains(const Stmt &stmt) {
  for (auto &parent : StaticAssertDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<StaticAssertDecl> StaticAssertDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<StaticAssertDecl> dr = StaticAssertDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<StaticAssertDecl> StaticAssertDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return StaticAssertDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kStaticAssertDeclDerivedKinds[] = {
    StaticAssertDecl::static_kind(),
};

gap::generator<StaticAssertDecl> StaticAssertDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kStaticAssertDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<StaticAssertDecl> e = StaticAssertDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<StaticAssertDecl> StaticAssertDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kStaticAssertDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<StaticAssertDecl> e = StaticAssertDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<StaticAssertDecl> StaticAssertDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::STATIC_ASSERT:
      return reinterpret_cast<const StaticAssertDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr StaticAssertDecl::assert_expression(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

StringLiteral StaticAssertDecl::message(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return StringLiteral::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token StaticAssertDecl::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

bool StaticAssertDecl::is_failed(void) const {
  return impl->reader.getVal46();
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RequiresExprBodyDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RequiresExprBodyDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RequiresExprBodyDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RequiresExprBodyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RequiresExprBodyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool RequiresExprBodyDecl::contains(const Decl &decl) {
  for (auto &parent : RequiresExprBodyDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool RequiresExprBodyDecl::contains(const Stmt &stmt) {
  for (auto &parent : RequiresExprBodyDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<RequiresExprBodyDecl> dr = RequiresExprBodyDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<RequiresExprBodyDecl> RequiresExprBodyDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return RequiresExprBodyDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kRequiresExprBodyDeclDerivedKinds[] = {
    RequiresExprBodyDecl::static_kind(),
};

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kRequiresExprBodyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<RequiresExprBodyDecl> e = RequiresExprBodyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RequiresExprBodyDecl> RequiresExprBodyDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kRequiresExprBodyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<RequiresExprBodyDecl> e = RequiresExprBodyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RequiresExprBodyDecl> RequiresExprBodyDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::REQUIRES_EXPR_BODY:
      return reinterpret_cast<const RequiresExprBodyDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Decl> RequiresExprBodyDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaDetectMismatchDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaDetectMismatchDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaDetectMismatchDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = PragmaDetectMismatchDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = PragmaDetectMismatchDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool PragmaDetectMismatchDecl::contains(const Decl &decl) {
  for (auto &parent : PragmaDetectMismatchDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool PragmaDetectMismatchDecl::contains(const Stmt &stmt) {
  for (auto &parent : PragmaDetectMismatchDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<PragmaDetectMismatchDecl> dr = PragmaDetectMismatchDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return PragmaDetectMismatchDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kPragmaDetectMismatchDeclDerivedKinds[] = {
    PragmaDetectMismatchDecl::static_kind(),
};

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kPragmaDetectMismatchDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<PragmaDetectMismatchDecl> e = PragmaDetectMismatchDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kPragmaDetectMismatchDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<PragmaDetectMismatchDecl> e = PragmaDetectMismatchDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaDetectMismatchDecl> PragmaDetectMismatchDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::PRAGMA_DETECT_MISMATCH:
      return reinterpret_cast<const PragmaDetectMismatchDecl &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaDetectMismatchDecl::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal59();
  return std::string_view(data.cStr(), data.size());
}

std::string_view PragmaDetectMismatchDecl::value(void) const {
  capnp::Text::Reader data = impl->reader.getVal60();
  return std::string_view(data.cStr(), data.size());
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = PragmaCommentDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool PragmaCommentDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : PragmaCommentDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = PragmaCommentDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = PragmaCommentDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool PragmaCommentDecl::contains(const Decl &decl) {
  for (auto &parent : PragmaCommentDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool PragmaCommentDecl::contains(const Stmt &stmt) {
  for (auto &parent : PragmaCommentDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<PragmaCommentDecl> dr = PragmaCommentDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<PragmaCommentDecl> PragmaCommentDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return PragmaCommentDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kPragmaCommentDeclDerivedKinds[] = {
    PragmaCommentDecl::static_kind(),
};

gap::generator<PragmaCommentDecl> PragmaCommentDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kPragmaCommentDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<PragmaCommentDecl> e = PragmaCommentDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<PragmaCommentDecl> PragmaCommentDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kPragmaCommentDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<PragmaCommentDecl> e = PragmaCommentDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<PragmaCommentDecl> PragmaCommentDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::PRAGMA_COMMENT:
      return reinterpret_cast<const PragmaCommentDecl &>(parent);
    default: return std::nullopt;
  }
}

std::string_view PragmaCommentDecl::argument(void) const {
  capnp::Text::Reader data = impl->reader.getVal59();
  return std::string_view(data.cStr(), data.size());
}

PragmaMSCommentKind PragmaCommentDecl::comment_kind(void) const {
  return static_cast<PragmaMSCommentKind>(impl->reader.getVal61());
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCPropertyImplDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCPropertyImplDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCPropertyImplDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCPropertyImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCPropertyImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCPropertyImplDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCPropertyImplDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCPropertyImplDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCPropertyImplDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCPropertyImplDecl> dr = ObjCPropertyImplDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCPropertyImplDecl> ObjCPropertyImplDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCPropertyImplDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCPropertyImplDeclDerivedKinds[] = {
    ObjCPropertyImplDecl::static_kind(),
};

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCPropertyImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCPropertyImplDecl> e = ObjCPropertyImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCPropertyImplDecl> ObjCPropertyImplDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCPropertyImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCPropertyImplDecl> e = ObjCPropertyImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCPropertyImplDecl> ObjCPropertyImplDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_PROPERTY_IMPL:
      return reinterpret_cast<const ObjCPropertyImplDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr ObjCPropertyImplDecl::getter_cxx_constructor(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ObjCMethodDecl ObjCPropertyImplDecl::getter_method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCPropertyDecl ObjCPropertyImplDecl::property_declaration(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return ObjCPropertyDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCPropertyImplDeclKind ObjCPropertyImplDecl::property_implementation(void) const {
  return static_cast<ObjCPropertyImplDeclKind>(impl->reader.getVal61());
}

ObjCIvarDecl ObjCPropertyImplDecl::property_instance_variable_declaration(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return ObjCIvarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCPropertyImplDecl::property_instance_variable_declaration_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

Expr ObjCPropertyImplDecl::setter_cxx_assignment(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ObjCMethodDecl ObjCPropertyImplDecl::setter_method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal64();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ObjCPropertyImplDecl::is_instance_variable_name_specified(void) const {
  return impl->reader.getVal46();
}

gap::generator<NamedDecl> NamedDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NamedDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NamedDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NamedDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NamedDecl> NamedDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamedDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamedDecl> NamedDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NamedDecl> NamedDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamedDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamedDecl> NamedDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NamedDecl::contains(const Decl &decl) {
  for (auto &parent : NamedDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NamedDecl::contains(const Stmt &stmt) {
  for (auto &parent : NamedDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<NamedDecl> NamedDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<NamedDecl> dr = NamedDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<NamedDecl> NamedDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return NamedDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kNamedDeclDerivedKinds[] = {
    NamespaceAliasDecl::static_kind(),
    NamespaceDecl::static_kind(),
    ObjCCompatibleAliasDecl::static_kind(),
    ObjCMethodDecl::static_kind(),
    ObjCPropertyDecl::static_kind(),
    UnresolvedUsingIfExistsDecl::static_kind(),
    UsingDirectiveDecl::static_kind(),
    UsingPackDecl::static_kind(),
    UsingShadowDecl::static_kind(),
    LabelDecl::static_kind(),
    ObjCInterfaceDecl::static_kind(),
    ObjCProtocolDecl::static_kind(),
    ObjCCategoryDecl::static_kind(),
    TemplateTemplateParmDecl::static_kind(),
    BuiltinTemplateDecl::static_kind(),
    ConceptDecl::static_kind(),
    UnresolvedUsingTypenameDecl::static_kind(),
    TemplateTypeParmDecl::static_kind(),
    ConstructorUsingShadowDecl::static_kind(),
    BindingDecl::static_kind(),
    EnumConstantDecl::static_kind(),
    IndirectFieldDecl::static_kind(),
    MSGuidDecl::static_kind(),
    OMPDeclareReductionDecl::static_kind(),
    TemplateParamObjectDecl::static_kind(),
    UnnamedGlobalConstantDecl::static_kind(),
    UnresolvedUsingValueDecl::static_kind(),
    UsingDecl::static_kind(),
    UsingEnumDecl::static_kind(),
    ObjCImplementationDecl::static_kind(),
    ObjCCategoryImplDecl::static_kind(),
    TypeAliasTemplateDecl::static_kind(),
    VarTemplateDecl::static_kind(),
    ClassTemplateDecl::static_kind(),
    FunctionTemplateDecl::static_kind(),
    ObjCTypeParamDecl::static_kind(),
    TypeAliasDecl::static_kind(),
    TypedefDecl::static_kind(),
    EnumDecl::static_kind(),
    RecordDecl::static_kind(),
    OMPDeclareMapperDecl::static_kind(),
    FieldDecl::static_kind(),
    FunctionDecl::static_kind(),
    MSPropertyDecl::static_kind(),
    NonTypeTemplateParmDecl::static_kind(),
    VarDecl::static_kind(),
    CXXRecordDecl::static_kind(),
    ObjCAtDefsFieldDecl::static_kind(),
    ObjCIvarDecl::static_kind(),
    CXXDeductionGuideDecl::static_kind(),
    CXXMethodDecl::static_kind(),
    VarTemplateSpecializationDecl::static_kind(),
    DecompositionDecl::static_kind(),
    ImplicitParamDecl::static_kind(),
    OMPCapturedExprDecl::static_kind(),
    ParmVarDecl::static_kind(),
    ClassTemplateSpecializationDecl::static_kind(),
    CXXConstructorDecl::static_kind(),
    CXXConversionDecl::static_kind(),
    CXXDestructorDecl::static_kind(),
    VarTemplatePartialSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<NamedDecl> NamedDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kNamedDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<NamedDecl> e = NamedDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NamedDecl> NamedDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kNamedDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<NamedDecl> e = NamedDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NamedDecl> NamedDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::LABEL:
    case mx::DeclKind::USING_ENUM:
    case mx::DeclKind::USING:
    case mx::DeclKind::UNRESOLVED_USING_VALUE:
    case mx::DeclKind::UNNAMED_GLOBAL_CONSTANT:
    case mx::DeclKind::TEMPLATE_PARAM_OBJECT:
    case mx::DeclKind::OMP_DECLARE_REDUCTION:
    case mx::DeclKind::MS_GUID:
    case mx::DeclKind::INDIRECT_FIELD:
    case mx::DeclKind::ENUM_CONSTANT:
    case mx::DeclKind::VAR:
    case mx::DeclKind::PARM_VAR:
    case mx::DeclKind::OMP_CAPTURED_EXPR:
    case mx::DeclKind::IMPLICIT_PARAM:
    case mx::DeclKind::DECOMPOSITION:
    case mx::DeclKind::VAR_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::NON_TYPE_TEMPLATE_PARM:
    case mx::DeclKind::MS_PROPERTY:
    case mx::DeclKind::FUNCTION:
    case mx::DeclKind::CXX_METHOD:
    case mx::DeclKind::CXX_DESTRUCTOR:
    case mx::DeclKind::CXX_CONVERSION:
    case mx::DeclKind::CXX_CONSTRUCTOR:
    case mx::DeclKind::CXX_DEDUCTION_GUIDE:
    case mx::DeclKind::FIELD:
    case mx::DeclKind::OBJ_C_IVAR:
    case mx::DeclKind::OBJ_C_AT_DEFS_FIELD:
    case mx::DeclKind::BINDING:
    case mx::DeclKind::OMP_DECLARE_MAPPER:
    case mx::DeclKind::USING_SHADOW:
    case mx::DeclKind::CONSTRUCTOR_USING_SHADOW:
    case mx::DeclKind::USING_PACK:
    case mx::DeclKind::USING_DIRECTIVE:
    case mx::DeclKind::UNRESOLVED_USING_IF_EXISTS:
    case mx::DeclKind::TEMPLATE_TYPE_PARM:
    case mx::DeclKind::RECORD:
    case mx::DeclKind::CXX_RECORD:
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::ENUM:
    case mx::DeclKind::UNRESOLVED_USING_TYPENAME:
    case mx::DeclKind::TYPEDEF:
    case mx::DeclKind::TYPE_ALIAS:
    case mx::DeclKind::OBJ_C_TYPE_PARAM:
    case mx::DeclKind::FUNCTION_TEMPLATE:
    case mx::DeclKind::CLASS_TEMPLATE:
    case mx::DeclKind::VAR_TEMPLATE:
    case mx::DeclKind::TYPE_ALIAS_TEMPLATE:
    case mx::DeclKind::CONCEPT:
    case mx::DeclKind::BUILTIN_TEMPLATE:
    case mx::DeclKind::TEMPLATE_TEMPLATE_PARM:
    case mx::DeclKind::OBJ_C_PROPERTY:
    case mx::DeclKind::OBJ_C_METHOD:
    case mx::DeclKind::OBJ_C_CATEGORY:
    case mx::DeclKind::OBJ_C_PROTOCOL:
    case mx::DeclKind::OBJ_C_INTERFACE:
    case mx::DeclKind::OBJ_C_CATEGORY_IMPL:
    case mx::DeclKind::OBJ_C_IMPLEMENTATION:
    case mx::DeclKind::OBJ_C_COMPATIBLE_ALIAS:
    case mx::DeclKind::NAMESPACE:
    case mx::DeclKind::NAMESPACE_ALIAS:
      return reinterpret_cast<const NamedDecl &>(parent);
    default: return std::nullopt;
  }
}

Linkage NamedDecl::formal_linkage(void) const {
  return static_cast<Linkage>(impl->reader.getVal61());
}

std::string_view NamedDecl::name(void) const {
  capnp::Text::Reader data = impl->reader.getVal59();
  return std::string_view(data.cStr(), data.size());
}

std::optional<ObjCStringFormatFamily> NamedDecl::obj_cf_string_formatting_family(void) const {
  if (!impl->reader.getVal46()) {
    return std::nullopt;
  } else {
    return static_cast<ObjCStringFormatFamily>(impl->reader.getVal65());
  }
  return std::nullopt;
}

std::string_view NamedDecl::qualified_name_as_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal60();
  return std::string_view(data.cStr(), data.size());
}

NamedDecl NamedDecl::underlying_declaration(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Visibility NamedDecl::visibility(void) const {
  return static_cast<Visibility>(impl->reader.getVal66());
}

bool NamedDecl::has_external_formal_linkage(void) const {
  return impl->reader.getVal49();
}

bool NamedDecl::has_linkage(void) const {
  return impl->reader.getVal50();
}

bool NamedDecl::has_linkage_been_computed(void) const {
  return impl->reader.getVal51();
}

bool NamedDecl::is_cxx_class_member(void) const {
  return impl->reader.getVal55();
}

bool NamedDecl::is_cxx_instance_member(void) const {
  return impl->reader.getVal56();
}

bool NamedDecl::is_externally_declarable(void) const {
  return impl->reader.getVal57();
}

bool NamedDecl::is_externally_visible(void) const {
  return impl->reader.getVal67();
}

bool NamedDecl::is_linkage_valid(void) const {
  return impl->reader.getVal68();
}

gap::generator<LabelDecl> LabelDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LabelDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LabelDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LabelDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<LabelDecl> LabelDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LabelDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LabelDecl> LabelDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<LabelDecl> LabelDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LabelDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LabelDecl> LabelDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool LabelDecl::contains(const Decl &decl) {
  for (auto &parent : LabelDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool LabelDecl::contains(const Stmt &stmt) {
  for (auto &parent : LabelDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<LabelDecl> LabelDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<LabelDecl> dr = LabelDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<LabelDecl> LabelDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return LabelDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kLabelDeclDerivedKinds[] = {
    LabelDecl::static_kind(),
};

gap::generator<LabelDecl> LabelDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kLabelDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<LabelDecl> e = LabelDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LabelDecl> LabelDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kLabelDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<LabelDecl> e = LabelDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LabelDecl> LabelDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<LabelDecl> LabelDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::LABEL:
      return reinterpret_cast<const LabelDecl &>(parent);
    default: return std::nullopt;
  }
}

std::string_view LabelDecl::ms_assembly_label(void) const {
  capnp::Text::Reader data = impl->reader.getVal69();
  return std::string_view(data.cStr(), data.size());
}

LabelStmt LabelDecl::statement(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return LabelStmt::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool LabelDecl::is_gnu_local(void) const {
  return impl->reader.getVal70();
}

bool LabelDecl::is_ms_assembly_label(void) const {
  return impl->reader.getVal71();
}

bool LabelDecl::is_resolved_ms_assembly_label(void) const {
  return impl->reader.getVal72();
}

gap::generator<BaseUsingDecl> BaseUsingDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BaseUsingDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BaseUsingDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BaseUsingDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BaseUsingDecl> BaseUsingDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BaseUsingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BaseUsingDecl> BaseUsingDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BaseUsingDecl> BaseUsingDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BaseUsingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BaseUsingDecl> BaseUsingDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BaseUsingDecl::contains(const Decl &decl) {
  for (auto &parent : BaseUsingDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BaseUsingDecl::contains(const Stmt &stmt) {
  for (auto &parent : BaseUsingDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<BaseUsingDecl> BaseUsingDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<BaseUsingDecl> dr = BaseUsingDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<BaseUsingDecl> BaseUsingDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return BaseUsingDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kBaseUsingDeclDerivedKinds[] = {
    UsingDecl::static_kind(),
    UsingEnumDecl::static_kind(),
};

gap::generator<BaseUsingDecl> BaseUsingDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kBaseUsingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<BaseUsingDecl> e = BaseUsingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BaseUsingDecl> BaseUsingDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kBaseUsingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<BaseUsingDecl> e = BaseUsingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BaseUsingDecl> BaseUsingDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<BaseUsingDecl> BaseUsingDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING_ENUM:
    case mx::DeclKind::USING:
      return reinterpret_cast<const BaseUsingDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<UsingShadowDecl> BaseUsingDecl::nth_shadow(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : shadows()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<UsingShadowDecl> BaseUsingDecl::shadows(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = UsingShadowDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<UsingEnumDecl> UsingEnumDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingEnumDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingEnumDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingEnumDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UsingEnumDecl> UsingEnumDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingEnumDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingEnumDecl> UsingEnumDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UsingEnumDecl> UsingEnumDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingEnumDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingEnumDecl> UsingEnumDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UsingEnumDecl::contains(const Decl &decl) {
  for (auto &parent : UsingEnumDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UsingEnumDecl::contains(const Stmt &stmt) {
  for (auto &parent : UsingEnumDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UsingEnumDecl> UsingEnumDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UsingEnumDecl> dr = UsingEnumDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UsingEnumDecl> UsingEnumDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UsingEnumDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUsingEnumDeclDerivedKinds[] = {
    UsingEnumDecl::static_kind(),
};

gap::generator<UsingEnumDecl> UsingEnumDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUsingEnumDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UsingEnumDecl> e = UsingEnumDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingEnumDecl> UsingEnumDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUsingEnumDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UsingEnumDecl> e = UsingEnumDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingEnumDecl> UsingEnumDecl::from(const BaseUsingDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingEnumDecl> UsingEnumDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingEnumDecl> UsingEnumDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING_ENUM:
      return reinterpret_cast<const UsingEnumDecl &>(parent);
    default: return std::nullopt;
  }
}

EnumDecl UsingEnumDecl::enum_declaration(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return EnumDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token UsingEnumDecl::enum_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

Token UsingEnumDecl::using_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

gap::generator<UsingDecl> UsingDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UsingDecl> UsingDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingDecl> UsingDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UsingDecl> UsingDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingDecl> UsingDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UsingDecl::contains(const Decl &decl) {
  for (auto &parent : UsingDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UsingDecl::contains(const Stmt &stmt) {
  for (auto &parent : UsingDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UsingDecl> UsingDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UsingDecl> dr = UsingDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UsingDecl> UsingDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UsingDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUsingDeclDerivedKinds[] = {
    UsingDecl::static_kind(),
};

gap::generator<UsingDecl> UsingDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUsingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UsingDecl> e = UsingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingDecl> UsingDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUsingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UsingDecl> e = UsingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingDecl> UsingDecl::from(const BaseUsingDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingDecl> UsingDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingDecl> UsingDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING:
      return reinterpret_cast<const UsingDecl &>(parent);
    default: return std::nullopt;
  }
}

Token UsingDecl::using_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

bool UsingDecl::has_typename(void) const {
  return impl->reader.getVal70();
}

bool UsingDecl::is_access_declaration(void) const {
  return impl->reader.getVal71();
}

gap::generator<ValueDecl> ValueDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ValueDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ValueDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ValueDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ValueDecl> ValueDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ValueDecl> ValueDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ValueDecl> ValueDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ValueDecl> ValueDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ValueDecl::contains(const Decl &decl) {
  for (auto &parent : ValueDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ValueDecl::contains(const Stmt &stmt) {
  for (auto &parent : ValueDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ValueDecl> ValueDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ValueDecl> dr = ValueDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ValueDecl> ValueDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ValueDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kValueDeclDerivedKinds[] = {
    BindingDecl::static_kind(),
    EnumConstantDecl::static_kind(),
    IndirectFieldDecl::static_kind(),
    MSGuidDecl::static_kind(),
    OMPDeclareReductionDecl::static_kind(),
    TemplateParamObjectDecl::static_kind(),
    UnnamedGlobalConstantDecl::static_kind(),
    UnresolvedUsingValueDecl::static_kind(),
    OMPDeclareMapperDecl::static_kind(),
    FieldDecl::static_kind(),
    FunctionDecl::static_kind(),
    MSPropertyDecl::static_kind(),
    NonTypeTemplateParmDecl::static_kind(),
    VarDecl::static_kind(),
    ObjCAtDefsFieldDecl::static_kind(),
    ObjCIvarDecl::static_kind(),
    CXXDeductionGuideDecl::static_kind(),
    CXXMethodDecl::static_kind(),
    VarTemplateSpecializationDecl::static_kind(),
    DecompositionDecl::static_kind(),
    ImplicitParamDecl::static_kind(),
    OMPCapturedExprDecl::static_kind(),
    ParmVarDecl::static_kind(),
    CXXConstructorDecl::static_kind(),
    CXXConversionDecl::static_kind(),
    CXXDestructorDecl::static_kind(),
    VarTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<ValueDecl> ValueDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ValueDecl> e = ValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ValueDecl> ValueDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ValueDecl> e = ValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ValueDecl> ValueDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ValueDecl> ValueDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::UNRESOLVED_USING_VALUE:
    case mx::DeclKind::UNNAMED_GLOBAL_CONSTANT:
    case mx::DeclKind::TEMPLATE_PARAM_OBJECT:
    case mx::DeclKind::OMP_DECLARE_REDUCTION:
    case mx::DeclKind::MS_GUID:
    case mx::DeclKind::INDIRECT_FIELD:
    case mx::DeclKind::ENUM_CONSTANT:
    case mx::DeclKind::VAR:
    case mx::DeclKind::PARM_VAR:
    case mx::DeclKind::OMP_CAPTURED_EXPR:
    case mx::DeclKind::IMPLICIT_PARAM:
    case mx::DeclKind::DECOMPOSITION:
    case mx::DeclKind::VAR_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::NON_TYPE_TEMPLATE_PARM:
    case mx::DeclKind::MS_PROPERTY:
    case mx::DeclKind::FUNCTION:
    case mx::DeclKind::CXX_METHOD:
    case mx::DeclKind::CXX_DESTRUCTOR:
    case mx::DeclKind::CXX_CONVERSION:
    case mx::DeclKind::CXX_CONSTRUCTOR:
    case mx::DeclKind::CXX_DEDUCTION_GUIDE:
    case mx::DeclKind::FIELD:
    case mx::DeclKind::OBJ_C_IVAR:
    case mx::DeclKind::OBJ_C_AT_DEFS_FIELD:
    case mx::DeclKind::BINDING:
    case mx::DeclKind::OMP_DECLARE_MAPPER:
      return reinterpret_cast<const ValueDecl &>(parent);
    default: return std::nullopt;
  }
}

Type ValueDecl::type(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ValueDecl::is_weak(void) const {
  return impl->reader.getVal70();
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedUsingValueDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedUsingValueDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedUsingValueDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnresolvedUsingValueDecl::contains(const Decl &decl) {
  for (auto &parent : UnresolvedUsingValueDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnresolvedUsingValueDecl::contains(const Stmt &stmt) {
  for (auto &parent : UnresolvedUsingValueDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UnresolvedUsingValueDecl> dr = UnresolvedUsingValueDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UnresolvedUsingValueDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUnresolvedUsingValueDeclDerivedKinds[] = {
    UnresolvedUsingValueDecl::static_kind(),
};

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUnresolvedUsingValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UnresolvedUsingValueDecl> e = UnresolvedUsingValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUnresolvedUsingValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedUsingValueDecl> e = UnresolvedUsingValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnresolvedUsingValueDecl> UnresolvedUsingValueDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::UNRESOLVED_USING_VALUE:
      return reinterpret_cast<const UnresolvedUsingValueDecl &>(parent);
    default: return std::nullopt;
  }
}

Token UnresolvedUsingValueDecl::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

Token UnresolvedUsingValueDecl::using_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

bool UnresolvedUsingValueDecl::is_access_declaration(void) const {
  return impl->reader.getVal71();
}

bool UnresolvedUsingValueDecl::is_pack_expansion(void) const {
  return impl->reader.getVal72();
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnnamedGlobalConstantDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnnamedGlobalConstantDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnnamedGlobalConstantDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnnamedGlobalConstantDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnnamedGlobalConstantDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnnamedGlobalConstantDecl::contains(const Decl &decl) {
  for (auto &parent : UnnamedGlobalConstantDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnnamedGlobalConstantDecl::contains(const Stmt &stmt) {
  for (auto &parent : UnnamedGlobalConstantDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UnnamedGlobalConstantDecl> dr = UnnamedGlobalConstantDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UnnamedGlobalConstantDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUnnamedGlobalConstantDeclDerivedKinds[] = {
    UnnamedGlobalConstantDecl::static_kind(),
};

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUnnamedGlobalConstantDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UnnamedGlobalConstantDecl> e = UnnamedGlobalConstantDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUnnamedGlobalConstantDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UnnamedGlobalConstantDecl> e = UnnamedGlobalConstantDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnnamedGlobalConstantDecl> UnnamedGlobalConstantDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::UNNAMED_GLOBAL_CONSTANT:
      return reinterpret_cast<const UnnamedGlobalConstantDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateParamObjectDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateParamObjectDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateParamObjectDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateParamObjectDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateParamObjectDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TemplateParamObjectDecl::contains(const Decl &decl) {
  for (auto &parent : TemplateParamObjectDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TemplateParamObjectDecl::contains(const Stmt &stmt) {
  for (auto &parent : TemplateParamObjectDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TemplateParamObjectDecl> dr = TemplateParamObjectDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TemplateParamObjectDecl> TemplateParamObjectDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TemplateParamObjectDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTemplateParamObjectDeclDerivedKinds[] = {
    TemplateParamObjectDecl::static_kind(),
};

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTemplateParamObjectDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TemplateParamObjectDecl> e = TemplateParamObjectDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateParamObjectDecl> TemplateParamObjectDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTemplateParamObjectDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TemplateParamObjectDecl> e = TemplateParamObjectDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateParamObjectDecl> TemplateParamObjectDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateParamObjectDecl> TemplateParamObjectDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateParamObjectDecl> TemplateParamObjectDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TEMPLATE_PARAM_OBJECT:
      return reinterpret_cast<const TemplateParamObjectDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclareReductionDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclareReductionDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclareReductionDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclareReductionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclareReductionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDeclareReductionDecl::contains(const Decl &decl) {
  for (auto &parent : OMPDeclareReductionDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDeclareReductionDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPDeclareReductionDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPDeclareReductionDecl> dr = OMPDeclareReductionDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPDeclareReductionDecl> OMPDeclareReductionDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPDeclareReductionDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPDeclareReductionDeclDerivedKinds[] = {
    OMPDeclareReductionDecl::static_kind(),
};

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPDeclareReductionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPDeclareReductionDecl> e = OMPDeclareReductionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclareReductionDecl> OMPDeclareReductionDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPDeclareReductionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclareReductionDecl> e = OMPDeclareReductionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclareReductionDecl> OMPDeclareReductionDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclareReductionDecl> OMPDeclareReductionDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclareReductionDecl> OMPDeclareReductionDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_DECLARE_REDUCTION:
      return reinterpret_cast<const OMPDeclareReductionDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPDeclareReductionDecl::combiner(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPDeclareReductionDecl::combiner_in(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPDeclareReductionDecl::combiner_out(void) const {
  RawEntityId eid = impl->reader.getVal62();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPDeclareReductionDecl::initializer_original(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPDeclareReductionDecl::initializer_private(void) const {
  RawEntityId eid = impl->reader.getVal64();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Expr OMPDeclareReductionDecl::initializer(void) const {
  RawEntityId eid = impl->reader.getVal73();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

OMPDeclareReductionDeclInitKind OMPDeclareReductionDecl::initializer_kind(void) const {
  return static_cast<OMPDeclareReductionDeclInitKind>(impl->reader.getVal74());
}

gap::generator<Decl> OMPDeclareReductionDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<MSGuidDecl> MSGuidDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSGuidDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSGuidDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSGuidDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSGuidDecl> MSGuidDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = MSGuidDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSGuidDecl> MSGuidDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSGuidDecl> MSGuidDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = MSGuidDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSGuidDecl> MSGuidDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSGuidDecl::contains(const Decl &decl) {
  for (auto &parent : MSGuidDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSGuidDecl::contains(const Stmt &stmt) {
  for (auto &parent : MSGuidDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<MSGuidDecl> MSGuidDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<MSGuidDecl> dr = MSGuidDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<MSGuidDecl> MSGuidDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return MSGuidDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kMSGuidDeclDerivedKinds[] = {
    MSGuidDecl::static_kind(),
};

gap::generator<MSGuidDecl> MSGuidDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kMSGuidDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<MSGuidDecl> e = MSGuidDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSGuidDecl> MSGuidDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kMSGuidDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<MSGuidDecl> e = MSGuidDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSGuidDecl> MSGuidDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<MSGuidDecl> MSGuidDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<MSGuidDecl> MSGuidDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::MS_GUID:
      return reinterpret_cast<const MSGuidDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = IndirectFieldDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool IndirectFieldDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : IndirectFieldDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = IndirectFieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = IndirectFieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool IndirectFieldDecl::contains(const Decl &decl) {
  for (auto &parent : IndirectFieldDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool IndirectFieldDecl::contains(const Stmt &stmt) {
  for (auto &parent : IndirectFieldDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<IndirectFieldDecl> dr = IndirectFieldDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<IndirectFieldDecl> IndirectFieldDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return IndirectFieldDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kIndirectFieldDeclDerivedKinds[] = {
    IndirectFieldDecl::static_kind(),
};

gap::generator<IndirectFieldDecl> IndirectFieldDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kIndirectFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<IndirectFieldDecl> e = IndirectFieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<IndirectFieldDecl> IndirectFieldDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kIndirectFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<IndirectFieldDecl> e = IndirectFieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<IndirectFieldDecl> IndirectFieldDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<IndirectFieldDecl> IndirectFieldDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<IndirectFieldDecl> IndirectFieldDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::INDIRECT_FIELD:
      return reinterpret_cast<const IndirectFieldDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<NamedDecl> IndirectFieldDecl::chain(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = NamedDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<FieldDecl> IndirectFieldDecl::anonymous_field(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FieldDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<VarDecl> IndirectFieldDecl::variable_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal54();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<EnumConstantDecl> EnumConstantDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnumConstantDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnumConstantDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnumConstantDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<EnumConstantDecl> EnumConstantDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EnumConstantDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EnumConstantDecl> EnumConstantDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<EnumConstantDecl> EnumConstantDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EnumConstantDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EnumConstantDecl> EnumConstantDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool EnumConstantDecl::contains(const Decl &decl) {
  for (auto &parent : EnumConstantDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool EnumConstantDecl::contains(const Stmt &stmt) {
  for (auto &parent : EnumConstantDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<EnumConstantDecl> EnumConstantDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<EnumConstantDecl> dr = EnumConstantDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<EnumConstantDecl> EnumConstantDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return EnumConstantDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kEnumConstantDeclDerivedKinds[] = {
    EnumConstantDecl::static_kind(),
};

gap::generator<EnumConstantDecl> EnumConstantDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kEnumConstantDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<EnumConstantDecl> e = EnumConstantDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnumConstantDecl> EnumConstantDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kEnumConstantDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<EnumConstantDecl> e = EnumConstantDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnumConstantDecl> EnumConstantDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<EnumConstantDecl> EnumConstantDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<EnumConstantDecl> EnumConstantDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::ENUM_CONSTANT:
      return reinterpret_cast<const EnumConstantDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> EnumConstantDecl::initializer_expression(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<DeclaratorDecl> DeclaratorDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DeclaratorDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DeclaratorDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DeclaratorDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DeclaratorDecl> DeclaratorDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = DeclaratorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclaratorDecl> DeclaratorDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DeclaratorDecl> DeclaratorDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = DeclaratorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DeclaratorDecl> DeclaratorDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DeclaratorDecl::contains(const Decl &decl) {
  for (auto &parent : DeclaratorDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DeclaratorDecl::contains(const Stmt &stmt) {
  for (auto &parent : DeclaratorDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<DeclaratorDecl> DeclaratorDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<DeclaratorDecl> dr = DeclaratorDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<DeclaratorDecl> DeclaratorDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return DeclaratorDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kDeclaratorDeclDerivedKinds[] = {
    FieldDecl::static_kind(),
    FunctionDecl::static_kind(),
    MSPropertyDecl::static_kind(),
    NonTypeTemplateParmDecl::static_kind(),
    VarDecl::static_kind(),
    ObjCAtDefsFieldDecl::static_kind(),
    ObjCIvarDecl::static_kind(),
    CXXDeductionGuideDecl::static_kind(),
    CXXMethodDecl::static_kind(),
    VarTemplateSpecializationDecl::static_kind(),
    DecompositionDecl::static_kind(),
    ImplicitParamDecl::static_kind(),
    OMPCapturedExprDecl::static_kind(),
    ParmVarDecl::static_kind(),
    CXXConstructorDecl::static_kind(),
    CXXConversionDecl::static_kind(),
    CXXDestructorDecl::static_kind(),
    VarTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<DeclaratorDecl> DeclaratorDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kDeclaratorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<DeclaratorDecl> e = DeclaratorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DeclaratorDecl> DeclaratorDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kDeclaratorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<DeclaratorDecl> e = DeclaratorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DeclaratorDecl> DeclaratorDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DeclaratorDecl> DeclaratorDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DeclaratorDecl> DeclaratorDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::VAR:
    case mx::DeclKind::PARM_VAR:
    case mx::DeclKind::OMP_CAPTURED_EXPR:
    case mx::DeclKind::IMPLICIT_PARAM:
    case mx::DeclKind::DECOMPOSITION:
    case mx::DeclKind::VAR_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::NON_TYPE_TEMPLATE_PARM:
    case mx::DeclKind::MS_PROPERTY:
    case mx::DeclKind::FUNCTION:
    case mx::DeclKind::CXX_METHOD:
    case mx::DeclKind::CXX_DESTRUCTOR:
    case mx::DeclKind::CXX_CONVERSION:
    case mx::DeclKind::CXX_CONSTRUCTOR:
    case mx::DeclKind::CXX_DEDUCTION_GUIDE:
    case mx::DeclKind::FIELD:
    case mx::DeclKind::OBJ_C_IVAR:
    case mx::DeclKind::OBJ_C_AT_DEFS_FIELD:
      return reinterpret_cast<const DeclaratorDecl &>(parent);
    default: return std::nullopt;
  }
}

Token DeclaratorDecl::first_inner_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

Token DeclaratorDecl::first_outer_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

std::optional<Expr> DeclaratorDecl::trailing_requires_clause(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal62();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token DeclaratorDecl::type_spec_end_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal63());
}

Token DeclaratorDecl::type_spec_start_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal64());
}

std::optional<TemplateParameterList> DeclaratorDecl::nth_template_parameter_list(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_parameter_lists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateParameterList> DeclaratorDecl::template_parameter_lists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->TemplateParameterListFor(impl->ep, v)) {
      co_yield TemplateParameterList(std::move(d47));
    }
  }
  co_return;
}

gap::generator<VarDecl> VarDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VarDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VarDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VarDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<VarDecl> VarDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarDecl> VarDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<VarDecl> VarDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarDecl> VarDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool VarDecl::contains(const Decl &decl) {
  for (auto &parent : VarDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool VarDecl::contains(const Stmt &stmt) {
  for (auto &parent : VarDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<VarDecl> VarDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<VarDecl> dr = VarDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<VarDecl> VarDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return VarDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kVarDeclDerivedKinds[] = {
    VarDecl::static_kind(),
    VarTemplateSpecializationDecl::static_kind(),
    DecompositionDecl::static_kind(),
    ImplicitParamDecl::static_kind(),
    OMPCapturedExprDecl::static_kind(),
    ParmVarDecl::static_kind(),
    VarTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<VarDecl> VarDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kVarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<VarDecl> e = VarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VarDecl> VarDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kVarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<VarDecl> e = VarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VarDecl> VarDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarDecl> VarDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarDecl> VarDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarDecl> VarDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::VAR:
    case mx::DeclKind::PARM_VAR:
    case mx::DeclKind::OMP_CAPTURED_EXPR:
    case mx::DeclKind::IMPLICIT_PARAM:
    case mx::DeclKind::DECOMPOSITION:
    case mx::DeclKind::VAR_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const VarDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<VarDecl> VarDecl::acting_definition(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<VarTemplateDecl> VarDecl::described_variable_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal75();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Expr> VarDecl::initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal76();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

VarDeclInitializationStyle VarDecl::initializer_style(void) const {
  return static_cast<VarDeclInitializationStyle>(impl->reader.getVal74());
}

std::optional<VarDecl> VarDecl::initializing_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal77();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<VarDecl> VarDecl::instantiated_from_static_data_member(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal78();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

LanguageLinkage VarDecl::language_linkage(void) const {
  return static_cast<LanguageLinkage>(impl->reader.getVal79());
}

Token VarDecl::point_of_instantiation(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal80());
}

StorageClass VarDecl::storage_class(void) const {
  return static_cast<StorageClass>(impl->reader.getVal81());
}

StorageDuration VarDecl::storage_duration(void) const {
  return static_cast<StorageDuration>(impl->reader.getVal82());
}

VarDeclTLSKind VarDecl::tls_kind(void) const {
  return static_cast<VarDeclTLSKind>(impl->reader.getVal83());
}

ThreadStorageClassSpecifier VarDecl::tsc_spec(void) const {
  return static_cast<ThreadStorageClassSpecifier>(impl->reader.getVal84());
}

std::optional<VarDecl> VarDecl::template_instantiation_pattern(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal85();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return VarDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TemplateSpecializationKind VarDecl::template_specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal86());
}

TemplateSpecializationKind VarDecl::template_specialization_kind_for_instantiation(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal87());
}

bool VarDecl::has_constant_initialization(void) const {
  return impl->reader.getVal71();
}

bool VarDecl::has_dependent_alignment(void) const {
  return impl->reader.getVal72();
}

bool VarDecl::has_external_storage(void) const {
  return impl->reader.getVal88();
}

std::optional<bool> VarDecl::has_flexible_array_initializer(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal89());
  }
  return std::nullopt;
}

bool VarDecl::has_global_storage(void) const {
  return impl->reader.getVal91();
}

std::optional<bool> VarDecl::has_ice_initializer(void) const {
  if (!impl->reader.getVal93()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal92());
  }
  return std::nullopt;
}

bool VarDecl::has_initializer(void) const {
  return impl->reader.getVal94();
}

bool VarDecl::has_local_storage(void) const {
  return impl->reader.getVal95();
}

bool VarDecl::is_arc_pseudo_strong(void) const {
  return impl->reader.getVal96();
}

bool VarDecl::is_cxx_for_range_declaration(void) const {
  return impl->reader.getVal97();
}

bool VarDecl::is_constexpr(void) const {
  return impl->reader.getVal98();
}

bool VarDecl::is_direct_initializer(void) const {
  return impl->reader.getVal99();
}

bool VarDecl::is_escaping_byref(void) const {
  return impl->reader.getVal100();
}

bool VarDecl::is_exception_variable(void) const {
  return impl->reader.getVal101();
}

bool VarDecl::is_extern_c(void) const {
  return impl->reader.getVal102();
}

bool VarDecl::is_file_variable_declaration(void) const {
  return impl->reader.getVal103();
}

bool VarDecl::is_function_or_method_variable_declaration(void) const {
  return impl->reader.getVal104();
}

bool VarDecl::is_in_extern_c_context(void) const {
  return impl->reader.getVal105();
}

bool VarDecl::is_in_extern_cxx_context(void) const {
  return impl->reader.getVal106();
}

bool VarDecl::is_initializer_capture(void) const {
  return impl->reader.getVal107();
}

bool VarDecl::is_inline(void) const {
  return impl->reader.getVal108();
}

bool VarDecl::is_inline_specified(void) const {
  return impl->reader.getVal109();
}

bool VarDecl::is_known_to_be_defined(void) const {
  return impl->reader.getVal110();
}

bool VarDecl::is_local_variable_declaration(void) const {
  return impl->reader.getVal111();
}

bool VarDecl::is_local_variable_declaration_or_parm(void) const {
  return impl->reader.getVal112();
}

bool VarDecl::is_nrvo_variable(void) const {
  return impl->reader.getVal113();
}

bool VarDecl::is_no_destroy(void) const {
  return impl->reader.getVal114();
}

bool VarDecl::is_non_escaping_byref(void) const {
  return impl->reader.getVal115();
}

bool VarDecl::is_obj_c_for_declaration(void) const {
  return impl->reader.getVal116();
}

bool VarDecl::is_previous_declaration_in_same_block_scope(void) const {
  return impl->reader.getVal117();
}

bool VarDecl::is_static_data_member(void) const {
  return impl->reader.getVal118();
}

bool VarDecl::is_static_local(void) const {
  return impl->reader.getVal119();
}

bool VarDecl::is_this_declaration_a_demoted_definition(void) const {
  return impl->reader.getVal120();
}

bool VarDecl::is_usable_in_constant_expressions(void) const {
  return impl->reader.getVal121();
}

bool VarDecl::might_be_usable_in_constant_expressions(void) const {
  return impl->reader.getVal122();
}

QualTypeDestructionKind VarDecl::needs_destruction(void) const {
  return static_cast<QualTypeDestructionKind>(impl->reader.getVal123());
}

gap::generator<ParmVarDecl> ParmVarDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ParmVarDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ParmVarDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ParmVarDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ParmVarDecl> ParmVarDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ParmVarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParmVarDecl> ParmVarDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ParmVarDecl> ParmVarDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ParmVarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ParmVarDecl> ParmVarDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ParmVarDecl::contains(const Decl &decl) {
  for (auto &parent : ParmVarDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ParmVarDecl::contains(const Stmt &stmt) {
  for (auto &parent : ParmVarDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ParmVarDecl> ParmVarDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ParmVarDecl> dr = ParmVarDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ParmVarDecl> ParmVarDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ParmVarDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kParmVarDeclDerivedKinds[] = {
    ParmVarDecl::static_kind(),
};

gap::generator<ParmVarDecl> ParmVarDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kParmVarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ParmVarDecl> e = ParmVarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ParmVarDecl> ParmVarDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kParmVarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ParmVarDecl> e = ParmVarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ParmVarDecl> ParmVarDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ParmVarDecl> ParmVarDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ParmVarDecl> ParmVarDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ParmVarDecl> ParmVarDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ParmVarDecl> ParmVarDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::PARM_VAR:
      return reinterpret_cast<const ParmVarDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> ParmVarDecl::default_argument(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal124();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TokenRange ParmVarDecl::default_argument_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal125(), impl->reader.getVal126());
}

DeclObjCDeclQualifier ParmVarDecl::obj_c_decl_qualifier(void) const {
  return static_cast<DeclObjCDeclQualifier>(impl->reader.getVal127());
}

Type ParmVarDecl::original_type(void) const {
  RawEntityId eid = impl->reader.getVal128();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<Expr> ParmVarDecl::uninstantiated_default_argument(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal129();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool ParmVarDecl::has_default_argument(void) const {
  return impl->reader.getVal130();
}

bool ParmVarDecl::has_inherited_default_argument(void) const {
  return impl->reader.getVal131();
}

bool ParmVarDecl::has_uninstantiated_default_argument(void) const {
  return impl->reader.getVal132();
}

bool ParmVarDecl::has_unparsed_default_argument(void) const {
  return impl->reader.getVal133();
}

bool ParmVarDecl::is_destroyed_in_callee(void) const {
  return impl->reader.getVal134();
}

bool ParmVarDecl::is_knr_promoted(void) const {
  return impl->reader.getVal135();
}

bool ParmVarDecl::is_obj_c_method_parameter(void) const {
  return impl->reader.getVal136();
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPCapturedExprDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPCapturedExprDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPCapturedExprDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPCapturedExprDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPCapturedExprDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPCapturedExprDecl::contains(const Decl &decl) {
  for (auto &parent : OMPCapturedExprDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPCapturedExprDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPCapturedExprDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPCapturedExprDecl> dr = OMPCapturedExprDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPCapturedExprDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPCapturedExprDeclDerivedKinds[] = {
    OMPCapturedExprDecl::static_kind(),
};

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPCapturedExprDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPCapturedExprDecl> e = OMPCapturedExprDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPCapturedExprDecl> OMPCapturedExprDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPCapturedExprDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPCapturedExprDecl> e = OMPCapturedExprDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPCapturedExprDecl> OMPCapturedExprDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_CAPTURED_EXPR:
      return reinterpret_cast<const OMPCapturedExprDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ImplicitParamDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ImplicitParamDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ImplicitParamDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ImplicitParamDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ImplicitParamDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ImplicitParamDecl::contains(const Decl &decl) {
  for (auto &parent : ImplicitParamDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ImplicitParamDecl::contains(const Stmt &stmt) {
  for (auto &parent : ImplicitParamDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ImplicitParamDecl> dr = ImplicitParamDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ImplicitParamDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kImplicitParamDeclDerivedKinds[] = {
    ImplicitParamDecl::static_kind(),
};

gap::generator<ImplicitParamDecl> ImplicitParamDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kImplicitParamDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ImplicitParamDecl> e = ImplicitParamDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImplicitParamDecl> ImplicitParamDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kImplicitParamDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ImplicitParamDecl> e = ImplicitParamDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ImplicitParamDecl> ImplicitParamDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::IMPLICIT_PARAM:
      return reinterpret_cast<const ImplicitParamDecl &>(parent);
    default: return std::nullopt;
  }
}

ImplicitParamDeclImplicitParamKind ImplicitParamDecl::parameter_kind(void) const {
  return static_cast<ImplicitParamDeclImplicitParamKind>(impl->reader.getVal127());
}

gap::generator<DecompositionDecl> DecompositionDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = DecompositionDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool DecompositionDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : DecompositionDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<DecompositionDecl> DecompositionDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = DecompositionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DecompositionDecl> DecompositionDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<DecompositionDecl> DecompositionDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = DecompositionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<DecompositionDecl> DecompositionDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool DecompositionDecl::contains(const Decl &decl) {
  for (auto &parent : DecompositionDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool DecompositionDecl::contains(const Stmt &stmt) {
  for (auto &parent : DecompositionDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<DecompositionDecl> DecompositionDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<DecompositionDecl> dr = DecompositionDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<DecompositionDecl> DecompositionDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return DecompositionDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kDecompositionDeclDerivedKinds[] = {
    DecompositionDecl::static_kind(),
};

gap::generator<DecompositionDecl> DecompositionDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kDecompositionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<DecompositionDecl> e = DecompositionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<DecompositionDecl> DecompositionDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kDecompositionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<DecompositionDecl> e = DecompositionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<DecompositionDecl> DecompositionDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DecompositionDecl> DecompositionDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DecompositionDecl> DecompositionDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DecompositionDecl> DecompositionDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<DecompositionDecl> DecompositionDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::DECOMPOSITION:
      return reinterpret_cast<const DecompositionDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<BindingDecl> DecompositionDecl::nth_binding(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : bindings()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<BindingDecl> DecompositionDecl::bindings(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = BindingDecl::from(Decl(std::move(d48)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VarTemplateSpecializationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VarTemplateSpecializationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VarTemplateSpecializationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplateSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplateSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool VarTemplateSpecializationDecl::contains(const Decl &decl) {
  for (auto &parent : VarTemplateSpecializationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool VarTemplateSpecializationDecl::contains(const Stmt &stmt) {
  for (auto &parent : VarTemplateSpecializationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<VarTemplateSpecializationDecl> dr = VarTemplateSpecializationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return VarTemplateSpecializationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kVarTemplateSpecializationDeclDerivedKinds[] = {
    VarTemplateSpecializationDecl::static_kind(),
    VarTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kVarTemplateSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<VarTemplateSpecializationDecl> e = VarTemplateSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kVarTemplateSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<VarTemplateSpecializationDecl> e = VarTemplateSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateSpecializationDecl> VarTemplateSpecializationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::VAR_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const VarTemplateSpecializationDecl &>(parent);
    default: return std::nullopt;
  }
}

Token VarTemplateSpecializationDecl::extern_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal124());
}

TemplateSpecializationKind VarTemplateSpecializationDecl::specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal127());
}

VarTemplateDecl VarTemplateSpecializationDecl::specialized_template(void) const {
  RawEntityId eid = impl->reader.getVal125();
  return VarTemplateDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<TemplateArgument> VarTemplateSpecializationDecl::nth_template_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> VarTemplateSpecializationDecl::template_arguments(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d48));
    }
  }
  co_return;
}

std::optional<TemplateArgument> VarTemplateSpecializationDecl::nth_template_instantiation_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_instantiation_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> VarTemplateSpecializationDecl::template_instantiation_arguments(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    EntityId id(v);
    if (auto d58 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d58));
    }
  }
  co_return;
}

Token VarTemplateSpecializationDecl::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal126());
}

Type VarTemplateSpecializationDecl::type_as_written(void) const {
  RawEntityId eid = impl->reader.getVal128();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool VarTemplateSpecializationDecl::is_class_scope_explicit_specialization(void) const {
  return impl->reader.getVal130();
}

bool VarTemplateSpecializationDecl::is_explicit_instantiation_or_specialization(void) const {
  return impl->reader.getVal131();
}

bool VarTemplateSpecializationDecl::is_explicit_specialization(void) const {
  return impl->reader.getVal132();
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VarTemplatePartialSpecializationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VarTemplatePartialSpecializationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VarTemplatePartialSpecializationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplatePartialSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplatePartialSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool VarTemplatePartialSpecializationDecl::contains(const Decl &decl) {
  for (auto &parent : VarTemplatePartialSpecializationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool VarTemplatePartialSpecializationDecl::contains(const Stmt &stmt) {
  for (auto &parent : VarTemplatePartialSpecializationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<VarTemplatePartialSpecializationDecl> dr = VarTemplatePartialSpecializationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return VarTemplatePartialSpecializationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kVarTemplatePartialSpecializationDeclDerivedKinds[] = {
    VarTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kVarTemplatePartialSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<VarTemplatePartialSpecializationDecl> e = VarTemplatePartialSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kVarTemplatePartialSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<VarTemplatePartialSpecializationDecl> e = VarTemplatePartialSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const VarTemplateSpecializationDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const VarDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplatePartialSpecializationDecl> VarTemplatePartialSpecializationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const VarTemplatePartialSpecializationDecl &>(parent);
    default: return std::nullopt;
  }
}

VarTemplatePartialSpecializationDecl VarTemplatePartialSpecializationDecl::instantiated_from_member(void) const {
  RawEntityId eid = impl->reader.getVal129();
  return VarTemplatePartialSpecializationDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

TemplateParameterList VarTemplatePartialSpecializationDecl::template_parameters(void) const {
  RawEntityId eid = impl->reader.getVal137();
  return TemplateParameterList(impl->ep->TemplateParameterListFor(impl->ep, eid));
}

bool VarTemplatePartialSpecializationDecl::has_associated_constraints(void) const {
  return impl->reader.getVal133();
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NonTypeTemplateParmDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NonTypeTemplateParmDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NonTypeTemplateParmDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NonTypeTemplateParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NonTypeTemplateParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NonTypeTemplateParmDecl::contains(const Decl &decl) {
  for (auto &parent : NonTypeTemplateParmDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NonTypeTemplateParmDecl::contains(const Stmt &stmt) {
  for (auto &parent : NonTypeTemplateParmDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<NonTypeTemplateParmDecl> dr = NonTypeTemplateParmDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return NonTypeTemplateParmDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kNonTypeTemplateParmDeclDerivedKinds[] = {
    NonTypeTemplateParmDecl::static_kind(),
};

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kNonTypeTemplateParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<NonTypeTemplateParmDecl> e = NonTypeTemplateParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kNonTypeTemplateParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<NonTypeTemplateParmDecl> e = NonTypeTemplateParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<NonTypeTemplateParmDecl> NonTypeTemplateParmDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::NON_TYPE_TEMPLATE_PARM:
      return reinterpret_cast<const NonTypeTemplateParmDecl &>(parent);
    default: return std::nullopt;
  }
}

bool NonTypeTemplateParmDecl::default_argument_was_inherited(void) const {
  return impl->reader.getVal71();
}

std::optional<Expr> NonTypeTemplateParmDecl::default_argument(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token NonTypeTemplateParmDecl::default_argument_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal75());
}

std::optional<unsigned> NonTypeTemplateParmDecl::num_expansion_types(void) const {
  if (!impl->reader.getVal72()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal138());
  }
  return std::nullopt;
}

std::optional<Expr> NonTypeTemplateParmDecl::placeholder_type_constraint(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal76();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool NonTypeTemplateParmDecl::has_default_argument(void) const {
  return impl->reader.getVal88();
}

bool NonTypeTemplateParmDecl::has_placeholder_type_constraint(void) const {
  return impl->reader.getVal89();
}

bool NonTypeTemplateParmDecl::is_expanded_parameter_pack(void) const {
  return impl->reader.getVal90();
}

bool NonTypeTemplateParmDecl::is_pack_expansion(void) const {
  return impl->reader.getVal91();
}

std::optional<Type> NonTypeTemplateParmDecl::nth_expansion_type(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : expansion_types()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Type> NonTypeTemplateParmDecl::expansion_types(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->TypeFor(impl->ep, v)) {
      co_yield Type(std::move(d48));
    }
  }
  co_return;
}

gap::generator<MSPropertyDecl> MSPropertyDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = MSPropertyDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool MSPropertyDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : MSPropertyDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<MSPropertyDecl> MSPropertyDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = MSPropertyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertyDecl> MSPropertyDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<MSPropertyDecl> MSPropertyDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = MSPropertyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<MSPropertyDecl> MSPropertyDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool MSPropertyDecl::contains(const Decl &decl) {
  for (auto &parent : MSPropertyDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool MSPropertyDecl::contains(const Stmt &stmt) {
  for (auto &parent : MSPropertyDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<MSPropertyDecl> MSPropertyDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<MSPropertyDecl> dr = MSPropertyDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<MSPropertyDecl> MSPropertyDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return MSPropertyDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kMSPropertyDeclDerivedKinds[] = {
    MSPropertyDecl::static_kind(),
};

gap::generator<MSPropertyDecl> MSPropertyDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kMSPropertyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<MSPropertyDecl> e = MSPropertyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<MSPropertyDecl> MSPropertyDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kMSPropertyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<MSPropertyDecl> e = MSPropertyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<MSPropertyDecl> MSPropertyDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<MSPropertyDecl> MSPropertyDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<MSPropertyDecl> MSPropertyDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<MSPropertyDecl> MSPropertyDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::MS_PROPERTY:
      return reinterpret_cast<const MSPropertyDecl &>(parent);
    default: return std::nullopt;
  }
}

bool MSPropertyDecl::has_getter(void) const {
  return impl->reader.getVal71();
}

bool MSPropertyDecl::has_setter(void) const {
  return impl->reader.getVal72();
}

gap::generator<FunctionDecl> FunctionDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FunctionDecl> FunctionDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FunctionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionDecl> FunctionDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FunctionDecl> FunctionDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FunctionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionDecl> FunctionDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FunctionDecl::contains(const Decl &decl) {
  for (auto &parent : FunctionDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FunctionDecl::contains(const Stmt &stmt) {
  for (auto &parent : FunctionDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FunctionDecl> FunctionDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FunctionDecl> dr = FunctionDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FunctionDecl> FunctionDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FunctionDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFunctionDeclDerivedKinds[] = {
    FunctionDecl::static_kind(),
    CXXDeductionGuideDecl::static_kind(),
    CXXMethodDecl::static_kind(),
    CXXConstructorDecl::static_kind(),
    CXXConversionDecl::static_kind(),
    CXXDestructorDecl::static_kind(),
};

gap::generator<FunctionDecl> FunctionDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFunctionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FunctionDecl> e = FunctionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionDecl> FunctionDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFunctionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FunctionDecl> e = FunctionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionDecl> FunctionDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionDecl> FunctionDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionDecl> FunctionDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionDecl> FunctionDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FUNCTION:
    case mx::DeclKind::CXX_METHOD:
    case mx::DeclKind::CXX_DESTRUCTOR:
    case mx::DeclKind::CXX_CONVERSION:
    case mx::DeclKind::CXX_CONSTRUCTOR:
    case mx::DeclKind::CXX_DEDUCTION_GUIDE:
      return reinterpret_cast<const FunctionDecl &>(parent);
    default: return std::nullopt;
  }
}

bool FunctionDecl::uses_fp_intrin(void) const {
  return impl->reader.getVal71();
}

std::optional<bool> FunctionDecl::does_declaration_force_externally_visible_definition(void) const {
  if (!impl->reader.getVal88()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal72());
  }
  return std::nullopt;
}

bool FunctionDecl::does_this_declaration_have_a_body(void) const {
  return impl->reader.getVal89();
}

Type FunctionDecl::call_result_type(void) const {
  RawEntityId eid = impl->reader.getVal73();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ConstexprSpecKind FunctionDecl::constexpr_kind(void) const {
  return static_cast<ConstexprSpecKind>(impl->reader.getVal74());
}

Type FunctionDecl::declared_return_type(void) const {
  RawEntityId eid = impl->reader.getVal75();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<FunctionTemplateDecl> FunctionDecl::described_function_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal76();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token FunctionDecl::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal77());
}

TokenRange FunctionDecl::exception_spec_source_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal78(), impl->reader.getVal80());
}

ExceptionSpecificationType FunctionDecl::exception_spec_type(void) const {
  return static_cast<ExceptionSpecificationType>(impl->reader.getVal79());
}

std::optional<FunctionDecl> FunctionDecl::instantiated_from_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal85();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<FunctionDecl> FunctionDecl::instantiated_from_member_function(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal124();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

LanguageLinkage FunctionDecl::language_linkage(void) const {
  return static_cast<LanguageLinkage>(impl->reader.getVal81());
}

MultiVersionKind FunctionDecl::multi_version_kind(void) const {
  return static_cast<MultiVersionKind>(impl->reader.getVal82());
}

std::optional<unsigned> FunctionDecl::odr_hash(void) const {
  if (!impl->reader.getVal90()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal138());
  }
  return std::nullopt;
}

OverloadedOperatorKind FunctionDecl::overloaded_operator(void) const {
  return static_cast<OverloadedOperatorKind>(impl->reader.getVal83());
}

TokenRange FunctionDecl::parameters_source_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal125(), impl->reader.getVal126());
}

Token FunctionDecl::point_of_instantiation(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal128());
}

std::optional<FunctionTemplateDecl> FunctionDecl::primary_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal129();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type FunctionDecl::return_type(void) const {
  RawEntityId eid = impl->reader.getVal137();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TokenRange FunctionDecl::return_type_source_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal139(), impl->reader.getVal140());
}

StorageClass FunctionDecl::storage_class(void) const {
  return static_cast<StorageClass>(impl->reader.getVal84());
}

std::optional<FunctionDecl> FunctionDecl::template_instantiation_pattern(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal141();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TemplateSpecializationKind FunctionDecl::template_specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal86());
}

TemplateSpecializationKind FunctionDecl::template_specialization_kind_for_instantiation(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal87());
}

FunctionDeclTemplatedKind FunctionDecl::templated_kind(void) const {
  return static_cast<FunctionDeclTemplatedKind>(impl->reader.getVal123());
}

bool FunctionDecl::has_implicit_return_zero(void) const {
  return impl->reader.getVal91();
}

bool FunctionDecl::has_inherited_prototype(void) const {
  return impl->reader.getVal92();
}

bool FunctionDecl::has_one_parameter_or_default_arguments(void) const {
  return impl->reader.getVal93();
}

bool FunctionDecl::has_prototype(void) const {
  return impl->reader.getVal94();
}

bool FunctionDecl::has_skipped_body(void) const {
  return impl->reader.getVal95();
}

bool FunctionDecl::has_trivial_body(void) const {
  return impl->reader.getVal96();
}

bool FunctionDecl::has_written_prototype(void) const {
  return impl->reader.getVal97();
}

bool FunctionDecl::instantiation_is_pending(void) const {
  return impl->reader.getVal98();
}

bool FunctionDecl::is_cpu_dispatch_multi_version(void) const {
  return impl->reader.getVal99();
}

bool FunctionDecl::is_cpu_specific_multi_version(void) const {
  return impl->reader.getVal100();
}

bool FunctionDecl::is_consteval(void) const {
  return impl->reader.getVal101();
}

bool FunctionDecl::is_constexpr(void) const {
  return impl->reader.getVal102();
}

bool FunctionDecl::is_constexpr_specified(void) const {
  return impl->reader.getVal103();
}

bool FunctionDecl::is_defaulted(void) const {
  return impl->reader.getVal104();
}

bool FunctionDecl::is_deleted(void) const {
  return impl->reader.getVal105();
}

bool FunctionDecl::is_deleted_as_written(void) const {
  return impl->reader.getVal106();
}

bool FunctionDecl::is_destroying_operator_delete(void) const {
  return impl->reader.getVal107();
}

bool FunctionDecl::is_explicitly_defaulted(void) const {
  return impl->reader.getVal108();
}

bool FunctionDecl::is_extern_c(void) const {
  return impl->reader.getVal109();
}

bool FunctionDecl::is_function_template_specialization(void) const {
  return impl->reader.getVal110();
}

bool FunctionDecl::is_global(void) const {
  return impl->reader.getVal111();
}

bool FunctionDecl::is_implicitly_instantiable(void) const {
  return impl->reader.getVal112();
}

bool FunctionDecl::is_in_extern_c_context(void) const {
  return impl->reader.getVal113();
}

bool FunctionDecl::is_in_extern_cxx_context(void) const {
  return impl->reader.getVal114();
}

bool FunctionDecl::is_ineligible_or_not_selected(void) const {
  return impl->reader.getVal115();
}

bool FunctionDecl::is_inline_builtin_declaration(void) const {
  return impl->reader.getVal116();
}

std::optional<bool> FunctionDecl::is_inline_definition_externally_visible(void) const {
  if (!impl->reader.getVal118()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal117());
  }
  return std::nullopt;
}

bool FunctionDecl::is_inline_specified(void) const {
  return impl->reader.getVal119();
}

bool FunctionDecl::is_inlined(void) const {
  return impl->reader.getVal120();
}

bool FunctionDecl::is_late_template_parsed(void) const {
  return impl->reader.getVal121();
}

std::optional<bool> FunctionDecl::is_ms_extern_inline(void) const {
  if (!impl->reader.getVal130()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal122());
  }
  return std::nullopt;
}

bool FunctionDecl::is_msvcrt_entry_point(void) const {
  return impl->reader.getVal131();
}

bool FunctionDecl::is_main(void) const {
  return impl->reader.getVal132();
}

bool FunctionDecl::is_multi_version(void) const {
  return impl->reader.getVal133();
}

bool FunctionDecl::is_no_return(void) const {
  return impl->reader.getVal134();
}

bool FunctionDecl::is_overloaded_operator(void) const {
  return impl->reader.getVal135();
}

bool FunctionDecl::is_pure(void) const {
  return impl->reader.getVal136();
}

bool FunctionDecl::is_replaceable_global_allocation_function(void) const {
  return impl->reader.getVal142();
}

std::optional<bool> FunctionDecl::is_reserved_global_placement_operator(void) const {
  if (!impl->reader.getVal144()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal143());
  }
  return std::nullopt;
}

bool FunctionDecl::is_static(void) const {
  return impl->reader.getVal145();
}

bool FunctionDecl::is_target_clones_multi_version(void) const {
  return impl->reader.getVal146();
}

bool FunctionDecl::is_target_multi_version(void) const {
  return impl->reader.getVal147();
}

bool FunctionDecl::is_template_instantiation(void) const {
  return impl->reader.getVal148();
}

bool FunctionDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal149();
}

bool FunctionDecl::is_this_declaration_instantiated_from_a_friend_definition(void) const {
  return impl->reader.getVal150();
}

bool FunctionDecl::is_trivial(void) const {
  return impl->reader.getVal151();
}

bool FunctionDecl::is_trivial_for_call(void) const {
  return impl->reader.getVal152();
}

bool FunctionDecl::is_user_provided(void) const {
  return impl->reader.getVal153();
}

bool FunctionDecl::is_variadic(void) const {
  return impl->reader.getVal154();
}

bool FunctionDecl::is_virtual_as_written(void) const {
  return impl->reader.getVal155();
}

std::optional<ParmVarDecl> FunctionDecl::nth_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ParmVarDecl> FunctionDecl::parameters(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ParmVarDecl::from(Decl(std::move(d48)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

bool FunctionDecl::uses_seh_try(void) const {
  return impl->reader.getVal156();
}

bool FunctionDecl::will_have_body(void) const {
  return impl->reader.getVal157();
}

std::optional<Stmt> FunctionDecl::body(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal158();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Stmt(std::move(eptr));
    }
  }
  return std::nullopt;
}

gap::generator<Decl> FunctionDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<CXXMethodDecl> CXXMethodDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXMethodDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXMethodDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXMethodDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXMethodDecl> CXXMethodDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXMethodDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXMethodDecl> CXXMethodDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXMethodDecl> CXXMethodDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXMethodDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXMethodDecl> CXXMethodDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXMethodDecl::contains(const Decl &decl) {
  for (auto &parent : CXXMethodDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXMethodDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXMethodDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXMethodDecl> CXXMethodDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXMethodDecl> dr = CXXMethodDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXMethodDecl> CXXMethodDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXMethodDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXMethodDeclDerivedKinds[] = {
    CXXMethodDecl::static_kind(),
    CXXConstructorDecl::static_kind(),
    CXXConversionDecl::static_kind(),
    CXXDestructorDecl::static_kind(),
};

gap::generator<CXXMethodDecl> CXXMethodDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXMethodDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXMethodDecl> e = CXXMethodDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXMethodDecl> CXXMethodDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXMethodDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXMethodDecl> e = CXXMethodDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXMethodDecl> CXXMethodDecl::from(const FunctionDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXMethodDecl> CXXMethodDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXMethodDecl> CXXMethodDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXMethodDecl> CXXMethodDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXMethodDecl> CXXMethodDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_METHOD:
    case mx::DeclKind::CXX_DESTRUCTOR:
    case mx::DeclKind::CXX_CONVERSION:
    case mx::DeclKind::CXX_CONSTRUCTOR:
      return reinterpret_cast<const CXXMethodDecl &>(parent);
    default: return std::nullopt;
  }
}

RefQualifierKind CXXMethodDecl::reference_qualifier(void) const {
  return static_cast<RefQualifierKind>(impl->reader.getVal127());
}

std::optional<Type> CXXMethodDecl::this_object_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal159();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> CXXMethodDecl::this_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal160();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool CXXMethodDecl::has_inline_body(void) const {
  return impl->reader.getVal161();
}

bool CXXMethodDecl::is_const(void) const {
  return impl->reader.getVal162();
}

bool CXXMethodDecl::is_copy_assignment_operator(void) const {
  return impl->reader.getVal163();
}

bool CXXMethodDecl::is_instance(void) const {
  return impl->reader.getVal164();
}

bool CXXMethodDecl::is_lambda_static_invoker(void) const {
  return impl->reader.getVal165();
}

bool CXXMethodDecl::is_move_assignment_operator(void) const {
  return impl->reader.getVal166();
}

bool CXXMethodDecl::is_virtual(void) const {
  return impl->reader.getVal167();
}

bool CXXMethodDecl::is_volatile(void) const {
  return impl->reader.getVal168();
}

std::optional<CXXMethodDecl> CXXMethodDecl::nth_overridden_method(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : overridden_methods()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<CXXMethodDecl> CXXMethodDecl::overridden_methods(void) const {
  auto list = impl->reader.getVal169();
  for (auto v : list) {
    EntityId id(v);
    if (auto d169 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = CXXMethodDecl::from(Decl(std::move(d169)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDestructorDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDestructorDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDestructorDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXDestructorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXDestructorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDestructorDecl::contains(const Decl &decl) {
  for (auto &parent : CXXDestructorDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDestructorDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXDestructorDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXDestructorDecl> dr = CXXDestructorDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXDestructorDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXDestructorDeclDerivedKinds[] = {
    CXXDestructorDecl::static_kind(),
};

gap::generator<CXXDestructorDecl> CXXDestructorDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXDestructorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXDestructorDecl> e = CXXDestructorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDestructorDecl> CXXDestructorDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXDestructorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXDestructorDecl> e = CXXDestructorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const CXXMethodDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const FunctionDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDestructorDecl> CXXDestructorDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_DESTRUCTOR:
      return reinterpret_cast<const CXXDestructorDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<FunctionDecl> CXXDestructorDecl::operator_delete(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal170();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Expr> CXXDestructorDecl::operator_delete_this_argument(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal171();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<CXXConversionDecl> CXXConversionDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXConversionDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXConversionDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXConversionDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXConversionDecl> CXXConversionDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXConversionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConversionDecl> CXXConversionDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXConversionDecl> CXXConversionDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXConversionDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConversionDecl> CXXConversionDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXConversionDecl::contains(const Decl &decl) {
  for (auto &parent : CXXConversionDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXConversionDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXConversionDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXConversionDecl> CXXConversionDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXConversionDecl> dr = CXXConversionDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXConversionDecl> CXXConversionDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXConversionDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXConversionDeclDerivedKinds[] = {
    CXXConversionDecl::static_kind(),
};

gap::generator<CXXConversionDecl> CXXConversionDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXConversionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXConversionDecl> e = CXXConversionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXConversionDecl> CXXConversionDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXConversionDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXConversionDecl> e = CXXConversionDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const CXXMethodDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const FunctionDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConversionDecl> CXXConversionDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_CONVERSION:
      return reinterpret_cast<const CXXConversionDecl &>(parent);
    default: return std::nullopt;
  }
}

Type CXXConversionDecl::conversion_type(void) const {
  RawEntityId eid = impl->reader.getVal170();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool CXXConversionDecl::is_explicit(void) const {
  return impl->reader.getVal172();
}

bool CXXConversionDecl::is_lambda_to_block_pointer_conversion(void) const {
  return impl->reader.getVal173();
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXConstructorDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXConstructorDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXConstructorDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXConstructorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXConstructorDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXConstructorDecl::contains(const Decl &decl) {
  for (auto &parent : CXXConstructorDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXConstructorDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXConstructorDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXConstructorDecl> dr = CXXConstructorDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXConstructorDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXConstructorDeclDerivedKinds[] = {
    CXXConstructorDecl::static_kind(),
};

gap::generator<CXXConstructorDecl> CXXConstructorDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXConstructorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXConstructorDecl> e = CXXConstructorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXConstructorDecl> CXXConstructorDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXConstructorDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXConstructorDecl> e = CXXConstructorDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const CXXMethodDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const FunctionDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_CONSTRUCTOR:
      return reinterpret_cast<const CXXConstructorDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<CXXConstructorDecl> CXXConstructorDecl::target_constructor(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal170();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXConstructorDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool CXXConstructorDecl::is_default_constructor(void) const {
  return impl->reader.getVal172();
}

bool CXXConstructorDecl::is_delegating_constructor(void) const {
  return impl->reader.getVal173();
}

bool CXXConstructorDecl::is_explicit(void) const {
  return impl->reader.getVal174();
}

bool CXXConstructorDecl::is_inheriting_constructor(void) const {
  return impl->reader.getVal175();
}

bool CXXConstructorDecl::is_specialization_copying_object(void) const {
  return impl->reader.getVal176();
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXDeductionGuideDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXDeductionGuideDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXDeductionGuideDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXDeductionGuideDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXDeductionGuideDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXDeductionGuideDecl::contains(const Decl &decl) {
  for (auto &parent : CXXDeductionGuideDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXDeductionGuideDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXDeductionGuideDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXDeductionGuideDecl> dr = CXXDeductionGuideDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXDeductionGuideDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXDeductionGuideDeclDerivedKinds[] = {
    CXXDeductionGuideDecl::static_kind(),
};

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXDeductionGuideDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXDeductionGuideDecl> e = CXXDeductionGuideDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXDeductionGuideDecl> CXXDeductionGuideDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXDeductionGuideDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXDeductionGuideDecl> e = CXXDeductionGuideDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::from(const FunctionDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXDeductionGuideDecl> CXXDeductionGuideDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_DEDUCTION_GUIDE:
      return reinterpret_cast<const CXXDeductionGuideDecl &>(parent);
    default: return std::nullopt;
  }
}

CXXConstructorDecl CXXDeductionGuideDecl::corresponding_constructor(void) const {
  RawEntityId eid = impl->reader.getVal159();
  return CXXConstructorDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

TemplateDecl CXXDeductionGuideDecl::deduced_template(void) const {
  RawEntityId eid = impl->reader.getVal160();
  return TemplateDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool CXXDeductionGuideDecl::is_copy_deduction_candidate(void) const {
  return impl->reader.getVal161();
}

bool CXXDeductionGuideDecl::is_explicit(void) const {
  return impl->reader.getVal162();
}

gap::generator<FieldDecl> FieldDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FieldDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FieldDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FieldDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FieldDecl> FieldDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FieldDecl> FieldDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FieldDecl> FieldDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FieldDecl> FieldDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FieldDecl::contains(const Decl &decl) {
  for (auto &parent : FieldDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FieldDecl::contains(const Stmt &stmt) {
  for (auto &parent : FieldDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FieldDecl> FieldDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FieldDecl> dr = FieldDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FieldDecl> FieldDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FieldDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFieldDeclDerivedKinds[] = {
    FieldDecl::static_kind(),
    ObjCAtDefsFieldDecl::static_kind(),
    ObjCIvarDecl::static_kind(),
};

gap::generator<FieldDecl> FieldDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FieldDecl> e = FieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FieldDecl> FieldDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FieldDecl> e = FieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FieldDecl> FieldDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FieldDecl> FieldDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FieldDecl> FieldDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FieldDecl> FieldDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FIELD:
    case mx::DeclKind::OBJ_C_IVAR:
    case mx::DeclKind::OBJ_C_AT_DEFS_FIELD:
      return reinterpret_cast<const FieldDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Expr> FieldDecl::bit_width(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<VariableArrayType> FieldDecl::captured_vla_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal75();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return VariableArrayType::from(Type(std::move(eptr)));
    }
  }
  return std::nullopt;
}

InClassInitStyle FieldDecl::in_class_initializer_style(void) const {
  return static_cast<InClassInitStyle>(impl->reader.getVal74());
}

std::optional<Expr> FieldDecl::in_class_initializer(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal76();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->StmtFor(impl->ep, eid)) {
      return Expr::from(Stmt(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool FieldDecl::has_captured_vla_type(void) const {
  return impl->reader.getVal71();
}

bool FieldDecl::has_in_class_initializer(void) const {
  return impl->reader.getVal72();
}

bool FieldDecl::is_anonymous_struct_or_union(void) const {
  return impl->reader.getVal88();
}

bool FieldDecl::is_bit_field(void) const {
  return impl->reader.getVal89();
}

bool FieldDecl::is_mutable(void) const {
  return impl->reader.getVal90();
}

bool FieldDecl::is_unnamed_bitfield(void) const {
  return impl->reader.getVal91();
}

bool FieldDecl::is_zero_length_bit_field(void) const {
  return impl->reader.getVal92();
}

bool FieldDecl::is_zero_size(void) const {
  return impl->reader.getVal93();
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCIvarDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCIvarDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCIvarDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCIvarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCIvarDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCIvarDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCIvarDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCIvarDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCIvarDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCIvarDecl> dr = ObjCIvarDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCIvarDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCIvarDeclDerivedKinds[] = {
    ObjCIvarDecl::static_kind(),
};

gap::generator<ObjCIvarDecl> ObjCIvarDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCIvarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCIvarDecl> e = ObjCIvarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCIvarDecl> ObjCIvarDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCIvarDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCIvarDecl> e = ObjCIvarDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::from(const FieldDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCIvarDecl> ObjCIvarDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_IVAR:
      return reinterpret_cast<const ObjCIvarDecl &>(parent);
    default: return std::nullopt;
  }
}

ObjCIvarDeclAccessControl ObjCIvarDecl::access_control(void) const {
  return static_cast<ObjCIvarDeclAccessControl>(impl->reader.getVal79());
}

ObjCIvarDeclAccessControl ObjCIvarDecl::canonical_access_control(void) const {
  return static_cast<ObjCIvarDeclAccessControl>(impl->reader.getVal81());
}

ObjCInterfaceDecl ObjCIvarDecl::containing_interface(void) const {
  RawEntityId eid = impl->reader.getVal77();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCIvarDecl ObjCIvarDecl::next_instance_variable(void) const {
  RawEntityId eid = impl->reader.getVal78();
  return ObjCIvarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ObjCIvarDecl::synthesize(void) const {
  return impl->reader.getVal94();
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCAtDefsFieldDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCAtDefsFieldDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCAtDefsFieldDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCAtDefsFieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCAtDefsFieldDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCAtDefsFieldDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCAtDefsFieldDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCAtDefsFieldDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCAtDefsFieldDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCAtDefsFieldDecl> dr = ObjCAtDefsFieldDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCAtDefsFieldDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCAtDefsFieldDeclDerivedKinds[] = {
    ObjCAtDefsFieldDecl::static_kind(),
};

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCAtDefsFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCAtDefsFieldDecl> e = ObjCAtDefsFieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCAtDefsFieldDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCAtDefsFieldDecl> e = ObjCAtDefsFieldDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::from(const FieldDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::from(const DeclaratorDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCAtDefsFieldDecl> ObjCAtDefsFieldDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_AT_DEFS_FIELD:
      return reinterpret_cast<const ObjCAtDefsFieldDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<BindingDecl> BindingDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BindingDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BindingDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BindingDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BindingDecl> BindingDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BindingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BindingDecl> BindingDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BindingDecl> BindingDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BindingDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BindingDecl> BindingDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BindingDecl::contains(const Decl &decl) {
  for (auto &parent : BindingDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BindingDecl::contains(const Stmt &stmt) {
  for (auto &parent : BindingDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<BindingDecl> BindingDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<BindingDecl> dr = BindingDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<BindingDecl> BindingDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return BindingDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kBindingDeclDerivedKinds[] = {
    BindingDecl::static_kind(),
};

gap::generator<BindingDecl> BindingDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kBindingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<BindingDecl> e = BindingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BindingDecl> BindingDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kBindingDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<BindingDecl> e = BindingDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BindingDecl> BindingDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<BindingDecl> BindingDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<BindingDecl> BindingDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::BINDING:
      return reinterpret_cast<const BindingDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr BindingDecl::binding(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

ValueDecl BindingDecl::decomposed_declaration(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return ValueDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

VarDecl BindingDecl::holding_variable(void) const {
  RawEntityId eid = impl->reader.getVal62();
  return VarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclarativeDirectiveValueDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclarativeDirectiveValueDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclarativeDirectiveValueDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclarativeDirectiveValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclarativeDirectiveValueDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDeclarativeDirectiveValueDecl::contains(const Decl &decl) {
  for (auto &parent : OMPDeclarativeDirectiveValueDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDeclarativeDirectiveValueDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPDeclarativeDirectiveValueDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPDeclarativeDirectiveValueDecl> dr = OMPDeclarativeDirectiveValueDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPDeclarativeDirectiveValueDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPDeclarativeDirectiveValueDeclDerivedKinds[] = {
    OMPDeclareMapperDecl::static_kind(),
};

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPDeclarativeDirectiveValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPDeclarativeDirectiveValueDecl> e = OMPDeclarativeDirectiveValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPDeclarativeDirectiveValueDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclarativeDirectiveValueDecl> e = OMPDeclarativeDirectiveValueDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclarativeDirectiveValueDecl> OMPDeclarativeDirectiveValueDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_DECLARE_MAPPER:
      return reinterpret_cast<const OMPDeclarativeDirectiveValueDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = OMPDeclareMapperDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool OMPDeclareMapperDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : OMPDeclareMapperDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclareMapperDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = OMPDeclareMapperDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool OMPDeclareMapperDecl::contains(const Decl &decl) {
  for (auto &parent : OMPDeclareMapperDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool OMPDeclareMapperDecl::contains(const Stmt &stmt) {
  for (auto &parent : OMPDeclareMapperDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<OMPDeclareMapperDecl> dr = OMPDeclareMapperDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<OMPDeclareMapperDecl> OMPDeclareMapperDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return OMPDeclareMapperDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kOMPDeclareMapperDeclDerivedKinds[] = {
    OMPDeclareMapperDecl::static_kind(),
};

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kOMPDeclareMapperDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<OMPDeclareMapperDecl> e = OMPDeclareMapperDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<OMPDeclareMapperDecl> OMPDeclareMapperDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kOMPDeclareMapperDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<OMPDeclareMapperDecl> e = OMPDeclareMapperDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<OMPDeclareMapperDecl> OMPDeclareMapperDecl::from(const OMPDeclarativeDirectiveValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclareMapperDecl> OMPDeclareMapperDecl::from(const ValueDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclareMapperDecl> OMPDeclareMapperDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<OMPDeclareMapperDecl> OMPDeclareMapperDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OMP_DECLARE_MAPPER:
      return reinterpret_cast<const OMPDeclareMapperDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr OMPDeclareMapperDecl::mapper_variable_reference(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<Decl> OMPDeclareMapperDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<UsingShadowDecl> UsingShadowDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingShadowDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingShadowDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingShadowDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UsingShadowDecl> UsingShadowDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingShadowDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingShadowDecl> UsingShadowDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UsingShadowDecl> UsingShadowDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingShadowDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingShadowDecl> UsingShadowDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UsingShadowDecl::contains(const Decl &decl) {
  for (auto &parent : UsingShadowDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UsingShadowDecl::contains(const Stmt &stmt) {
  for (auto &parent : UsingShadowDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UsingShadowDecl> UsingShadowDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UsingShadowDecl> dr = UsingShadowDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UsingShadowDecl> UsingShadowDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UsingShadowDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUsingShadowDeclDerivedKinds[] = {
    UsingShadowDecl::static_kind(),
    ConstructorUsingShadowDecl::static_kind(),
};

gap::generator<UsingShadowDecl> UsingShadowDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUsingShadowDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UsingShadowDecl> e = UsingShadowDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingShadowDecl> UsingShadowDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUsingShadowDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UsingShadowDecl> e = UsingShadowDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingShadowDecl> UsingShadowDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingShadowDecl> UsingShadowDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING_SHADOW:
    case mx::DeclKind::CONSTRUCTOR_USING_SHADOW:
      return reinterpret_cast<const UsingShadowDecl &>(parent);
    default: return std::nullopt;
  }
}

BaseUsingDecl UsingShadowDecl::introducer(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return BaseUsingDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<UsingShadowDecl> UsingShadowDecl::next_using_shadow_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return UsingShadowDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

NamedDecl UsingShadowDecl::target_declaration(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConstructorUsingShadowDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConstructorUsingShadowDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConstructorUsingShadowDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ConstructorUsingShadowDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ConstructorUsingShadowDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConstructorUsingShadowDecl::contains(const Decl &decl) {
  for (auto &parent : ConstructorUsingShadowDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConstructorUsingShadowDecl::contains(const Stmt &stmt) {
  for (auto &parent : ConstructorUsingShadowDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ConstructorUsingShadowDecl> dr = ConstructorUsingShadowDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ConstructorUsingShadowDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kConstructorUsingShadowDeclDerivedKinds[] = {
    ConstructorUsingShadowDecl::static_kind(),
};

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kConstructorUsingShadowDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ConstructorUsingShadowDecl> e = ConstructorUsingShadowDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kConstructorUsingShadowDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ConstructorUsingShadowDecl> e = ConstructorUsingShadowDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::from(const UsingShadowDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CONSTRUCTOR_USING_SHADOW:
      return reinterpret_cast<const ConstructorUsingShadowDecl &>(parent);
    default: return std::nullopt;
  }
}

bool ConstructorUsingShadowDecl::constructs_virtual_base(void) const {
  return impl->reader.getVal70();
}

CXXRecordDecl ConstructorUsingShadowDecl::constructed_base_class(void) const {
  RawEntityId eid = impl->reader.getVal62();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::constructed_base_class_shadow_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal63();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ConstructorUsingShadowDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

CXXRecordDecl ConstructorUsingShadowDecl::nominated_base_class(void) const {
  RawEntityId eid = impl->reader.getVal64();
  return CXXRecordDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<ConstructorUsingShadowDecl> ConstructorUsingShadowDecl::nominated_base_class_shadow_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ConstructorUsingShadowDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<UsingPackDecl> UsingPackDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingPackDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingPackDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingPackDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UsingPackDecl> UsingPackDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingPackDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingPackDecl> UsingPackDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UsingPackDecl> UsingPackDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingPackDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingPackDecl> UsingPackDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UsingPackDecl::contains(const Decl &decl) {
  for (auto &parent : UsingPackDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UsingPackDecl::contains(const Stmt &stmt) {
  for (auto &parent : UsingPackDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UsingPackDecl> UsingPackDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UsingPackDecl> dr = UsingPackDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UsingPackDecl> UsingPackDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UsingPackDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUsingPackDeclDerivedKinds[] = {
    UsingPackDecl::static_kind(),
};

gap::generator<UsingPackDecl> UsingPackDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUsingPackDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UsingPackDecl> e = UsingPackDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingPackDecl> UsingPackDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUsingPackDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UsingPackDecl> e = UsingPackDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingPackDecl> UsingPackDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingPackDecl> UsingPackDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING_PACK:
      return reinterpret_cast<const UsingPackDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<NamedDecl> UsingPackDecl::nth_expansion(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : expansions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<NamedDecl> UsingPackDecl::expansions(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = NamedDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

NamedDecl UsingPackDecl::instantiated_from_using_declaration(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UsingDirectiveDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UsingDirectiveDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UsingDirectiveDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingDirectiveDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UsingDirectiveDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UsingDirectiveDecl::contains(const Decl &decl) {
  for (auto &parent : UsingDirectiveDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UsingDirectiveDecl::contains(const Stmt &stmt) {
  for (auto &parent : UsingDirectiveDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UsingDirectiveDecl> dr = UsingDirectiveDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UsingDirectiveDecl> UsingDirectiveDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UsingDirectiveDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUsingDirectiveDeclDerivedKinds[] = {
    UsingDirectiveDecl::static_kind(),
};

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUsingDirectiveDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UsingDirectiveDecl> e = UsingDirectiveDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UsingDirectiveDecl> UsingDirectiveDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUsingDirectiveDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UsingDirectiveDecl> e = UsingDirectiveDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UsingDirectiveDecl> UsingDirectiveDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UsingDirectiveDecl> UsingDirectiveDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::USING_DIRECTIVE:
      return reinterpret_cast<const UsingDirectiveDecl &>(parent);
    default: return std::nullopt;
  }
}

Token UsingDirectiveDecl::identifier_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

Token UsingDirectiveDecl::namespace_key_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

NamedDecl UsingDirectiveDecl::nominated_namespace_as_written(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token UsingDirectiveDecl::using_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedUsingIfExistsDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedUsingIfExistsDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedUsingIfExistsDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingIfExistsDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingIfExistsDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnresolvedUsingIfExistsDecl::contains(const Decl &decl) {
  for (auto &parent : UnresolvedUsingIfExistsDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnresolvedUsingIfExistsDecl::contains(const Stmt &stmt) {
  for (auto &parent : UnresolvedUsingIfExistsDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UnresolvedUsingIfExistsDecl> dr = UnresolvedUsingIfExistsDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UnresolvedUsingIfExistsDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUnresolvedUsingIfExistsDeclDerivedKinds[] = {
    UnresolvedUsingIfExistsDecl::static_kind(),
};

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUnresolvedUsingIfExistsDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UnresolvedUsingIfExistsDecl> e = UnresolvedUsingIfExistsDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUnresolvedUsingIfExistsDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedUsingIfExistsDecl> e = UnresolvedUsingIfExistsDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnresolvedUsingIfExistsDecl> UnresolvedUsingIfExistsDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::UNRESOLVED_USING_IF_EXISTS:
      return reinterpret_cast<const UnresolvedUsingIfExistsDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeDecl> TypeDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypeDecl> TypeDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeDecl> TypeDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypeDecl> TypeDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeDecl> TypeDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypeDecl::contains(const Decl &decl) {
  for (auto &parent : TypeDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypeDecl::contains(const Stmt &stmt) {
  for (auto &parent : TypeDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TypeDecl> TypeDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TypeDecl> dr = TypeDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TypeDecl> TypeDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TypeDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTypeDeclDerivedKinds[] = {
    UnresolvedUsingTypenameDecl::static_kind(),
    TemplateTypeParmDecl::static_kind(),
    ObjCTypeParamDecl::static_kind(),
    TypeAliasDecl::static_kind(),
    TypedefDecl::static_kind(),
    EnumDecl::static_kind(),
    RecordDecl::static_kind(),
    CXXRecordDecl::static_kind(),
    ClassTemplateSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<TypeDecl> TypeDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTypeDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TypeDecl> e = TypeDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeDecl> TypeDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTypeDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TypeDecl> e = TypeDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeDecl> TypeDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeDecl> TypeDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TEMPLATE_TYPE_PARM:
    case mx::DeclKind::RECORD:
    case mx::DeclKind::CXX_RECORD:
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::ENUM:
    case mx::DeclKind::UNRESOLVED_USING_TYPENAME:
    case mx::DeclKind::TYPEDEF:
    case mx::DeclKind::TYPE_ALIAS:
    case mx::DeclKind::OBJ_C_TYPE_PARAM:
      return reinterpret_cast<const TypeDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Type> TypeDecl::type_for_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal52();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateTypeParmDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateTypeParmDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateTypeParmDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateTypeParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateTypeParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TemplateTypeParmDecl::contains(const Decl &decl) {
  for (auto &parent : TemplateTypeParmDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TemplateTypeParmDecl::contains(const Stmt &stmt) {
  for (auto &parent : TemplateTypeParmDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TemplateTypeParmDecl> dr = TemplateTypeParmDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TemplateTypeParmDecl> TemplateTypeParmDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TemplateTypeParmDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTemplateTypeParmDeclDerivedKinds[] = {
    TemplateTypeParmDecl::static_kind(),
};

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTemplateTypeParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TemplateTypeParmDecl> e = TemplateTypeParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateTypeParmDecl> TemplateTypeParmDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTemplateTypeParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TemplateTypeParmDecl> e = TemplateTypeParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateTypeParmDecl> TemplateTypeParmDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateTypeParmDecl> TemplateTypeParmDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateTypeParmDecl> TemplateTypeParmDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TEMPLATE_TYPE_PARM:
      return reinterpret_cast<const TemplateTypeParmDecl &>(parent);
    default: return std::nullopt;
  }
}

bool TemplateTypeParmDecl::default_argument_was_inherited(void) const {
  return impl->reader.getVal70();
}

std::optional<Type> TemplateTypeParmDecl::default_argument(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<Type> TemplateTypeParmDecl::default_argument_info(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal54();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

Token TemplateTypeParmDecl::default_argument_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

bool TemplateTypeParmDecl::has_default_argument(void) const {
  return impl->reader.getVal71();
}

bool TemplateTypeParmDecl::has_type_constraint(void) const {
  return impl->reader.getVal72();
}

bool TemplateTypeParmDecl::is_expanded_parameter_pack(void) const {
  return impl->reader.getVal88();
}

bool TemplateTypeParmDecl::is_pack_expansion(void) const {
  return impl->reader.getVal89();
}

bool TemplateTypeParmDecl::was_declared_with_typename(void) const {
  return impl->reader.getVal90();
}

gap::generator<TagDecl> TagDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TagDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TagDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TagDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TagDecl> TagDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TagDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TagDecl> TagDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TagDecl> TagDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TagDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TagDecl> TagDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TagDecl::contains(const Decl &decl) {
  for (auto &parent : TagDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TagDecl::contains(const Stmt &stmt) {
  for (auto &parent : TagDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TagDecl> TagDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TagDecl> dr = TagDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TagDecl> TagDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TagDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTagDeclDerivedKinds[] = {
    EnumDecl::static_kind(),
    RecordDecl::static_kind(),
    CXXRecordDecl::static_kind(),
    ClassTemplateSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<TagDecl> TagDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTagDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TagDecl> e = TagDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TagDecl> TagDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTagDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TagDecl> e = TagDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TagDecl> TagDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TagDecl> TagDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TagDecl> TagDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::RECORD:
    case mx::DeclKind::CXX_RECORD:
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
    case mx::DeclKind::ENUM:
      return reinterpret_cast<const TagDecl &>(parent);
    default: return std::nullopt;
  }
}

TokenRange TagDecl::brace_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal53(), impl->reader.getVal54());
}

Token TagDecl::first_inner_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

Token TagDecl::first_outer_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal63());
}

TagTypeKind TagDecl::tag_kind(void) const {
  return static_cast<TagTypeKind>(impl->reader.getVal74());
}

std::optional<TypedefNameDecl> TagDecl::typedef_name_for_anonymous_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal64();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TypedefNameDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool TagDecl::has_name_for_linkage(void) const {
  return impl->reader.getVal70();
}

bool TagDecl::is_being_defined(void) const {
  return impl->reader.getVal71();
}

bool TagDecl::is_class(void) const {
  return impl->reader.getVal72();
}

bool TagDecl::is_complete_definition(void) const {
  return impl->reader.getVal88();
}

bool TagDecl::is_complete_definition_required(void) const {
  return impl->reader.getVal89();
}

bool TagDecl::is_dependent_type(void) const {
  return impl->reader.getVal90();
}

bool TagDecl::is_embedded_in_declarator(void) const {
  return impl->reader.getVal91();
}

bool TagDecl::is_enum(void) const {
  return impl->reader.getVal92();
}

bool TagDecl::is_free_standing(void) const {
  return impl->reader.getVal93();
}

bool TagDecl::is_interface(void) const {
  return impl->reader.getVal94();
}

bool TagDecl::is_struct(void) const {
  return impl->reader.getVal95();
}

bool TagDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal96();
}

bool TagDecl::is_this_declaration_a_demoted_definition(void) const {
  return impl->reader.getVal97();
}

bool TagDecl::is_union(void) const {
  return impl->reader.getVal98();
}

bool TagDecl::may_have_out_of_date_definition(void) const {
  return impl->reader.getVal99();
}

std::optional<TemplateParameterList> TagDecl::nth_template_parameter_list(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_parameter_lists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateParameterList> TagDecl::template_parameter_lists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->TemplateParameterListFor(impl->ep, v)) {
      co_yield TemplateParameterList(std::move(d47));
    }
  }
  co_return;
}

gap::generator<Decl> TagDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<RecordDecl> RecordDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RecordDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RecordDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RecordDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<RecordDecl> RecordDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RecordDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RecordDecl> RecordDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<RecordDecl> RecordDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RecordDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RecordDecl> RecordDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool RecordDecl::contains(const Decl &decl) {
  for (auto &parent : RecordDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool RecordDecl::contains(const Stmt &stmt) {
  for (auto &parent : RecordDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<RecordDecl> RecordDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<RecordDecl> dr = RecordDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<RecordDecl> RecordDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return RecordDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kRecordDeclDerivedKinds[] = {
    RecordDecl::static_kind(),
    CXXRecordDecl::static_kind(),
    ClassTemplateSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<RecordDecl> RecordDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kRecordDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<RecordDecl> e = RecordDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RecordDecl> RecordDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kRecordDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<RecordDecl> e = RecordDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RecordDecl> RecordDecl::from(const TagDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<RecordDecl> RecordDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<RecordDecl> RecordDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<RecordDecl> RecordDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::RECORD:
    case mx::DeclKind::CXX_RECORD:
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const RecordDecl &>(parent);
    default: return std::nullopt;
  }
}

bool RecordDecl::can_pass_in_registers(void) const {
  return impl->reader.getVal100();
}

std::optional<FieldDecl> RecordDecl::nth_field(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : fields()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<FieldDecl> RecordDecl::fields(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    EntityId id(v);
    if (auto d58 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = FieldDecl::from(Decl(std::move(d58)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

RecordDeclArgPassingKind RecordDecl::argument_passing_restrictions(void) const {
  return static_cast<RecordDeclArgPassingKind>(impl->reader.getVal79());
}

bool RecordDecl::has_flexible_array_member(void) const {
  return impl->reader.getVal101();
}

bool RecordDecl::has_loaded_fields_from_external_storage(void) const {
  return impl->reader.getVal102();
}

bool RecordDecl::has_non_trivial_to_primitive_copy_c_union(void) const {
  return impl->reader.getVal103();
}

bool RecordDecl::has_non_trivial_to_primitive_default_initialize_c_union(void) const {
  return impl->reader.getVal104();
}

bool RecordDecl::has_non_trivial_to_primitive_destruct_c_union(void) const {
  return impl->reader.getVal105();
}

bool RecordDecl::has_object_member(void) const {
  return impl->reader.getVal106();
}

bool RecordDecl::has_volatile_member(void) const {
  return impl->reader.getVal107();
}

bool RecordDecl::is_anonymous_struct_or_union(void) const {
  return impl->reader.getVal108();
}

bool RecordDecl::is_captured_record(void) const {
  return impl->reader.getVal109();
}

bool RecordDecl::is_injected_class_name(void) const {
  return impl->reader.getVal110();
}

bool RecordDecl::is_lambda(void) const {
  return impl->reader.getVal111();
}

bool RecordDecl::is_ms_struct(void) const {
  return impl->reader.getVal112();
}

bool RecordDecl::is_non_trivial_to_primitive_copy(void) const {
  return impl->reader.getVal113();
}

bool RecordDecl::is_non_trivial_to_primitive_default_initialize(void) const {
  return impl->reader.getVal114();
}

bool RecordDecl::is_non_trivial_to_primitive_destroy(void) const {
  return impl->reader.getVal115();
}

bool RecordDecl::is_or_contains_union(void) const {
  return impl->reader.getVal116();
}

bool RecordDecl::is_parameter_destroyed_in_callee(void) const {
  return impl->reader.getVal117();
}

bool RecordDecl::is_randomized(void) const {
  return impl->reader.getVal118();
}

bool RecordDecl::may_insert_extra_padding(void) const {
  return impl->reader.getVal119();
}

gap::generator<CXXRecordDecl> CXXRecordDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = CXXRecordDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool CXXRecordDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : CXXRecordDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<CXXRecordDecl> CXXRecordDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXRecordDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXRecordDecl> CXXRecordDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<CXXRecordDecl> CXXRecordDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = CXXRecordDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<CXXRecordDecl> CXXRecordDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool CXXRecordDecl::contains(const Decl &decl) {
  for (auto &parent : CXXRecordDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool CXXRecordDecl::contains(const Stmt &stmt) {
  for (auto &parent : CXXRecordDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<CXXRecordDecl> CXXRecordDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<CXXRecordDecl> dr = CXXRecordDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<CXXRecordDecl> CXXRecordDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return CXXRecordDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kCXXRecordDeclDerivedKinds[] = {
    CXXRecordDecl::static_kind(),
    ClassTemplateSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<CXXRecordDecl> CXXRecordDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kCXXRecordDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<CXXRecordDecl> e = CXXRecordDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<CXXRecordDecl> CXXRecordDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kCXXRecordDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<CXXRecordDecl> e = CXXRecordDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<CXXRecordDecl> CXXRecordDecl::from(const RecordDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXRecordDecl> CXXRecordDecl::from(const TagDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXRecordDecl> CXXRecordDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXRecordDecl> CXXRecordDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<CXXRecordDecl> CXXRecordDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CXX_RECORD:
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const CXXRecordDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<bool> CXXRecordDecl::allow_const_default_initializer(void) const {
  if (!impl->reader.getVal121()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal120());
  }
  return std::nullopt;
}

std::optional<std::vector<CXXBaseSpecifier>> CXXRecordDecl::bases(void) const {
  if (!impl->reader.getVal122()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal169();
  std::vector<CXXBaseSpecifier> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d169 = impl->ep->CXXBaseSpecifierFor(impl->ep, v)) {
      vec.emplace_back(std::move(d169));
    }
  }
  return vec;
}

std::optional<MSInheritanceModel> CXXRecordDecl::calculate_inheritance_model(void) const {
  if (!impl->reader.getVal130()) {
    return std::nullopt;
  } else {
    return static_cast<MSInheritanceModel>(impl->reader.getVal81());
  }
  return std::nullopt;
}

std::optional<CXXConstructorDecl> CXXRecordDecl::nth_constructor(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : constructors()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<CXXConstructorDecl> CXXRecordDecl::constructors(void) const {
  auto list = impl->reader.getVal177();
  for (auto v : list) {
    EntityId id(v);
    if (auto d177 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = CXXConstructorDecl::from(Decl(std::move(d177)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<std::vector<FriendDecl>> CXXRecordDecl::friends(void) const {
  if (!impl->reader.getVal131()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal178();
  std::vector<FriendDecl> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d178 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = FriendDecl::from(Decl(std::move(d178)))) {
        vec.emplace_back(std::move(*e));
      }
    }
  }
  return vec;
}

std::optional<FunctionTemplateDecl> CXXRecordDecl::dependent_lambda_call_operator(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<ClassTemplateDecl> CXXRecordDecl::described_class_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal75();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ClassTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<CXXDestructorDecl> CXXRecordDecl::destructor(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal76();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXDestructorDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<TemplateParameterList> CXXRecordDecl::generic_lambda_template_parameter_list(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal77();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TemplateParameterListFor(impl->ep, eid)) {
      return TemplateParameterList(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<CXXRecordDecl> CXXRecordDecl::instantiated_from_member_class(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal78();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXRecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<CXXMethodDecl> CXXRecordDecl::lambda_call_operator(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal80();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXMethodDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<LambdaCaptureDefault> CXXRecordDecl::lambda_capture_default(void) const {
  if (!impl->reader.getVal132()) {
    return std::nullopt;
  } else {
    return static_cast<LambdaCaptureDefault>(impl->reader.getVal82());
  }
  return std::nullopt;
}

std::optional<Decl> CXXRecordDecl::lambda_context_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal85();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return Decl(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<std::vector<NamedDecl>> CXXRecordDecl::lambda_explicit_template_parameters(void) const {
  if (!impl->reader.getVal133()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal179();
  std::vector<NamedDecl> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d179 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = NamedDecl::from(Decl(std::move(d179)))) {
        vec.emplace_back(std::move(*e));
      }
    }
  }
  return vec;
}

std::optional<unsigned> CXXRecordDecl::lambda_mangling_number(void) const {
  if (!impl->reader.getVal134()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal138());
  }
  return std::nullopt;
}

std::optional<Type> CXXRecordDecl::lambda_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal124();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<MSInheritanceModel> CXXRecordDecl::ms_inheritance_model(void) const {
  if (!impl->reader.getVal135()) {
    return std::nullopt;
  } else {
    return static_cast<MSInheritanceModel>(impl->reader.getVal83());
  }
  return std::nullopt;
}

MSVtorDispMode CXXRecordDecl::ms_vtor_disp_mode(void) const {
  return static_cast<MSVtorDispMode>(impl->reader.getVal84());
}

std::optional<unsigned> CXXRecordDecl::num_bases(void) const {
  if (!impl->reader.getVal136()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal180());
  }
  return std::nullopt;
}

std::optional<unsigned> CXXRecordDecl::num_virtual_bases(void) const {
  if (!impl->reader.getVal142()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal181());
  }
  return std::nullopt;
}

std::optional<unsigned> CXXRecordDecl::odr_hash(void) const {
  if (!impl->reader.getVal143()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal182());
  }
  return std::nullopt;
}

std::optional<CXXRecordDecl> CXXRecordDecl::template_instantiation_pattern(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal125();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return CXXRecordDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TemplateSpecializationKind CXXRecordDecl::template_specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal86());
}

std::optional<bool> CXXRecordDecl::has_any_dependent_bases(void) const {
  if (!impl->reader.getVal145()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal144());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_constexpr_default_constructor(void) const {
  if (!impl->reader.getVal147()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal146());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_constexpr_destructor(void) const {
  if (!impl->reader.getVal149()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal148());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_constexpr_non_copy_move_constructor(void) const {
  if (!impl->reader.getVal151()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal150());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_copy_assignment_with_const_parameter(void) const {
  if (!impl->reader.getVal153()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal152());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_copy_constructor_with_const_parameter(void) const {
  if (!impl->reader.getVal155()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal154());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_default_constructor(void) const {
  if (!impl->reader.getVal157()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal156());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_definition(void) const {
  if (!impl->reader.getVal162()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal161());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_direct_fields(void) const {
  if (!impl->reader.getVal164()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal163());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_friends(void) const {
  if (!impl->reader.getVal166()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal165());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_in_class_initializer(void) const {
  if (!impl->reader.getVal168()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal167());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_inherited_assignment(void) const {
  if (!impl->reader.getVal173()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal172());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_inherited_constructor(void) const {
  if (!impl->reader.getVal175()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal174());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_initializer_method(void) const {
  if (!impl->reader.getVal183()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal176());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_irrelevant_destructor(void) const {
  if (!impl->reader.getVal185()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal184());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_known_lambda_internal_linkage(void) const {
  if (!impl->reader.getVal187()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal186());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_move_assignment(void) const {
  if (!impl->reader.getVal189()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal188());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_move_constructor(void) const {
  if (!impl->reader.getVal191()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal190());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_mutable_fields(void) const {
  if (!impl->reader.getVal193()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal192());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_literal_type_fields_or_bases(void) const {
  if (!impl->reader.getVal195()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal194());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_copy_assignment(void) const {
  if (!impl->reader.getVal197()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal196());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_copy_constructor(void) const {
  if (!impl->reader.getVal199()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal198());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_copy_constructor_for_call(void) const {
  if (!impl->reader.getVal201()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal200());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_default_constructor(void) const {
  if (!impl->reader.getVal203()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal202());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_destructor(void) const {
  if (!impl->reader.getVal205()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal204());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_destructor_for_call(void) const {
  if (!impl->reader.getVal207()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal206());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_move_assignment(void) const {
  if (!impl->reader.getVal209()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal208());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_move_constructor(void) const {
  if (!impl->reader.getVal211()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal210());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_non_trivial_move_constructor_for_call(void) const {
  if (!impl->reader.getVal213()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal212());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_private_fields(void) const {
  if (!impl->reader.getVal215()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal214());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_protected_fields(void) const {
  if (!impl->reader.getVal217()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal216());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_simple_copy_assignment(void) const {
  if (!impl->reader.getVal219()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal218());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_simple_copy_constructor(void) const {
  if (!impl->reader.getVal221()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal220());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_simple_destructor(void) const {
  if (!impl->reader.getVal223()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal222());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_simple_move_assignment(void) const {
  if (!impl->reader.getVal225()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal224());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_simple_move_constructor(void) const {
  if (!impl->reader.getVal227()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal226());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_copy_assignment(void) const {
  if (!impl->reader.getVal229()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal228());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_copy_constructor(void) const {
  if (!impl->reader.getVal231()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal230());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_copy_constructor_for_call(void) const {
  if (!impl->reader.getVal233()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal232());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_default_constructor(void) const {
  if (!impl->reader.getVal235()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal234());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_destructor(void) const {
  if (!impl->reader.getVal237()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal236());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_destructor_for_call(void) const {
  if (!impl->reader.getVal239()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal238());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_move_assignment(void) const {
  if (!impl->reader.getVal241()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal240());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_move_constructor(void) const {
  if (!impl->reader.getVal243()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal242());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_trivial_move_constructor_for_call(void) const {
  if (!impl->reader.getVal245()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal244());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_uninitialized_reference_member(void) const {
  if (!impl->reader.getVal247()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal246());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_constructor(void) const {
  if (!impl->reader.getVal249()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal248());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_copy_assignment(void) const {
  if (!impl->reader.getVal251()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal250());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_copy_constructor(void) const {
  if (!impl->reader.getVal253()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal252());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_destructor(void) const {
  if (!impl->reader.getVal255()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal254());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_move_assignment(void) const {
  if (!impl->reader.getVal257()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal256());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_move_constructor(void) const {
  if (!impl->reader.getVal259()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal258());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_declared_move_operation(void) const {
  if (!impl->reader.getVal261()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal260());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_user_provided_default_constructor(void) const {
  if (!impl->reader.getVal263()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal262());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::has_variant_members(void) const {
  if (!impl->reader.getVal265()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal264());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::implicit_copy_assignment_has_const_parameter(void) const {
  if (!impl->reader.getVal267()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal266());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::implicit_copy_constructor_has_const_parameter(void) const {
  if (!impl->reader.getVal269()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal268());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_abstract(void) const {
  if (!impl->reader.getVal271()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal270());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_aggregate(void) const {
  if (!impl->reader.getVal273()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal272());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_any_destructor_no_return(void) const {
  if (!impl->reader.getVal275()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal274());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_c_like(void) const {
  if (!impl->reader.getVal277()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal276());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_cxx11_standard_layout(void) const {
  if (!impl->reader.getVal279()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal278());
  }
  return std::nullopt;
}

bool CXXRecordDecl::is_dependent_lambda(void) const {
  return impl->reader.getVal280();
}

std::optional<bool> CXXRecordDecl::is_dynamic_class(void) const {
  if (!impl->reader.getVal282()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal281());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_effectively_final(void) const {
  if (!impl->reader.getVal284()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal283());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_empty(void) const {
  if (!impl->reader.getVal286()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal285());
  }
  return std::nullopt;
}

bool CXXRecordDecl::is_generic_lambda(void) const {
  return impl->reader.getVal287();
}

std::optional<bool> CXXRecordDecl::is_interface_like(void) const {
  if (!impl->reader.getVal289()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal288());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_literal(void) const {
  if (!impl->reader.getVal291()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal290());
  }
  return std::nullopt;
}

std::optional<FunctionDecl> CXXRecordDecl::is_local_class(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal126();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return FunctionDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

bool CXXRecordDecl::is_never_dependent_lambda(void) const {
  return impl->reader.getVal292();
}

std::optional<bool> CXXRecordDecl::is_pod(void) const {
  if (!impl->reader.getVal294()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal293());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_polymorphic(void) const {
  if (!impl->reader.getVal296()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal295());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_standard_layout(void) const {
  if (!impl->reader.getVal298()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal297());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_structural(void) const {
  if (!impl->reader.getVal300()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal299());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_trivial(void) const {
  if (!impl->reader.getVal302()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal301());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::is_trivially_copyable(void) const {
  if (!impl->reader.getVal304()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal303());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::lambda_is_default_constructible_and_assignable(void) const {
  if (!impl->reader.getVal306()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal305());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::may_be_abstract(void) const {
  if (!impl->reader.getVal308()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal307());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::may_be_dynamic_class(void) const {
  if (!impl->reader.getVal310()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal309());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::may_be_non_dynamic_class(void) const {
  if (!impl->reader.getVal312()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal311());
  }
  return std::nullopt;
}

std::optional<std::vector<CXXMethodDecl>> CXXRecordDecl::methods(void) const {
  if (!impl->reader.getVal314()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal313();
  std::vector<CXXMethodDecl> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d313 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = CXXMethodDecl::from(Decl(std::move(d313)))) {
        vec.emplace_back(std::move(*e));
      }
    }
  }
  return vec;
}

std::optional<bool> CXXRecordDecl::needs_implicit_copy_assignment(void) const {
  if (!impl->reader.getVal316()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal315());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_implicit_copy_constructor(void) const {
  if (!impl->reader.getVal318()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal317());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_implicit_default_constructor(void) const {
  if (!impl->reader.getVal320()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal319());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_implicit_destructor(void) const {
  if (!impl->reader.getVal322()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal321());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_implicit_move_assignment(void) const {
  if (!impl->reader.getVal324()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal323());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_implicit_move_constructor(void) const {
  if (!impl->reader.getVal326()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal325());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_overload_resolution_for_copy_assignment(void) const {
  if (!impl->reader.getVal328()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal327());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_overload_resolution_for_copy_constructor(void) const {
  if (!impl->reader.getVal330()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal329());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_overload_resolution_for_destructor(void) const {
  if (!impl->reader.getVal332()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal331());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_overload_resolution_for_move_assignment(void) const {
  if (!impl->reader.getVal334()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal333());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::needs_overload_resolution_for_move_constructor(void) const {
  if (!impl->reader.getVal336()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal335());
  }
  return std::nullopt;
}

std::optional<bool> CXXRecordDecl::null_field_offset_is_zero(void) const {
  if (!impl->reader.getVal338()) {
    return std::nullopt;
  } else {
    return static_cast<bool>(impl->reader.getVal337());
  }
  return std::nullopt;
}

std::optional<std::vector<CXXBaseSpecifier>> CXXRecordDecl::virtual_bases(void) const {
  if (!impl->reader.getVal340()) {
    return std::nullopt;
  }
  auto list = impl->reader.getVal339();
  std::vector<CXXBaseSpecifier> vec;
  vec.reserve(list.size());
  for (auto v : list) {
    EntityId id(v);
    if (auto d339 = impl->ep->CXXBaseSpecifierFor(impl->ep, v)) {
      vec.emplace_back(std::move(d339));
    }
  }
  return vec;
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ClassTemplateSpecializationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ClassTemplateSpecializationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ClassTemplateSpecializationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplateSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplateSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ClassTemplateSpecializationDecl::contains(const Decl &decl) {
  for (auto &parent : ClassTemplateSpecializationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ClassTemplateSpecializationDecl::contains(const Stmt &stmt) {
  for (auto &parent : ClassTemplateSpecializationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ClassTemplateSpecializationDecl> dr = ClassTemplateSpecializationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ClassTemplateSpecializationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kClassTemplateSpecializationDeclDerivedKinds[] = {
    ClassTemplateSpecializationDecl::static_kind(),
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kClassTemplateSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ClassTemplateSpecializationDecl> e = ClassTemplateSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kClassTemplateSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ClassTemplateSpecializationDecl> e = ClassTemplateSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const CXXRecordDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const RecordDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const TagDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateSpecializationDecl> ClassTemplateSpecializationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CLASS_TEMPLATE_SPECIALIZATION:
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const ClassTemplateSpecializationDecl &>(parent);
    default: return std::nullopt;
  }
}

Token ClassTemplateSpecializationDecl::extern_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal128());
}

Token ClassTemplateSpecializationDecl::point_of_instantiation(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal129());
}

TemplateSpecializationKind ClassTemplateSpecializationDecl::specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal87());
}

ClassTemplateDecl ClassTemplateSpecializationDecl::specialized_template(void) const {
  RawEntityId eid = impl->reader.getVal137();
  return ClassTemplateDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<TemplateArgument> ClassTemplateSpecializationDecl::nth_template_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> ClassTemplateSpecializationDecl::template_arguments(void) const {
  auto list = impl->reader.getVal341();
  for (auto v : list) {
    EntityId id(v);
    if (auto d341 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d341));
    }
  }
  co_return;
}

std::optional<TemplateArgument> ClassTemplateSpecializationDecl::nth_template_instantiation_argument(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_instantiation_arguments()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateArgument> ClassTemplateSpecializationDecl::template_instantiation_arguments(void) const {
  auto list = impl->reader.getVal342();
  for (auto v : list) {
    EntityId id(v);
    if (auto d342 = impl->ep->TemplateArgumentFor(impl->ep, v)) {
      co_yield TemplateArgument(std::move(d342));
    }
  }
  co_return;
}

Token ClassTemplateSpecializationDecl::template_keyword_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal139());
}

std::optional<Type> ClassTemplateSpecializationDecl::type_as_written(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal140();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool ClassTemplateSpecializationDecl::is_class_scope_explicit_specialization(void) const {
  return impl->reader.getVal343();
}

bool ClassTemplateSpecializationDecl::is_explicit_instantiation_or_specialization(void) const {
  return impl->reader.getVal344();
}

bool ClassTemplateSpecializationDecl::is_explicit_specialization(void) const {
  return impl->reader.getVal345();
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ClassTemplatePartialSpecializationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ClassTemplatePartialSpecializationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ClassTemplatePartialSpecializationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplatePartialSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplatePartialSpecializationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ClassTemplatePartialSpecializationDecl::contains(const Decl &decl) {
  for (auto &parent : ClassTemplatePartialSpecializationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ClassTemplatePartialSpecializationDecl::contains(const Stmt &stmt) {
  for (auto &parent : ClassTemplatePartialSpecializationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ClassTemplatePartialSpecializationDecl> dr = ClassTemplatePartialSpecializationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ClassTemplatePartialSpecializationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kClassTemplatePartialSpecializationDeclDerivedKinds[] = {
    ClassTemplatePartialSpecializationDecl::static_kind(),
};

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kClassTemplatePartialSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ClassTemplatePartialSpecializationDecl> e = ClassTemplatePartialSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kClassTemplatePartialSpecializationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ClassTemplatePartialSpecializationDecl> e = ClassTemplatePartialSpecializationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const ClassTemplateSpecializationDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const CXXRecordDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const RecordDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const TagDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplatePartialSpecializationDecl> ClassTemplatePartialSpecializationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:
      return reinterpret_cast<const ClassTemplatePartialSpecializationDecl &>(parent);
    default: return std::nullopt;
  }
}

Type ClassTemplatePartialSpecializationDecl::injected_specialization_type(void) const {
  RawEntityId eid = impl->reader.getVal141();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

ClassTemplatePartialSpecializationDecl ClassTemplatePartialSpecializationDecl::instantiated_from_member(void) const {
  RawEntityId eid = impl->reader.getVal158();
  return ClassTemplatePartialSpecializationDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ClassTemplatePartialSpecializationDecl ClassTemplatePartialSpecializationDecl::instantiated_from_member_template(void) const {
  RawEntityId eid = impl->reader.getVal159();
  return ClassTemplatePartialSpecializationDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

TemplateParameterList ClassTemplatePartialSpecializationDecl::template_parameters(void) const {
  RawEntityId eid = impl->reader.getVal160();
  return TemplateParameterList(impl->ep->TemplateParameterListFor(impl->ep, eid));
}

bool ClassTemplatePartialSpecializationDecl::has_associated_constraints(void) const {
  return impl->reader.getVal346();
}

gap::generator<EnumDecl> EnumDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EnumDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EnumDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EnumDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<EnumDecl> EnumDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EnumDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EnumDecl> EnumDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<EnumDecl> EnumDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EnumDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EnumDecl> EnumDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool EnumDecl::contains(const Decl &decl) {
  for (auto &parent : EnumDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool EnumDecl::contains(const Stmt &stmt) {
  for (auto &parent : EnumDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<EnumDecl> EnumDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<EnumDecl> dr = EnumDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<EnumDecl> EnumDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return EnumDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kEnumDeclDerivedKinds[] = {
    EnumDecl::static_kind(),
};

gap::generator<EnumDecl> EnumDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kEnumDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<EnumDecl> e = EnumDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EnumDecl> EnumDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kEnumDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<EnumDecl> e = EnumDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EnumDecl> EnumDecl::from(const TagDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<EnumDecl> EnumDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<EnumDecl> EnumDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<EnumDecl> EnumDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::ENUM:
      return reinterpret_cast<const EnumDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<EnumConstantDecl> EnumDecl::nth_enumerator(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : enumerators()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<EnumConstantDecl> EnumDecl::enumerators(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    EntityId id(v);
    if (auto d58 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = EnumConstantDecl::from(Decl(std::move(d58)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<EnumDecl> EnumDecl::instantiated_from_member_enum(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal73();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return EnumDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

std::optional<Type> EnumDecl::integer_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal75();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

TokenRange EnumDecl::integer_type_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal76(), impl->reader.getVal77());
}

std::optional<unsigned> EnumDecl::odr_hash(void) const {
  if (!impl->reader.getVal100()) {
    return std::nullopt;
  } else {
    return static_cast<unsigned>(impl->reader.getVal138());
  }
  return std::nullopt;
}

std::optional<Type> EnumDecl::promotion_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal78();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

std::optional<EnumDecl> EnumDecl::template_instantiation_pattern(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal80();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return EnumDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

TemplateSpecializationKind EnumDecl::template_specialization_kind(void) const {
  return static_cast<TemplateSpecializationKind>(impl->reader.getVal79());
}

bool EnumDecl::is_closed(void) const {
  return impl->reader.getVal101();
}

bool EnumDecl::is_closed_flag(void) const {
  return impl->reader.getVal102();
}

bool EnumDecl::is_closed_non_flag(void) const {
  return impl->reader.getVal103();
}

bool EnumDecl::is_complete(void) const {
  return impl->reader.getVal104();
}

bool EnumDecl::is_fixed(void) const {
  return impl->reader.getVal105();
}

bool EnumDecl::is_scoped(void) const {
  return impl->reader.getVal106();
}

bool EnumDecl::is_scoped_using_class_tag(void) const {
  return impl->reader.getVal107();
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = UnresolvedUsingTypenameDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool UnresolvedUsingTypenameDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : UnresolvedUsingTypenameDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingTypenameDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = UnresolvedUsingTypenameDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool UnresolvedUsingTypenameDecl::contains(const Decl &decl) {
  for (auto &parent : UnresolvedUsingTypenameDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool UnresolvedUsingTypenameDecl::contains(const Stmt &stmt) {
  for (auto &parent : UnresolvedUsingTypenameDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<UnresolvedUsingTypenameDecl> dr = UnresolvedUsingTypenameDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return UnresolvedUsingTypenameDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kUnresolvedUsingTypenameDeclDerivedKinds[] = {
    UnresolvedUsingTypenameDecl::static_kind(),
};

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kUnresolvedUsingTypenameDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<UnresolvedUsingTypenameDecl> e = UnresolvedUsingTypenameDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kUnresolvedUsingTypenameDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<UnresolvedUsingTypenameDecl> e = UnresolvedUsingTypenameDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<UnresolvedUsingTypenameDecl> UnresolvedUsingTypenameDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::UNRESOLVED_USING_TYPENAME:
      return reinterpret_cast<const UnresolvedUsingTypenameDecl &>(parent);
    default: return std::nullopt;
  }
}

Token UnresolvedUsingTypenameDecl::ellipsis_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

Token UnresolvedUsingTypenameDecl::typename_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

Token UnresolvedUsingTypenameDecl::using_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

bool UnresolvedUsingTypenameDecl::is_pack_expansion(void) const {
  return impl->reader.getVal70();
}

gap::generator<TypedefNameDecl> TypedefNameDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypedefNameDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypedefNameDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypedefNameDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypedefNameDecl> TypedefNameDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypedefNameDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypedefNameDecl> TypedefNameDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypedefNameDecl> TypedefNameDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypedefNameDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypedefNameDecl> TypedefNameDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypedefNameDecl::contains(const Decl &decl) {
  for (auto &parent : TypedefNameDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypedefNameDecl::contains(const Stmt &stmt) {
  for (auto &parent : TypedefNameDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TypedefNameDecl> TypedefNameDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TypedefNameDecl> dr = TypedefNameDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TypedefNameDecl> TypedefNameDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TypedefNameDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTypedefNameDeclDerivedKinds[] = {
    ObjCTypeParamDecl::static_kind(),
    TypeAliasDecl::static_kind(),
    TypedefDecl::static_kind(),
};

gap::generator<TypedefNameDecl> TypedefNameDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTypedefNameDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TypedefNameDecl> e = TypedefNameDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypedefNameDecl> TypedefNameDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTypedefNameDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TypedefNameDecl> e = TypedefNameDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypedefNameDecl> TypedefNameDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypedefNameDecl> TypedefNameDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypedefNameDecl> TypedefNameDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TYPEDEF:
    case mx::DeclKind::TYPE_ALIAS:
    case mx::DeclKind::OBJ_C_TYPE_PARAM:
      return reinterpret_cast<const TypedefNameDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<TagDecl> TypedefNameDecl::anonymous_declaration_with_typedef_name(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TagDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Type TypedefNameDecl::underlying_type(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool TypedefNameDecl::is_moded(void) const {
  return impl->reader.getVal70();
}

bool TypedefNameDecl::is_transparent_tag(void) const {
  return impl->reader.getVal71();
}

gap::generator<TypedefDecl> TypedefDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypedefDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypedefDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypedefDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypedefDecl> TypedefDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypedefDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypedefDecl> TypedefDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypedefDecl> TypedefDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypedefDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypedefDecl> TypedefDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypedefDecl::contains(const Decl &decl) {
  for (auto &parent : TypedefDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypedefDecl::contains(const Stmt &stmt) {
  for (auto &parent : TypedefDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TypedefDecl> TypedefDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TypedefDecl> dr = TypedefDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TypedefDecl> TypedefDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TypedefDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTypedefDeclDerivedKinds[] = {
    TypedefDecl::static_kind(),
};

gap::generator<TypedefDecl> TypedefDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTypedefDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TypedefDecl> e = TypedefDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypedefDecl> TypedefDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTypedefDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TypedefDecl> e = TypedefDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypedefDecl> TypedefDecl::from(const TypedefNameDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypedefDecl> TypedefDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypedefDecl> TypedefDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypedefDecl> TypedefDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TYPEDEF:
      return reinterpret_cast<const TypedefDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TypeAliasDecl> TypeAliasDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeAliasDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeAliasDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeAliasDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypeAliasDecl> TypeAliasDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeAliasDecl> TypeAliasDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypeAliasDecl> TypeAliasDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeAliasDecl> TypeAliasDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypeAliasDecl::contains(const Decl &decl) {
  for (auto &parent : TypeAliasDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypeAliasDecl::contains(const Stmt &stmt) {
  for (auto &parent : TypeAliasDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TypeAliasDecl> TypeAliasDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TypeAliasDecl> dr = TypeAliasDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TypeAliasDecl> TypeAliasDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TypeAliasDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTypeAliasDeclDerivedKinds[] = {
    TypeAliasDecl::static_kind(),
};

gap::generator<TypeAliasDecl> TypeAliasDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTypeAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TypeAliasDecl> e = TypeAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeAliasDecl> TypeAliasDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTypeAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TypeAliasDecl> e = TypeAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeAliasDecl> TypeAliasDecl::from(const TypedefNameDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasDecl> TypeAliasDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasDecl> TypeAliasDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasDecl> TypeAliasDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TYPE_ALIAS:
      return reinterpret_cast<const TypeAliasDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<TypeAliasTemplateDecl> TypeAliasDecl::described_alias_template(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal62();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return TypeAliasTemplateDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCTypeParamDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCTypeParamDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCTypeParamDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCTypeParamDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCTypeParamDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCTypeParamDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCTypeParamDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCTypeParamDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCTypeParamDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCTypeParamDecl> dr = ObjCTypeParamDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCTypeParamDecl> ObjCTypeParamDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCTypeParamDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCTypeParamDeclDerivedKinds[] = {
    ObjCTypeParamDecl::static_kind(),
};

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCTypeParamDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCTypeParamDecl> e = ObjCTypeParamDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCTypeParamDecl> ObjCTypeParamDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCTypeParamDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCTypeParamDecl> e = ObjCTypeParamDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCTypeParamDecl> ObjCTypeParamDecl::from(const TypedefNameDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCTypeParamDecl> ObjCTypeParamDecl::from(const TypeDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCTypeParamDecl> ObjCTypeParamDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCTypeParamDecl> ObjCTypeParamDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_TYPE_PARAM:
      return reinterpret_cast<const ObjCTypeParamDecl &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCTypeParamDecl::colon_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

ObjCTypeParamVariance ObjCTypeParamDecl::variance(void) const {
  return static_cast<ObjCTypeParamVariance>(impl->reader.getVal74());
}

Token ObjCTypeParamDecl::variance_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal63());
}

bool ObjCTypeParamDecl::has_explicit_bound(void) const {
  return impl->reader.getVal72();
}

gap::generator<TemplateDecl> TemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TemplateDecl> TemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateDecl> TemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TemplateDecl> TemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateDecl> TemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TemplateDecl::contains(const Decl &decl) {
  for (auto &parent : TemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : TemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TemplateDecl> TemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TemplateDecl> dr = TemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TemplateDecl> TemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTemplateDeclDerivedKinds[] = {
    TemplateTemplateParmDecl::static_kind(),
    BuiltinTemplateDecl::static_kind(),
    ConceptDecl::static_kind(),
    TypeAliasTemplateDecl::static_kind(),
    VarTemplateDecl::static_kind(),
    ClassTemplateDecl::static_kind(),
    FunctionTemplateDecl::static_kind(),
};

gap::generator<TemplateDecl> TemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TemplateDecl> e = TemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateDecl> TemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TemplateDecl> e = TemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateDecl> TemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateDecl> TemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FUNCTION_TEMPLATE:
    case mx::DeclKind::CLASS_TEMPLATE:
    case mx::DeclKind::VAR_TEMPLATE:
    case mx::DeclKind::TYPE_ALIAS_TEMPLATE:
    case mx::DeclKind::CONCEPT:
    case mx::DeclKind::BUILTIN_TEMPLATE:
    case mx::DeclKind::TEMPLATE_TEMPLATE_PARM:
      return reinterpret_cast<const TemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

TemplateParameterList TemplateDecl::template_parameters(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return TemplateParameterList(impl->ep->TemplateParameterListFor(impl->ep, eid));
}

NamedDecl TemplateDecl::templated_declaration(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool TemplateDecl::has_associated_constraints(void) const {
  return impl->reader.getVal70();
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = RedeclarableTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool RedeclarableTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : RedeclarableTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RedeclarableTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = RedeclarableTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool RedeclarableTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : RedeclarableTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool RedeclarableTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : RedeclarableTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<RedeclarableTemplateDecl> dr = RedeclarableTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<RedeclarableTemplateDecl> RedeclarableTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return RedeclarableTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kRedeclarableTemplateDeclDerivedKinds[] = {
    TypeAliasTemplateDecl::static_kind(),
    VarTemplateDecl::static_kind(),
    ClassTemplateDecl::static_kind(),
    FunctionTemplateDecl::static_kind(),
};

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kRedeclarableTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<RedeclarableTemplateDecl> e = RedeclarableTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<RedeclarableTemplateDecl> RedeclarableTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kRedeclarableTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<RedeclarableTemplateDecl> e = RedeclarableTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<RedeclarableTemplateDecl> RedeclarableTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<RedeclarableTemplateDecl> RedeclarableTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<RedeclarableTemplateDecl> RedeclarableTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FUNCTION_TEMPLATE:
    case mx::DeclKind::CLASS_TEMPLATE:
    case mx::DeclKind::VAR_TEMPLATE:
    case mx::DeclKind::TYPE_ALIAS_TEMPLATE:
      return reinterpret_cast<const RedeclarableTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

RedeclarableTemplateDecl RedeclarableTemplateDecl::instantiated_from_member_template(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return RedeclarableTemplateDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool RedeclarableTemplateDecl::is_member_specialization(void) const {
  return impl->reader.getVal71();
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FunctionTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FunctionTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FunctionTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FunctionTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FunctionTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FunctionTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : FunctionTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FunctionTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : FunctionTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FunctionTemplateDecl> dr = FunctionTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FunctionTemplateDecl> FunctionTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FunctionTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFunctionTemplateDeclDerivedKinds[] = {
    FunctionTemplateDecl::static_kind(),
};

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFunctionTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FunctionTemplateDecl> e = FunctionTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FunctionTemplateDecl> FunctionTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFunctionTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FunctionTemplateDecl> e = FunctionTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FunctionTemplateDecl> FunctionTemplateDecl::from(const RedeclarableTemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionTemplateDecl> FunctionTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionTemplateDecl> FunctionTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<FunctionTemplateDecl> FunctionTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FUNCTION_TEMPLATE:
      return reinterpret_cast<const FunctionTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

bool FunctionTemplateDecl::is_abbreviated(void) const {
  return impl->reader.getVal72();
}

bool FunctionTemplateDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal88();
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ClassTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ClassTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ClassTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ClassTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ClassTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : ClassTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ClassTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : ClassTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ClassTemplateDecl> dr = ClassTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ClassTemplateDecl> ClassTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ClassTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kClassTemplateDeclDerivedKinds[] = {
    ClassTemplateDecl::static_kind(),
};

gap::generator<ClassTemplateDecl> ClassTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kClassTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ClassTemplateDecl> e = ClassTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ClassTemplateDecl> ClassTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kClassTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ClassTemplateDecl> e = ClassTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ClassTemplateDecl> ClassTemplateDecl::from(const RedeclarableTemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateDecl> ClassTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateDecl> ClassTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ClassTemplateDecl> ClassTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CLASS_TEMPLATE:
      return reinterpret_cast<const ClassTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

bool ClassTemplateDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal72();
}

gap::generator<VarTemplateDecl> VarTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = VarTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool VarTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : VarTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<VarTemplateDecl> VarTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplateDecl> VarTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<VarTemplateDecl> VarTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = VarTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<VarTemplateDecl> VarTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool VarTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : VarTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool VarTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : VarTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<VarTemplateDecl> VarTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<VarTemplateDecl> dr = VarTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<VarTemplateDecl> VarTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return VarTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kVarTemplateDeclDerivedKinds[] = {
    VarTemplateDecl::static_kind(),
};

gap::generator<VarTemplateDecl> VarTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kVarTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<VarTemplateDecl> e = VarTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<VarTemplateDecl> VarTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kVarTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<VarTemplateDecl> e = VarTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<VarTemplateDecl> VarTemplateDecl::from(const RedeclarableTemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateDecl> VarTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateDecl> VarTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<VarTemplateDecl> VarTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::VAR_TEMPLATE:
      return reinterpret_cast<const VarTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

bool VarTemplateDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal72();
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TypeAliasTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TypeAliasTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TypeAliasTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeAliasTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TypeAliasTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TypeAliasTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : TypeAliasTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TypeAliasTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : TypeAliasTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TypeAliasTemplateDecl> dr = TypeAliasTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TypeAliasTemplateDecl> TypeAliasTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TypeAliasTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTypeAliasTemplateDeclDerivedKinds[] = {
    TypeAliasTemplateDecl::static_kind(),
};

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTypeAliasTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TypeAliasTemplateDecl> e = TypeAliasTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TypeAliasTemplateDecl> TypeAliasTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTypeAliasTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TypeAliasTemplateDecl> e = TypeAliasTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TypeAliasTemplateDecl> TypeAliasTemplateDecl::from(const RedeclarableTemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasTemplateDecl> TypeAliasTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasTemplateDecl> TypeAliasTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TypeAliasTemplateDecl> TypeAliasTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TYPE_ALIAS_TEMPLATE:
      return reinterpret_cast<const TypeAliasTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<ConceptDecl> ConceptDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ConceptDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ConceptDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ConceptDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ConceptDecl> ConceptDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ConceptDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConceptDecl> ConceptDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ConceptDecl> ConceptDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ConceptDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ConceptDecl> ConceptDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ConceptDecl::contains(const Decl &decl) {
  for (auto &parent : ConceptDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ConceptDecl::contains(const Stmt &stmt) {
  for (auto &parent : ConceptDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ConceptDecl> ConceptDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ConceptDecl> dr = ConceptDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ConceptDecl> ConceptDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ConceptDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kConceptDeclDerivedKinds[] = {
    ConceptDecl::static_kind(),
};

gap::generator<ConceptDecl> ConceptDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kConceptDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ConceptDecl> e = ConceptDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ConceptDecl> ConceptDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kConceptDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ConceptDecl> e = ConceptDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ConceptDecl> ConceptDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ConceptDecl> ConceptDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ConceptDecl> ConceptDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::CONCEPT:
      return reinterpret_cast<const ConceptDecl &>(parent);
    default: return std::nullopt;
  }
}

Expr ConceptDecl::constraint_expression(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

bool ConceptDecl::is_type_concept(void) const {
  return impl->reader.getVal71();
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = BuiltinTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool BuiltinTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : BuiltinTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BuiltinTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = BuiltinTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool BuiltinTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : BuiltinTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool BuiltinTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : BuiltinTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<BuiltinTemplateDecl> dr = BuiltinTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<BuiltinTemplateDecl> BuiltinTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return BuiltinTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kBuiltinTemplateDeclDerivedKinds[] = {
    BuiltinTemplateDecl::static_kind(),
};

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kBuiltinTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<BuiltinTemplateDecl> e = BuiltinTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<BuiltinTemplateDecl> BuiltinTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kBuiltinTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<BuiltinTemplateDecl> e = BuiltinTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<BuiltinTemplateDecl> BuiltinTemplateDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<BuiltinTemplateDecl> BuiltinTemplateDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<BuiltinTemplateDecl> BuiltinTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::BUILTIN_TEMPLATE:
      return reinterpret_cast<const BuiltinTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = TemplateTemplateParmDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool TemplateTemplateParmDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : TemplateTemplateParmDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateTemplateParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = TemplateTemplateParmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool TemplateTemplateParmDecl::contains(const Decl &decl) {
  for (auto &parent : TemplateTemplateParmDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool TemplateTemplateParmDecl::contains(const Stmt &stmt) {
  for (auto &parent : TemplateTemplateParmDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<TemplateTemplateParmDecl> dr = TemplateTemplateParmDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<TemplateTemplateParmDecl> TemplateTemplateParmDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return TemplateTemplateParmDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kTemplateTemplateParmDeclDerivedKinds[] = {
    TemplateTemplateParmDecl::static_kind(),
};

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kTemplateTemplateParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<TemplateTemplateParmDecl> e = TemplateTemplateParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<TemplateTemplateParmDecl> TemplateTemplateParmDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kTemplateTemplateParmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<TemplateTemplateParmDecl> e = TemplateTemplateParmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<TemplateTemplateParmDecl> TemplateTemplateParmDecl::from(const TemplateDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateTemplateParmDecl> TemplateTemplateParmDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<TemplateTemplateParmDecl> TemplateTemplateParmDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::TEMPLATE_TEMPLATE_PARM:
      return reinterpret_cast<const TemplateTemplateParmDecl &>(parent);
    default: return std::nullopt;
  }
}

bool TemplateTemplateParmDecl::default_argument_was_inherited(void) const {
  return impl->reader.getVal71();
}

Token TemplateTemplateParmDecl::default_argument_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

bool TemplateTemplateParmDecl::has_default_argument(void) const {
  return impl->reader.getVal72();
}

bool TemplateTemplateParmDecl::is_expanded_parameter_pack(void) const {
  return impl->reader.getVal88();
}

bool TemplateTemplateParmDecl::is_pack_expansion(void) const {
  return impl->reader.getVal89();
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCPropertyDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCPropertyDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCPropertyDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCPropertyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCPropertyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCPropertyDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCPropertyDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCPropertyDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCPropertyDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCPropertyDecl> dr = ObjCPropertyDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCPropertyDecl> ObjCPropertyDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCPropertyDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCPropertyDeclDerivedKinds[] = {
    ObjCPropertyDecl::static_kind(),
};

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCPropertyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCPropertyDecl> e = ObjCPropertyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCPropertyDecl> ObjCPropertyDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCPropertyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCPropertyDecl> e = ObjCPropertyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCPropertyDecl> ObjCPropertyDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCPropertyDecl> ObjCPropertyDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_PROPERTY:
      return reinterpret_cast<const ObjCPropertyDecl &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCPropertyDecl::at_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

ObjCMethodDecl ObjCPropertyDecl::getter_method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCPropertyDecl::getter_name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

Token ObjCPropertyDecl::l_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

ObjCPropertyDeclPropertyControl ObjCPropertyDecl::property_implementation(void) const {
  return static_cast<ObjCPropertyDeclPropertyControl>(impl->reader.getVal74());
}

ObjCIvarDecl ObjCPropertyDecl::property_instance_variable_declaration(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return ObjCIvarDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCPropertyQueryKind ObjCPropertyDecl::query_kind(void) const {
  return static_cast<ObjCPropertyQueryKind>(impl->reader.getVal79());
}

ObjCPropertyDeclSetterKind ObjCPropertyDecl::setter_kind(void) const {
  return static_cast<ObjCPropertyDeclSetterKind>(impl->reader.getVal81());
}

ObjCMethodDecl ObjCPropertyDecl::setter_method_declaration(void) const {
  RawEntityId eid = impl->reader.getVal64();
  return ObjCMethodDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCPropertyDecl::setter_name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal73());
}

Type ObjCPropertyDecl::type(void) const {
  RawEntityId eid = impl->reader.getVal75();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ObjCPropertyDecl::is_atomic(void) const {
  return impl->reader.getVal70();
}

bool ObjCPropertyDecl::is_class_property(void) const {
  return impl->reader.getVal71();
}

bool ObjCPropertyDecl::is_direct_property(void) const {
  return impl->reader.getVal72();
}

bool ObjCPropertyDecl::is_instance_property(void) const {
  return impl->reader.getVal88();
}

bool ObjCPropertyDecl::is_optional(void) const {
  return impl->reader.getVal89();
}

bool ObjCPropertyDecl::is_read_only(void) const {
  return impl->reader.getVal90();
}

bool ObjCPropertyDecl::is_retaining(void) const {
  return impl->reader.getVal91();
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCMethodDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCMethodDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCMethodDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCMethodDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCMethodDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCMethodDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCMethodDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCMethodDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCMethodDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCMethodDecl> dr = ObjCMethodDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCMethodDecl> ObjCMethodDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCMethodDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCMethodDeclDerivedKinds[] = {
    ObjCMethodDecl::static_kind(),
};

gap::generator<ObjCMethodDecl> ObjCMethodDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCMethodDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCMethodDecl> e = ObjCMethodDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCMethodDecl> ObjCMethodDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCMethodDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCMethodDecl> e = ObjCMethodDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCMethodDecl> ObjCMethodDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCMethodDecl> ObjCMethodDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_METHOD:
      return reinterpret_cast<const ObjCMethodDecl &>(parent);
    default: return std::nullopt;
  }
}

bool ObjCMethodDecl::defined_in_ns_object(void) const {
  return impl->reader.getVal70();
}

ObjCPropertyDecl ObjCMethodDecl::find_property_declaration(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return ObjCPropertyDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCInterfaceDecl ObjCMethodDecl::class_interface(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ImplicitParamDecl ObjCMethodDecl::command_declaration(void) const {
  RawEntityId eid = impl->reader.getVal54();
  return ImplicitParamDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCMethodDecl::declarator_end_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

ObjCMethodDeclImplementationControl ObjCMethodDecl::implementation_control(void) const {
  return static_cast<ObjCMethodDeclImplementationControl>(impl->reader.getVal74());
}

ObjCMethodFamily ObjCMethodDecl::method_family(void) const {
  return static_cast<ObjCMethodFamily>(impl->reader.getVal79());
}

DeclObjCDeclQualifier ObjCMethodDecl::obj_c_decl_qualifier(void) const {
  return static_cast<DeclObjCDeclQualifier>(impl->reader.getVal81());
}

Type ObjCMethodDecl::return_type(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

TokenRange ObjCMethodDecl::return_type_source_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal64(), impl->reader.getVal73());
}

Token ObjCMethodDecl::selector_start_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal75());
}

ImplicitParamDecl ObjCMethodDecl::self_declaration(void) const {
  RawEntityId eid = impl->reader.getVal76();
  return ImplicitParamDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ObjCMethodDecl::has_parameter_destroyed_in_callee(void) const {
  return impl->reader.getVal71();
}

bool ObjCMethodDecl::has_redeclaration(void) const {
  return impl->reader.getVal72();
}

bool ObjCMethodDecl::has_related_result_type(void) const {
  return impl->reader.getVal88();
}

bool ObjCMethodDecl::has_skipped_body(void) const {
  return impl->reader.getVal89();
}

bool ObjCMethodDecl::is_class_method(void) const {
  return impl->reader.getVal90();
}

bool ObjCMethodDecl::is_defined(void) const {
  return impl->reader.getVal91();
}

bool ObjCMethodDecl::is_designated_initializer_for_the_interface(void) const {
  return impl->reader.getVal92();
}

bool ObjCMethodDecl::is_direct_method(void) const {
  return impl->reader.getVal93();
}

bool ObjCMethodDecl::is_instance_method(void) const {
  return impl->reader.getVal94();
}

bool ObjCMethodDecl::is_optional(void) const {
  return impl->reader.getVal95();
}

bool ObjCMethodDecl::is_overriding(void) const {
  return impl->reader.getVal96();
}

bool ObjCMethodDecl::is_property_accessor(void) const {
  return impl->reader.getVal97();
}

bool ObjCMethodDecl::is_redeclaration(void) const {
  return impl->reader.getVal98();
}

bool ObjCMethodDecl::is_synthesized_accessor_stub(void) const {
  return impl->reader.getVal99();
}

bool ObjCMethodDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal100();
}

bool ObjCMethodDecl::is_this_declaration_a_designated_initializer(void) const {
  return impl->reader.getVal101();
}

bool ObjCMethodDecl::is_variadic(void) const {
  return impl->reader.getVal102();
}

std::optional<ParmVarDecl> ObjCMethodDecl::nth_parameter(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : parameters()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ParmVarDecl> ObjCMethodDecl::parameters(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ParmVarDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Token> ObjCMethodDecl::nth_selector_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : selector_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ObjCMethodDecl::selector_tokens(void) const {
  auto list = impl->reader.getVal48();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t48 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t48;
    }
  }
  co_return;
}

gap::generator<Decl> ObjCMethodDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCContainerDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCContainerDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCContainerDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCContainerDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCContainerDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCContainerDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCContainerDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCContainerDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCContainerDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCContainerDecl> dr = ObjCContainerDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCContainerDecl> ObjCContainerDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCContainerDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCContainerDeclDerivedKinds[] = {
    ObjCInterfaceDecl::static_kind(),
    ObjCProtocolDecl::static_kind(),
    ObjCCategoryDecl::static_kind(),
    ObjCImplementationDecl::static_kind(),
    ObjCCategoryImplDecl::static_kind(),
};

gap::generator<ObjCContainerDecl> ObjCContainerDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCContainerDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCContainerDecl> e = ObjCContainerDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCContainerDecl> ObjCContainerDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCContainerDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCContainerDecl> e = ObjCContainerDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCContainerDecl> ObjCContainerDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCContainerDecl> ObjCContainerDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_CATEGORY:
    case mx::DeclKind::OBJ_C_PROTOCOL:
    case mx::DeclKind::OBJ_C_INTERFACE:
    case mx::DeclKind::OBJ_C_CATEGORY_IMPL:
    case mx::DeclKind::OBJ_C_IMPLEMENTATION:
      return reinterpret_cast<const ObjCContainerDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<ObjCMethodDecl> ObjCContainerDecl::nth_class_method(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : class_methods()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCMethodDecl> ObjCContainerDecl::class_methods(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCMethodDecl::from(Decl(std::move(d47)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCPropertyDecl> ObjCContainerDecl::nth_class_propertie(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : class_properties()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCPropertyDecl> ObjCContainerDecl::class_properties(void) const {
  auto list = impl->reader.getVal48();
  for (auto v : list) {
    EntityId id(v);
    if (auto d48 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCPropertyDecl::from(Decl(std::move(d48)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

TokenRange ObjCContainerDecl::at_end_range(void) const {
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  return fragment->TokenRangeFor(fragment, impl->reader.getVal52(), impl->reader.getVal53());
}

Token ObjCContainerDecl::at_start_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

std::optional<ObjCMethodDecl> ObjCContainerDecl::nth_instance_method(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : instance_methods()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCMethodDecl> ObjCContainerDecl::instance_methods(void) const {
  auto list = impl->reader.getVal58();
  for (auto v : list) {
    EntityId id(v);
    if (auto d58 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCMethodDecl::from(Decl(std::move(d58)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCPropertyDecl> ObjCContainerDecl::nth_instance_propertie(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : instance_properties()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCPropertyDecl> ObjCContainerDecl::instance_properties(void) const {
  auto list = impl->reader.getVal169();
  for (auto v : list) {
    EntityId id(v);
    if (auto d169 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCPropertyDecl::from(Decl(std::move(d169)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCMethodDecl> ObjCContainerDecl::nth_method(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : methods()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCMethodDecl> ObjCContainerDecl::methods(void) const {
  auto list = impl->reader.getVal177();
  for (auto v : list) {
    EntityId id(v);
    if (auto d177 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCMethodDecl::from(Decl(std::move(d177)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCPropertyDecl> ObjCContainerDecl::nth_propertie(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : properties()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCPropertyDecl> ObjCContainerDecl::properties(void) const {
  auto list = impl->reader.getVal178();
  for (auto v : list) {
    EntityId id(v);
    if (auto d178 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCPropertyDecl::from(Decl(std::move(d178)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<Decl> ObjCContainerDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal179();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCCategoryDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCCategoryDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCCategoryDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCategoryDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCategoryDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCCategoryDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCCategoryDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCCategoryDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCCategoryDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCCategoryDecl> dr = ObjCCategoryDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCCategoryDecl> ObjCCategoryDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCCategoryDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCCategoryDeclDerivedKinds[] = {
    ObjCCategoryDecl::static_kind(),
};

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCCategoryDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCCategoryDecl> e = ObjCCategoryDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCCategoryDecl> ObjCCategoryDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCCategoryDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCCategoryDecl> e = ObjCCategoryDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCCategoryDecl> ObjCCategoryDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCategoryDecl> ObjCCategoryDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCategoryDecl> ObjCCategoryDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_CATEGORY:
      return reinterpret_cast<const ObjCCategoryDecl &>(parent);
    default: return std::nullopt;
  }
}

bool ObjCCategoryDecl::is_class_extension(void) const {
  return impl->reader.getVal70();
}

Token ObjCCategoryDecl::category_name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

ObjCInterfaceDecl ObjCCategoryDecl::class_interface(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

ObjCCategoryImplDecl ObjCCategoryDecl::implementation(void) const {
  RawEntityId eid = impl->reader.getVal64();
  return ObjCCategoryImplDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCCategoryDecl::instance_variable_l_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal73());
}

Token ObjCCategoryDecl::instance_variable_r_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal75());
}

ObjCCategoryDecl ObjCCategoryDecl::next_class_category(void) const {
  RawEntityId eid = impl->reader.getVal76();
  return ObjCCategoryDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<ObjCIvarDecl> ObjCCategoryDecl::nth_instance_variable(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : instance_variables()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCIvarDecl> ObjCCategoryDecl::instance_variables(void) const {
  auto list = impl->reader.getVal313();
  for (auto v : list) {
    EntityId id(v);
    if (auto d313 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCIvarDecl::from(Decl(std::move(d313)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Token> ObjCCategoryDecl::nth_protocol_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocol_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ObjCCategoryDecl::protocol_tokens(void) const {
  auto list = impl->reader.getVal339();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t339 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t339;
    }
  }
  co_return;
}

std::optional<ObjCProtocolDecl> ObjCCategoryDecl::nth_protocol(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocols()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCCategoryDecl::protocols(void) const {
  auto list = impl->reader.getVal341();
  for (auto v : list) {
    EntityId id(v);
    if (auto d341 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d341)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCProtocolDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCProtocolDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCProtocolDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCProtocolDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCProtocolDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCProtocolDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCProtocolDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCProtocolDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCProtocolDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCProtocolDecl> dr = ObjCProtocolDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCProtocolDecl> ObjCProtocolDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCProtocolDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCProtocolDeclDerivedKinds[] = {
    ObjCProtocolDecl::static_kind(),
};

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCProtocolDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCProtocolDecl> e = ObjCProtocolDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCProtocolDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCProtocolDecl> e = ObjCProtocolDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCProtocolDecl> ObjCProtocolDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCProtocolDecl> ObjCProtocolDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCProtocolDecl> ObjCProtocolDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_PROTOCOL:
      return reinterpret_cast<const ObjCProtocolDecl &>(parent);
    default: return std::nullopt;
  }
}

std::string_view ObjCProtocolDecl::obj_c_runtime_name_as_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal69();
  return std::string_view(data.cStr(), data.size());
}

bool ObjCProtocolDecl::has_definition(void) const {
  return impl->reader.getVal70();
}

bool ObjCProtocolDecl::is_non_runtime_protocol(void) const {
  return impl->reader.getVal71();
}

bool ObjCProtocolDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal72();
}

std::optional<Token> ObjCProtocolDecl::nth_protocol_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocol_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ObjCProtocolDecl::protocol_tokens(void) const {
  auto list = impl->reader.getVal313();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t313 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t313;
    }
  }
  co_return;
}

std::optional<ObjCProtocolDecl> ObjCProtocolDecl::nth_protocol(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocols()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCProtocolDecl::protocols(void) const {
  auto list = impl->reader.getVal339();
  for (auto v : list) {
    EntityId id(v);
    if (auto d339 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d339)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCInterfaceDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCInterfaceDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCInterfaceDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCInterfaceDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCInterfaceDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCInterfaceDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCInterfaceDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCInterfaceDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCInterfaceDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCInterfaceDecl> dr = ObjCInterfaceDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCInterfaceDecl> ObjCInterfaceDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCInterfaceDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCInterfaceDeclDerivedKinds[] = {
    ObjCInterfaceDecl::static_kind(),
};

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCInterfaceDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCInterfaceDecl> e = ObjCInterfaceDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCInterfaceDecl> ObjCInterfaceDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCInterfaceDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCInterfaceDecl> e = ObjCInterfaceDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCInterfaceDecl> ObjCInterfaceDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCInterfaceDecl> ObjCInterfaceDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCInterfaceDecl> ObjCInterfaceDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_INTERFACE:
      return reinterpret_cast<const ObjCInterfaceDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<ObjCProtocolDecl> ObjCInterfaceDecl::nth_all_referenced_protocol(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : all_referenced_protocols()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCInterfaceDecl::all_referenced_protocols(void) const {
  auto list = impl->reader.getVal313();
  for (auto v : list) {
    EntityId id(v);
    if (auto d313 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d313)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

bool ObjCInterfaceDecl::declares_or_inherits_designated_initializers(void) const {
  return impl->reader.getVal70();
}

Token ObjCInterfaceDecl::end_of_definition_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

ObjCImplementationDecl ObjCInterfaceDecl::implementation(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return ObjCImplementationDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::string_view ObjCInterfaceDecl::obj_c_runtime_name_as_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal69();
  return std::string_view(data.cStr(), data.size());
}

std::optional<ObjCInterfaceDecl> ObjCInterfaceDecl::super_class(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal64();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return ObjCInterfaceDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token ObjCInterfaceDecl::super_class_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal73());
}

std::optional<Type> ObjCInterfaceDecl::super_class_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal75();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

Type ObjCInterfaceDecl::type_for_declaration(void) const {
  RawEntityId eid = impl->reader.getVal76();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

bool ObjCInterfaceDecl::has_definition(void) const {
  return impl->reader.getVal71();
}

bool ObjCInterfaceDecl::has_designated_initializers(void) const {
  return impl->reader.getVal72();
}

bool ObjCInterfaceDecl::is_arc_weakref_unavailable(void) const {
  return impl->reader.getVal88();
}

bool ObjCInterfaceDecl::is_implicit_interface_declaration(void) const {
  return impl->reader.getVal89();
}

ObjCInterfaceDecl ObjCInterfaceDecl::is_obj_c_requires_property_definitions(void) const {
  RawEntityId eid = impl->reader.getVal77();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

bool ObjCInterfaceDecl::is_this_declaration_a_definition(void) const {
  return impl->reader.getVal90();
}

std::optional<ObjCIvarDecl> ObjCInterfaceDecl::nth_instance_variable(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : instance_variables()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCIvarDecl> ObjCInterfaceDecl::instance_variables(void) const {
  auto list = impl->reader.getVal339();
  for (auto v : list) {
    EntityId id(v);
    if (auto d339 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCIvarDecl::from(Decl(std::move(d339)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCCategoryDecl> ObjCInterfaceDecl::nth_known_categorie(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : known_categories()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCCategoryDecl> ObjCInterfaceDecl::known_categories(void) const {
  auto list = impl->reader.getVal341();
  for (auto v : list) {
    EntityId id(v);
    if (auto d341 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCCategoryDecl::from(Decl(std::move(d341)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCCategoryDecl> ObjCInterfaceDecl::nth_known_extension(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : known_extensions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCCategoryDecl> ObjCInterfaceDecl::known_extensions(void) const {
  auto list = impl->reader.getVal342();
  for (auto v : list) {
    EntityId id(v);
    if (auto d342 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCCategoryDecl::from(Decl(std::move(d342)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<Token> ObjCInterfaceDecl::nth_protocol_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocol_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ObjCInterfaceDecl::protocol_tokens(void) const {
  auto list = impl->reader.getVal347();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t347 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t347;
    }
  }
  co_return;
}

std::optional<ObjCProtocolDecl> ObjCInterfaceDecl::nth_protocol(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : protocols()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCProtocolDecl> ObjCInterfaceDecl::protocols(void) const {
  auto list = impl->reader.getVal348();
  for (auto v : list) {
    EntityId id(v);
    if (auto d348 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCProtocolDecl::from(Decl(std::move(d348)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCCategoryDecl> ObjCInterfaceDecl::nth_visible_categorie(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : visible_categories()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCCategoryDecl> ObjCInterfaceDecl::visible_categories(void) const {
  auto list = impl->reader.getVal349();
  for (auto v : list) {
    EntityId id(v);
    if (auto d349 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCCategoryDecl::from(Decl(std::move(d349)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

std::optional<ObjCCategoryDecl> ObjCInterfaceDecl::nth_visible_extension(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : visible_extensions()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCCategoryDecl> ObjCInterfaceDecl::visible_extensions(void) const {
  auto list = impl->reader.getVal350();
  for (auto v : list) {
    EntityId id(v);
    if (auto d350 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCCategoryDecl::from(Decl(std::move(d350)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCImplDecl> ObjCImplDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCImplDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCImplDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCImplDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCImplDecl> ObjCImplDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCImplDecl> ObjCImplDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCImplDecl> ObjCImplDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCImplDecl> ObjCImplDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCImplDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCImplDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCImplDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCImplDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCImplDecl> ObjCImplDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCImplDecl> dr = ObjCImplDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCImplDecl> ObjCImplDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCImplDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCImplDeclDerivedKinds[] = {
    ObjCImplementationDecl::static_kind(),
    ObjCCategoryImplDecl::static_kind(),
};

gap::generator<ObjCImplDecl> ObjCImplDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCImplDecl> e = ObjCImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCImplDecl> ObjCImplDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCImplDecl> e = ObjCImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCImplDecl> ObjCImplDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCImplDecl> ObjCImplDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCImplDecl> ObjCImplDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_CATEGORY_IMPL:
    case mx::DeclKind::OBJ_C_IMPLEMENTATION:
      return reinterpret_cast<const ObjCImplDecl &>(parent);
    default: return std::nullopt;
  }
}

ObjCInterfaceDecl ObjCImplDecl::class_interface(void) const {
  RawEntityId eid = impl->reader.getVal62();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

std::optional<ObjCPropertyImplDecl> ObjCImplDecl::nth_property_implementation(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : property_implementations()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCPropertyImplDecl> ObjCImplDecl::property_implementations(void) const {
  auto list = impl->reader.getVal313();
  for (auto v : list) {
    EntityId id(v);
    if (auto d313 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCPropertyImplDecl::from(Decl(std::move(d313)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCCategoryImplDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCCategoryImplDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCCategoryImplDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCategoryImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCategoryImplDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCCategoryImplDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCCategoryImplDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCCategoryImplDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCCategoryImplDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCCategoryImplDecl> dr = ObjCCategoryImplDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCCategoryImplDecl> ObjCCategoryImplDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCCategoryImplDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCCategoryImplDeclDerivedKinds[] = {
    ObjCCategoryImplDecl::static_kind(),
};

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCCategoryImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCCategoryImplDecl> e = ObjCCategoryImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCCategoryImplDecl> ObjCCategoryImplDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCCategoryImplDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCCategoryImplDecl> e = ObjCCategoryImplDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCCategoryImplDecl> ObjCCategoryImplDecl::from(const ObjCImplDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCategoryImplDecl> ObjCCategoryImplDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCategoryImplDecl> ObjCCategoryImplDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCategoryImplDecl> ObjCCategoryImplDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_CATEGORY_IMPL:
      return reinterpret_cast<const ObjCCategoryImplDecl &>(parent);
    default: return std::nullopt;
  }
}

ObjCCategoryDecl ObjCCategoryImplDecl::category_declaration(void) const {
  RawEntityId eid = impl->reader.getVal63();
  return ObjCCategoryDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCCategoryImplDecl::category_name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal64());
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCImplementationDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCImplementationDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCImplementationDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCImplementationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCImplementationDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCImplementationDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCImplementationDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCImplementationDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCImplementationDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCImplementationDecl> dr = ObjCImplementationDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCImplementationDecl> ObjCImplementationDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCImplementationDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCImplementationDeclDerivedKinds[] = {
    ObjCImplementationDecl::static_kind(),
};

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCImplementationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCImplementationDecl> e = ObjCImplementationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCImplementationDecl> ObjCImplementationDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCImplementationDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCImplementationDecl> e = ObjCImplementationDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCImplementationDecl> ObjCImplementationDecl::from(const ObjCImplDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCImplementationDecl> ObjCImplementationDecl::from(const ObjCContainerDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCImplementationDecl> ObjCImplementationDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCImplementationDecl> ObjCImplementationDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_IMPLEMENTATION:
      return reinterpret_cast<const ObjCImplementationDecl &>(parent);
    default: return std::nullopt;
  }
}

Token ObjCImplementationDecl::instance_variable_l_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal63());
}

Token ObjCImplementationDecl::instance_variable_r_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal64());
}

std::string_view ObjCImplementationDecl::obj_c_runtime_name_as_string(void) const {
  capnp::Text::Reader data = impl->reader.getVal69();
  return std::string_view(data.cStr(), data.size());
}

ObjCInterfaceDecl ObjCImplementationDecl::super_class(void) const {
  RawEntityId eid = impl->reader.getVal73();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token ObjCImplementationDecl::super_class_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal75());
}

bool ObjCImplementationDecl::has_destructors(void) const {
  return impl->reader.getVal70();
}

bool ObjCImplementationDecl::has_non_zero_constructors(void) const {
  return impl->reader.getVal71();
}

std::optional<ObjCIvarDecl> ObjCImplementationDecl::nth_instance_variable(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : instance_variables()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<ObjCIvarDecl> ObjCImplementationDecl::instance_variables(void) const {
  auto list = impl->reader.getVal339();
  for (auto v : list) {
    EntityId id(v);
    if (auto d339 = impl->ep->DeclFor(impl->ep, v)) {
      if (auto e = ObjCIvarDecl::from(Decl(std::move(d339)))) {
        co_yield std::move(*e);
      }
    }
  }
  co_return;
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ObjCCompatibleAliasDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ObjCCompatibleAliasDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ObjCCompatibleAliasDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCompatibleAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ObjCCompatibleAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ObjCCompatibleAliasDecl::contains(const Decl &decl) {
  for (auto &parent : ObjCCompatibleAliasDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ObjCCompatibleAliasDecl::contains(const Stmt &stmt) {
  for (auto &parent : ObjCCompatibleAliasDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ObjCCompatibleAliasDecl> dr = ObjCCompatibleAliasDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ObjCCompatibleAliasDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kObjCCompatibleAliasDeclDerivedKinds[] = {
    ObjCCompatibleAliasDecl::static_kind(),
};

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kObjCCompatibleAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ObjCCompatibleAliasDecl> e = ObjCCompatibleAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kObjCCompatibleAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ObjCCompatibleAliasDecl> e = ObjCCompatibleAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<ObjCCompatibleAliasDecl> ObjCCompatibleAliasDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::OBJ_C_COMPATIBLE_ALIAS:
      return reinterpret_cast<const ObjCCompatibleAliasDecl &>(parent);
    default: return std::nullopt;
  }
}

ObjCInterfaceDecl ObjCCompatibleAliasDecl::class_interface(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return ObjCInterfaceDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

gap::generator<NamespaceDecl> NamespaceDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NamespaceDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NamespaceDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NamespaceDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NamespaceDecl> NamespaceDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamespaceDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamespaceDecl> NamespaceDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NamespaceDecl> NamespaceDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamespaceDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamespaceDecl> NamespaceDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NamespaceDecl::contains(const Decl &decl) {
  for (auto &parent : NamespaceDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NamespaceDecl::contains(const Stmt &stmt) {
  for (auto &parent : NamespaceDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<NamespaceDecl> NamespaceDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<NamespaceDecl> dr = NamespaceDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<NamespaceDecl> NamespaceDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return NamespaceDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kNamespaceDeclDerivedKinds[] = {
    NamespaceDecl::static_kind(),
};

gap::generator<NamespaceDecl> NamespaceDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kNamespaceDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<NamespaceDecl> e = NamespaceDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NamespaceDecl> NamespaceDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kNamespaceDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<NamespaceDecl> e = NamespaceDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NamespaceDecl> NamespaceDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<NamespaceDecl> NamespaceDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::NAMESPACE:
      return reinterpret_cast<const NamespaceDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Decl> NamespaceDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = NamespaceAliasDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool NamespaceAliasDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : NamespaceAliasDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamespaceAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = NamespaceAliasDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool NamespaceAliasDecl::contains(const Decl &decl) {
  for (auto &parent : NamespaceAliasDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool NamespaceAliasDecl::contains(const Stmt &stmt) {
  for (auto &parent : NamespaceAliasDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<NamespaceAliasDecl> dr = NamespaceAliasDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<NamespaceAliasDecl> NamespaceAliasDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return NamespaceAliasDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kNamespaceAliasDeclDerivedKinds[] = {
    NamespaceAliasDecl::static_kind(),
};

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kNamespaceAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<NamespaceAliasDecl> e = NamespaceAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<NamespaceAliasDecl> NamespaceAliasDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kNamespaceAliasDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<NamespaceAliasDecl> e = NamespaceAliasDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<NamespaceAliasDecl> NamespaceAliasDecl::from(const NamedDecl &parent) {
  return from(reinterpret_cast<const Decl &>(parent));
}

std::optional<NamespaceAliasDecl> NamespaceAliasDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::NAMESPACE_ALIAS:
      return reinterpret_cast<const NamespaceAliasDecl &>(parent);
    default: return std::nullopt;
  }
}

Token NamespaceAliasDecl::alias_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

NamedDecl NamespaceAliasDecl::aliased_namespace(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token NamespaceAliasDecl::namespace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal54());
}

Token NamespaceAliasDecl::target_name_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal62());
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LinkageSpecDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LinkageSpecDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LinkageSpecDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LinkageSpecDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LinkageSpecDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool LinkageSpecDecl::contains(const Decl &decl) {
  for (auto &parent : LinkageSpecDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool LinkageSpecDecl::contains(const Stmt &stmt) {
  for (auto &parent : LinkageSpecDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<LinkageSpecDecl> dr = LinkageSpecDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<LinkageSpecDecl> LinkageSpecDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return LinkageSpecDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kLinkageSpecDeclDerivedKinds[] = {
    LinkageSpecDecl::static_kind(),
};

gap::generator<LinkageSpecDecl> LinkageSpecDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kLinkageSpecDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<LinkageSpecDecl> e = LinkageSpecDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LinkageSpecDecl> LinkageSpecDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kLinkageSpecDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<LinkageSpecDecl> e = LinkageSpecDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LinkageSpecDecl> LinkageSpecDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::LINKAGE_SPEC:
      return reinterpret_cast<const LinkageSpecDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Decl> LinkageSpecDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = LifetimeExtendedTemporaryDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool LifetimeExtendedTemporaryDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : LifetimeExtendedTemporaryDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LifetimeExtendedTemporaryDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = LifetimeExtendedTemporaryDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool LifetimeExtendedTemporaryDecl::contains(const Decl &decl) {
  for (auto &parent : LifetimeExtendedTemporaryDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool LifetimeExtendedTemporaryDecl::contains(const Stmt &stmt) {
  for (auto &parent : LifetimeExtendedTemporaryDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<LifetimeExtendedTemporaryDecl> dr = LifetimeExtendedTemporaryDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return LifetimeExtendedTemporaryDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kLifetimeExtendedTemporaryDeclDerivedKinds[] = {
    LifetimeExtendedTemporaryDecl::static_kind(),
};

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kLifetimeExtendedTemporaryDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<LifetimeExtendedTemporaryDecl> e = LifetimeExtendedTemporaryDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kLifetimeExtendedTemporaryDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<LifetimeExtendedTemporaryDecl> e = LifetimeExtendedTemporaryDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<LifetimeExtendedTemporaryDecl> LifetimeExtendedTemporaryDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::LIFETIME_EXTENDED_TEMPORARY:
      return reinterpret_cast<const LifetimeExtendedTemporaryDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Stmt> LifetimeExtendedTemporaryDecl::children(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->StmtFor(impl->ep, v)) {
      co_yield Stmt(std::move(d47));
    }
  }
  co_return;
}

ValueDecl LifetimeExtendedTemporaryDecl::extending_declaration(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return ValueDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

StorageDuration LifetimeExtendedTemporaryDecl::storage_duration(void) const {
  return static_cast<StorageDuration>(impl->reader.getVal61());
}

Expr LifetimeExtendedTemporaryDecl::temporary_expression(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return Expr::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

gap::generator<ImportDecl> ImportDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ImportDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ImportDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ImportDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ImportDecl> ImportDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ImportDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImportDecl> ImportDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ImportDecl> ImportDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ImportDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ImportDecl> ImportDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ImportDecl::contains(const Decl &decl) {
  for (auto &parent : ImportDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ImportDecl::contains(const Stmt &stmt) {
  for (auto &parent : ImportDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ImportDecl> ImportDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ImportDecl> dr = ImportDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ImportDecl> ImportDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ImportDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kImportDeclDerivedKinds[] = {
    ImportDecl::static_kind(),
};

gap::generator<ImportDecl> ImportDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kImportDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ImportDecl> e = ImportDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ImportDecl> ImportDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kImportDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ImportDecl> e = ImportDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ImportDecl> ImportDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::IMPORT:
      return reinterpret_cast<const ImportDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<Token> ImportDecl::nth_identifier_token(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : identifier_tokens()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<Token> ImportDecl::identifier_tokens(void) const {
  auto list = impl->reader.getVal47();
  auto fragment = impl->ep->FragmentFor(impl->ep, impl->fragment_id);
  if (!fragment) {
    assert(false);
    co_return;
  }
  auto tok_reader = fragment->ParsedTokenReader(fragment);
  for (auto v : list) {
    EntityId id(v);
    if (auto t47 = fragment->ep->TokenFor(fragment->ep, tok_reader, v)) {
      co_yield t47;
    }
  }
  co_return;
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FriendTemplateDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FriendTemplateDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FriendTemplateDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FriendTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FriendTemplateDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FriendTemplateDecl::contains(const Decl &decl) {
  for (auto &parent : FriendTemplateDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FriendTemplateDecl::contains(const Stmt &stmt) {
  for (auto &parent : FriendTemplateDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FriendTemplateDecl> dr = FriendTemplateDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FriendTemplateDecl> FriendTemplateDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FriendTemplateDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFriendTemplateDeclDerivedKinds[] = {
    FriendTemplateDecl::static_kind(),
};

gap::generator<FriendTemplateDecl> FriendTemplateDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFriendTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FriendTemplateDecl> e = FriendTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FriendTemplateDecl> FriendTemplateDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFriendTemplateDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FriendTemplateDecl> e = FriendTemplateDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FriendTemplateDecl> FriendTemplateDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FRIEND_TEMPLATE:
      return reinterpret_cast<const FriendTemplateDecl &>(parent);
    default: return std::nullopt;
  }
}

NamedDecl FriendTemplateDecl::friend_declaration(void) const {
  RawEntityId eid = impl->reader.getVal45();
  return NamedDecl::from(Decl(impl->ep->DeclFor(impl->ep, eid))).value();
}

Token FriendTemplateDecl::friend_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

Type FriendTemplateDecl::friend_type(void) const {
  RawEntityId eid = impl->reader.getVal53();
  return Type(impl->ep->TypeFor(impl->ep, eid));
}

std::optional<TemplateParameterList> FriendTemplateDecl::nth_template_parameter_list(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : template_parameter_lists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateParameterList> FriendTemplateDecl::template_parameter_lists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->TemplateParameterListFor(impl->ep, v)) {
      co_yield TemplateParameterList(std::move(d47));
    }
  }
  co_return;
}

gap::generator<FriendDecl> FriendDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FriendDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FriendDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FriendDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FriendDecl> FriendDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FriendDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FriendDecl> FriendDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FriendDecl> FriendDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FriendDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FriendDecl> FriendDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FriendDecl::contains(const Decl &decl) {
  for (auto &parent : FriendDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FriendDecl::contains(const Stmt &stmt) {
  for (auto &parent : FriendDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FriendDecl> FriendDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FriendDecl> dr = FriendDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FriendDecl> FriendDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FriendDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFriendDeclDerivedKinds[] = {
    FriendDecl::static_kind(),
};

gap::generator<FriendDecl> FriendDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFriendDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FriendDecl> e = FriendDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FriendDecl> FriendDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFriendDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FriendDecl> e = FriendDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FriendDecl> FriendDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FRIEND:
      return reinterpret_cast<const FriendDecl &>(parent);
    default: return std::nullopt;
  }
}

std::optional<NamedDecl> FriendDecl::friend_declaration(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal45();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->DeclFor(impl->ep, eid)) {
      return NamedDecl::from(Decl(std::move(eptr)));
    }
  }
  return std::nullopt;
}

Token FriendDecl::friend_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

std::optional<Type> FriendDecl::friend_type(void) const {
  if (true) {
    RawEntityId eid = impl->reader.getVal53();
    if (eid == kInvalidEntityId) {
      return std::nullopt;
    }
    if (auto eptr = impl->ep->TypeFor(impl->ep, eid)) {
      return Type(std::move(eptr));
    }
  }
  return std::nullopt;
}

bool FriendDecl::is_unsupported_friend(void) const {
  return impl->reader.getVal46();
}

std::optional<TemplateParameterList> FriendDecl::nth_friend_type_template_parameter_list(unsigned n) const {
  unsigned i = 0u;
  for (auto ent : friend_type_template_parameter_lists()) {
    if (i++ == n) {
      return ent;
    }
  }
  return std::nullopt;
}

gap::generator<TemplateParameterList> FriendDecl::friend_type_template_parameter_lists(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    EntityId id(v);
    if (auto d47 = impl->ep->TemplateParameterListFor(impl->ep, v)) {
      co_yield TemplateParameterList(std::move(d47));
    }
  }
  co_return;
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = FileScopeAsmDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool FileScopeAsmDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : FileScopeAsmDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FileScopeAsmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = FileScopeAsmDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool FileScopeAsmDecl::contains(const Decl &decl) {
  for (auto &parent : FileScopeAsmDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool FileScopeAsmDecl::contains(const Stmt &stmt) {
  for (auto &parent : FileScopeAsmDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<FileScopeAsmDecl> dr = FileScopeAsmDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<FileScopeAsmDecl> FileScopeAsmDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return FileScopeAsmDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kFileScopeAsmDeclDerivedKinds[] = {
    FileScopeAsmDecl::static_kind(),
};

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kFileScopeAsmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<FileScopeAsmDecl> e = FileScopeAsmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<FileScopeAsmDecl> FileScopeAsmDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kFileScopeAsmDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<FileScopeAsmDecl> e = FileScopeAsmDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<FileScopeAsmDecl> FileScopeAsmDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::FILE_SCOPE_ASM:
      return reinterpret_cast<const FileScopeAsmDecl &>(parent);
    default: return std::nullopt;
  }
}

Token FileScopeAsmDecl::assembly_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

StringLiteral FileScopeAsmDecl::assembly_string(void) const {
  RawEntityId eid = impl->reader.getVal52();
  return StringLiteral::from(Stmt(impl->ep->StmtFor(impl->ep, eid))).value();
}

Token FileScopeAsmDecl::r_paren_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal53());
}

gap::generator<ExternCContextDecl> ExternCContextDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExternCContextDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExternCContextDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExternCContextDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExternCContextDecl> ExternCContextDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ExternCContextDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExternCContextDecl> ExternCContextDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExternCContextDecl> ExternCContextDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ExternCContextDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExternCContextDecl> ExternCContextDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExternCContextDecl::contains(const Decl &decl) {
  for (auto &parent : ExternCContextDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExternCContextDecl::contains(const Stmt &stmt) {
  for (auto &parent : ExternCContextDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ExternCContextDecl> ExternCContextDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ExternCContextDecl> dr = ExternCContextDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ExternCContextDecl> ExternCContextDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ExternCContextDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kExternCContextDeclDerivedKinds[] = {
    ExternCContextDecl::static_kind(),
};

gap::generator<ExternCContextDecl> ExternCContextDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kExternCContextDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ExternCContextDecl> e = ExternCContextDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExternCContextDecl> ExternCContextDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kExternCContextDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ExternCContextDecl> e = ExternCContextDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExternCContextDecl> ExternCContextDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::EXTERN_C_CONTEXT:
      return reinterpret_cast<const ExternCContextDecl &>(parent);
    default: return std::nullopt;
  }
}

gap::generator<Decl> ExternCContextDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<ExportDecl> ExportDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = ExportDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool ExportDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : ExportDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<ExportDecl> ExportDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ExportDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExportDecl> ExportDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<ExportDecl> ExportDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = ExportDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<ExportDecl> ExportDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool ExportDecl::contains(const Decl &decl) {
  for (auto &parent : ExportDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool ExportDecl::contains(const Stmt &stmt) {
  for (auto &parent : ExportDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<ExportDecl> ExportDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<ExportDecl> dr = ExportDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<ExportDecl> ExportDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return ExportDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kExportDeclDerivedKinds[] = {
    ExportDecl::static_kind(),
};

gap::generator<ExportDecl> ExportDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kExportDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<ExportDecl> e = ExportDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<ExportDecl> ExportDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kExportDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<ExportDecl> e = ExportDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<ExportDecl> ExportDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::EXPORT:
      return reinterpret_cast<const ExportDecl &>(parent);
    default: return std::nullopt;
  }
}

Token ExportDecl::export_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal45());
}

Token ExportDecl::r_brace_token(void) const {
  return impl->ep->TokenFor(impl->ep, impl->reader.getVal52());
}

bool ExportDecl::has_braces(void) const {
  return impl->reader.getVal46();
}

gap::generator<Decl> ExportDecl::declarations_in_context(void) const {
  auto list = impl->reader.getVal47();
  for (auto v : list) {
    if (auto eptr = impl->ep->DeclFor(impl->ep, v)) {
      co_yield std::move(eptr);
    }
  }
}

gap::generator<EmptyDecl> EmptyDecl::containing(const Token &tok) {
  for (auto ctx = tok.context(); ctx.has_value(); ctx = ctx->parent()) {
    if (auto d = EmptyDecl::from(*ctx)) {
      co_yield *d;
    }
  }
}

bool EmptyDecl::contains(const Token &tok) const {
  auto id_ = id();
  for (auto &parent : EmptyDecl::containing(tok)) {
    if (parent.id() == id_) { return true; }
  }
  return false;
}

gap::generator<EmptyDecl> EmptyDecl::containing(const Decl &decl) {
  for (auto ancestor = decl.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EmptyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EmptyDecl> EmptyDecl::containing(const std::optional<Decl> &decl) {
  if (decl.has_value()) {
    for (auto res : containing(decl.value())) {
      co_yield res;
    }
  }
}

gap::generator<EmptyDecl> EmptyDecl::containing(const Stmt &stmt) {
  for (auto ancestor = stmt.parent_declaration(); ancestor.has_value(); ancestor = ancestor->parent_declaration()) {
    if (auto d = EmptyDecl::from(*ancestor)) {
      co_yield *d;
    }
  }
}

gap::generator<EmptyDecl> EmptyDecl::containing(const std::optional<Stmt> &stmt) {
  if (stmt.has_value()) {
    for (auto res : containing(stmt.value())) {
      co_yield res;
    }
  }
}

bool EmptyDecl::contains(const Decl &decl) {
  for (auto &parent : EmptyDecl::containing(decl)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

bool EmptyDecl::contains(const Stmt &stmt) {
  for (auto &parent : EmptyDecl::containing(stmt)) {
    auto eq = parent <=> *this;
    if (eq == 0) { return true; }
  }
  return false;
}

gap::generator<EmptyDecl> EmptyDecl::redeclarations(void) const {
  for (Decl r : Decl::redeclarations()) {
    if (std::optional<EmptyDecl> dr = EmptyDecl::from(r)) {
      co_yield std::move(dr.value());
      continue;
    }
    assert(false);
  // Wrong type?
  }
  co_return;
}

std::optional<EmptyDecl> EmptyDecl::by_id(const Index &index, EntityId eid) {
  VariantId vid = eid.Unpack();
  if (std::holds_alternative<DeclId>(vid)) {
    return EmptyDecl::from(index.declaration(eid.Pack()));
  } else if (std::holds_alternative<InvalidId>(vid)) {
    assert(eid.Pack() == kInvalidEntityId);
  }
  return std::nullopt;
}

static const DeclKind kEmptyDeclDerivedKinds[] = {
    EmptyDecl::static_kind(),
};

gap::generator<EmptyDecl> EmptyDecl::in(const Index &index) {
  const EntityProvider::Ptr &ep = entity_provider_of(index);
  for (DeclKind k : kEmptyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k)) {
      if (std::optional<EmptyDecl> e = EmptyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

gap::generator<EmptyDecl> EmptyDecl::in(const Fragment &frag) {
  const EntityProvider::Ptr &ep = entity_provider_of(frag);
  PackedFragmentId frag_id = frag.id();
  for (DeclKind k : kEmptyDeclDerivedKinds) {
    for (DeclImplPtr eptr : ep->DeclsFor(ep, k, frag_id)) {
      if (std::optional<EmptyDecl> e = EmptyDecl::from(Decl(std::move(eptr)))) {
        co_yield std::move(e.value());
      }
    }
  }
}

std::optional<EmptyDecl> EmptyDecl::from(const Decl &parent) {
  switch (parent.kind()) {
    case mx::DeclKind::EMPTY:
      return reinterpret_cast<const EmptyDecl &>(parent);
    default: return std::nullopt;
  }
}

#pragma GCC diagnostic pop
#endif
}  // namespace mx
