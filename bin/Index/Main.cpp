// Copyright (c) 2022-present, Trail of Bits, Inc.
// All rights reserved.
//
// This source code is licensed in accordance with the terms specified in
// the LICENSE file found in the root directory of this source tree.

#include <cstdlib>
#include <filesystem>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <iostream>
#include <memory>
#include <multiplier/Result.h>
#include <multiplier/SQLiteStore.h>
#include <pasta/Util/Init.h>
#include <sstream>
#include <system_error>
#include <llvm/IR/LLVMContext.h>
#include <llvm/Support/Host.h>
#include <llvm/Support/InitLLVM.h>
#include <llvm/Support/JSON.h>
#include <llvm/Support/MemoryBuffer.h>

#include "Context.h"
#include "Parser.h"
#include "Importer.h"

// Should we show a help message?
DECLARE_bool(help);

// Number of threads to use in the executors. These are mostly used for indexing
// jobs.
DEFINE_int32(num_workers, -1, "Number of worker threads to use for parallel jobs");

// Should we show progress bars when indexing?
DEFINE_bool(show_progress, false, "Show indexing progress bars");

// Directory where stuff SQLite database is stored.
DEFINE_string(db, "mx-index.db",
              "Path to the database file into which semi-permanent indexer data "
              "should be stored. Defaults mx-index.db in the current working directory.");

DEFINE_string(target, "", "Path to the binary or JSON (compile commands) file to import");

DEFINE_string(env_path, "", "Path to the file listing environment variables to import");

DEFINE_bool(generate_sourceir, false, "Generate SourceIR from the top-level declarations");

namespace {

std::unique_ptr<llvm::MemoryBuffer>
ReadFileBuffer(const std::string file_name) {
  if (!file_name.empty()) {
    auto maybe_envp = llvm::MemoryBuffer::getFileOrSTDIN(file_name, -1, false);
    if (maybe_envp) {
      return std::move(*maybe_envp);
    }
  }
  return nullptr;
}

indexer::EnvVariableMap
ParseEnvVariablesFromFile(const std::string file_name) {
  const static std::string sep = "=";
  std::unordered_map<std::string, std::string> envp;

  // Check if the file buffer is valid
  if (auto envp_buffer = ReadFileBuffer(file_name); envp_buffer) {
    auto ss = std::stringstream{envp_buffer->getBuffer().str()};
    for (std::string line; std::getline(ss, line, '\n');) {
      if (auto loc = line.find(sep); loc != std::string::npos) {
        std::string name = line.substr(0, loc);
        // Fix PWD & CWD env variable and set it to current path
        if (name == "PWD" || name == "CWD") {
          envp[name] = std::filesystem::current_path();
        } else {
          envp[name] = line.substr(loc + 1, line.size());
        }
      }
    }
  }
  return envp;
}

}

extern "C" int main(int argc, char *argv[]) {
  pasta::InitPasta init_pasta;

  std::stringstream ss;
  ss << "Usage: " << argv[0]
     << " [--num_workers N] [--db DATABASE] [--target COMPILE_COMMANDS]\n";

  google::SetUsageMessage(ss.str());
  google::ParseCommandLineFlags(&argc, &argv, false);
  google::InitGoogleLogging(argv[0]);

  if (FLAGS_help) {
    std::cerr << google::ProgramUsage() << std::endl;
    return EXIT_FAILURE;
  }

  if (FLAGS_db.empty()) {
    std::cerr
        << "Database path cannot be empty; specify it with --db";
    return EXIT_FAILURE;
  }

  if (FLAGS_target.empty()) {
    std::cerr
        << "Must specify a path to a target file to import with --target. "
           "Use - or /dev/stdin to read from stdin.";
    return EXIT_FAILURE;
  }

  sqlite::Connection conn(FLAGS_db);
  // Generated by rolling a 4,294,967,296-sided die. Guaranteed to be random.
  conn.Execute("PRAGMA application_id = 0xce9ccea7");

  mx::Executor executor{{FLAGS_num_workers}};
  auto ic = std::make_shared<indexer::IndexingContext>(FLAGS_db, executor);
  auto fs = pasta::FileSystem::CreateNative();
  pasta::FileManager fm(fs);

  if(FLAGS_show_progress) {
    ic->InitializeProgressBars();
  }

  if(!FLAGS_generate_sourceir) {
    ic->codegen.Disable();
  }

  std::filesystem::path path(FLAGS_target);

  if (FLAGS_target == "/dev/stdin") {
    FLAGS_target = "-";
  
  } else if (FLAGS_target == "-") {
    path = "/dev/stdin";
  }

  auto maybe_buff = llvm::MemoryBuffer::getFileOrSTDIN(FLAGS_target, -1, false);
  if (!maybe_buff) {
    std::cerr
        << "Unable to open file " << FLAGS_target << ":"
        << maybe_buff.getError().message();
    return EXIT_FAILURE;
  }

  auto envp = ParseEnvVariablesFromFile(FLAGS_env_path);

  llvm::LLVMContext context;
  indexer::Importer importer(path.parent_path(), fm, ic);
  indexer::Parser parser(context, importer);
  if (!parser.Parse(*maybe_buff.get(), envp)) {
    std::cerr
          << "An error occurred when trying to import " << FLAGS_target;
    return EXIT_FAILURE;
  }

  importer.Import(executor);

  executor.Start();
  executor.Wait();

  return EXIT_SUCCESS;
}
