#
# Copyright (c) 2023-present, Trail of Bits, Inc.
# All rights reserved.
#
# This source code is licensed in accordance with the terms specified in
# the LICENSE file found in the root directory of this source tree.
#

# Auto-generated file; do not modify!

from abc import ABC
from enum import IntEnum
from typing import Generator, Iterable, Mapping, Optional, overload, Sequence, Tuple
import pathlib
import multiplier
import multiplier.ir
import multiplier.ast
import multiplier.ir.abi
import multiplier.ir.llvm
import multiplier.ir.core
import multiplier.ir.meta
import multiplier.frontend
import multiplier.ir.memref
import multiplier.ir.builtin
import multiplier.ir.lowlevel
import multiplier.ir.highlevel
import multiplier.ir.unsupported

class DeclKind(IntEnum):
  ACCESS_SPEC = 0
  BINDING = 1
  BLOCK = 2
  BUILTIN_TEMPLATE = 3
  CXX_CONSTRUCTOR = 4
  CXX_CONVERSION = 5
  CXX_DEDUCTION_GUIDE = 6
  CXX_DESTRUCTOR = 7
  CXX_METHOD = 8
  CXX_RECORD = 9
  CAPTURED = 10
  CLASS_TEMPLATE = 11
  CLASS_TEMPLATE_PARTIAL_SPECIALIZATION = 12
  CLASS_TEMPLATE_SPECIALIZATION = 13
  CONCEPT = 14
  CONSTRUCTOR_USING_SHADOW = 15
  DECOMPOSITION = 16
  EMPTY = 17
  ENUM_CONSTANT = 18
  ENUM = 19
  EXPORT = 20
  EXTERN_C_CONTEXT = 21
  FIELD = 22
  FILE_SCOPE_ASM = 23
  FRIEND = 24
  FRIEND_TEMPLATE = 25
  FUNCTION = 26
  FUNCTION_TEMPLATE = 27
  HLSL_BUFFER = 28
  IMPLICIT_CONCEPT_SPECIALIZATION = 29
  IMPLICIT_PARAM = 30
  IMPORT = 31
  INDIRECT_FIELD = 32
  LABEL = 33
  LIFETIME_EXTENDED_TEMPORARY = 34
  LINKAGE_SPEC = 35
  MS_GUID = 36
  MS_PROPERTY = 37
  NAMESPACE_ALIAS = 38
  NAMESPACE = 39
  NON_TYPE_TEMPLATE_PARM = 40
  OMP_ALLOCATE = 41
  OMP_CAPTURED_EXPR = 42
  OMP_DECLARE_MAPPER = 43
  OMP_DECLARE_REDUCTION = 44
  OMP_REQUIRES = 45
  OMP_THREAD_PRIVATE = 46
  OBJ_C_AT_DEFS_FIELD = 47
  OBJ_C_CATEGORY = 48
  OBJ_C_CATEGORY_IMPL = 49
  OBJ_C_COMPATIBLE_ALIAS = 50
  OBJ_C_IMPLEMENTATION = 51
  OBJ_C_INTERFACE = 52
  OBJ_C_IVAR = 53
  OBJ_C_METHOD = 54
  OBJ_C_PROPERTY = 55
  OBJ_C_PROPERTY_IMPL = 56
  OBJ_C_PROTOCOL = 57
  OBJ_C_TYPE_PARAM = 58
  PARM_VAR = 59
  PRAGMA_COMMENT = 60
  PRAGMA_DETECT_MISMATCH = 61
  RECORD = 62
  REQUIRES_EXPR_BODY = 63
  STATIC_ASSERT = 64
  TEMPLATE_PARAM_OBJECT = 65
  TEMPLATE_TEMPLATE_PARM = 66
  TEMPLATE_TYPE_PARM = 67
  TOP_LEVEL_STMT = 68
  TRANSLATION_UNIT = 69
  TYPE_ALIAS = 70
  TYPE_ALIAS_TEMPLATE = 71
  TYPEDEF = 72
  UNNAMED_GLOBAL_CONSTANT = 73
  UNRESOLVED_USING_IF_EXISTS = 74
  UNRESOLVED_USING_TYPENAME = 75
  UNRESOLVED_USING_VALUE = 76
  USING = 77
  USING_DIRECTIVE = 78
  USING_ENUM = 79
  USING_PACK = 80
  USING_SHADOW = 81
  VAR = 82
  VAR_TEMPLATE = 83
  VAR_TEMPLATE_PARTIAL_SPECIALIZATION = 84
  VAR_TEMPLATE_SPECIALIZATION = 85

class AttrKind(IntEnum):
  A_ARCH64_SVE_PCS = 0
  A_ARCH64_VECTOR_PCS = 1
  AMDGPU_FLAT_WORK_GROUP_SIZE = 2
  AMDGPU_KERNEL_CALL = 3
  AMDGPU_NUM_SGPR = 4
  AMDGPU_NUM_VGPR = 5
  AMDGPU_WAVES_PER_EU = 6
  ARM_INTERRUPT = 7
  AVR_INTERRUPT = 8
  AVR_SIGNAL = 9
  ABI_TAG = 10
  ACQUIRE_CAPABILITY = 11
  ACQUIRE_HANDLE = 12
  ACQUIRED_AFTER = 13
  ACQUIRED_BEFORE = 14
  ADDRESS_SPACE = 15
  ALIAS = 16
  ALIGN_MAC68K = 17
  ALIGN_NATURAL = 18
  ALIGN_VALUE = 19
  ALIGNED = 20
  ALLOC_ALIGN = 21
  ALLOC_SIZE = 22
  ALWAYS_DESTROY = 23
  ALWAYS_INLINE = 24
  ANALYZER_NO_RETURN = 25
  ANNOTATE = 26
  ANNOTATE_TYPE = 27
  ANY_X86_INTERRUPT = 28
  ANY_X86_NO_CALLER_SAVED_REGISTERS = 29
  ANY_X86_NO_CF_CHECK = 30
  ARC_WEAKREF_UNAVAILABLE = 31
  ARGUMENT_WITH_TYPE_TAG = 32
  ARM_BUILTIN_ALIAS = 33
  ARM_IN = 34
  ARM_IN_OUT = 35
  ARM_LOCALLY_STREAMING = 36
  ARM_MVE_STRICT_POLYMORPHISM = 37
  ARM_NEW = 38
  ARM_OUT = 39
  ARM_PRESERVES = 40
  ARM_STREAMING = 41
  ARM_STREAMING_COMPATIBLE = 42
  ARTIFICIAL = 43
  ASM_LABEL = 44
  ASSERT_CAPABILITY = 45
  ASSERT_EXCLUSIVE_LOCK = 46
  ASSERT_SHARED_LOCK = 47
  ASSUME_ALIGNED = 48
  ASSUMPTION = 49
  AVAILABILITY = 50
  AVAILABLE_ONLY_IN_DEFAULT_EVAL_METHOD = 51
  BPF_PRESERVE_ACCESS_INDEX = 52
  BPF_PRESERVE_STATIC_OFFSET = 53
  BTF_DECL_TAG = 54
  BTF_TYPE_TAG = 55
  BLOCKS = 56
  BUILTIN_ALIAS = 57
  BUILTIN = 58
  C11_NO_RETURN = 59
  C_DECL = 60
  CF_AUDITED_TRANSFER = 61
  CF_CONSUMED = 62
  CF_GUARD = 63
  CFI_CANONICAL_JUMP_TABLE = 64
  CF_RETURNS_NOT_RETAINED = 65
  CF_RETURNS_RETAINED = 66
  CF_UNKNOWN_TRANSFER = 67
  CPU_DISPATCH = 68
  CPU_SPECIFIC = 69
  CUDA_CONSTANT = 70
  CUDA_DEVICE = 71
  CUDA_DEVICE_BUILTIN_SURFACE_TYPE = 72
  CUDA_DEVICE_BUILTIN_TEXTURE_TYPE = 73
  CUDA_GLOBAL = 74
  CUDA_HOST = 75
  CUDA_INVALID_TARGET = 76
  CUDA_LAUNCH_BOUNDS = 77
  CUDA_SHARED = 78
  CXX11_NO_RETURN = 79
  CALLABLE_WHEN = 80
  CALLBACK = 81
  CALLED_ONCE = 82
  CAPABILITY = 83
  CAPTURED_RECORD = 84
  CARRIES_DEPENDENCY = 85
  CLEANUP = 86
  CMSE_NS_CALL = 87
  CMSE_NS_ENTRY = 88
  CODE_ALIGN = 89
  CODE_MODEL = 90
  CODE_SEG = 91
  COLD = 92
  COMMON = 93
  CONST = 94
  CONST_INIT = 95
  CONSTRUCTOR = 96
  CONSUMABLE = 97
  CONSUMABLE_AUTO_CAST = 98
  CONSUMABLE_SET_ON_READ = 99
  CONVERGENT = 100
  CORO_DISABLE_LIFETIME_BOUND = 101
  CORO_LIFETIME_BOUND = 102
  CORO_ONLY_DESTROY_WHEN_COMPLETE = 103
  CORO_RETURN_TYPE = 104
  CORO_WRAPPER = 105
  COUNTED_BY = 106
  DLL_EXPORT = 107
  DLL_EXPORT_STATIC_LOCAL = 108
  DLL_IMPORT = 109
  DLL_IMPORT_STATIC_LOCAL = 110
  DEPRECATED = 111
  DESTRUCTOR = 112
  DIAGNOSE_AS_BUILTIN = 113
  DIAGNOSE_IF = 114
  DISABLE_SANITIZER_INSTRUMENTATION = 115
  DISABLE_TAIL_CALLS = 116
  EMPTY_BASES = 117
  ENABLE_IF = 118
  ENFORCE_TCB = 119
  ENFORCE_TCB_LEAF = 120
  ENUM_EXTENSIBILITY = 121
  ERROR = 122
  EXCLUDE_FROM_EXPLICIT_INSTANTIATION = 123
  EXCLUSIVE_TRYLOCK_FUNCTION = 124
  EXTERNAL_SOURCE_SYMBOL = 125
  FALL_THROUGH = 126
  FAST_CALL = 127
  FINAL = 128
  FLAG_ENUM = 129
  FLATTEN = 130
  FORMAT_ARG = 131
  FORMAT = 132
  FUNCTION_RETURN_THUNKS = 133
  GNU_INLINE = 134
  GUARDED_BY = 135
  GUARDED_VAR = 136
  HIP_MANAGED = 137
  HLSL_GROUP_SHARED_ADDRESS_SPACE = 138
  HLSL_NUM_THREADS = 139
  HLSL_PARAM_MODIFIER = 140
  HLSL_RESOURCE = 141
  HLSL_RESOURCE_BINDING = 142
  HLSLSV__DISPATCH_THREAD_ID = 143
  HLSLSV__GROUP_INDEX = 144
  HLSL_SHADER = 145
  HOT = 146
  IB_ACTION = 147
  IB_OUTLET = 148
  IB_OUTLET_COLLECTION = 149
  I_FUNC = 150
  INIT_PRIORITY = 151
  INIT_SEG = 152
  INTEL_OCL_BICC = 153
  INTERNAL_LINKAGE = 154
  LTO_VISIBILITY_PUBLIC = 155
  LAYOUT_VERSION = 156
  LEAF = 157
  LIFETIME_BOUND = 158
  LIKELY = 159
  LOADER_UNINITIALIZED = 160
  LOCK_RETURNED = 161
  LOCKS_EXCLUDED = 162
  LOOP_HINT = 163
  M68K_INTERRUPT = 164
  M68K_RTD = 165
  MIG_SERVER_ROUTINE_ = 166
  MSABI = 167
  MS_ALLOCATOR = 168
  MS_CONSTEXPR = 169
  MS_INHERITANCE = 170
  MS_NO_V_TABLE = 171
  MSP430_INTERRUPT = 172
  MS_STRUCT = 173
  MS_VTOR_DISP = 174
  MAX_FIELD_ALIGNMENT = 175
  MAY_ALIAS = 176
  MAYBE_UNDEF = 177
  MICRO_MIPS = 178
  MIN_SIZE = 179
  MIN_VECTOR_WIDTH = 180
  MIPS16 = 181
  MIPS_INTERRUPT = 182
  MIPS_LONG_CALL = 183
  MIPS_SHORT_CALL = 184
  MODE = 185
  MUST_TAIL = 186
  NS_CONSUMED = 187
  NS_CONSUMES_SELF = 188
  NS_ERROR_DOMAIN = 189
  NS_RETURNS_AUTORELEASED = 190
  NS_RETURNS_NOT_RETAINED = 191
  NS_RETURNS_RETAINED = 192
  NVPTX_KERNEL = 193
  NAKED = 194
  NO_ALIAS = 195
  NO_BUILTIN = 196
  NO_COMMON = 197
  NO_DEBUG = 198
  NO_DEREF = 199
  NO_DESTROY = 200
  NO_DUPLICATE = 201
  NO_ESCAPE = 202
  NO_INLINE = 203
  NO_INSTRUMENT_FUNCTION = 204
  NO_MERGE = 205
  NO_MICRO_MIPS = 206
  NO_MIPS16 = 207
  NO_PROFILE_FUNCTION = 208
  NO_RANDOMIZE_LAYOUT = 209
  NO_RETURN = 210
  NO_SANITIZE = 211
  NO_SPECULATIVE_LOAD_HARDENING = 212
  NO_SPLIT_STACK = 213
  NO_STACK_PROTECTOR = 214
  NO_THREAD_SAFETY_ANALYSIS = 215
  NO_THROW = 216
  NO_UNIQUE_ADDRESS = 217
  NO_UWTABLE = 218
  NON_NULL = 219
  NOT_TAIL_CALLED = 220
  OMP_ALLOCATE_DECL = 221
  OMP_CAPTURE_KIND = 222
  OMP_CAPTURE_NO_INIT = 223
  OMP_DECLARE_SIMD_DECL = 224
  OMP_DECLARE_TARGET_DECL = 225
  OMP_DECLARE_VARIANT = 226
  OMP_REFERENCED_VAR = 227
  OMP_THREAD_PRIVATE_DECL = 228
  OS_CONSUMED = 229
  OS_CONSUMES_THIS = 230
  OS_RETURNS_NOT_RETAINED = 231
  OS_RETURNS_RETAINED = 232
  OS_RETURNS_RETAINED_ON_NON_ZERO = 233
  OS_RETURNS_RETAINED_ON_ZERO = 234
  OBJ_C_BOXABLE = 235
  OBJ_C_BRIDGE = 236
  OBJ_C_BRIDGE_MUTABLE = 237
  OBJ_C_BRIDGE_RELATED = 238
  OBJ_C_CLASS_STUB = 239
  OBJ_C_DESIGNATED_INITIALIZER = 240
  OBJ_C_DIRECT = 241
  OBJ_C_DIRECT_MEMBERS = 242
  OBJ_C_EXCEPTION = 243
  OBJ_C_EXPLICIT_PROTOCOL_IMPL = 244
  OBJ_C_EXTERNALLY_RETAINED = 245
  OBJ_CGC = 246
  OBJ_C_INDEPENDENT_CLASS = 247
  OBJ_C_INERT_UNSAFE_UNRETAINED = 248
  OBJ_C_KIND_OF = 249
  OBJ_C_METHOD_FAMILY = 250
  OBJ_CNS_OBJECT = 251
  OBJ_C_NON_LAZY_CLASS = 252
  OBJ_C_NON_RUNTIME_PROTOCOL = 253
  OBJ_C_OWNERSHIP = 254
  OBJ_C_PRECISE_LIFETIME = 255
  OBJ_C_REQUIRES_PROPERTY_DEFS = 256
  OBJ_C_REQUIRES_SUPER = 257
  OBJ_C_RETURNS_INNER_POINTER = 258
  OBJ_C_ROOT_CLASS = 259
  OBJ_C_RUNTIME_NAME = 260
  OBJ_C_RUNTIME_VISIBLE = 261
  OBJ_C_SUBCLASSING_RESTRICTED = 262
  OPEN_CL_ACCESS = 263
  OPEN_CL_CONSTANT_ADDRESS_SPACE = 264
  OPEN_CL_GENERIC_ADDRESS_SPACE = 265
  OPEN_CL_GLOBAL_ADDRESS_SPACE = 266
  OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE = 267
  OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE = 268
  OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE = 269
  OPEN_CL_KERNEL = 270
  OPEN_CL_LOCAL_ADDRESS_SPACE = 271
  OPEN_CL_PRIVATE_ADDRESS_SPACE = 272
  OPEN_CL_UNROLL_HINT = 273
  OPTIMIZE_NONE = 274
  OVERLOADABLE = 275
  OVERRIDE = 276
  OWNER = 277
  OWNERSHIP = 278
  PACKED = 279
  PARAM_TYPESTATE = 280
  PASCAL = 281
  PASS_OBJECT_SIZE = 282
  PATCHABLE_FUNCTION_ENTRY = 283
  PCS = 284
  POINTER = 285
  PRAGMA_CLANG_BSS_SECTION = 286
  PRAGMA_CLANG_DATA_SECTION = 287
  PRAGMA_CLANG_RELRO_SECTION = 288
  PRAGMA_CLANG_RODATA_SECTION = 289
  PRAGMA_CLANG_TEXT_SECTION = 290
  PREFERRED_NAME = 291
  PREFERRED_TYPE = 292
  PRESERVE_ALL = 293
  PRESERVE_MOST = 294
  PT_GUARDED_BY = 295
  PT_GUARDED_VAR = 296
  PTR32 = 297
  PTR64 = 298
  PURE = 299
  RISCV_INTERRUPT = 300
  RANDOMIZE_LAYOUT = 301
  READ_ONLY_PLACEMENT = 302
  REG_CALL = 303
  REINITIALIZES = 304
  RELEASE_CAPABILITY = 305
  RELEASE_HANDLE = 306
  RENDER_SCRIPT_KERNEL = 307
  REQD_WORK_GROUP_SIZE = 308
  REQUIRES_CAPABILITY = 309
  RESTRICT = 310
  RETAIN = 311
  RETURN_TYPESTATE = 312
  RETURNS_NON_NULL = 313
  RETURNS_TWICE = 314
  S_PTR = 315
  SYCL_KERNEL = 316
  SYCL_SPECIAL_CLASS = 317
  SCOPED_LOCKABLE = 318
  SECTION = 319
  SELECT_ANY = 320
  SENTINEL = 321
  SET_TYPESTATE = 322
  SHARED_TRYLOCK_FUNCTION = 323
  SPECULATIVE_LOAD_HARDENING = 324
  STANDALONE_DEBUG = 325
  STD_CALL = 326
  STRICT_FP = 327
  STRICT_GUARD_STACK_CHECK = 328
  SUPPRESS = 329
  SWIFT_ASYNC = 330
  SWIFT_ASYNC_CALL = 331
  SWIFT_ASYNC_CONTEXT = 332
  SWIFT_ASYNC_ERROR = 333
  SWIFT_ASYNC_NAME = 334
  SWIFT_ATTR = 335
  SWIFT_BRIDGE = 336
  SWIFT_BRIDGED_TYPEDEF = 337
  SWIFT_CALL = 338
  SWIFT_CONTEXT = 339
  SWIFT_ERROR = 340
  SWIFT_ERROR_RESULT = 341
  SWIFT_IMPORT_AS_NON_GENERIC = 342
  SWIFT_IMPORT_PROPERTY_AS_ACCESSORS = 343
  SWIFT_INDIRECT_RESULT = 344
  SWIFT_NAME = 345
  SWIFT_NEW_TYPE = 346
  SWIFT_OBJ_C_MEMBERS = 347
  SWIFT_PRIVATE = 348
  SWIFT_VERSIONED_ADDITION = 349
  SWIFT_VERSIONED_REMOVAL = 350
  SYS_VABI = 351
  TLS_MODEL = 352
  TARGET = 353
  TARGET_CLONES = 354
  TARGET_VERSION = 355
  TEST_TYPESTATE = 356
  THIS_CALL = 357
  THREAD = 358
  TRANSPARENT_UNION = 359
  TRIVIAL_ABI = 360
  TRY_ACQUIRE_CAPABILITY = 361
  TYPE_NON_NULL = 362
  TYPE_NULL_UNSPECIFIED = 363
  TYPE_NULLABLE = 364
  TYPE_NULLABLE_RESULT = 365
  TYPE_TAG_FOR_DATATYPE = 366
  TYPE_VISIBILITY = 367
  U_PTR = 368
  UNAVAILABLE = 369
  UNINITIALIZED = 370
  UNLIKELY = 371
  UNSAFE_BUFFER_USAGE = 372
  UNUSED = 373
  USE_HANDLE = 374
  USED = 375
  USING_IF_EXISTS = 376
  UUID = 377
  VEC_RETURN = 378
  VEC_TYPE_HINT = 379
  VECTOR_CALL = 380
  VISIBILITY = 381
  WARN_UNUSED = 382
  WARN_UNUSED_RESULT = 383
  WEAK = 384
  WEAK_IMPORT = 385
  WEAK_REF = 386
  WEB_ASSEMBLY_EXPORT_NAME = 387
  WEB_ASSEMBLY_FUNCREF = 388
  WEB_ASSEMBLY_IMPORT_MODULE = 389
  WEB_ASSEMBLY_IMPORT_NAME = 390
  WORK_GROUP_SIZE_HINT = 391
  X86_FORCE_ALIGN_ARG_POINTER = 392
  X_RAY_INSTRUMENT = 393
  X_RAY_LOG_ARGS = 394
  ZERO_CALL_USED_REGS = 395

class AArch64SVEPcsAttrSpelling(IntEnum):
  GNU_AARCH64_SVE_PCS = 0
  CXX11_CLANG_AARCH64_SVE_PCS = 1
  C23_CLANG_AARCH64_SVE_PCS = 2
  SPELLING_NOT_CALCULATED = 3

class AArch64VectorPcsAttrSpelling(IntEnum):
  GNU_AARCH64_VECTOR_PCS = 0
  CXX11_CLANG_AARCH64_VECTOR_PCS = 1
  C23_CLANG_AARCH64_VECTOR_PCS = 2
  SPELLING_NOT_CALCULATED = 3

class AMDGPUFlatWorkGroupSizeAttrSpelling(IntEnum):
  GNU_AMDGPU_FLAT_WORK_GROUP_SIZE = 0
  CXX11_CLANG_AMDGPU_FLAT_WORK_GROUP_SIZE = 1
  SPELLING_NOT_CALCULATED = 2

class AMDGPUKernelCallAttrSpelling(IntEnum):
  GNU_AMDGPU_KERNEL = 0
  CXX11_CLANG_AMDGPU_KERNEL = 1
  C23_CLANG_AMDGPU_KERNEL = 2
  SPELLING_NOT_CALCULATED = 3

class AMDGPUNumSGPRAttrSpelling(IntEnum):
  GNU_AMDGPU_NUM_SGPR = 0
  CXX11_CLANG_AMDGPU_NUM_SGPR = 1
  SPELLING_NOT_CALCULATED = 2

class AMDGPUNumVGPRAttrSpelling(IntEnum):
  GNU_AMDGPU_NUM_VGPR = 0
  CXX11_CLANG_AMDGPU_NUM_VGPR = 1
  SPELLING_NOT_CALCULATED = 2

class AMDGPUWavesPerEUAttrSpelling(IntEnum):
  GNU_AMDGPU_WAVES_PER_EU = 0
  CXX11_CLANG_AMDGPU_WAVES_PER_EU = 1
  SPELLING_NOT_CALCULATED = 2

class ARMInterruptAttrInterruptType(IntEnum):
  IRQ = 0
  FIQ = 1
  SWI = 2
  ABORT = 3
  UNDEF = 4
  GENERIC = 5

class ARMInterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class AVRInterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class AVRSignalAttrSpelling(IntEnum):
  GNU_SIGNAL = 0
  CXX11_GNU_SIGNAL = 1
  C23_GNU_SIGNAL = 2
  SPELLING_NOT_CALCULATED = 3

class AbiTagAttrSpelling(IntEnum):
  GNU_ABI_TAG = 0
  CXX11_GNU_ABI_TAG = 1
  SPELLING_NOT_CALCULATED = 2

class AcquireCapabilityAttrSpelling(IntEnum):
  GNU_ACQUIRE_CAPABILITY = 0
  CXX11_CLANG_ACQUIRE_CAPABILITY = 1
  GNU_ACQUIRE_SHARED_CAPABILITY = 2
  CXX11_CLANG_ACQUIRE_SHARED_CAPABILITY = 3
  GNU_EXCLUSIVE_LOCK_FUNCTION = 4
  GNU_SHARED_LOCK_FUNCTION = 5
  SPELLING_NOT_CALCULATED = 6

class AcquireHandleAttrSpelling(IntEnum):
  GNU_ACQUIRE_HANDLE = 0
  CXX11_CLANG_ACQUIRE_HANDLE = 1
  C23_CLANG_ACQUIRE_HANDLE = 2
  SPELLING_NOT_CALCULATED = 3

class AddressSpaceAttrSpelling(IntEnum):
  GNU_ADDRESS_SPACE = 0
  CXX11_CLANG_ADDRESS_SPACE = 1
  C23_CLANG_ADDRESS_SPACE = 2
  SPELLING_NOT_CALCULATED = 3

class AliasAttrSpelling(IntEnum):
  GNU_ALIAS = 0
  CXX11_GNU_ALIAS = 1
  C23_GNU_ALIAS = 2
  SPELLING_NOT_CALCULATED = 3

class AlignedAttrSpelling(IntEnum):
  GNU_ALIGNED = 0
  CXX11_GNU_ALIGNED = 1
  C23_GNU_ALIGNED = 2
  DECLSPEC_ALIGN = 3
  KEYWORD_ALIGNAS = 4
  KEYWORD__ALIGNAS = 5
  SPELLING_NOT_CALCULATED = 6

class AllocAlignAttrSpelling(IntEnum):
  GNU_ALLOC_ALIGN = 0
  CXX11_GNU_ALLOC_ALIGN = 1
  C23_GNU_ALLOC_ALIGN = 2
  SPELLING_NOT_CALCULATED = 3

class AllocSizeAttrSpelling(IntEnum):
  GNU_ALLOC_SIZE = 0
  CXX11_GNU_ALLOC_SIZE = 1
  C23_GNU_ALLOC_SIZE = 2
  SPELLING_NOT_CALCULATED = 3

class AlwaysDestroyAttrSpelling(IntEnum):
  GNU_ALWAYS_DESTROY = 0
  CXX11_CLANG_ALWAYS_DESTROY = 1
  SPELLING_NOT_CALCULATED = 2

class AlwaysInlineAttrSpelling(IntEnum):
  GNU_ALWAYS_INLINE = 0
  CXX11_GNU_ALWAYS_INLINE = 1
  C23_GNU_ALWAYS_INLINE = 2
  CXX11_CLANG_ALWAYS_INLINE = 3
  C23_CLANG_ALWAYS_INLINE = 4
  KEYWORD_FORCEINLINE = 5
  SPELLING_NOT_CALCULATED = 6

class AnnotateAttrSpelling(IntEnum):
  GNU_ANNOTATE = 0
  CXX11_CLANG_ANNOTATE = 1
  C23_CLANG_ANNOTATE = 2
  SPELLING_NOT_CALCULATED = 3

class AnnotateTypeAttrSpelling(IntEnum):
  CXX11_CLANG_ANNOTATE_TYPE = 0
  C23_CLANG_ANNOTATE_TYPE = 1
  SPELLING_NOT_CALCULATED = 2

class AnyX86InterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class AnyX86NoCallerSavedRegistersAttrSpelling(IntEnum):
  GNU_NO_CALLER_SAVED_REGISTERS = 0
  CXX11_GNU_NO_CALLER_SAVED_REGISTERS = 1
  C23_GNU_NO_CALLER_SAVED_REGISTERS = 2
  SPELLING_NOT_CALCULATED = 3

class AnyX86NoCfCheckAttrSpelling(IntEnum):
  GNU_NOCF_CHECK = 0
  CXX11_GNU_NOCF_CHECK = 1
  C23_GNU_NOCF_CHECK = 2
  SPELLING_NOT_CALCULATED = 3

class ArcWeakrefUnavailableAttrSpelling(IntEnum):
  GNU_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE = 0
  CXX11_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE = 1
  C23_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE = 2
  SPELLING_NOT_CALCULATED = 3

class ArgumentWithTypeTagAttrSpelling(IntEnum):
  GNU_ARGUMENT_WITH_TYPE_TAG = 0
  CXX11_CLANG_ARGUMENT_WITH_TYPE_TAG = 1
  C23_CLANG_ARGUMENT_WITH_TYPE_TAG = 2
  GNU_POINTER_WITH_TYPE_TAG = 3
  CXX11_CLANG_POINTER_WITH_TYPE_TAG = 4
  C23_CLANG_POINTER_WITH_TYPE_TAG = 5
  SPELLING_NOT_CALCULATED = 6

class ArmBuiltinAliasAttrSpelling(IntEnum):
  GNU_CLANG_ARM_BUILTIN_ALIAS = 0
  CXX11_CLANG_CLANG_ARM_BUILTIN_ALIAS = 1
  C23_CLANG_CLANG_ARM_BUILTIN_ALIAS = 2
  SPELLING_NOT_CALCULATED = 3

class ArmMveStrictPolymorphismAttrSpelling(IntEnum):
  GNU_CLANG_ARM_MVE_STRICT_POLYMORPHISM = 0
  CXX11_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM = 1
  C23_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM = 2
  SPELLING_NOT_CALCULATED = 3

class ArtificialAttrSpelling(IntEnum):
  GNU_ARTIFICIAL = 0
  CXX11_GNU_ARTIFICIAL = 1
  C23_GNU_ARTIFICIAL = 2
  SPELLING_NOT_CALCULATED = 3

class AsmLabelAttrSpelling(IntEnum):
  KEYWORD_ASSEMBLY = 0
  SPELLING_NOT_CALCULATED = 1

class AssertCapabilityAttrSpelling(IntEnum):
  GNU_ASSERT_CAPABILITY = 0
  CXX11_CLANG_ASSERT_CAPABILITY = 1
  GNU_ASSERT_SHARED_CAPABILITY = 2
  CXX11_CLANG_ASSERT_SHARED_CAPABILITY = 3
  SPELLING_NOT_CALCULATED = 4

class AssumeAlignedAttrSpelling(IntEnum):
  GNU_ASSUME_ALIGNED = 0
  CXX11_GNU_ASSUME_ALIGNED = 1
  C23_GNU_ASSUME_ALIGNED = 2
  SPELLING_NOT_CALCULATED = 3

class AssumptionAttrSpelling(IntEnum):
  GNU_ASSUME = 0
  CXX11_CLANG_ASSUME = 1
  C23_CLANG_ASSUME = 2
  SPELLING_NOT_CALCULATED = 3

class AtomicExprAtomicOp(IntEnum):
  C11_ATOMIC_INITIALIZER = 0
  C11_ATOMIC_LOAD = 1
  C11_ATOMIC_STORE = 2
  C11_ATOMIC_EXCHANGE = 3
  C11_ATOMIC_COMPARE_EXCHANGE_STRONG = 4
  C11_ATOMIC_COMPARE_EXCHANGE_WEAK = 5
  C11_ATOMIC_FETCH_ADD = 6
  C11_ATOMIC_FETCH_SUB = 7
  C11_ATOMIC_FETCH_AND = 8
  C11_ATOMIC_FETCH_OR = 9
  C11_ATOMIC_FETCH_XOR = 10
  C11_ATOMIC_FETCH_NAND = 11
  C11_ATOMIC_FETCH_MAX = 12
  C11_ATOMIC_FETCH_MIN = 13
  ATOMIC_LOAD = 14
  ATOMIC_LOAD_N = 15
  ATOMIC_STORE = 16
  ATOMIC_STORE_N = 17
  ATOMIC_EXCHANGE = 18
  ATOMIC_EXCHANGE_N = 19
  ATOMIC_COMPARE_EXCHANGE = 20
  ATOMIC_COMPARE_EXCHANGE_N = 21
  ATOMIC_FETCH_ADD = 22
  ATOMIC_FETCH_SUB = 23
  ATOMIC_FETCH_AND = 24
  ATOMIC_FETCH_OR = 25
  ATOMIC_FETCH_XOR = 26
  ATOMIC_FETCH_NAND = 27
  ATOMIC_ADD_FETCH = 28
  ATOMIC_SUB_FETCH = 29
  ATOMIC_AND_FETCH = 30
  ATOMIC_OR_FETCH = 31
  ATOMIC_XOR_FETCH = 32
  ATOMIC_MAX_FETCH = 33
  ATOMIC_MIN_FETCH = 34
  ATOMIC_NAND_FETCH = 35
  SCOPED_ATOMIC_LOAD = 36
  SCOPED_ATOMIC_LOAD_N = 37
  SCOPED_ATOMIC_STORE = 38
  SCOPED_ATOMIC_STORE_N = 39
  SCOPED_ATOMIC_EXCHANGE = 40
  SCOPED_ATOMIC_EXCHANGE_N = 41
  SCOPED_ATOMIC_COMPARE_EXCHANGE = 42
  SCOPED_ATOMIC_COMPARE_EXCHANGE_N = 43
  SCOPED_ATOMIC_FETCH_ADD = 44
  SCOPED_ATOMIC_FETCH_SUB = 45
  SCOPED_ATOMIC_FETCH_AND = 46
  SCOPED_ATOMIC_FETCH_OR = 47
  SCOPED_ATOMIC_FETCH_XOR = 48
  SCOPED_ATOMIC_FETCH_NAND = 49
  SCOPED_ATOMIC_ADD_FETCH = 50
  SCOPED_ATOMIC_SUB_FETCH = 51
  SCOPED_ATOMIC_AND_FETCH = 52
  SCOPED_ATOMIC_OR_FETCH = 53
  SCOPED_ATOMIC_XOR_FETCH = 54
  SCOPED_ATOMIC_MAX_FETCH = 55
  SCOPED_ATOMIC_MIN_FETCH = 56
  SCOPED_ATOMIC_NAND_FETCH = 57
  SCOPED_ATOMIC_FETCH_MIN = 58
  SCOPED_ATOMIC_FETCH_MAX = 59
  OPENCL_ATOMIC_INITIALIZER = 60
  OPENCL_ATOMIC_LOAD = 61
  OPENCL_ATOMIC_STORE = 62
  OPENCL_ATOMIC_EXCHANGE = 63
  OPENCL_ATOMIC_COMPARE_EXCHANGE_STRONG = 64
  OPENCL_ATOMIC_COMPARE_EXCHANGE_WEAK = 65
  OPENCL_ATOMIC_FETCH_ADD = 66
  OPENCL_ATOMIC_FETCH_SUB = 67
  OPENCL_ATOMIC_FETCH_AND = 68
  OPENCL_ATOMIC_FETCH_OR = 69
  OPENCL_ATOMIC_FETCH_XOR = 70
  OPENCL_ATOMIC_FETCH_MIN = 71
  OPENCL_ATOMIC_FETCH_MAX = 72
  ATOMIC_FETCH_MIN = 73
  ATOMIC_FETCH_MAX = 74
  HIP_ATOMIC_LOAD = 75
  HIP_ATOMIC_STORE = 76
  HIP_ATOMIC_COMPARE_EXCHANGE_WEAK = 77
  HIP_ATOMIC_COMPARE_EXCHANGE_STRONG = 78
  HIP_ATOMIC_EXCHANGE = 79
  HIP_ATOMIC_FETCH_ADD = 80
  HIP_ATOMIC_FETCH_SUB = 81
  HIP_ATOMIC_FETCH_AND = 82
  HIP_ATOMIC_FETCH_OR = 83
  HIP_ATOMIC_FETCH_XOR = 84
  HIP_ATOMIC_FETCH_MIN = 85
  HIP_ATOMIC_FETCH_MAX = 86

class AvailabilityAttrSpelling(IntEnum):
  GNU_AVAILABILITY = 0
  CXX11_CLANG_AVAILABILITY = 1
  C23_CLANG_AVAILABILITY = 2
  SPELLING_NOT_CALCULATED = 3

class AvailableOnlyInDefaultEvalMethodAttrSpelling(IntEnum):
  GNU_AVAILABLE_ONLY_IN_DEFAULT_EVAL_METHOD = 0
  CXX11_CLANG_AVAILABLE_ONLY_IN_DEFAULT_EVAL_METHOD = 1
  C23_CLANG_AVAILABLE_ONLY_IN_DEFAULT_EVAL_METHOD = 2
  SPELLING_NOT_CALCULATED = 3

class BPFPreserveAccessIndexAttrSpelling(IntEnum):
  GNU_PRESERVE_ACCESS_INDEX = 0
  CXX11_CLANG_PRESERVE_ACCESS_INDEX = 1
  C23_CLANG_PRESERVE_ACCESS_INDEX = 2
  SPELLING_NOT_CALCULATED = 3

class BPFPreserveStaticOffsetAttrSpelling(IntEnum):
  GNU_PRESERVE_STATIC_OFFSET = 0
  CXX11_CLANG_PRESERVE_STATIC_OFFSET = 1
  C23_CLANG_PRESERVE_STATIC_OFFSET = 2
  SPELLING_NOT_CALCULATED = 3

class BTFDeclTagAttrSpelling(IntEnum):
  GNU_BTF_DECLARATION_TAG = 0
  CXX11_CLANG_BTF_DECLARATION_TAG = 1
  C23_CLANG_BTF_DECLARATION_TAG = 2
  SPELLING_NOT_CALCULATED = 3

class BTFTypeTagAttrSpelling(IntEnum):
  GNU_BTF_TYPE_TAG = 0
  CXX11_CLANG_BTF_TYPE_TAG = 1
  C23_CLANG_BTF_TYPE_TAG = 2
  SPELLING_NOT_CALCULATED = 3

class BlocksAttrBlockType(IntEnum):
  BY_REFERENCE = 0

class BlocksAttrSpelling(IntEnum):
  GNU_BLOCKS = 0
  CXX11_CLANG_BLOCKS = 1
  C23_CLANG_BLOCKS = 2
  SPELLING_NOT_CALCULATED = 3

class BuiltinAliasAttrSpelling(IntEnum):
  CXX11_CLANG_BUILTIN_ALIAS = 0
  C23_CLANG_BUILTIN_ALIAS = 1
  GNU_CLANG_BUILTIN_ALIAS = 2
  SPELLING_NOT_CALCULATED = 3

class BuiltinTypeKind(IntEnum):
  OCL_IMAGE_1D_RO = 0
  OCL_IMAGE_1D_ARRAY_RO = 1
  OCL_IMAGE_1D_BUFFER_RO = 2
  OCL_IMAGE_2D_RO = 3
  OCL_IMAGE_2D_ARRAY_RO = 4
  OCL_IMAGE_2D_DEPTH_RO = 5
  OCL_IMAGE_2D_ARRAY_DEPTH_RO = 6
  OCL_IMAGE_2D_MSAARO = 7
  OCL_IMAGE_2D_ARRAY_MSAARO = 8
  OCL_IMAGE_2D_MSAA_DEPTH_RO = 9
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RO = 10
  OCL_IMAGE_3D_RO = 11
  OCL_IMAGE_1D_WO = 12
  OCL_IMAGE_1D_ARRAY_WO = 13
  OCL_IMAGE_1D_BUFFER_WO = 14
  OCL_IMAGE_2D_WO = 15
  OCL_IMAGE_2D_ARRAY_WO = 16
  OCL_IMAGE_2D_DEPTH_WO = 17
  OCL_IMAGE_2D_ARRAY_DEPTH_WO = 18
  OCL_IMAGE_2D_MSAAWO = 19
  OCL_IMAGE_2D_ARRAY_MSAAWO = 20
  OCL_IMAGE_2D_MSAA_DEPTH_WO = 21
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_WO = 22
  OCL_IMAGE_3D_WO = 23
  OCL_IMAGE_1D_RW = 24
  OCL_IMAGE_1D_ARRAY_RW = 25
  OCL_IMAGE_1D_BUFFER_RW = 26
  OCL_IMAGE_2D_RW = 27
  OCL_IMAGE_2D_ARRAY_RW = 28
  OCL_IMAGE_2D_DEPTH_RW = 29
  OCL_IMAGE_2D_ARRAY_DEPTH_RW = 30
  OCL_IMAGE_2D_MSAARW = 31
  OCL_IMAGE_2D_ARRAY_MSAARW = 32
  OCL_IMAGE_2D_MSAA_DEPTH_RW = 33
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RW = 34
  OCL_IMAGE_3D_RW = 35
  OCL_INTEL_SUBGROUP_AVC_MCE_PAYLOAD = 36
  OCL_INTEL_SUBGROUP_AVC_IME_PAYLOAD = 37
  OCL_INTEL_SUBGROUP_AVC_REF_PAYLOAD = 38
  OCL_INTEL_SUBGROUP_AVC_SIC_PAYLOAD = 39
  OCL_INTEL_SUBGROUP_AVC_MCE_RESULT = 40
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT = 41
  OCL_INTEL_SUBGROUP_AVC_REF_RESULT = 42
  OCL_INTEL_SUBGROUP_AVC_SIC_RESULT = 43
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT_SINGLE_REFERENCE_STREAMOUT = 44
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT_DUAL_REFERENCE_STREAMOUT = 45
  OCL_INTEL_SUBGROUP_AVC_IME_SINGLE_REFERENCE_STREAMIN = 46
  OCL_INTEL_SUBGROUP_AVC_IME_DUAL_REFERENCE_STREAMIN = 47
  SVE_INT8 = 48
  SVE_INT16 = 49
  SVE_INT32 = 50
  SVE_INT64 = 51
  SVE_UINT8 = 52
  SVE_UINT16 = 53
  SVE_UINT32 = 54
  SVE_UINT64 = 55
  SVE_FLOAT16 = 56
  SVE_FLOAT32 = 57
  SVE_FLOAT64 = 58
  SVE_B_FLOAT16 = 59
  SVE_INT8X2 = 60
  SVE_INT16X2 = 61
  SVE_INT32X2 = 62
  SVE_INT64X2 = 63
  SVE_UINT8X2 = 64
  SVE_UINT16X2 = 65
  SVE_UINT32X2 = 66
  SVE_UINT64X2 = 67
  SVE_FLOAT16X2 = 68
  SVE_FLOAT32X2 = 69
  SVE_FLOAT64X2 = 70
  SVE_B_FLOAT16X2 = 71
  SVE_INT8X3 = 72
  SVE_INT16X3 = 73
  SVE_INT32X3 = 74
  SVE_INT64X3 = 75
  SVE_UINT8X3 = 76
  SVE_UINT16X3 = 77
  SVE_UINT32X3 = 78
  SVE_UINT64X3 = 79
  SVE_FLOAT16X3 = 80
  SVE_FLOAT32X3 = 81
  SVE_FLOAT64X3 = 82
  SVE_B_FLOAT16X3 = 83
  SVE_INT8X4 = 84
  SVE_INT16X4 = 85
  SVE_INT32X4 = 86
  SVE_INT64X4 = 87
  SVE_UINT8X4 = 88
  SVE_UINT16X4 = 89
  SVE_UINT32X4 = 90
  SVE_UINT64X4 = 91
  SVE_FLOAT16X4 = 92
  SVE_FLOAT32X4 = 93
  SVE_FLOAT64X4 = 94
  SVE_B_FLOAT16X4 = 95
  SVE_BOOLEAN = 96
  SVE_BOOLX2 = 97
  SVE_BOOLX4 = 98
  SVE_COUNT = 99
  VECTOR_QUAD = 100
  VECTOR_PAIR = 101
  RVV_INT8MF8 = 102
  RVV_INT8MF4 = 103
  RVV_INT8MF2 = 104
  RVV_INT8M1 = 105
  RVV_INT8M2 = 106
  RVV_INT8M4 = 107
  RVV_INT8M8 = 108
  RVV_UINT8MF8 = 109
  RVV_UINT8MF4 = 110
  RVV_UINT8MF2 = 111
  RVV_UINT8M1 = 112
  RVV_UINT8M2 = 113
  RVV_UINT8M4 = 114
  RVV_UINT8M8 = 115
  RVV_INT16MF4 = 116
  RVV_INT16MF2 = 117
  RVV_INT16M1 = 118
  RVV_INT16M2 = 119
  RVV_INT16M4 = 120
  RVV_INT16M8 = 121
  RVV_UINT16MF4 = 122
  RVV_UINT16MF2 = 123
  RVV_UINT16M1 = 124
  RVV_UINT16M2 = 125
  RVV_UINT16M4 = 126
  RVV_UINT16M8 = 127
  RVV_INT32MF2 = 128
  RVV_INT32M1 = 129
  RVV_INT32M2 = 130
  RVV_INT32M4 = 131
  RVV_INT32M8 = 132
  RVV_UINT32MF2 = 133
  RVV_UINT32M1 = 134
  RVV_UINT32M2 = 135
  RVV_UINT32M4 = 136
  RVV_UINT32M8 = 137
  RVV_INT64M1 = 138
  RVV_INT64M2 = 139
  RVV_INT64M4 = 140
  RVV_INT64M8 = 141
  RVV_UINT64M1 = 142
  RVV_UINT64M2 = 143
  RVV_UINT64M4 = 144
  RVV_UINT64M8 = 145
  RVV_FLOAT16MF4 = 146
  RVV_FLOAT16MF2 = 147
  RVV_FLOAT16M1 = 148
  RVV_FLOAT16M2 = 149
  RVV_FLOAT16M4 = 150
  RVV_FLOAT16M8 = 151
  RVV_B_FLOAT16MF4 = 152
  RVV_B_FLOAT16MF2 = 153
  RVV_B_FLOAT16M1 = 154
  RVV_B_FLOAT16M2 = 155
  RVV_B_FLOAT16M4 = 156
  RVV_B_FLOAT16M8 = 157
  RVV_FLOAT32MF2 = 158
  RVV_FLOAT32M1 = 159
  RVV_FLOAT32M2 = 160
  RVV_FLOAT32M4 = 161
  RVV_FLOAT32M8 = 162
  RVV_FLOAT64M1 = 163
  RVV_FLOAT64M2 = 164
  RVV_FLOAT64M4 = 165
  RVV_FLOAT64M8 = 166
  RVV_BOOL1 = 167
  RVV_BOOL2 = 168
  RVV_BOOL4 = 169
  RVV_BOOL8 = 170
  RVV_BOOL16 = 171
  RVV_BOOL32 = 172
  RVV_BOOL64 = 173
  RVV_INT8MF8X2 = 174
  RVV_INT8MF8X3 = 175
  RVV_INT8MF8X4 = 176
  RVV_INT8MF8X5 = 177
  RVV_INT8MF8X6 = 178
  RVV_INT8MF8X7 = 179
  RVV_INT8MF8X8 = 180
  RVV_INT8MF4X2 = 181
  RVV_INT8MF4X3 = 182
  RVV_INT8MF4X4 = 183
  RVV_INT8MF4X5 = 184
  RVV_INT8MF4X6 = 185
  RVV_INT8MF4X7 = 186
  RVV_INT8MF4X8 = 187
  RVV_INT8MF2X2 = 188
  RVV_INT8MF2X3 = 189
  RVV_INT8MF2X4 = 190
  RVV_INT8MF2X5 = 191
  RVV_INT8MF2X6 = 192
  RVV_INT8MF2X7 = 193
  RVV_INT8MF2X8 = 194
  RVV_INT8M1X2 = 195
  RVV_INT8M1X3 = 196
  RVV_INT8M1X4 = 197
  RVV_INT8M1X5 = 198
  RVV_INT8M1X6 = 199
  RVV_INT8M1X7 = 200
  RVV_INT8M1X8 = 201
  RVV_INT8M2X2 = 202
  RVV_INT8M2X3 = 203
  RVV_INT8M2X4 = 204
  RVV_INT8M4X2 = 205
  RVV_UINT8MF8X2 = 206
  RVV_UINT8MF8X3 = 207
  RVV_UINT8MF8X4 = 208
  RVV_UINT8MF8X5 = 209
  RVV_UINT8MF8X6 = 210
  RVV_UINT8MF8X7 = 211
  RVV_UINT8MF8X8 = 212
  RVV_UINT8MF4X2 = 213
  RVV_UINT8MF4X3 = 214
  RVV_UINT8MF4X4 = 215
  RVV_UINT8MF4X5 = 216
  RVV_UINT8MF4X6 = 217
  RVV_UINT8MF4X7 = 218
  RVV_UINT8MF4X8 = 219
  RVV_UINT8MF2X2 = 220
  RVV_UINT8MF2X3 = 221
  RVV_UINT8MF2X4 = 222
  RVV_UINT8MF2X5 = 223
  RVV_UINT8MF2X6 = 224
  RVV_UINT8MF2X7 = 225
  RVV_UINT8MF2X8 = 226
  RVV_UINT8M1X2 = 227
  RVV_UINT8M1X3 = 228
  RVV_UINT8M1X4 = 229
  RVV_UINT8M1X5 = 230
  RVV_UINT8M1X6 = 231
  RVV_UINT8M1X7 = 232
  RVV_UINT8M1X8 = 233
  RVV_UINT8M2X2 = 234
  RVV_UINT8M2X3 = 235
  RVV_UINT8M2X4 = 236
  RVV_UINT8M4X2 = 237
  RVV_INT16MF4X2 = 238
  RVV_INT16MF4X3 = 239
  RVV_INT16MF4X4 = 240
  RVV_INT16MF4X5 = 241
  RVV_INT16MF4X6 = 242
  RVV_INT16MF4X7 = 243
  RVV_INT16MF4X8 = 244
  RVV_INT16MF2X2 = 245
  RVV_INT16MF2X3 = 246
  RVV_INT16MF2X4 = 247
  RVV_INT16MF2X5 = 248
  RVV_INT16MF2X6 = 249
  RVV_INT16MF2X7 = 250
  RVV_INT16MF2X8 = 251
  RVV_INT16M1X2 = 252
  RVV_INT16M1X3 = 253
  RVV_INT16M1X4 = 254
  RVV_INT16M1X5 = 255
  RVV_INT16M1X6 = 256
  RVV_INT16M1X7 = 257
  RVV_INT16M1X8 = 258
  RVV_INT16M2X2 = 259
  RVV_INT16M2X3 = 260
  RVV_INT16M2X4 = 261
  RVV_INT16M4X2 = 262
  RVV_UINT16MF4X2 = 263
  RVV_UINT16MF4X3 = 264
  RVV_UINT16MF4X4 = 265
  RVV_UINT16MF4X5 = 266
  RVV_UINT16MF4X6 = 267
  RVV_UINT16MF4X7 = 268
  RVV_UINT16MF4X8 = 269
  RVV_UINT16MF2X2 = 270
  RVV_UINT16MF2X3 = 271
  RVV_UINT16MF2X4 = 272
  RVV_UINT16MF2X5 = 273
  RVV_UINT16MF2X6 = 274
  RVV_UINT16MF2X7 = 275
  RVV_UINT16MF2X8 = 276
  RVV_UINT16M1X2 = 277
  RVV_UINT16M1X3 = 278
  RVV_UINT16M1X4 = 279
  RVV_UINT16M1X5 = 280
  RVV_UINT16M1X6 = 281
  RVV_UINT16M1X7 = 282
  RVV_UINT16M1X8 = 283
  RVV_UINT16M2X2 = 284
  RVV_UINT16M2X3 = 285
  RVV_UINT16M2X4 = 286
  RVV_UINT16M4X2 = 287
  RVV_INT32MF2X2 = 288
  RVV_INT32MF2X3 = 289
  RVV_INT32MF2X4 = 290
  RVV_INT32MF2X5 = 291
  RVV_INT32MF2X6 = 292
  RVV_INT32MF2X7 = 293
  RVV_INT32MF2X8 = 294
  RVV_INT32M1X2 = 295
  RVV_INT32M1X3 = 296
  RVV_INT32M1X4 = 297
  RVV_INT32M1X5 = 298
  RVV_INT32M1X6 = 299
  RVV_INT32M1X7 = 300
  RVV_INT32M1X8 = 301
  RVV_INT32M2X2 = 302
  RVV_INT32M2X3 = 303
  RVV_INT32M2X4 = 304
  RVV_INT32M4X2 = 305
  RVV_UINT32MF2X2 = 306
  RVV_UINT32MF2X3 = 307
  RVV_UINT32MF2X4 = 308
  RVV_UINT32MF2X5 = 309
  RVV_UINT32MF2X6 = 310
  RVV_UINT32MF2X7 = 311
  RVV_UINT32MF2X8 = 312
  RVV_UINT32M1X2 = 313
  RVV_UINT32M1X3 = 314
  RVV_UINT32M1X4 = 315
  RVV_UINT32M1X5 = 316
  RVV_UINT32M1X6 = 317
  RVV_UINT32M1X7 = 318
  RVV_UINT32M1X8 = 319
  RVV_UINT32M2X2 = 320
  RVV_UINT32M2X3 = 321
  RVV_UINT32M2X4 = 322
  RVV_UINT32M4X2 = 323
  RVV_INT64M1X2 = 324
  RVV_INT64M1X3 = 325
  RVV_INT64M1X4 = 326
  RVV_INT64M1X5 = 327
  RVV_INT64M1X6 = 328
  RVV_INT64M1X7 = 329
  RVV_INT64M1X8 = 330
  RVV_INT64M2X2 = 331
  RVV_INT64M2X3 = 332
  RVV_INT64M2X4 = 333
  RVV_INT64M4X2 = 334
  RVV_UINT64M1X2 = 335
  RVV_UINT64M1X3 = 336
  RVV_UINT64M1X4 = 337
  RVV_UINT64M1X5 = 338
  RVV_UINT64M1X6 = 339
  RVV_UINT64M1X7 = 340
  RVV_UINT64M1X8 = 341
  RVV_UINT64M2X2 = 342
  RVV_UINT64M2X3 = 343
  RVV_UINT64M2X4 = 344
  RVV_UINT64M4X2 = 345
  RVV_FLOAT16MF4X2 = 346
  RVV_FLOAT16MF4X3 = 347
  RVV_FLOAT16MF4X4 = 348
  RVV_FLOAT16MF4X5 = 349
  RVV_FLOAT16MF4X6 = 350
  RVV_FLOAT16MF4X7 = 351
  RVV_FLOAT16MF4X8 = 352
  RVV_FLOAT16MF2X2 = 353
  RVV_FLOAT16MF2X3 = 354
  RVV_FLOAT16MF2X4 = 355
  RVV_FLOAT16MF2X5 = 356
  RVV_FLOAT16MF2X6 = 357
  RVV_FLOAT16MF2X7 = 358
  RVV_FLOAT16MF2X8 = 359
  RVV_FLOAT16M1X2 = 360
  RVV_FLOAT16M1X3 = 361
  RVV_FLOAT16M1X4 = 362
  RVV_FLOAT16M1X5 = 363
  RVV_FLOAT16M1X6 = 364
  RVV_FLOAT16M1X7 = 365
  RVV_FLOAT16M1X8 = 366
  RVV_FLOAT16M2X2 = 367
  RVV_FLOAT16M2X3 = 368
  RVV_FLOAT16M2X4 = 369
  RVV_FLOAT16M4X2 = 370
  RVV_FLOAT32MF2X2 = 371
  RVV_FLOAT32MF2X3 = 372
  RVV_FLOAT32MF2X4 = 373
  RVV_FLOAT32MF2X5 = 374
  RVV_FLOAT32MF2X6 = 375
  RVV_FLOAT32MF2X7 = 376
  RVV_FLOAT32MF2X8 = 377
  RVV_FLOAT32M1X2 = 378
  RVV_FLOAT32M1X3 = 379
  RVV_FLOAT32M1X4 = 380
  RVV_FLOAT32M1X5 = 381
  RVV_FLOAT32M1X6 = 382
  RVV_FLOAT32M1X7 = 383
  RVV_FLOAT32M1X8 = 384
  RVV_FLOAT32M2X2 = 385
  RVV_FLOAT32M2X3 = 386
  RVV_FLOAT32M2X4 = 387
  RVV_FLOAT32M4X2 = 388
  RVV_FLOAT64M1X2 = 389
  RVV_FLOAT64M1X3 = 390
  RVV_FLOAT64M1X4 = 391
  RVV_FLOAT64M1X5 = 392
  RVV_FLOAT64M1X6 = 393
  RVV_FLOAT64M1X7 = 394
  RVV_FLOAT64M1X8 = 395
  RVV_FLOAT64M2X2 = 396
  RVV_FLOAT64M2X3 = 397
  RVV_FLOAT64M2X4 = 398
  RVV_FLOAT64M4X2 = 399
  RVV_B_FLOAT16MF4X2 = 400
  RVV_B_FLOAT16MF4X3 = 401
  RVV_B_FLOAT16MF4X4 = 402
  RVV_B_FLOAT16MF4X5 = 403
  RVV_B_FLOAT16MF4X6 = 404
  RVV_B_FLOAT16MF4X7 = 405
  RVV_B_FLOAT16MF4X8 = 406
  RVV_B_FLOAT16MF2X2 = 407
  RVV_B_FLOAT16MF2X3 = 408
  RVV_B_FLOAT16MF2X4 = 409
  RVV_B_FLOAT16MF2X5 = 410
  RVV_B_FLOAT16MF2X6 = 411
  RVV_B_FLOAT16MF2X7 = 412
  RVV_B_FLOAT16MF2X8 = 413
  RVV_B_FLOAT16M1X2 = 414
  RVV_B_FLOAT16M1X3 = 415
  RVV_B_FLOAT16M1X4 = 416
  RVV_B_FLOAT16M1X5 = 417
  RVV_B_FLOAT16M1X6 = 418
  RVV_B_FLOAT16M1X7 = 419
  RVV_B_FLOAT16M1X8 = 420
  RVV_B_FLOAT16M2X2 = 421
  RVV_B_FLOAT16M2X3 = 422
  RVV_B_FLOAT16M2X4 = 423
  RVV_B_FLOAT16M4X2 = 424
  WASM_EXTERN_REFERENCE = 425
  VOID = 426
  BOOLEAN = 427
  CHARACTER_U = 428
  U_CHAR = 429
  W_CHAR_U = 430
  CHAR8 = 431
  CHAR16 = 432
  CHAR32 = 433
  U_SHORT = 434
  U_INT = 435
  U_LONG = 436
  U_LONG_LONG = 437
  U_INT128 = 438
  CHARACTER_S = 439
  S_CHAR = 440
  W_CHAR_S = 441
  SHORT = 442
  INT = 443
  LONG = 444
  LONG_LONG = 445
  INT128 = 446
  SHORT_ACCUM = 447
  ACCUM = 448
  LONG_ACCUM = 449
  U_SHORT_ACCUM = 450
  U_ACCUM = 451
  U_LONG_ACCUM = 452
  SHORT_FRACT = 453
  FRACT = 454
  LONG_FRACT = 455
  U_SHORT_FRACT = 456
  U_FRACT = 457
  U_LONG_FRACT = 458
  SAT_SHORT_ACCUM = 459
  SAT_ACCUM = 460
  SAT_LONG_ACCUM = 461
  SAT_U_SHORT_ACCUM = 462
  SAT_U_ACCUM = 463
  SAT_U_LONG_ACCUM = 464
  SAT_SHORT_FRACT = 465
  SAT_FRACT = 466
  SAT_LONG_FRACT = 467
  SAT_U_SHORT_FRACT = 468
  SAT_U_FRACT = 469
  SAT_U_LONG_FRACT = 470
  HALF = 471
  FLOAT = 472
  DOUBLE = 473
  LONG_DOUBLE = 474
  FLOAT16 = 475
  B_FLOAT16 = 476
  FLOAT128 = 477
  IBM128 = 478
  NULL_POINTER = 479
  OBJ_C_ID = 480
  OBJ_C_CLASS = 481
  OBJ_C_SEL = 482
  OCL_SAMPLER = 483
  OCL_EVENT = 484
  OCL_CLK_EVENT = 485
  OCL_QUEUE = 486
  OCL_RESERVE_ID = 487
  DEPENDENT = 488
  OVERLOAD = 489
  BOUND_MEMBER = 490
  PSEUDO_OBJECT = 491
  UNKNOWN_ANY = 492
  BUILTIN_FN = 493
  ARC_UNBRIDGED_CAST = 494
  INCOMPLETE_MATRIX_INDEX = 495
  OMP_ARRAY_SECTION = 496
  OMP_ARRAY_SHAPING = 497
  OMP_ITERATOR = 498
  UNRESOLVED = 499

class CDeclAttrSpelling(IntEnum):
  GNU_CDECL = 0
  CXX11_GNU_CDECL = 1
  C23_GNU_CDECL = 2
  KEYWORD_CDECL = 3
  SPELLING_NOT_CALCULATED = 4

class CFAuditedTransferAttrSpelling(IntEnum):
  GNU_CF_AUDITED_TRANSFER = 0
  CXX11_CLANG_CF_AUDITED_TRANSFER = 1
  C23_CLANG_CF_AUDITED_TRANSFER = 2
  SPELLING_NOT_CALCULATED = 3

class CFConsumedAttrSpelling(IntEnum):
  GNU_CF_CONSUMED = 0
  CXX11_CLANG_CF_CONSUMED = 1
  C23_CLANG_CF_CONSUMED = 2
  SPELLING_NOT_CALCULATED = 3

class CFGuardAttrGuardArg(IntEnum):
  NOCF = 0

class CFGuardAttrSpelling(IntEnum):
  DECLSPEC_GUARD = 0
  GNU_GUARD = 1
  CXX11_CLANG_GUARD = 2
  C23_CLANG_GUARD = 3
  SPELLING_NOT_CALCULATED = 4

class CFICanonicalJumpTableAttrSpelling(IntEnum):
  GNU_CFI_CANONICAL_JUMP_TABLE = 0
  CXX11_CLANG_CFI_CANONICAL_JUMP_TABLE = 1
  C23_CLANG_CFI_CANONICAL_JUMP_TABLE = 2
  SPELLING_NOT_CALCULATED = 3

class CFReturnsNotRetainedAttrSpelling(IntEnum):
  GNU_CF_RETURNS_NOT_RETAINED = 0
  CXX11_CLANG_CF_RETURNS_NOT_RETAINED = 1
  C23_CLANG_CF_RETURNS_NOT_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class CFReturnsRetainedAttrSpelling(IntEnum):
  GNU_CF_RETURNS_RETAINED = 0
  CXX11_CLANG_CF_RETURNS_RETAINED = 1
  C23_CLANG_CF_RETURNS_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class CFUnknownTransferAttrSpelling(IntEnum):
  GNU_CF_UNKNOWN_TRANSFER = 0
  CXX11_CLANG_CF_UNKNOWN_TRANSFER = 1
  C23_CLANG_CF_UNKNOWN_TRANSFER = 2
  SPELLING_NOT_CALCULATED = 3

class CPUDispatchAttrSpelling(IntEnum):
  GNU_CPU_DISPATCH = 0
  CXX11_CLANG_CPU_DISPATCH = 1
  C23_CLANG_CPU_DISPATCH = 2
  DECLSPEC_CPU_DISPATCH = 3
  SPELLING_NOT_CALCULATED = 4

class CPUSpecificAttrSpelling(IntEnum):
  GNU_CPU_SPECIFIC = 0
  CXX11_CLANG_CPU_SPECIFIC = 1
  C23_CLANG_CPU_SPECIFIC = 2
  DECLSPEC_CPU_SPECIFIC = 3
  SPELLING_NOT_CALCULATED = 4

class CUDAConstantAttrSpelling(IntEnum):
  GNU_CONSTANT = 0
  DECLSPEC_CONSTANT = 1
  SPELLING_NOT_CALCULATED = 2

class CUDADeviceAttrSpelling(IntEnum):
  GNU_DEVICE = 0
  DECLSPEC_DEVICE = 1
  SPELLING_NOT_CALCULATED = 2

class CUDADeviceBuiltinSurfaceTypeAttrSpelling(IntEnum):
  GNU_DEVICE_BUILTIN_SURFACE_TYPE = 0
  DECLSPEC_DEVICE_BUILTIN_SURFACE_TYPE = 1
  SPELLING_NOT_CALCULATED = 2

class CUDADeviceBuiltinTextureTypeAttrSpelling(IntEnum):
  GNU_DEVICE_BUILTIN_TEXTURE_TYPE = 0
  DECLSPEC_DEVICE_BUILTIN_TEXTURE_TYPE = 1
  SPELLING_NOT_CALCULATED = 2

class CUDAGlobalAttrSpelling(IntEnum):
  GNU_GLOBAL = 0
  DECLSPEC_GLOBAL = 1
  SPELLING_NOT_CALCULATED = 2

class CUDAHostAttrSpelling(IntEnum):
  GNU_HOST = 0
  DECLSPEC_HOST = 1
  SPELLING_NOT_CALCULATED = 2

class CUDALaunchBoundsAttrSpelling(IntEnum):
  GNU_LAUNCH_BOUNDS = 0
  DECLSPEC_LAUNCH_BOUNDS = 1
  SPELLING_NOT_CALCULATED = 2

class CUDASharedAttrSpelling(IntEnum):
  GNU_SHARED = 0
  DECLSPEC_SHARED = 1
  SPELLING_NOT_CALCULATED = 2

class CXX11NoReturnAttrSpelling(IntEnum):
  CXX11_NORETURN = 0
  C23_NORETURN = 1
  C23___NORETURN = 2
  SPELLING_NOT_CALCULATED = 3

class CXXRecordDeclLambdaDependencyKind(IntEnum):
  UNKNOWN = 0
  ALWAYS_DEPENDENT = 1
  NEVER_DEPENDENT = 2

class CallExprADLCallKind(IntEnum):
  NOT_ADL = 0
  USES_ADL = 1

class CallableWhenAttrConsumedState(IntEnum):
  UNKNOWN = 0
  CONSUMED = 1
  UNCONSUMED = 2

class CallableWhenAttrSpelling(IntEnum):
  GNU_CALLABLE_WHEN = 0
  CXX11_CLANG_CALLABLE_WHEN = 1
  SPELLING_NOT_CALCULATED = 2

class CallbackAttrSpelling(IntEnum):
  GNU_CALLBACK = 0
  CXX11_CLANG_CALLBACK = 1
  C23_CLANG_CALLBACK = 2
  SPELLING_NOT_CALCULATED = 3

class CalledOnceAttrSpelling(IntEnum):
  GNU_CALLED_ONCE = 0
  CXX11_CLANG_CALLED_ONCE = 1
  C23_CLANG_CALLED_ONCE = 2
  SPELLING_NOT_CALCULATED = 3

class CapabilityAttrSpelling(IntEnum):
  GNU_CAPABILITY = 0
  CXX11_CLANG_CAPABILITY = 1
  GNU_SHARED_CAPABILITY = 2
  CXX11_CLANG_SHARED_CAPABILITY = 3
  SPELLING_NOT_CALCULATED = 4

class CapturedStmtVariableCaptureKind(IntEnum):
  THIS = 0
  BY_REFERENCE = 1
  BY_COPY = 2
  VLA_TYPE = 3

class CarriesDependencyAttrSpelling(IntEnum):
  GNU_CARRIES_DEPENDENCY = 0
  CXX11_CARRIES_DEPENDENCY = 1
  SPELLING_NOT_CALCULATED = 2

class CleanupAttrSpelling(IntEnum):
  GNU_CLEANUP = 0
  CXX11_GNU_CLEANUP = 1
  C23_GNU_CLEANUP = 2
  SPELLING_NOT_CALCULATED = 3

class CodeAlignAttrSpelling(IntEnum):
  GNU_CODE_ALIGN = 0
  CXX11_CLANG_CODE_ALIGN = 1
  C23_CLANG_CODE_ALIGN = 2
  SPELLING_NOT_CALCULATED = 3

class CodeModelAttrSpelling(IntEnum):
  GNU_MODEL = 0
  CXX11_GNU_MODEL = 1
  C23_GNU_MODEL = 2
  SPELLING_NOT_CALCULATED = 3

class ColdAttrSpelling(IntEnum):
  GNU_COLD = 0
  CXX11_GNU_COLD = 1
  C23_GNU_COLD = 2
  SPELLING_NOT_CALCULATED = 3

class CommonAttrSpelling(IntEnum):
  GNU_COMMON = 0
  CXX11_GNU_COMMON = 1
  C23_GNU_COMMON = 2
  SPELLING_NOT_CALCULATED = 3

class ConstAttrSpelling(IntEnum):
  GNU_CONST = 0
  CXX11_GNU_CONST = 1
  C23_GNU_CONST = 2
  SPELLING_NOT_CALCULATED = 3

class ConstInitAttrSpelling(IntEnum):
  KEYWORD_CONSTINIT = 0
  GNU_REQUIRE_CONSTANT_INITIALIZATION = 1
  CXX11_CLANG_REQUIRE_CONSTANT_INITIALIZATION = 2
  SPELLING_NOT_CALCULATED = 3

class ConstructorAttrSpelling(IntEnum):
  GNU_CONSTRUCTOR = 0
  CXX11_GNU_CONSTRUCTOR = 1
  C23_GNU_CONSTRUCTOR = 2
  SPELLING_NOT_CALCULATED = 3

class ConsumableAttrConsumedState(IntEnum):
  UNKNOWN = 0
  CONSUMED = 1
  UNCONSUMED = 2

class ConsumableAttrSpelling(IntEnum):
  GNU_CONSUMABLE = 0
  CXX11_CLANG_CONSUMABLE = 1
  SPELLING_NOT_CALCULATED = 2

class ConsumableAutoCastAttrSpelling(IntEnum):
  GNU_CONSUMABLE_AUTO_CAST_STATE = 0
  CXX11_CLANG_CONSUMABLE_AUTO_CAST_STATE = 1
  SPELLING_NOT_CALCULATED = 2

class ConsumableSetOnReadAttrSpelling(IntEnum):
  GNU_CONSUMABLE_STATE_ON_READ = 0
  CXX11_CLANG_CONSUMABLE_STATE_ON_READ = 1
  SPELLING_NOT_CALCULATED = 2

class ConvergentAttrSpelling(IntEnum):
  GNU_CONVERGENT = 0
  CXX11_CLANG_CONVERGENT = 1
  C23_CLANG_CONVERGENT = 2
  SPELLING_NOT_CALCULATED = 3

class CoroDisableLifetimeBoundAttrSpelling(IntEnum):
  GNU_CORO_DISABLE_LIFETIMEBOUND = 0
  CXX11_CLANG_CORO_DISABLE_LIFETIMEBOUND = 1
  C23_CLANG_CORO_DISABLE_LIFETIMEBOUND = 2
  SPELLING_NOT_CALCULATED = 3

class CoroLifetimeBoundAttrSpelling(IntEnum):
  GNU_CORO_LIFETIMEBOUND = 0
  CXX11_CLANG_CORO_LIFETIMEBOUND = 1
  C23_CLANG_CORO_LIFETIMEBOUND = 2
  SPELLING_NOT_CALCULATED = 3

class CoroOnlyDestroyWhenCompleteAttrSpelling(IntEnum):
  GNU_CORO_ONLY_DESTROY_WHEN_COMPLETE = 0
  CXX11_CLANG_CORO_ONLY_DESTROY_WHEN_COMPLETE = 1
  C23_CLANG_CORO_ONLY_DESTROY_WHEN_COMPLETE = 2
  SPELLING_NOT_CALCULATED = 3

class CoroReturnTypeAttrSpelling(IntEnum):
  GNU_CORO_RETURN_TYPE = 0
  CXX11_CLANG_CORO_RETURN_TYPE = 1
  C23_CLANG_CORO_RETURN_TYPE = 2
  SPELLING_NOT_CALCULATED = 3

class CoroWrapperAttrSpelling(IntEnum):
  GNU_CORO_WRAPPER = 0
  CXX11_CLANG_CORO_WRAPPER = 1
  C23_CLANG_CORO_WRAPPER = 2
  SPELLING_NOT_CALCULATED = 3

class CountedByAttrSpelling(IntEnum):
  GNU_COUNTED_BY = 0
  CXX11_CLANG_COUNTED_BY = 1
  C23_CLANG_COUNTED_BY = 2
  SPELLING_NOT_CALCULATED = 3

class DLLExportAttrSpelling(IntEnum):
  DECLSPEC_DLLEXPORT = 0
  GNU_DLLEXPORT = 1
  CXX11_GNU_DLLEXPORT = 2
  C23_GNU_DLLEXPORT = 3
  SPELLING_NOT_CALCULATED = 4

class DLLImportAttrSpelling(IntEnum):
  DECLSPEC_DLLIMPORT = 0
  GNU_DLLIMPORT = 1
  CXX11_GNU_DLLIMPORT = 2
  C23_GNU_DLLIMPORT = 3
  SPELLING_NOT_CALCULATED = 4

class DeclFriendObjectKind(IntEnum):
  NONE = 0
  DECLARED = 1
  UNDECLARED = 2

class DeclIdentifierNamespace(IntEnum):
  LABEL = 0
  TAG = 1
  TYPE = 2
  MEMBER = 3
  NAMESPACE = 4
  ORDINARY = 5
  OBJ_C_PROTOCOL = 6
  ORDINARY_FRIEND = 7
  TAG_FRIEND = 8
  USING = 9
  NON_MEMBER_OPERATOR = 10
  LOCAL_EXTERN = 11
  OMP_REDUCTION = 12
  OMP_MAPPER = 13

class DeclModuleOwnershipKind(IntEnum):
  UNOWNED = 0
  VISIBLE = 1
  VISIBLE_WHEN_IMPORTED = 2
  REACHABLE_WHEN_IMPORTED = 3
  MODULE_PRIVATE = 4

class DeclObjCDeclQualifier(IntEnum):
  NONE = 0
  IN = 1
  INOUT = 2
  OUT = 3
  BYCOPY = 4
  BYREF = 5
  ONEWAY = 6
  CS_NULLABILITY = 7

class DeprecatedAttrSpelling(IntEnum):
  GNU_DEPRECATED = 0
  CXX11_GNU_DEPRECATED = 1
  C23_GNU_DEPRECATED = 2
  DECLSPEC_DEPRECATED = 3
  CXX11_DEPRECATED = 4
  C23_DEPRECATED = 5
  SPELLING_NOT_CALCULATED = 6

class DestructorAttrSpelling(IntEnum):
  GNU_DESTRUCTOR = 0
  CXX11_GNU_DESTRUCTOR = 1
  C23_GNU_DESTRUCTOR = 2
  SPELLING_NOT_CALCULATED = 3

class DiagnoseAsBuiltinAttrSpelling(IntEnum):
  GNU_DIAGNOSE_AS_BUILTIN = 0
  CXX11_CLANG_DIAGNOSE_AS_BUILTIN = 1
  C23_CLANG_DIAGNOSE_AS_BUILTIN = 2
  SPELLING_NOT_CALCULATED = 3

class DiagnoseIfAttrDiagnosticType(IntEnum):
  ERROR = 0
  WARNING = 1

class DisableSanitizerInstrumentationAttrSpelling(IntEnum):
  GNU_DISABLE_SANITIZER_INSTRUMENTATION = 0
  CXX11_CLANG_DISABLE_SANITIZER_INSTRUMENTATION = 1
  C23_CLANG_DISABLE_SANITIZER_INSTRUMENTATION = 2
  SPELLING_NOT_CALCULATED = 3

class DisableTailCallsAttrSpelling(IntEnum):
  GNU_DISABLE_TAIL_CALLS = 0
  CXX11_CLANG_DISABLE_TAIL_CALLS = 1
  C23_CLANG_DISABLE_TAIL_CALLS = 2
  SPELLING_NOT_CALCULATED = 3

class EnforceTCBAttrSpelling(IntEnum):
  GNU_ENFORCE_TCB = 0
  CXX11_CLANG_ENFORCE_TCB = 1
  C23_CLANG_ENFORCE_TCB = 2
  SPELLING_NOT_CALCULATED = 3

class EnforceTCBLeafAttrSpelling(IntEnum):
  GNU_ENFORCE_TCB_LEAF = 0
  CXX11_CLANG_ENFORCE_TCB_LEAF = 1
  C23_CLANG_ENFORCE_TCB_LEAF = 2
  SPELLING_NOT_CALCULATED = 3

class EnumExtensibilityAttrKind(IntEnum):
  CLOSED = 0
  OPEN = 1

class EnumExtensibilityAttrSpelling(IntEnum):
  GNU_ENUM_EXTENSIBILITY = 0
  CXX11_CLANG_ENUM_EXTENSIBILITY = 1
  C23_CLANG_ENUM_EXTENSIBILITY = 2
  SPELLING_NOT_CALCULATED = 3

class ErrorAttrSpelling(IntEnum):
  GNU_ERROR = 0
  CXX11_GNU_ERROR = 1
  C23_GNU_ERROR = 2
  GNU_WARNING = 3
  CXX11_GNU_WARNING = 4
  C23_GNU_WARNING = 5
  SPELLING_NOT_CALCULATED = 6

class ExcludeFromExplicitInstantiationAttrSpelling(IntEnum):
  GNU_EXCLUDE_FROM_EXPLICIT_INSTANTIATION = 0
  CXX11_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION = 1
  C23_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION = 2
  SPELLING_NOT_CALCULATED = 3

class ExprConstantExprKind(IntEnum):
  NORMAL = 0
  NON_CLASS_TEMPLATE_ARGUMENT = 1
  CLASS_TEMPLATE_ARGUMENT = 2
  IMMEDIATE_INVOCATION = 3

class ExprLValueClassification(IntEnum):
  VALID = 0
  NOT_OBJECT_TYPE = 1
  INCOMPLETE_VOID_TYPE = 2
  DUPLICATE_VECTOR_COMPONENTS = 3
  INVALID_EXPRESSION = 4
  INVALID_MESSAGE_EXPRESSION = 5
  MEMBER_FUNCTION = 6
  SUB_OBJ_C_PROPERTY_SETTING = 7
  CLASS_TEMPORARY = 8
  ARRAY_TEMPORARY = 9

class ExprNullPointerConstantKind(IntEnum):
  NOT_NULL = 0
  ZERO_EXPRESSION = 1
  ZERO_LITERAL = 2
  CXX11_NULLPTR = 3
  GNU_NULL = 4

class ExprNullPointerConstantValueDependence(IntEnum):
  NEVER_VALUE_DEPENDENT = 0
  VALUE_DEPENDENT_IS_NULL = 1
  VALUE_DEPENDENT_IS_NOT_NULL = 2

class ExprSideEffectsKind(IntEnum):
  NO_SIDE_EFFECTS = 0
  ALLOW_UNDEFINED_BEHAVIOR = 1
  ALLOW_SIDE_EFFECTS = 2

class ExprisModifiableLvalueResult(IntEnum):
  VALID = 0
  NOT_OBJECT_TYPE = 1
  INCOMPLETE_VOID_TYPE = 2
  DUPLICATE_VECTOR_COMPONENTS = 3
  INVALID_EXPRESSION = 4
  L_VALUE_CAST = 5
  INCOMPLETE_TYPE = 6
  CONST_QUALIFIED = 7
  CONST_QUALIFIED_FIELD = 8
  CONST_ADDRESS_SPACE = 9
  ARRAY_TYPE = 10
  NO_SETTER_PROPERTY = 11
  MEMBER_FUNCTION = 12
  SUB_OBJ_C_PROPERTY_SETTING = 13
  INVALID_MESSAGE_EXPRESSION = 14
  CLASS_TEMPORARY = 15
  ARRAY_TEMPORARY = 16

class ExternalSourceSymbolAttrSpelling(IntEnum):
  GNU_EXTERNAL_SOURCE_SYMBOL = 0
  CXX11_CLANG_EXTERNAL_SOURCE_SYMBOL = 1
  C23_CLANG_EXTERNAL_SOURCE_SYMBOL = 2
  SPELLING_NOT_CALCULATED = 3

class FallThroughAttrSpelling(IntEnum):
  CXX11_FALLTHROUGH = 0
  C23_FALLTHROUGH = 1
  CXX11_CLANG_FALLTHROUGH = 2
  GNU_FALLTHROUGH = 3
  CXX11_GNU_FALLTHROUGH = 4
  C23_GNU_FALLTHROUGH = 5
  SPELLING_NOT_CALCULATED = 6

class FastCallAttrSpelling(IntEnum):
  GNU_FASTCALL = 0
  CXX11_GNU_FASTCALL = 1
  C23_GNU_FASTCALL = 2
  KEYWORD_FASTCALL = 3
  SPELLING_NOT_CALCULATED = 4

class FinalAttrSpelling(IntEnum):
  KEYWORD_FINAL = 0
  KEYWORD_SEALED = 1
  SPELLING_NOT_CALCULATED = 2

class FlagEnumAttrSpelling(IntEnum):
  GNU_FLAG_ENUM = 0
  CXX11_CLANG_FLAG_ENUM = 1
  C23_CLANG_FLAG_ENUM = 2
  SPELLING_NOT_CALCULATED = 3

class FlattenAttrSpelling(IntEnum):
  GNU_FLATTEN = 0
  CXX11_GNU_FLATTEN = 1
  C23_GNU_FLATTEN = 2
  SPELLING_NOT_CALCULATED = 3

class FormatArgAttrSpelling(IntEnum):
  GNU_FORMAT_ARGUMENT = 0
  CXX11_GNU_FORMAT_ARGUMENT = 1
  C23_GNU_FORMAT_ARGUMENT = 2
  SPELLING_NOT_CALCULATED = 3

class FormatAttrSpelling(IntEnum):
  GNU_FORMAT = 0
  CXX11_GNU_FORMAT = 1
  C23_GNU_FORMAT = 2
  SPELLING_NOT_CALCULATED = 3

class FunctionDeclTemplatedKind(IntEnum):
  NON_TEMPLATE = 0
  FUNCTION_TEMPLATE = 1
  MEMBER_SPECIALIZATION = 2
  FUNCTION_TEMPLATE_SPECIALIZATION = 3
  DEPENDENT_FUNCTION_TEMPLATE_SPECIALIZATION = 4
  DEPENDENT_NON_TEMPLATE = 5

class FunctionReturnThunksAttrKind(IntEnum):
  KEEP = 0
  EXTERN = 1

class FunctionReturnThunksAttrSpelling(IntEnum):
  GNU_FUNCTION_RETURN = 0
  CXX11_GNU_FUNCTION_RETURN = 1
  C23_GNU_FUNCTION_RETURN = 2
  SPELLING_NOT_CALCULATED = 3

class FunctionTypeAArch64SMETypeAttributes(IntEnum):
  SME_NORMAL_FUNCTION = 0
  SMEP_STATE_SM_ENABLED_MASK = 1
  SMEP_STATE_SM_COMPATIBLE_MASK = 2
  SMEZA_MASK = 3
  SMEZT0_SHIFT = 4
  SMEZT0_MASK = 5
  SME_ATTRIBUTE_MASK = 6

class FunctionTypeArmStateValue(IntEnum):
  ARM_NONE = 0
  ARM_PRESERVES = 1
  ARM_IN = 2
  ARM_OUT = 3
  ARM_IN_OUT = 4

class GNUInlineAttrSpelling(IntEnum):
  GNU_GNU_INLINE = 0
  CXX11_GNU_GNU_INLINE = 1
  C23_GNU_GNU_INLINE = 2
  SPELLING_NOT_CALCULATED = 3

class GuardedVarAttrSpelling(IntEnum):
  GNU_GUARDED_VARIABLE = 0
  CXX11_CLANG_GUARDED_VARIABLE = 1
  SPELLING_NOT_CALCULATED = 2

class HIPManagedAttrSpelling(IntEnum):
  GNU_MANAGED = 0
  DECLSPEC_MANAGED = 1
  SPELLING_NOT_CALCULATED = 2

class HLSLParamModifierAttrSpelling(IntEnum):
  KEYWORD_IN = 0
  KEYWORD_INOUT = 1
  KEYWORD_OUT = 2
  SPELLING_NOT_CALCULATED = 3

class HLSLShaderAttrShaderType(IntEnum):
  PIXEL = 0
  VERTEX = 1
  GEOMETRY = 2
  HULL = 3
  DOMAIN_ = 4
  COMPUTE = 5
  RAY_GENERATION = 6
  INTERSECTION = 7
  ANY_HIT = 8
  CLOSEST_HIT = 9
  MISS = 10
  CALLABLE = 11
  MESH = 12
  AMPLIFICATION = 13

class HotAttrSpelling(IntEnum):
  GNU_HOT = 0
  CXX11_GNU_HOT = 1
  C23_GNU_HOT = 2
  SPELLING_NOT_CALCULATED = 3

class IBActionAttrSpelling(IntEnum):
  GNU_IBACTION = 0
  CXX11_CLANG_IBACTION = 1
  C23_CLANG_IBACTION = 2
  SPELLING_NOT_CALCULATED = 3

class IBOutletAttrSpelling(IntEnum):
  GNU_IBOUTLET = 0
  CXX11_CLANG_IBOUTLET = 1
  C23_CLANG_IBOUTLET = 2
  SPELLING_NOT_CALCULATED = 3

class IBOutletCollectionAttrSpelling(IntEnum):
  GNU_IBOUTLETCOLLECTION = 0
  CXX11_CLANG_IBOUTLETCOLLECTION = 1
  C23_CLANG_IBOUTLETCOLLECTION = 2
  SPELLING_NOT_CALCULATED = 3

class IFuncAttrSpelling(IntEnum):
  GNU_IFUNC = 0
  CXX11_GNU_IFUNC = 1
  C23_GNU_IFUNC = 2
  SPELLING_NOT_CALCULATED = 3

class ImplicitCastExprOnStack(IntEnum):
  ON_STACK = 0

class InitPriorityAttrSpelling(IntEnum):
  GNU_INITIALIZER_PRIORITY = 0
  CXX11_GNU_INITIALIZER_PRIORITY = 1
  SPELLING_NOT_CALCULATED = 2

class IntelOclBiccAttrSpelling(IntEnum):
  GNU_INTEL_OCL_BICC = 0
  CXX11_CLANG_INTEL_OCL_BICC = 1
  SPELLING_NOT_CALCULATED = 2

class InternalLinkageAttrSpelling(IntEnum):
  GNU_INTERNAL_LINKAGE = 0
  CXX11_CLANG_INTERNAL_LINKAGE = 1
  C23_CLANG_INTERNAL_LINKAGE = 2
  SPELLING_NOT_CALCULATED = 3

class LTOVisibilityPublicAttrSpelling(IntEnum):
  GNU_LTO_VISIBILITY_PUBLIC = 0
  CXX11_CLANG_LTO_VISIBILITY_PUBLIC = 1
  C23_CLANG_LTO_VISIBILITY_PUBLIC = 2
  SPELLING_NOT_CALCULATED = 3

class LeafAttrSpelling(IntEnum):
  GNU_LEAF = 0
  CXX11_GNU_LEAF = 1
  C23_GNU_LEAF = 2
  SPELLING_NOT_CALCULATED = 3

class LifetimeBoundAttrSpelling(IntEnum):
  GNU_LIFETIMEBOUND = 0
  CXX11_CLANG_LIFETIMEBOUND = 1
  SPELLING_NOT_CALCULATED = 2

class LikelyAttrSpelling(IntEnum):
  CXX11_LIKELY = 0
  C23_CLANG_LIKELY = 1
  SPELLING_NOT_CALCULATED = 2

class LoaderUninitializedAttrSpelling(IntEnum):
  GNU_LOADER_UNINITIALIZED = 0
  CXX11_CLANG_LOADER_UNINITIALIZED = 1
  C23_CLANG_LOADER_UNINITIALIZED = 2
  SPELLING_NOT_CALCULATED = 3

class LoopHintAttrLoopHintState(IntEnum):
  ENABLE = 0
  DISABLE = 1
  NUMERIC = 2
  FIXED_WIDTH = 3
  SCALABLE_WIDTH = 4
  ASSUME_SAFETY = 5
  FULL = 6

class LoopHintAttrOptionType(IntEnum):
  VECTORIZE = 0
  VECTORIZE_WIDTH = 1
  INTERLEAVE = 2
  INTERLEAVE_COUNT = 3
  UNROLL = 4
  UNROLL_COUNT = 5
  UNROLL_AND_JAM = 6
  UNROLL_AND_JAM_COUNT = 7
  PIPELINE_DISABLED = 8
  PIPELINE_INITIATION_INTERVAL = 9
  DISTRIBUTE = 10
  VECTORIZE_PREDICATE = 11

class LoopHintAttrSpelling(IntEnum):
  PRAGMA_CLANG_LOOP = 0
  PRAGMA_UNROLL = 1
  PRAGMA_NOUNROLL = 2
  PRAGMA_UNROLL_AND_JAM = 3
  PRAGMA_NOUNROLL_AND_JAM = 4
  SPELLING_NOT_CALCULATED = 5

class M68kRTDAttrSpelling(IntEnum):
  GNUM68K_RTD = 0
  CXX11_CLANG_M68K_RTD = 1
  C23_CLANG_M68K_RTD = 2
  SPELLING_NOT_CALCULATED = 3

class MIGServerRoutineAttrSpelling(IntEnum):
  GNU_MIG_SERVER_ROUTINE = 0
  CXX11_CLANG_MIG_SERVER_ROUTINE = 1
  C23_CLANG_MIG_SERVER_ROUTINE = 2
  SPELLING_NOT_CALCULATED = 3

class MSABIAttrSpelling(IntEnum):
  GNU_MS_ABI = 0
  CXX11_GNU_MS_ABI = 1
  C23_GNU_MS_ABI = 2
  SPELLING_NOT_CALCULATED = 3

class MSInheritanceAttrSpelling(IntEnum):
  KEYWORD_SINGLE_INHERITANCE = 0
  KEYWORD_MULTIPLE_INHERITANCE = 1
  KEYWORD_VIRTUAL_INHERITANCE = 2
  KEYWORD_UNSPECIFIED_INHERITANCE = 3
  SPELLING_NOT_CALCULATED = 4

class MSP430InterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class MSStructAttrSpelling(IntEnum):
  GNU_MS_STRUCT = 0
  CXX11_GNU_MS_STRUCT = 1
  C23_GNU_MS_STRUCT = 2
  SPELLING_NOT_CALCULATED = 3

class MayAliasAttrSpelling(IntEnum):
  GNU_MAY_ALIAS = 0
  CXX11_GNU_MAY_ALIAS = 1
  C23_GNU_MAY_ALIAS = 2
  SPELLING_NOT_CALCULATED = 3

class MaybeUndefAttrSpelling(IntEnum):
  GNU_MAYBE_UNDEF = 0
  CXX11_CLANG_MAYBE_UNDEF = 1
  C23_CLANG_MAYBE_UNDEF = 2
  SPELLING_NOT_CALCULATED = 3

class MicroMipsAttrSpelling(IntEnum):
  GNU_MICROMIPS = 0
  CXX11_GNU_MICROMIPS = 1
  C23_GNU_MICROMIPS = 2
  SPELLING_NOT_CALCULATED = 3

class MinSizeAttrSpelling(IntEnum):
  GNU_MINSIZE = 0
  CXX11_CLANG_MINSIZE = 1
  C23_CLANG_MINSIZE = 2
  SPELLING_NOT_CALCULATED = 3

class MinVectorWidthAttrSpelling(IntEnum):
  GNU_MIN_VECTOR_WIDTH = 0
  CXX11_CLANG_MIN_VECTOR_WIDTH = 1
  C23_CLANG_MIN_VECTOR_WIDTH = 2
  SPELLING_NOT_CALCULATED = 3

class Mips16AttrSpelling(IntEnum):
  GNU_MIPS16 = 0
  CXX11_GNU_MIPS16 = 1
  C23_GNU_MIPS16 = 2
  SPELLING_NOT_CALCULATED = 3

class MipsInterruptAttrInterruptType(IntEnum):
  SW0 = 0
  SW1 = 1
  HW0 = 2
  HW1 = 3
  HW2 = 4
  HW3 = 5
  HW4 = 6
  HW5 = 7
  EIC = 8

class MipsInterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class MipsLongCallAttrSpelling(IntEnum):
  GNU_LONG_CALL = 0
  CXX11_GNU_LONG_CALL = 1
  C23_GNU_LONG_CALL = 2
  GNU_FAR = 3
  CXX11_GNU_FAR = 4
  C23_GNU_FAR = 5
  SPELLING_NOT_CALCULATED = 6

class MipsShortCallAttrSpelling(IntEnum):
  GNU_SHORT_CALL = 0
  CXX11_GNU_SHORT_CALL = 1
  C23_GNU_SHORT_CALL = 2
  GNU_NEAR = 3
  CXX11_GNU_NEAR = 4
  C23_GNU_NEAR = 5
  SPELLING_NOT_CALCULATED = 6

class ModeAttrSpelling(IntEnum):
  GNU_MODE = 0
  CXX11_GNU_MODE = 1
  C23_GNU_MODE = 2
  SPELLING_NOT_CALCULATED = 3

class MustTailAttrSpelling(IntEnum):
  GNU_MUSTTAIL = 0
  CXX11_CLANG_MUSTTAIL = 1
  C23_CLANG_MUSTTAIL = 2
  SPELLING_NOT_CALCULATED = 3

class NSConsumedAttrSpelling(IntEnum):
  GNU_NS_CONSUMED = 0
  CXX11_CLANG_NS_CONSUMED = 1
  C23_CLANG_NS_CONSUMED = 2
  SPELLING_NOT_CALCULATED = 3

class NSConsumesSelfAttrSpelling(IntEnum):
  GNU_NS_CONSUMES_SELF = 0
  CXX11_CLANG_NS_CONSUMES_SELF = 1
  C23_CLANG_NS_CONSUMES_SELF = 2
  SPELLING_NOT_CALCULATED = 3

class NSReturnsAutoreleasedAttrSpelling(IntEnum):
  GNU_NS_RETURNS_AUTORELEASED = 0
  CXX11_CLANG_NS_RETURNS_AUTORELEASED = 1
  C23_CLANG_NS_RETURNS_AUTORELEASED = 2
  SPELLING_NOT_CALCULATED = 3

class NSReturnsNotRetainedAttrSpelling(IntEnum):
  GNU_NS_RETURNS_NOT_RETAINED = 0
  CXX11_CLANG_NS_RETURNS_NOT_RETAINED = 1
  C23_CLANG_NS_RETURNS_NOT_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class NSReturnsRetainedAttrSpelling(IntEnum):
  GNU_NS_RETURNS_RETAINED = 0
  CXX11_CLANG_NS_RETURNS_RETAINED = 1
  C23_CLANG_NS_RETURNS_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class NVPTXKernelAttrSpelling(IntEnum):
  GNU_NVPTX_KERNEL = 0
  CXX11_CLANG_NVPTX_KERNEL = 1
  C23_CLANG_NVPTX_KERNEL = 2
  SPELLING_NOT_CALCULATED = 3

class NakedAttrSpelling(IntEnum):
  GNU_NAKED = 0
  CXX11_GNU_NAKED = 1
  C23_GNU_NAKED = 2
  DECLSPEC_NAKED = 3
  SPELLING_NOT_CALCULATED = 4

class NamedDeclExplicitVisibilityKind(IntEnum):
  VISIBILITY_FOR_TYPE = 0
  VISIBILITY_FOR_VALUE = 1

class NoBuiltinAttrSpelling(IntEnum):
  GNU_NO_BUILTIN = 0
  CXX11_CLANG_NO_BUILTIN = 1
  C23_CLANG_NO_BUILTIN = 2
  SPELLING_NOT_CALCULATED = 3

class NoCommonAttrSpelling(IntEnum):
  GNU_NOCOMMON = 0
  CXX11_GNU_NOCOMMON = 1
  C23_GNU_NOCOMMON = 2
  SPELLING_NOT_CALCULATED = 3

class NoDebugAttrSpelling(IntEnum):
  GNU_NODEBUG = 0
  CXX11_GNU_NODEBUG = 1
  C23_GNU_NODEBUG = 2
  SPELLING_NOT_CALCULATED = 3

class NoDerefAttrSpelling(IntEnum):
  GNU_NODEREF = 0
  CXX11_CLANG_NODEREF = 1
  C23_CLANG_NODEREF = 2
  SPELLING_NOT_CALCULATED = 3

class NoDestroyAttrSpelling(IntEnum):
  GNU_NO_DESTROY = 0
  CXX11_CLANG_NO_DESTROY = 1
  SPELLING_NOT_CALCULATED = 2

class NoDuplicateAttrSpelling(IntEnum):
  GNU_NODUPLICATE = 0
  CXX11_CLANG_NODUPLICATE = 1
  C23_CLANG_NODUPLICATE = 2
  SPELLING_NOT_CALCULATED = 3

class NoEscapeAttrSpelling(IntEnum):
  GNU_NOESCAPE = 0
  CXX11_CLANG_NOESCAPE = 1
  C23_CLANG_NOESCAPE = 2
  SPELLING_NOT_CALCULATED = 3

class NoInlineAttrSpelling(IntEnum):
  KEYWORD_NOINLINE = 0
  GNU_NOINLINE = 1
  CXX11_GNU_NOINLINE = 2
  C23_GNU_NOINLINE = 3
  CXX11_CLANG_NOINLINE = 4
  C23_CLANG_NOINLINE = 5
  DECLSPEC_NOINLINE = 6
  SPELLING_NOT_CALCULATED = 7

class NoInstrumentFunctionAttrSpelling(IntEnum):
  GNU_NO_INSTRUMENT_FUNCTION = 0
  CXX11_GNU_NO_INSTRUMENT_FUNCTION = 1
  C23_GNU_NO_INSTRUMENT_FUNCTION = 2
  SPELLING_NOT_CALCULATED = 3

class NoMergeAttrSpelling(IntEnum):
  GNU_NOMERGE = 0
  CXX11_CLANG_NOMERGE = 1
  C23_CLANG_NOMERGE = 2
  SPELLING_NOT_CALCULATED = 3

class NoMicroMipsAttrSpelling(IntEnum):
  GNU_NOMICROMIPS = 0
  CXX11_GNU_NOMICROMIPS = 1
  C23_GNU_NOMICROMIPS = 2
  SPELLING_NOT_CALCULATED = 3

class NoMips16AttrSpelling(IntEnum):
  GNU_NOMIPS16 = 0
  CXX11_GNU_NOMIPS16 = 1
  C23_GNU_NOMIPS16 = 2
  SPELLING_NOT_CALCULATED = 3

class NoProfileFunctionAttrSpelling(IntEnum):
  GNU_NO_PROFILE_INSTRUMENT_FUNCTION = 0
  CXX11_GNU_NO_PROFILE_INSTRUMENT_FUNCTION = 1
  C23_GNU_NO_PROFILE_INSTRUMENT_FUNCTION = 2
  SPELLING_NOT_CALCULATED = 3

class NoRandomizeLayoutAttrSpelling(IntEnum):
  GNU_NO_RANDOMIZE_LAYOUT = 0
  CXX11_GNU_NO_RANDOMIZE_LAYOUT = 1
  C23_GNU_NO_RANDOMIZE_LAYOUT = 2
  SPELLING_NOT_CALCULATED = 3

class NoReturnAttrSpelling(IntEnum):
  GNU_NORETURN = 0
  CXX11_GNU_NORETURN = 1
  C23_GNU_NORETURN = 2
  DECLSPEC_NORETURN = 3
  SPELLING_NOT_CALCULATED = 4

class NoSanitizeAttrSpelling(IntEnum):
  GNU_NO_SANITIZE = 0
  CXX11_CLANG_NO_SANITIZE = 1
  C23_CLANG_NO_SANITIZE = 2
  SPELLING_NOT_CALCULATED = 3

class NoSpeculativeLoadHardeningAttrSpelling(IntEnum):
  GNU_NO_SPECULATIVE_LOAD_HARDENING = 0
  CXX11_CLANG_NO_SPECULATIVE_LOAD_HARDENING = 1
  C23_CLANG_NO_SPECULATIVE_LOAD_HARDENING = 2
  SPELLING_NOT_CALCULATED = 3

class NoSplitStackAttrSpelling(IntEnum):
  GNU_NO_SPLIT_STACK = 0
  CXX11_GNU_NO_SPLIT_STACK = 1
  C23_GNU_NO_SPLIT_STACK = 2
  SPELLING_NOT_CALCULATED = 3

class NoStackProtectorAttrSpelling(IntEnum):
  GNU_NO_STACK_PROTECTOR = 0
  CXX11_CLANG_NO_STACK_PROTECTOR = 1
  C23_CLANG_NO_STACK_PROTECTOR = 2
  CXX11_GNU_NO_STACK_PROTECTOR = 3
  C23_GNU_NO_STACK_PROTECTOR = 4
  DECLSPEC_SAFEBUFFERS = 5
  SPELLING_NOT_CALCULATED = 6

class NoThreadSafetyAnalysisAttrSpelling(IntEnum):
  GNU_NO_THREAD_SAFETY_ANALYSIS = 0
  CXX11_CLANG_NO_THREAD_SAFETY_ANALYSIS = 1
  C23_CLANG_NO_THREAD_SAFETY_ANALYSIS = 2
  SPELLING_NOT_CALCULATED = 3

class NoThrowAttrSpelling(IntEnum):
  GNU_NOTHROW = 0
  CXX11_GNU_NOTHROW = 1
  C23_GNU_NOTHROW = 2
  DECLSPEC_NOTHROW = 3
  SPELLING_NOT_CALCULATED = 4

class NoUniqueAddressAttrSpelling(IntEnum):
  CXX11_NO_UNIQUE_ADDRESS = 0
  CXX11_MSVC_NO_UNIQUE_ADDRESS = 1
  SPELLING_NOT_CALCULATED = 2

class NoUwtableAttrSpelling(IntEnum):
  GNU_NOUWTABLE = 0
  CXX11_CLANG_NOUWTABLE = 1
  C23_CLANG_NOUWTABLE = 2
  SPELLING_NOT_CALCULATED = 3

class NonNullAttrSpelling(IntEnum):
  GNU_NONNULL = 0
  CXX11_GNU_NONNULL = 1
  C23_GNU_NONNULL = 2
  SPELLING_NOT_CALCULATED = 3

class NotTailCalledAttrSpelling(IntEnum):
  GNU_NOT_TAIL_CALLED = 0
  CXX11_CLANG_NOT_TAIL_CALLED = 1
  C23_CLANG_NOT_TAIL_CALLED = 2
  SPELLING_NOT_CALCULATED = 3

class OMPAllocateDeclAttrAllocatorTypeTy(IntEnum):
  OMP_NULL_MEMORY_ALLOC = 0
  OMP_DEFAULT_MEMORY_ALLOC = 1
  OMP_LARGE_CAP_MEMORY_ALLOC = 2
  OMP_CONST_MEMORY_ALLOC = 3
  OMP_HIGH_BW_MEMORY_ALLOC = 4
  OMP_LOW_LAT_MEMORY_ALLOC = 5
  OMPC_GROUP_MEMORY_ALLOC = 6
  OMPP_TEAM_MEMORY_ALLOC = 7
  OMP_THREAD_MEMORY_ALLOC = 8
  OMP_USER_DEFINED_MEMORY_ALLOC = 9

class OMPDeclareSimdDeclAttrBranchStateTy(IntEnum):
  UNDEFINED = 0
  INBRANCH = 1
  NOTINBRANCH = 2

class OMPDeclareTargetDeclAttrDevTypeTy(IntEnum):
  HOST = 0
  NO_HOST = 1
  ANY = 2

class OMPDeclareTargetDeclAttrMapTypeTy(IntEnum):
  TO = 0
  ENTER = 1
  LINK = 2

class OSConsumedAttrSpelling(IntEnum):
  GNU_OS_CONSUMED = 0
  CXX11_CLANG_OS_CONSUMED = 1
  C23_CLANG_OS_CONSUMED = 2
  SPELLING_NOT_CALCULATED = 3

class OSConsumesThisAttrSpelling(IntEnum):
  GNU_OS_CONSUMES_THIS = 0
  CXX11_CLANG_OS_CONSUMES_THIS = 1
  C23_CLANG_OS_CONSUMES_THIS = 2
  SPELLING_NOT_CALCULATED = 3

class OSReturnsNotRetainedAttrSpelling(IntEnum):
  GNU_OS_RETURNS_NOT_RETAINED = 0
  CXX11_CLANG_OS_RETURNS_NOT_RETAINED = 1
  C23_CLANG_OS_RETURNS_NOT_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class OSReturnsRetainedAttrSpelling(IntEnum):
  GNU_OS_RETURNS_RETAINED = 0
  CXX11_CLANG_OS_RETURNS_RETAINED = 1
  C23_CLANG_OS_RETURNS_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class OSReturnsRetainedOnNonZeroAttrSpelling(IntEnum):
  GNU_OS_RETURNS_RETAINED_ON_NON_ZERO = 0
  CXX11_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO = 1
  C23_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO = 2
  SPELLING_NOT_CALCULATED = 3

class OSReturnsRetainedOnZeroAttrSpelling(IntEnum):
  GNU_OS_RETURNS_RETAINED_ON_ZERO = 0
  CXX11_CLANG_OS_RETURNS_RETAINED_ON_ZERO = 1
  C23_CLANG_OS_RETURNS_RETAINED_ON_ZERO = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCBoxableAttrSpelling(IntEnum):
  GNU_OBJC_BOXABLE = 0
  CXX11_CLANG_OBJC_BOXABLE = 1
  C23_CLANG_OBJC_BOXABLE = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCBridgeAttrSpelling(IntEnum):
  GNU_OBJC_BRIDGE = 0
  CXX11_CLANG_OBJC_BRIDGE = 1
  C23_CLANG_OBJC_BRIDGE = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCBridgeMutableAttrSpelling(IntEnum):
  GNU_OBJC_BRIDGE_MUTABLE = 0
  CXX11_CLANG_OBJC_BRIDGE_MUTABLE = 1
  C23_CLANG_OBJC_BRIDGE_MUTABLE = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCBridgeRelatedAttrSpelling(IntEnum):
  GNU_OBJC_BRIDGE_RELATED = 0
  CXX11_CLANG_OBJC_BRIDGE_RELATED = 1
  C23_CLANG_OBJC_BRIDGE_RELATED = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCClassStubAttrSpelling(IntEnum):
  GNU_OBJC_CLASS_STUB = 0
  CXX11_CLANG_OBJC_CLASS_STUB = 1
  C23_CLANG_OBJC_CLASS_STUB = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCDesignatedInitializerAttrSpelling(IntEnum):
  GNU_OBJC_DESIGNATED_INITIALIZER = 0
  CXX11_CLANG_OBJC_DESIGNATED_INITIALIZER = 1
  C23_CLANG_OBJC_DESIGNATED_INITIALIZER = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCDirectAttrSpelling(IntEnum):
  GNU_OBJC_DIRECT = 0
  CXX11_CLANG_OBJC_DIRECT = 1
  C23_CLANG_OBJC_DIRECT = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCDirectMembersAttrSpelling(IntEnum):
  GNU_OBJC_DIRECT_MEMBERS = 0
  CXX11_CLANG_OBJC_DIRECT_MEMBERS = 1
  C23_CLANG_OBJC_DIRECT_MEMBERS = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCExceptionAttrSpelling(IntEnum):
  GNU_OBJC_EXCEPTION = 0
  CXX11_CLANG_OBJC_EXCEPTION = 1
  C23_CLANG_OBJC_EXCEPTION = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCExplicitProtocolImplAttrSpelling(IntEnum):
  GNU_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION = 0
  CXX11_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION = 1
  C23_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCExternallyRetainedAttrSpelling(IntEnum):
  GNU_OBJC_EXTERNALLY_RETAINED = 0
  CXX11_CLANG_OBJC_EXTERNALLY_RETAINED = 1
  C23_CLANG_OBJC_EXTERNALLY_RETAINED = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCGCAttrSpelling(IntEnum):
  GNU_OBJC_GC = 0
  CXX11_CLANG_OBJC_GC = 1
  C23_CLANG_OBJC_GC = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCIndependentClassAttrSpelling(IntEnum):
  GNU_OBJC_INDEPENDENT_CLASS = 0
  CXX11_CLANG_OBJC_INDEPENDENT_CLASS = 1
  C23_CLANG_OBJC_INDEPENDENT_CLASS = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCIvarDeclAccessControl(IntEnum):
  NONE = 0
  PRIVATE = 1
  PROTECTED = 2
  PUBLIC = 3
  PACKAGE = 4

class ObjCMessageExprReceiverKind(IntEnum):
  CLASS = 0
  INSTANCE = 1
  SUPER_CLASS = 2
  SUPER_INSTANCE = 3

class ObjCMethodFamilyAttrFamilyKind(IntEnum):
  NONE = 0
  ALLOC = 1
  COPY = 2
  INITIALIZER = 3
  MUTABLE_COPY = 4
  NEW = 5

class ObjCMethodFamilyAttrSpelling(IntEnum):
  GNU_OBJC_METHOD_FAMILY = 0
  CXX11_CLANG_OBJC_METHOD_FAMILY = 1
  C23_CLANG_OBJC_METHOD_FAMILY = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCNSObjectAttrSpelling(IntEnum):
  GNUNS_OBJECT = 0
  CXX11_CLANG_NS_OBJECT = 1
  C23_CLANG_NS_OBJECT = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCNonLazyClassAttrSpelling(IntEnum):
  GNU_OBJC_NONLAZY_CLASS = 0
  CXX11_CLANG_OBJC_NONLAZY_CLASS = 1
  C23_CLANG_OBJC_NONLAZY_CLASS = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCNonRuntimeProtocolAttrSpelling(IntEnum):
  GNU_OBJC_NON_RUNTIME_PROTOCOL = 0
  CXX11_CLANG_OBJC_NON_RUNTIME_PROTOCOL = 1
  C23_CLANG_OBJC_NON_RUNTIME_PROTOCOL = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCOwnershipAttrSpelling(IntEnum):
  GNU_OBJC_OWNERSHIP = 0
  CXX11_CLANG_OBJC_OWNERSHIP = 1
  C23_CLANG_OBJC_OWNERSHIP = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCPreciseLifetimeAttrSpelling(IntEnum):
  GNU_OBJC_PRECISE_LIFETIME = 0
  CXX11_CLANG_OBJC_PRECISE_LIFETIME = 1
  C23_CLANG_OBJC_PRECISE_LIFETIME = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCPropertyDeclPropertyControl(IntEnum):
  NONE = 0
  REQUIRED = 1
  OPTIONAL = 2

class ObjCPropertyDeclSetterKind(IntEnum):
  ASSIGN = 0
  RETAIN = 1
  COPY = 2
  WEAK = 3

class ObjCPropertyImplDeclKind(IntEnum):
  SYNTHESIZE = 0
  DYNAMIC = 1

class ObjCRequiresPropertyDefsAttrSpelling(IntEnum):
  GNU_OBJC_REQUIRES_PROPERTY_DEFINITIONS = 0
  CXX11_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS = 1
  C23_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCRequiresSuperAttrSpelling(IntEnum):
  GNU_OBJC_REQUIRES_SUPER = 0
  CXX11_CLANG_OBJC_REQUIRES_SUPER = 1
  C23_CLANG_OBJC_REQUIRES_SUPER = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCReturnsInnerPointerAttrSpelling(IntEnum):
  GNU_OBJC_RETURNS_INNER_POINTER = 0
  CXX11_CLANG_OBJC_RETURNS_INNER_POINTER = 1
  C23_CLANG_OBJC_RETURNS_INNER_POINTER = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCRootClassAttrSpelling(IntEnum):
  GNU_OBJC_ROOT_CLASS = 0
  CXX11_CLANG_OBJC_ROOT_CLASS = 1
  C23_CLANG_OBJC_ROOT_CLASS = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCRuntimeNameAttrSpelling(IntEnum):
  GNU_OBJC_RUNTIME_NAME = 0
  CXX11_CLANG_OBJC_RUNTIME_NAME = 1
  C23_CLANG_OBJC_RUNTIME_NAME = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCRuntimeVisibleAttrSpelling(IntEnum):
  GNU_OBJC_RUNTIME_VISIBLE = 0
  CXX11_CLANG_OBJC_RUNTIME_VISIBLE = 1
  C23_CLANG_OBJC_RUNTIME_VISIBLE = 2
  SPELLING_NOT_CALCULATED = 3

class ObjCSubclassingRestrictedAttrSpelling(IntEnum):
  GNU_OBJC_SUBCLASSING_RESTRICTED = 0
  CXX11_CLANG_OBJC_SUBCLASSING_RESTRICTED = 1
  C23_CLANG_OBJC_SUBCLASSING_RESTRICTED = 2
  SPELLING_NOT_CALCULATED = 3

class OpenCLAccessAttrSpelling(IntEnum):
  KEYWORD_READ_ONLY = 0
  KEYWORD_WRITE_ONLY = 1
  KEYWORD_READ_WRITE = 2
  SPELLING_NOT_CALCULATED = 3

class OpenCLConstantAddressSpaceAttrSpelling(IntEnum):
  KEYWORD_CONSTANT = 0
  GNU_OPENCL_CONSTANT = 1
  CXX11_CLANG_OPENCL_CONSTANT = 2
  C23_CLANG_OPENCL_CONSTANT = 3
  SPELLING_NOT_CALCULATED = 4

class OpenCLGenericAddressSpaceAttrSpelling(IntEnum):
  KEYWORD_GENERIC = 0
  GNU_OPENCL_GENERIC = 1
  CXX11_CLANG_OPENCL_GENERIC = 2
  C23_CLANG_OPENCL_GENERIC = 3
  SPELLING_NOT_CALCULATED = 4

class OpenCLGlobalAddressSpaceAttrSpelling(IntEnum):
  KEYWORD_GLOBAL = 0
  GNU_OPENCL_GLOBAL = 1
  CXX11_CLANG_OPENCL_GLOBAL = 2
  C23_CLANG_OPENCL_GLOBAL = 3
  SPELLING_NOT_CALCULATED = 4

class OpenCLGlobalDeviceAddressSpaceAttrSpelling(IntEnum):
  GNU_OPENCL_GLOBAL_DEVICE = 0
  CXX11_CLANG_OPENCL_GLOBAL_DEVICE = 1
  C23_CLANG_OPENCL_GLOBAL_DEVICE = 2
  SPELLING_NOT_CALCULATED = 3

class OpenCLGlobalHostAddressSpaceAttrSpelling(IntEnum):
  GNU_OPENCL_GLOBAL_HOST = 0
  CXX11_CLANG_OPENCL_GLOBAL_HOST = 1
  C23_CLANG_OPENCL_GLOBAL_HOST = 2
  SPELLING_NOT_CALCULATED = 3

class OpenCLKernelAttrSpelling(IntEnum):
  KEYWORD_KERNEL = 0
  SPELLING_NOT_CALCULATED = 1

class OpenCLLocalAddressSpaceAttrSpelling(IntEnum):
  KEYWORD_LOCAL = 0
  GNU_OPENCL_LOCAL = 1
  CXX11_CLANG_OPENCL_LOCAL = 2
  C23_CLANG_OPENCL_LOCAL = 3
  SPELLING_NOT_CALCULATED = 4

class OpenCLPrivateAddressSpaceAttrSpelling(IntEnum):
  KEYWORD_PRIVATE = 0
  GNU_OPENCL_PRIVATE = 1
  CXX11_CLANG_OPENCL_PRIVATE = 2
  C23_CLANG_OPENCL_PRIVATE = 3
  SPELLING_NOT_CALCULATED = 4

class OptimizeNoneAttrSpelling(IntEnum):
  GNU_OPTNONE = 0
  CXX11_CLANG_OPTNONE = 1
  C23_CLANG_OPTNONE = 2
  SPELLING_NOT_CALCULATED = 3

class OverloadableAttrSpelling(IntEnum):
  GNU_OVERLOADABLE = 0
  CXX11_CLANG_OVERLOADABLE = 1
  C23_CLANG_OVERLOADABLE = 2
  SPELLING_NOT_CALCULATED = 3

class OwnershipAttrOwnershipKind(IntEnum):
  HOLDS = 0
  RETURNS = 1
  TAKES = 2

class OwnershipAttrSpelling(IntEnum):
  GNU_OWNERSHIP_HOLDS = 0
  CXX11_CLANG_OWNERSHIP_HOLDS = 1
  C23_CLANG_OWNERSHIP_HOLDS = 2
  GNU_OWNERSHIP_RETURNS = 3
  CXX11_CLANG_OWNERSHIP_RETURNS = 4
  C23_CLANG_OWNERSHIP_RETURNS = 5
  GNU_OWNERSHIP_TAKES = 6
  CXX11_CLANG_OWNERSHIP_TAKES = 7
  C23_CLANG_OWNERSHIP_TAKES = 8
  SPELLING_NOT_CALCULATED = 9

class PackedAttrSpelling(IntEnum):
  GNU_PACKED = 0
  CXX11_GNU_PACKED = 1
  C23_GNU_PACKED = 2
  SPELLING_NOT_CALCULATED = 3

class ParamTypestateAttrConsumedState(IntEnum):
  UNKNOWN = 0
  CONSUMED = 1
  UNCONSUMED = 2

class ParamTypestateAttrSpelling(IntEnum):
  GNU_PARAMETER_TYPESTATE = 0
  CXX11_CLANG_PARAMETER_TYPESTATE = 1
  SPELLING_NOT_CALCULATED = 2

class PascalAttrSpelling(IntEnum):
  GNU_PASCAL = 0
  CXX11_CLANG_PASCAL = 1
  C23_CLANG_PASCAL = 2
  KEYWORD_PASCAL = 3
  SPELLING_NOT_CALCULATED = 4

class PassObjectSizeAttrSpelling(IntEnum):
  GNU_PASS_OBJECT_SIZE = 0
  CXX11_CLANG_PASS_OBJECT_SIZE = 1
  C23_CLANG_PASS_OBJECT_SIZE = 2
  GNU_PASS_DYNAMIC_OBJECT_SIZE = 3
  CXX11_CLANG_PASS_DYNAMIC_OBJECT_SIZE = 4
  C23_CLANG_PASS_DYNAMIC_OBJECT_SIZE = 5
  SPELLING_NOT_CALCULATED = 6

class PatchableFunctionEntryAttrSpelling(IntEnum):
  GNU_PATCHABLE_FUNCTION_ENTRY = 0
  CXX11_GNU_PATCHABLE_FUNCTION_ENTRY = 1
  C23_GNU_PATCHABLE_FUNCTION_ENTRY = 2
  SPELLING_NOT_CALCULATED = 3

class PcsAttrPCSType(IntEnum):
  AAPCS = 0
  VFP = 1

class PcsAttrSpelling(IntEnum):
  GNU_PCS = 0
  CXX11_GNU_PCS = 1
  C23_GNU_PCS = 2
  SPELLING_NOT_CALCULATED = 3

class PreferredNameAttrSpelling(IntEnum):
  GNU_PREFERRED_NAME = 0
  CXX11_CLANG_PREFERRED_NAME = 1
  SPELLING_NOT_CALCULATED = 2

class PreferredTypeAttrSpelling(IntEnum):
  GNU_PREFERRED_TYPE = 0
  CXX11_CLANG_PREFERRED_TYPE = 1
  C23_CLANG_PREFERRED_TYPE = 2
  SPELLING_NOT_CALCULATED = 3

class PreserveAllAttrSpelling(IntEnum):
  GNU_PRESERVE_ALL = 0
  CXX11_CLANG_PRESERVE_ALL = 1
  C23_CLANG_PRESERVE_ALL = 2
  SPELLING_NOT_CALCULATED = 3

class PreserveMostAttrSpelling(IntEnum):
  GNU_PRESERVE_MOST = 0
  CXX11_CLANG_PRESERVE_MOST = 1
  C23_CLANG_PRESERVE_MOST = 2
  SPELLING_NOT_CALCULATED = 3

class PtGuardedVarAttrSpelling(IntEnum):
  GNU_PT_GUARDED_VARIABLE = 0
  CXX11_CLANG_PT_GUARDED_VARIABLE = 1
  SPELLING_NOT_CALCULATED = 2

class PureAttrSpelling(IntEnum):
  GNU_PURE = 0
  CXX11_GNU_PURE = 1
  C23_GNU_PURE = 2
  SPELLING_NOT_CALCULATED = 3

class QualifiedTypeDestructionKind(IntEnum):
  NONE = 0
  CXX_DESTRUCTOR = 1
  OBJC_STRONG_LIFETIME = 2
  OBJC_WEAK_LIFETIME = 3
  NONTRIVIAL_C_STRUCT = 4

class QualifiedTypeNonConstantStorageReason(IntEnum):
  MUTABLE_FIELD = 0
  NON_CONST_NON_REFERENCE_TYPE = 1
  NON_TRIVIAL_CONSTRUCTOR = 2
  NON_TRIVIAL_DESTRUCTOR = 3

class QualifiedTypePrimitiveCopyKind(IntEnum):
  TRIVIAL = 0
  VOLATILE_TRIVIAL = 1
  ARC_STRONG = 2
  ARC_WEAK = 3
  STRUCT = 4

class QualifiedTypePrimitiveDefaultInitializeKind(IntEnum):
  TRIVIAL = 0
  ARC_STRONG = 1
  ARC_WEAK = 2
  STRUCT = 3

class RISCVInterruptAttrInterruptType(IntEnum):
  SUPERVISOR = 0
  MACHINE = 1

class RISCVInterruptAttrSpelling(IntEnum):
  GNU_INTERRUPT = 0
  CXX11_GNU_INTERRUPT = 1
  C23_GNU_INTERRUPT = 2
  SPELLING_NOT_CALCULATED = 3

class RandomizeLayoutAttrSpelling(IntEnum):
  GNU_RANDOMIZE_LAYOUT = 0
  CXX11_GNU_RANDOMIZE_LAYOUT = 1
  C23_GNU_RANDOMIZE_LAYOUT = 2
  SPELLING_NOT_CALCULATED = 3

class ReadOnlyPlacementAttrSpelling(IntEnum):
  GNU_ENFORCE_READ_ONLY_PLACEMENT = 0
  CXX11_CLANG_ENFORCE_READ_ONLY_PLACEMENT = 1
  C23_CLANG_ENFORCE_READ_ONLY_PLACEMENT = 2
  SPELLING_NOT_CALCULATED = 3

class RegCallAttrSpelling(IntEnum):
  GNU_REGCALL = 0
  CXX11_GNU_REGCALL = 1
  C23_GNU_REGCALL = 2
  KEYWORD_REGCALL = 3
  SPELLING_NOT_CALCULATED = 4

class ReinitializesAttrSpelling(IntEnum):
  GNU_REINITIALIZES = 0
  CXX11_CLANG_REINITIALIZES = 1
  SPELLING_NOT_CALCULATED = 2

class ReleaseCapabilityAttrSpelling(IntEnum):
  GNU_RELEASE_CAPABILITY = 0
  CXX11_CLANG_RELEASE_CAPABILITY = 1
  GNU_RELEASE_SHARED_CAPABILITY = 2
  CXX11_CLANG_RELEASE_SHARED_CAPABILITY = 3
  GNU_RELEASE_GENERIC_CAPABILITY = 4
  CXX11_CLANG_RELEASE_GENERIC_CAPABILITY = 5
  GNU_UNLOCK_FUNCTION = 6
  CXX11_CLANG_UNLOCK_FUNCTION = 7
  SPELLING_NOT_CALCULATED = 8

class ReleaseHandleAttrSpelling(IntEnum):
  GNU_RELEASE_HANDLE = 0
  CXX11_CLANG_RELEASE_HANDLE = 1
  C23_CLANG_RELEASE_HANDLE = 2
  SPELLING_NOT_CALCULATED = 3

class RequiresCapabilityAttrSpelling(IntEnum):
  GNU_REQUIRES_CAPABILITY = 0
  CXX11_CLANG_REQUIRES_CAPABILITY = 1
  GNU_EXCLUSIVE_LOCKS_REQUIRED = 2
  CXX11_CLANG_EXCLUSIVE_LOCKS_REQUIRED = 3
  GNU_REQUIRES_SHARED_CAPABILITY = 4
  CXX11_CLANG_REQUIRES_SHARED_CAPABILITY = 5
  GNU_SHARED_LOCKS_REQUIRED = 6
  CXX11_CLANG_SHARED_LOCKS_REQUIRED = 7
  SPELLING_NOT_CALCULATED = 8

class RestrictAttrSpelling(IntEnum):
  DECLSPEC_RESTRICT = 0
  GNU_MALLOC = 1
  CXX11_GNU_MALLOC = 2
  C23_GNU_MALLOC = 3
  SPELLING_NOT_CALCULATED = 4

class RetainAttrSpelling(IntEnum):
  GNU_RETAIN = 0
  CXX11_GNU_RETAIN = 1
  C23_GNU_RETAIN = 2
  SPELLING_NOT_CALCULATED = 3

class ReturnTypestateAttrConsumedState(IntEnum):
  UNKNOWN = 0
  CONSUMED = 1
  UNCONSUMED = 2

class ReturnTypestateAttrSpelling(IntEnum):
  GNU_RETURN_TYPESTATE = 0
  CXX11_CLANG_RETURN_TYPESTATE = 1
  SPELLING_NOT_CALCULATED = 2

class ReturnsNonNullAttrSpelling(IntEnum):
  GNU_RETURNS_NONNULL = 0
  CXX11_GNU_RETURNS_NONNULL = 1
  C23_GNU_RETURNS_NONNULL = 2
  SPELLING_NOT_CALCULATED = 3

class ReturnsTwiceAttrSpelling(IntEnum):
  GNU_RETURNS_TWICE = 0
  CXX11_GNU_RETURNS_TWICE = 1
  C23_GNU_RETURNS_TWICE = 2
  SPELLING_NOT_CALCULATED = 3

class SYCLKernelAttrSpelling(IntEnum):
  GNU_SYCL_KERNEL = 0
  CXX11_CLANG_SYCL_KERNEL = 1
  C23_CLANG_SYCL_KERNEL = 2
  SPELLING_NOT_CALCULATED = 3

class SYCLSpecialClassAttrSpelling(IntEnum):
  GNU_SYCL_SPECIAL_CLASS = 0
  CXX11_CLANG_SYCL_SPECIAL_CLASS = 1
  C23_CLANG_SYCL_SPECIAL_CLASS = 2
  SPELLING_NOT_CALCULATED = 3

class ScopedLockableAttrSpelling(IntEnum):
  GNU_SCOPED_LOCKABLE = 0
  CXX11_CLANG_SCOPED_LOCKABLE = 1
  SPELLING_NOT_CALCULATED = 2

class SectionAttrSpelling(IntEnum):
  GNU_SECTION = 0
  CXX11_GNU_SECTION = 1
  C23_GNU_SECTION = 2
  DECLSPEC_ALLOCATE = 3
  SPELLING_NOT_CALCULATED = 4

class SelectAnyAttrSpelling(IntEnum):
  DECLSPEC_SELECTANY = 0
  GNU_SELECTANY = 1
  CXX11_GNU_SELECTANY = 2
  C23_GNU_SELECTANY = 3
  SPELLING_NOT_CALCULATED = 4

class SentinelAttrSpelling(IntEnum):
  GNU_SENTINEL = 0
  CXX11_GNU_SENTINEL = 1
  C23_GNU_SENTINEL = 2
  SPELLING_NOT_CALCULATED = 3

class SetTypestateAttrConsumedState(IntEnum):
  UNKNOWN = 0
  CONSUMED = 1
  UNCONSUMED = 2

class SetTypestateAttrSpelling(IntEnum):
  GNU_TYPESTATE = 0
  CXX11_CLANG_TYPESTATE = 1
  SPELLING_NOT_CALCULATED = 2

class SpeculativeLoadHardeningAttrSpelling(IntEnum):
  GNU_SPECULATIVE_LOAD_HARDENING = 0
  CXX11_CLANG_SPECULATIVE_LOAD_HARDENING = 1
  C23_CLANG_SPECULATIVE_LOAD_HARDENING = 2
  SPELLING_NOT_CALCULATED = 3

class StandaloneDebugAttrSpelling(IntEnum):
  GNU_STANDALONE_DEBUG = 0
  CXX11_CLANG_STANDALONE_DEBUG = 1
  SPELLING_NOT_CALCULATED = 2

class StdCallAttrSpelling(IntEnum):
  GNU_STDCALL = 0
  CXX11_GNU_STDCALL = 1
  C23_GNU_STDCALL = 2
  KEYWORD_STDCALL = 3
  SPELLING_NOT_CALCULATED = 4

class StmtLikelihood(IntEnum):
  UNLIKELY = 0
  NONE = 1
  LIKELY = 2

class StmtKind(IntEnum):
  WHILE_STMT = 0
  LABEL_STMT = 1
  VA_ARG_EXPR = 2
  UNARY_OPERATOR = 3
  UNARY_EXPR_OR_TYPE_TRAIT_EXPR = 4
  TYPO_EXPR = 5
  TYPE_TRAIT_EXPR = 6
  SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR = 7
  SUBST_NON_TYPE_TEMPLATE_PARM_EXPR = 8
  STRING_LITERAL = 9
  STMT_EXPR = 10
  SOURCE_LOC_EXPR = 11
  SIZE_OF_PACK_EXPR = 12
  SHUFFLE_VECTOR_EXPR = 13
  SYCL_UNIQUE_STABLE_NAME_EXPR = 14
  REQUIRES_EXPR = 15
  RECOVERY_EXPR = 16
  PSEUDO_OBJECT_EXPR = 17
  PREDEFINED_EXPR = 18
  PAREN_LIST_EXPR = 19
  PAREN_EXPR = 20
  PACK_EXPANSION_EXPR = 21
  UNRESOLVED_MEMBER_EXPR = 22
  UNRESOLVED_LOOKUP_EXPR = 23
  OPAQUE_VALUE_EXPR = 24
  OFFSET_OF_EXPR = 25
  OBJ_C_SUBSCRIPT_REF_EXPR = 26
  OBJ_C_STRING_LITERAL = 27
  OBJ_C_SELECTOR_EXPR = 28
  OBJ_C_PROTOCOL_EXPR = 29
  OBJ_C_PROPERTY_REF_EXPR = 30
  OBJ_C_MESSAGE_EXPR = 31
  OBJ_C_IVAR_REF_EXPR = 32
  OBJ_C_ISA_EXPR = 33
  OBJ_C_INDIRECT_COPY_RESTORE_EXPR = 34
  OBJ_C_ENCODE_EXPR = 35
  OBJ_C_DICTIONARY_LITERAL = 36
  OBJ_C_BOXED_EXPR = 37
  OBJ_C_BOOL_LITERAL_EXPR = 38
  OBJ_C_AVAILABILITY_CHECK_EXPR = 39
  OBJ_C_ARRAY_LITERAL = 40
  OMP_ITERATOR_EXPR = 41
  OMP_ARRAY_SHAPING_EXPR = 42
  OMP_ARRAY_SECTION_EXPR = 43
  NO_INIT_EXPR = 44
  MEMBER_EXPR = 45
  MATRIX_SUBSCRIPT_EXPR = 46
  MATERIALIZE_TEMPORARY_EXPR = 47
  MS_PROPERTY_SUBSCRIPT_EXPR = 48
  MS_PROPERTY_REF_EXPR = 49
  LAMBDA_EXPR = 50
  INTEGER_LITERAL = 51
  INIT_LIST_EXPR = 52
  IMPLICIT_VALUE_INIT_EXPR = 53
  IMAGINARY_LITERAL = 54
  GENERIC_SELECTION_EXPR = 55
  GNU_NULL_EXPR = 56
  FUNCTION_PARM_PACK_EXPR = 57
  EXPR_WITH_CLEANUPS = 58
  CONSTANT_EXPR = 59
  FLOATING_LITERAL = 60
  FIXED_POINT_LITERAL = 61
  EXT_VECTOR_ELEMENT_EXPR = 62
  EXPRESSION_TRAIT_EXPR = 63
  DESIGNATED_INIT_UPDATE_EXPR = 64
  DESIGNATED_INIT_EXPR = 65
  DEPENDENT_SCOPE_DECL_REF_EXPR = 66
  DEPENDENT_COAWAIT_EXPR = 67
  DECL_REF_EXPR = 68
  COYIELD_EXPR = 69
  COAWAIT_EXPR = 70
  CONVERT_VECTOR_EXPR = 71
  CONCEPT_SPECIALIZATION_EXPR = 72
  COMPOUND_LITERAL_EXPR = 73
  CHOOSE_EXPR = 74
  CHARACTER_LITERAL = 75
  IMPLICIT_CAST_EXPR = 76
  OBJ_C_BRIDGED_CAST_EXPR = 77
  CXX_STATIC_CAST_EXPR = 78
  CXX_REINTERPRET_CAST_EXPR = 79
  CXX_DYNAMIC_CAST_EXPR = 80
  CXX_CONST_CAST_EXPR = 81
  CXX_ADDRSPACE_CAST_EXPR = 82
  CXX_FUNCTIONAL_CAST_EXPR = 83
  C_STYLE_CAST_EXPR = 84
  BUILTIN_BIT_CAST_EXPR = 85
  CALL_EXPR = 86
  USER_DEFINED_LITERAL = 87
  CXX_OPERATOR_CALL_EXPR = 88
  CXX_MEMBER_CALL_EXPR = 89
  CUDA_KERNEL_CALL_EXPR = 90
  CXX_UUIDOF_EXPR = 91
  CXX_UNRESOLVED_CONSTRUCT_EXPR = 92
  CXX_TYPEID_EXPR = 93
  CXX_THROW_EXPR = 94
  CXX_THIS_EXPR = 95
  CXX_STD_INITIALIZER_LIST_EXPR = 96
  CXX_SCALAR_VALUE_INIT_EXPR = 97
  CXX_REWRITTEN_BINARY_OPERATOR = 98
  CXX_PSEUDO_DESTRUCTOR_EXPR = 99
  CXX_PAREN_LIST_INIT_EXPR = 100
  CXX_NULL_PTR_LITERAL_EXPR = 101
  CXX_NOEXCEPT_EXPR = 102
  CXX_NEW_EXPR = 103
  CXX_INHERITED_CTOR_INIT_EXPR = 104
  CXX_FOLD_EXPR = 105
  CXX_DEPENDENT_SCOPE_MEMBER_EXPR = 106
  CXX_DELETE_EXPR = 107
  CXX_DEFAULT_INIT_EXPR = 108
  CXX_DEFAULT_ARG_EXPR = 109
  CXX_CONSTRUCT_EXPR = 110
  CXX_TEMPORARY_OBJECT_EXPR = 111
  CXX_BOOL_LITERAL_EXPR = 112
  CXX_BIND_TEMPORARY_EXPR = 113
  BLOCK_EXPR = 114
  BINARY_OPERATOR = 115
  COMPOUND_ASSIGN_OPERATOR = 116
  ATOMIC_EXPR = 117
  AS_TYPE_EXPR = 118
  ARRAY_TYPE_TRAIT_EXPR = 119
  ARRAY_SUBSCRIPT_EXPR = 120
  ARRAY_INIT_LOOP_EXPR = 121
  ARRAY_INIT_INDEX_EXPR = 122
  ADDR_LABEL_EXPR = 123
  CONDITIONAL_OPERATOR = 124
  BINARY_CONDITIONAL_OPERATOR = 125
  ATTRIBUTED_STMT = 126
  SWITCH_STMT = 127
  DEFAULT_STMT = 128
  CASE_STMT = 129
  SEH_TRY_STMT = 130
  SEH_LEAVE_STMT = 131
  SEH_FINALLY_STMT = 132
  SEH_EXCEPT_STMT = 133
  RETURN_STMT = 134
  OBJ_C_FOR_COLLECTION_STMT = 135
  OBJ_C_AUTORELEASE_POOL_STMT = 136
  OBJ_C_AT_TRY_STMT = 137
  OBJ_C_AT_THROW_STMT = 138
  OBJ_C_AT_SYNCHRONIZED_STMT = 139
  OBJ_C_AT_FINALLY_STMT = 140
  OBJ_C_AT_CATCH_STMT = 141
  OMP_TEAMS_DIRECTIVE = 142
  OMP_TASKYIELD_DIRECTIVE = 143
  OMP_TASKWAIT_DIRECTIVE = 144
  OMP_TASKGROUP_DIRECTIVE = 145
  OMP_TASK_DIRECTIVE = 146
  OMP_TARGET_UPDATE_DIRECTIVE = 147
  OMP_TARGET_TEAMS_DIRECTIVE = 148
  OMP_TARGET_PARALLEL_FOR_DIRECTIVE = 149
  OMP_TARGET_PARALLEL_DIRECTIVE = 150
  OMP_TARGET_EXIT_DATA_DIRECTIVE = 151
  OMP_TARGET_ENTER_DATA_DIRECTIVE = 152
  OMP_TARGET_DIRECTIVE = 153
  OMP_TARGET_DATA_DIRECTIVE = 154
  OMP_SINGLE_DIRECTIVE = 155
  OMP_SECTIONS_DIRECTIVE = 156
  OMP_SECTION_DIRECTIVE = 157
  OMP_SCOPE_DIRECTIVE = 158
  OMP_SCAN_DIRECTIVE = 159
  OMP_PARALLEL_SECTIONS_DIRECTIVE = 160
  OMP_PARALLEL_MASTER_DIRECTIVE = 161
  OMP_PARALLEL_MASKED_DIRECTIVE = 162
  OMP_PARALLEL_DIRECTIVE = 163
  OMP_ORDERED_DIRECTIVE = 164
  OMP_META_DIRECTIVE = 165
  OMP_MASTER_DIRECTIVE = 166
  OMP_MASKED_DIRECTIVE = 167
  OMP_UNROLL_DIRECTIVE = 168
  OMP_TILE_DIRECTIVE = 169
  OMP_TEAMS_GENERIC_LOOP_DIRECTIVE = 170
  OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE = 171
  OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = 172
  OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE = 173
  OMP_TEAMS_DISTRIBUTE_DIRECTIVE = 174
  OMP_TASK_LOOP_SIMD_DIRECTIVE = 175
  OMP_TASK_LOOP_DIRECTIVE = 176
  OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE = 177
  OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE = 178
  OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = 179
  OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE = 180
  OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE = 181
  OMP_TARGET_SIMD_DIRECTIVE = 182
  OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE = 183
  OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE = 184
  OMP_SIMD_DIRECTIVE = 185
  OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE = 186
  OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE = 187
  OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE = 188
  OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE = 189
  OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE = 190
  OMP_PARALLEL_FOR_SIMD_DIRECTIVE = 191
  OMP_PARALLEL_FOR_DIRECTIVE = 192
  OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE = 193
  OMP_MASTER_TASK_LOOP_DIRECTIVE = 194
  OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE = 195
  OMP_MASKED_TASK_LOOP_DIRECTIVE = 196
  OMP_GENERIC_LOOP_DIRECTIVE = 197
  OMP_FOR_SIMD_DIRECTIVE = 198
  OMP_FOR_DIRECTIVE = 199
  OMP_DISTRIBUTE_SIMD_DIRECTIVE = 200
  OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE = 201
  OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE = 202
  OMP_DISTRIBUTE_DIRECTIVE = 203
  OMP_INTEROP_DIRECTIVE = 204
  OMP_FLUSH_DIRECTIVE = 205
  OMP_ERROR_DIRECTIVE = 206
  OMP_DISPATCH_DIRECTIVE = 207
  OMP_DEPOBJ_DIRECTIVE = 208
  OMP_CRITICAL_DIRECTIVE = 209
  OMP_CANCELLATION_POINT_DIRECTIVE = 210
  OMP_CANCEL_DIRECTIVE = 211
  OMP_BARRIER_DIRECTIVE = 212
  OMP_ATOMIC_DIRECTIVE = 213
  OMP_CANONICAL_LOOP = 214
  NULL_STMT = 215
  MS_DEPENDENT_EXISTS_STMT = 216
  INDIRECT_GOTO_STMT = 217
  IF_STMT = 218
  GOTO_STMT = 219
  FOR_STMT = 220
  DO_STMT = 221
  DECL_STMT = 222
  COROUTINE_BODY_STMT = 223
  CORETURN_STMT = 224
  CONTINUE_STMT = 225
  COMPOUND_STMT = 226
  CAPTURED_STMT = 227
  CXX_TRY_STMT = 228
  CXX_FOR_RANGE_STMT = 229
  CXX_CATCH_STMT = 230
  BREAK_STMT = 231
  MS_ASM_STMT = 232
  GCC_ASM_STMT = 233

class SuppressAttrSpelling(IntEnum):
  CXX11_GSL_SUPPRESS = 0
  GNU_SUPPRESS = 1
  CXX11_CLANG_SUPPRESS = 2
  C23_CLANG_SUPPRESS = 3
  SPELLING_NOT_CALCULATED = 4

class SwiftAsyncAttrKind(IntEnum):
  NONE = 0
  SWIFT_PRIVATE = 1
  NOT_SWIFT_PRIVATE = 2

class SwiftAsyncAttrSpelling(IntEnum):
  GNU_SWIFT_ASYNC = 0
  CXX11_CLANG_SWIFT_ASYNC = 1
  C23_CLANG_SWIFT_ASYNC = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftAsyncCallAttrSpelling(IntEnum):
  GNU_SWIFTASYNCCALL = 0
  CXX11_CLANG_SWIFTASYNCCALL = 1
  C23_CLANG_SWIFTASYNCCALL = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftAsyncContextAttrSpelling(IntEnum):
  GNU_SWIFT_ASYNC_CONTEXT = 0
  CXX11_CLANG_SWIFT_ASYNC_CONTEXT = 1
  C23_CLANG_SWIFT_ASYNC_CONTEXT = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftAsyncErrorAttrConventionKind(IntEnum):
  NONE = 0
  NON_NULL_ERROR = 1
  ZERO_ARGUMENT = 2
  NON_ZERO_ARGUMENT = 3

class SwiftAsyncErrorAttrSpelling(IntEnum):
  GNU_SWIFT_ASYNC_ERROR = 0
  CXX11_CLANG_SWIFT_ASYNC_ERROR = 1
  C23_CLANG_SWIFT_ASYNC_ERROR = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftCallAttrSpelling(IntEnum):
  GNU_SWIFTCALL = 0
  CXX11_CLANG_SWIFTCALL = 1
  C23_CLANG_SWIFTCALL = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftContextAttrSpelling(IntEnum):
  GNU_SWIFT_CONTEXT = 0
  CXX11_CLANG_SWIFT_CONTEXT = 1
  C23_CLANG_SWIFT_CONTEXT = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftErrorAttrConventionKind(IntEnum):
  NONE = 0
  NON_NULL_ERROR = 1
  NULL_RESULT = 2
  ZERO_RESULT = 3
  NON_ZERO_RESULT = 4

class SwiftErrorResultAttrSpelling(IntEnum):
  GNU_SWIFT_ERROR_RESULT = 0
  CXX11_CLANG_SWIFT_ERROR_RESULT = 1
  C23_CLANG_SWIFT_ERROR_RESULT = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftIndirectResultAttrSpelling(IntEnum):
  GNU_SWIFT_INDIRECT_RESULT = 0
  CXX11_CLANG_SWIFT_INDIRECT_RESULT = 1
  C23_CLANG_SWIFT_INDIRECT_RESULT = 2
  SPELLING_NOT_CALCULATED = 3

class SwiftNewTypeAttrNewtypeKind(IntEnum):
  STRUCT = 0
  ENUM = 1

class SwiftNewTypeAttrSpelling(IntEnum):
  GNU_SWIFT_NEWTYPE = 0
  GNU_SWIFT_WRAPPER = 1
  SPELLING_NOT_CALCULATED = 2

class SysVABIAttrSpelling(IntEnum):
  GNU_SYSV_ABI = 0
  CXX11_GNU_SYSV_ABI = 1
  C23_GNU_SYSV_ABI = 2
  SPELLING_NOT_CALCULATED = 3

class TLSModelAttrSpelling(IntEnum):
  GNU_TLS_MODEL = 0
  CXX11_GNU_TLS_MODEL = 1
  C23_GNU_TLS_MODEL = 2
  SPELLING_NOT_CALCULATED = 3

class TargetAttrSpelling(IntEnum):
  GNU_TARGET = 0
  CXX11_GNU_TARGET = 1
  C23_GNU_TARGET = 2
  SPELLING_NOT_CALCULATED = 3

class TargetClonesAttrSpelling(IntEnum):
  GNU_TARGET_CLONES = 0
  CXX11_GNU_TARGET_CLONES = 1
  C23_GNU_TARGET_CLONES = 2
  SPELLING_NOT_CALCULATED = 3

class TargetVersionAttrSpelling(IntEnum):
  GNU_TARGET_VERSION = 0
  CXX11_GNU_TARGET_VERSION = 1
  C23_GNU_TARGET_VERSION = 2
  SPELLING_NOT_CALCULATED = 3

class TemplateArgumentKind(IntEnum):
  EMPTY = 0
  TYPE = 1
  DECLARATION = 2
  NULL_POINTER = 3
  INTEGRAL = 4
  STRUCTURAL_VALUE = 5
  TEMPLATE = 6
  TEMPLATE_EXPANSION = 7
  EXPRESSION = 8
  PACK = 9

class TestTypestateAttrConsumedState(IntEnum):
  CONSUMED = 0
  UNCONSUMED = 1

class TestTypestateAttrSpelling(IntEnum):
  GNU_TEST_TYPESTATE = 0
  CXX11_CLANG_TEST_TYPESTATE = 1
  SPELLING_NOT_CALCULATED = 2

class ThisCallAttrSpelling(IntEnum):
  GNU_THISCALL = 0
  CXX11_GNU_THISCALL = 1
  C23_GNU_THISCALL = 2
  KEYWORD_THISCALL = 3
  SPELLING_NOT_CALCULATED = 4

class TransparentUnionAttrSpelling(IntEnum):
  GNU_TRANSPARENT_UNION = 0
  CXX11_GNU_TRANSPARENT_UNION = 1
  C23_GNU_TRANSPARENT_UNION = 2
  SPELLING_NOT_CALCULATED = 3

class TrivialABIAttrSpelling(IntEnum):
  GNU_TRIVIAL_ABI = 0
  CXX11_CLANG_TRIVIAL_ABI = 1
  SPELLING_NOT_CALCULATED = 2

class TryAcquireCapabilityAttrSpelling(IntEnum):
  GNU_TRY_ACQUIRE_CAPABILITY = 0
  CXX11_CLANG_TRY_ACQUIRE_CAPABILITY = 1
  GNU_TRY_ACQUIRE_SHARED_CAPABILITY = 2
  CXX11_CLANG_TRY_ACQUIRE_SHARED_CAPABILITY = 3
  SPELLING_NOT_CALCULATED = 4

class TypeScalarTypeKind(IntEnum):
  C_POINTER = 0
  BLOCK_POINTER = 1
  OBJ_C_OBJECT_POINTER = 2
  MEMBER_POINTER = 3
  BOOLEAN = 4
  INTEGRAL = 5
  FLOATING = 6
  INTEGRAL_COMPLEX = 7
  FLOATING_COMPLEX = 8
  FIXED_POINT = 9

class TypeKind(IntEnum):
  ADJUSTED = 0
  DECAYED = 1
  CONSTANT_ARRAY = 2
  DEPENDENT_SIZED_ARRAY = 3
  INCOMPLETE_ARRAY = 4
  VARIABLE_ARRAY = 5
  ATOMIC = 6
  ATTRIBUTED = 7
  BTF_TAG_ATTRIBUTED = 8
  BIT_INT = 9
  BLOCK_POINTER = 10
  BUILTIN = 11
  COMPLEX = 12
  DECLTYPE = 13
  AUTO = 14
  DEDUCED_TEMPLATE_SPECIALIZATION = 15
  DEPENDENT_ADDRESS_SPACE = 16
  DEPENDENT_BIT_INT = 17
  DEPENDENT_NAME = 18
  DEPENDENT_SIZED_EXT_VECTOR = 19
  DEPENDENT_TEMPLATE_SPECIALIZATION = 20
  DEPENDENT_VECTOR = 21
  ELABORATED = 22
  FUNCTION_NO_PROTO = 23
  FUNCTION_PROTO = 24
  INJECTED_CLASS_NAME = 25
  MACRO_QUALIFIED = 26
  CONSTANT_MATRIX = 27
  DEPENDENT_SIZED_MATRIX = 28
  MEMBER_POINTER = 29
  OBJ_C_OBJECT_POINTER = 30
  OBJ_C_OBJECT = 31
  OBJ_C_INTERFACE = 32
  OBJ_C_TYPE_PARAM = 33
  PACK_EXPANSION = 34
  PAREN = 35
  PIPE = 36
  POINTER = 37
  L_VALUE_REFERENCE = 38
  R_VALUE_REFERENCE = 39
  SUBST_TEMPLATE_TYPE_PARM_PACK = 40
  SUBST_TEMPLATE_TYPE_PARM = 41
  ENUM = 42
  RECORD = 43
  TEMPLATE_SPECIALIZATION = 44
  TEMPLATE_TYPE_PARM = 45
  TYPE_OF_EXPR = 46
  TYPE_OF = 47
  TYPEDEF = 48
  UNARY_TRANSFORM = 49
  UNRESOLVED_USING = 50
  USING = 51
  VECTOR = 52
  EXT_VECTOR = 53
  QUALIFIED = 54

class TypeTagForDatatypeAttrSpelling(IntEnum):
  GNU_TYPE_TAG_FOR_DATATYPE = 0
  CXX11_CLANG_TYPE_TAG_FOR_DATATYPE = 1
  C23_CLANG_TYPE_TAG_FOR_DATATYPE = 2
  SPELLING_NOT_CALCULATED = 3

class TypeVisibilityAttrSpelling(IntEnum):
  GNU_TYPE_VISIBILITY = 0
  CXX11_CLANG_TYPE_VISIBILITY = 1
  C23_CLANG_TYPE_VISIBILITY = 2
  SPELLING_NOT_CALCULATED = 3

class TypeVisibilityAttrVisibilityType(IntEnum):
  DEFAULT = 0
  HIDDEN = 1
  PROTECTED = 2

class UnaryTransformTypeUTTKind(IntEnum):
  ADD_LVALUE_REFERENCE = 0
  ADD_POINTER = 1
  ADD_RVALUE_REFERENCE = 2
  DECAY = 3
  MAKE_SIGNED = 4
  MAKE_UNSIGNED = 5
  REMOVE_ALL_EXTENTS = 6
  REMOVE_CONST = 7
  REMOVE_CV = 8
  REMOVE_CV_REFERENCE = 9
  REMOVE_EXTENT = 10
  REMOVE_POINTER = 11
  REMOVE_REFERENCE = 12
  REMOVE_RESTRICT = 13
  REMOVE_VOLATILE = 14
  ENUM_UNDERLYING_TYPE = 15

class UnavailableAttrImplicitReason(IntEnum):
  NONE = 0
  ARC_FORBIDDEN_TYPE = 1
  FORBIDDEN_WEAK = 2
  ARC_FORBIDDEN_CONVERSION = 3
  ARC_INIT_RETURNS_UNRELATED = 4
  ARC_FIELD_WITH_OWNERSHIP = 5

class UnavailableAttrSpelling(IntEnum):
  GNU_UNAVAILABLE = 0
  CXX11_CLANG_UNAVAILABLE = 1
  C23_CLANG_UNAVAILABLE = 2
  SPELLING_NOT_CALCULATED = 3

class UninitializedAttrSpelling(IntEnum):
  GNU_UNINITIALIZED = 0
  CXX11_CLANG_UNINITIALIZED = 1
  SPELLING_NOT_CALCULATED = 2

class UnlikelyAttrSpelling(IntEnum):
  CXX11_UNLIKELY = 0
  C23_CLANG_UNLIKELY = 1
  SPELLING_NOT_CALCULATED = 2

class UnsafeBufferUsageAttrSpelling(IntEnum):
  GNU_UNSAFE_BUFFER_USAGE = 0
  CXX11_CLANG_UNSAFE_BUFFER_USAGE = 1
  C23_CLANG_UNSAFE_BUFFER_USAGE = 2
  SPELLING_NOT_CALCULATED = 3

class UnusedAttrSpelling(IntEnum):
  CXX11_MAYBE_UNUSED = 0
  GNU_UNUSED = 1
  CXX11_GNU_UNUSED = 2
  C23_GNU_UNUSED = 3
  C23_MAYBE_UNUSED = 4
  SPELLING_NOT_CALCULATED = 5

class UseHandleAttrSpelling(IntEnum):
  GNU_USE_HANDLE = 0
  CXX11_CLANG_USE_HANDLE = 1
  C23_CLANG_USE_HANDLE = 2
  SPELLING_NOT_CALCULATED = 3

class UsedAttrSpelling(IntEnum):
  GNU_USED = 0
  CXX11_GNU_USED = 1
  C23_GNU_USED = 2
  SPELLING_NOT_CALCULATED = 3

class UserDefinedLiteralLiteralOperatorKind(IntEnum):
  RAW = 0
  TEMPLATE = 1
  INTEGER = 2
  FLOATING = 3
  STRING = 4
  CHARACTER = 5

class UsingIfExistsAttrSpelling(IntEnum):
  GNU_USING_IF_EXISTS = 0
  CXX11_CLANG_USING_IF_EXISTS = 1
  SPELLING_NOT_CALCULATED = 2

class UuidAttrSpelling(IntEnum):
  DECLSPEC_UUID = 0
  MICROSOFT_UUID = 1
  SPELLING_NOT_CALCULATED = 2

class VarDeclDefinitionKind(IntEnum):
  DECLARATION_ONLY = 0
  TENTATIVE_DEFINITION = 1
  DEFINITION = 2

class VarDeclInitializationStyle(IntEnum):
  C_INIT = 0
  CALL_INITIALIZER = 1
  LIST_INITIALIZER = 2
  PARENTHESIS_LIST_INITIALIZER = 3

class VarDeclTLSKind(IntEnum):
  NONE = 0
  STATIC = 1
  DYNAMIC = 2

class VecReturnAttrSpelling(IntEnum):
  GNU_VECRETURN = 0
  CXX11_CLANG_VECRETURN = 1
  SPELLING_NOT_CALCULATED = 2

class VectorCallAttrSpelling(IntEnum):
  GNU_VECTORCALL = 0
  CXX11_CLANG_VECTORCALL = 1
  C23_CLANG_VECTORCALL = 2
  KEYWORD_VECTORCALL = 3
  SPELLING_NOT_CALCULATED = 4

class VisibilityAttrSpelling(IntEnum):
  GNU_VISIBILITY = 0
  CXX11_GNU_VISIBILITY = 1
  C23_GNU_VISIBILITY = 2
  SPELLING_NOT_CALCULATED = 3

class VisibilityAttrVisibilityType(IntEnum):
  DEFAULT = 0
  HIDDEN = 1
  PROTECTED = 2

class WarnUnusedAttrSpelling(IntEnum):
  GNU_WARN_UNUSED = 0
  CXX11_GNU_WARN_UNUSED = 1
  C23_GNU_WARN_UNUSED = 2
  SPELLING_NOT_CALCULATED = 3

class WarnUnusedResultAttrSpelling(IntEnum):
  CXX11_NODISCARD = 0
  C23_NODISCARD = 1
  CXX11_CLANG_WARN_UNUSED_RESULT = 2
  GNU_WARN_UNUSED_RESULT = 3
  CXX11_GNU_WARN_UNUSED_RESULT = 4
  C23_GNU_WARN_UNUSED_RESULT = 5
  SPELLING_NOT_CALCULATED = 6

class WeakAttrSpelling(IntEnum):
  GNU_WEAK = 0
  CXX11_GNU_WEAK = 1
  C23_GNU_WEAK = 2
  SPELLING_NOT_CALCULATED = 3

class WeakImportAttrSpelling(IntEnum):
  GNU_WEAK_IMPORT = 0
  CXX11_CLANG_WEAK_IMPORT = 1
  C23_CLANG_WEAK_IMPORT = 2
  SPELLING_NOT_CALCULATED = 3

class WeakRefAttrSpelling(IntEnum):
  GNU_WEAKREF = 0
  CXX11_GNU_WEAKREF = 1
  C23_GNU_WEAKREF = 2
  SPELLING_NOT_CALCULATED = 3

class WebAssemblyExportNameAttrSpelling(IntEnum):
  GNU_EXPORT_NAME = 0
  CXX11_CLANG_EXPORT_NAME = 1
  C23_CLANG_EXPORT_NAME = 2
  SPELLING_NOT_CALCULATED = 3

class WebAssemblyImportModuleAttrSpelling(IntEnum):
  GNU_IMPORT_MODULE = 0
  CXX11_CLANG_IMPORT_MODULE = 1
  C23_CLANG_IMPORT_MODULE = 2
  SPELLING_NOT_CALCULATED = 3

class WebAssemblyImportNameAttrSpelling(IntEnum):
  GNU_IMPORT_NAME = 0
  CXX11_CLANG_IMPORT_NAME = 1
  C23_CLANG_IMPORT_NAME = 2
  SPELLING_NOT_CALCULATED = 3

class X86ForceAlignArgPointerAttrSpelling(IntEnum):
  GNU_FORCE_ALIGN_ARGUMENT_POINTER = 0
  CXX11_GNU_FORCE_ALIGN_ARGUMENT_POINTER = 1
  C23_GNU_FORCE_ALIGN_ARGUMENT_POINTER = 2
  SPELLING_NOT_CALCULATED = 3

class XRayInstrumentAttrSpelling(IntEnum):
  GNU_XRAY_ALWAYS_INSTRUMENT = 0
  CXX11_CLANG_XRAY_ALWAYS_INSTRUMENT = 1
  C23_CLANG_XRAY_ALWAYS_INSTRUMENT = 2
  GNU_XRAY_NEVER_INSTRUMENT = 3
  CXX11_CLANG_XRAY_NEVER_INSTRUMENT = 4
  C23_CLANG_XRAY_NEVER_INSTRUMENT = 5
  SPELLING_NOT_CALCULATED = 6

class XRayLogArgsAttrSpelling(IntEnum):
  GNU_XRAY_LOG_ARGUMENTS = 0
  CXX11_CLANG_XRAY_LOG_ARGUMENTS = 1
  C23_CLANG_XRAY_LOG_ARGUMENTS = 2
  SPELLING_NOT_CALCULATED = 3

class ZeroCallUsedRegsAttrSpelling(IntEnum):
  GNU_ZERO_CALL_USED_REGS = 0
  CXX11_GNU_ZERO_CALL_USED_REGS = 1
  C23_GNU_ZERO_CALL_USED_REGS = 2
  SPELLING_NOT_CALCULATED = 3

class ZeroCallUsedRegsAttrZeroCallUsedRegsKind(IntEnum):
  SKIP = 0
  USED_GPR_ARG = 1
  USED_GPR = 2
  USED_ARGUMENT = 3
  USED = 4
  ALL_GPR_ARG = 5
  ALL_GPR = 6
  ALL_ARGUMENT = 7
  ALL = 8

class ASTDumpOutputFormat(IntEnum):
  DEFAULT = 0
  JSON = 1

class AccessSpecifier(IntEnum):
  PUBLIC = 0
  PROTECTED = 1
  PRIVATE = 2
  NONE = 3

class AddrSpaceMapMangling(IntEnum):
  TARGET = 0
  ON = 1
  OFF = 2

class AlignRequirementKind(IntEnum):
  NONE = 0
  REQUIRED_BY_TYPEDEF = 1
  REQUIRED_BY_RECORD = 2
  REQUIRED_BY_ENUM = 3

class AltivecSrcCompatKind(IntEnum):
  MIXED = 0
  GCC = 1
  XL = 2

class ArgumentKind(IntEnum):
  STD_STRING = 0
  C_STRING = 1
  SINT = 2
  UINT = 3
  TOKENKIND = 4
  IDENTIFIERINFO = 5
  ADDRSPACE = 6
  QUALIFIED = 7
  QUALTYPE = 8
  DECLARATIONNAME = 9
  NAMEDDECL = 10
  NESTEDNAMESPEC = 11
  DECLCONTEXT = 12
  QUALTYPE_PAIR = 13
  ATTRIBUTE = 14

class ArraySizeModifier(IntEnum):
  NORMAL = 0
  STATIC = 1
  STAR = 2

class ArrayTypeTrait(IntEnum):
  ARRAY_RANK = 0
  ARRAY_EXTENT = 1

class AtomicScopeModelKind(IntEnum):
  NONE = 0
  OPEN_CL = 1
  HIP = 2
  GENERIC = 3

class AutoTypeKeyword(IntEnum):
  AUTO = 0
  DECLTYPE_AUTO = 1
  GNU_AUTO_TYPE = 2

class AvailabilityResult(IntEnum):
  AVAILABLE = 0
  NOT_YET_INTRODUCED = 1
  DEPRECATED = 2
  UNAVAILABLE = 3

class BinaryOperatorKind(IntEnum):
  POINTER_MEMORY_D = 0
  POINTER_MEMORY_I = 1
  MUL = 2
  DIV = 3
  REM = 4
  ADD = 5
  SUB = 6
  SHL = 7
  SHR = 8
  CMP = 9
  LT = 10
  GT = 11
  LE = 12
  GE = 13
  EQ = 14
  NE = 15
  AND = 16
  XOR = 17
  OR = 18
  L_AND = 19
  L_OR = 20
  ASSIGN = 21
  MUL_ASSIGN = 22
  DIV_ASSIGN = 23
  REM_ASSIGN = 24
  ADD_ASSIGN = 25
  SUB_ASSIGN = 26
  SHL_ASSIGN = 27
  SHR_ASSIGN = 28
  AND_ASSIGN = 29
  XOR_ASSIGN = 30
  OR_ASSIGN = 31
  COMMA = 32

class Bits(IntEnum):
  NONE = 0
  UNEXPANDED_PACK = 1
  INSTANTIATION = 2
  TYPE = 3
  VALUE = 4
  DEPENDENT = 5
  ERROR = 6
  VARIABLY_MODIFIED = 7
  SYNTACTIC = 8
  SEMANTIC = 9

class CXXConstructionKind(IntEnum):
  COMPLETE = 0
  NON_VIRTUAL_BASE = 1
  VIRTUAL_BASE = 2
  DELEGATING = 3

class CXXNewInitializationStyle(IntEnum):
  NONE = 0
  PARENTHESES = 1
  BRACES = 2

class CallingConv(IntEnum):
  C = 0
  X86_STD_CALL = 1
  X86_FAST_CALL = 2
  X86_THIS_CALL = 3
  X86_VECTOR_CALL = 4
  X86_PASCAL = 5
  WIN64 = 6
  X8664_SYS_V = 7
  X86_REG_CALL = 8
  AAPCS = 9
  AAPCSVFP = 10
  INTEL_OCL_BICC = 11
  SPIR_FUNCTION = 12
  OPEN_CL_KERNEL = 13
  SWIFT = 14
  SWIFT_ASYNC = 15
  PRESERVE_MOST = 16
  PRESERVE_ALL = 17
  A_ARCH64_VECTOR_CALL = 18
  A_ARCH64_SVEPCS = 19
  AMDGPU_KERNEL_CALL = 20
  M68K_RTD = 21

class CanThrowResult(IntEnum):
  CANNOT = 0
  DEPENDENT = 1
  CAN = 2

class CapturedRegionKind(IntEnum):
  DEFAULT = 0
  OBJ_C_AT_FINALLY = 1
  OPEN_MP = 2

class CastKind(IntEnum):
  DEPENDENT = 0
  BIT_CAST = 1
  L_VALUE_BIT_CAST = 2
  L_VALUE_TO_R_VALUE_BIT_CAST = 3
  L_VALUE_TO_R_VALUE = 4
  NO_OPERATION = 5
  BASE_TO_DERIVED = 6
  DERIVED_TO_BASE = 7
  UNCHECKED_DERIVED_TO_BASE = 8
  DYNAMIC = 9
  TO_UNION = 10
  ARRAY_TO_POINTER_DECAY = 11
  FUNCTION_TO_POINTER_DECAY = 12
  NULL_TO_POINTER = 13
  NULL_TO_MEMBER_POINTER = 14
  BASE_TO_DERIVED_MEMBER_POINTER = 15
  DERIVED_TO_BASE_MEMBER_POINTER = 16
  MEMBER_POINTER_TO_BOOLEAN = 17
  REINTERPRET_MEMBER_POINTER = 18
  USER_DEFINED_CONVERSION = 19
  CONSTRUCTOR_CONVERSION = 20
  INTEGRAL_TO_POINTER = 21
  POINTER_TO_INTEGRAL = 22
  POINTER_TO_BOOLEAN = 23
  TO_VOID = 24
  MATRIX_CAST = 25
  VECTOR_SPLAT = 26
  INTEGRAL_CAST = 27
  INTEGRAL_TO_BOOLEAN = 28
  INTEGRAL_TO_FLOATING = 29
  FLOATING_TO_FIXED_POINT = 30
  FIXED_POINT_TO_FLOATING = 31
  FIXED_POINT_CAST = 32
  FIXED_POINT_TO_INTEGRAL = 33
  INTEGRAL_TO_FIXED_POINT = 34
  FIXED_POINT_TO_BOOLEAN = 35
  FLOATING_TO_INTEGRAL = 36
  FLOATING_TO_BOOLEAN = 37
  BOOLEAN_TO_SIGNED_INTEGRAL = 38
  FLOATING_CAST = 39
  C_POINTER_TO_OBJ_C_POINTER_CAST = 40
  BLOCK_POINTER_TO_OBJ_C_POINTER_CAST = 41
  ANY_POINTER_TO_BLOCK_POINTER_CAST = 42
  OBJ_C_OBJECT_L_VALUE_CAST = 43
  FLOATING_REAL_TO_COMPLEX = 44
  FLOATING_COMPLEX_TO_REAL = 45
  FLOATING_COMPLEX_TO_BOOLEAN = 46
  FLOATING_COMPLEX_CAST = 47
  FLOATING_COMPLEX_TO_INTEGRAL_COMPLEX = 48
  INTEGRAL_REAL_TO_COMPLEX = 49
  INTEGRAL_COMPLEX_TO_REAL = 50
  INTEGRAL_COMPLEX_TO_BOOLEAN = 51
  INTEGRAL_COMPLEX_CAST = 52
  INTEGRAL_COMPLEX_TO_FLOATING_COMPLEX = 53
  ARC_PRODUCE_OBJECT = 54
  ARC_CONSUME_OBJECT = 55
  ARC_RECLAIM_RETURNED_OBJECT = 56
  ARC_EXTEND_BLOCK_OBJECT = 57
  ATOMIC_TO_NON_ATOMIC = 58
  NON_ATOMIC_TO_ATOMIC = 59
  COPY_AND_AUTORELEASE_BLOCK_OBJECT = 60
  BUILTIN_FN_TO_FN_POINTER = 61
  ZERO_TO_OCL_OPAQUE_TYPE = 62
  ADDRESS_SPACE_CONVERSION = 63
  INT_TO_OCL_SAMPLER = 64

class CharacterLiteralKind(IntEnum):
  ASCII = 0
  WIDE = 1
  UTF8 = 2
  UTF16 = 3
  UTF32 = 4

class ClangABI(IntEnum):
  VER38 = 0
  VER4 = 1
  VER6 = 2
  VER7 = 3
  VER9 = 4
  VER11 = 5
  VER12 = 6
  VER14 = 7
  VER15 = 8
  VER17 = 9
  LATEST = 10

class CommentKind(IntEnum):
  INVALID = 0
  ORDINARY_BCPL = 1
  ORDINARY_C = 2
  BCPL_SLASH = 3
  BCPL_EXCL = 4
  JAVA_DOC = 5
  QT = 6
  MERGED = 7

class ComparisonCategoryResult(IntEnum):
  EQUAL = 0
  EQUIVALENT = 1
  LESS = 2
  GREATER = 3
  UNORDERED = 4

class ComparisonCategoryType(IntEnum):
  PARTIAL_ORDERING = 0
  WEAK_ORDERING = 1
  STRONG_ORDERING = 2

class CompilingModuleKind(IntEnum):
  NONE = 0
  MODULE_MAP = 1
  HEADER_UNIT = 2
  MODULE_INTERFACE = 3

class ComplexRangeKind(IntEnum):
  CX_FULL = 0
  CX_LIMITED = 1
  CX_FORTRAN = 2
  CX_NONE = 3

class ConstantResultStorageKind(IntEnum):
  NONE = 0
  INT64 = 1
  AP_VALUE = 2

class ConstexprSpecKind(IntEnum):
  UNSPECIFIED = 0
  CONSTEXPR = 1
  CONSTEVAL = 2
  CONSTINIT = 3

class CoreFoundationABI(IntEnum):
  UNSPECIFIED = 0
  STANDALONE = 1
  OBJECTIVE_C = 2
  SWIFT = 3
  SWIFT50 = 4
  SWIFT42 = 5
  SWIFT41 = 6

class DataPositionTy(IntEnum):
  POSX = 0
  POSV = 1
  POSE = 2
  POS_UPDATE_EXPRESSION = 3
  POSD = 4
  POS_CONDITION = 5
  POSR = 6

class DeductionCandidate(IntEnum):
  NORMAL = 0
  COPY = 1
  AGGREGATE = 2

class DefaultArgKind(IntEnum):
  NONE = 0
  UNPARSED = 1
  UNINSTANTIATED = 2
  NORMAL = 3

class DefaultCallingConvention(IntEnum):
  NONE = 0
  C_DECL = 1
  FAST_CALL = 2
  STD_CALL = 3
  VECTOR_CALL = 4
  REG_CALL = 5
  RTD_CALL = 6

class DefaultVisiblityExportMapping(IntEnum):
  NONE = 0
  EXPLICIT = 1
  ALL = 2

class DesignatorKind(IntEnum):
  FIELD_DESIGNATOR = 0
  ARRAY_DESIGNATOR = 1
  ARRAY_RANGE_DESIGNATOR = 2

class DiagnosticLevelMask(IntEnum):
  NONE = 0
  NOTE = 1
  REMARK = 2
  WARNING = 3
  ERROR = 4
  ALL = 5

class ElaboratedTypeKeyword(IntEnum):
  STRUCT = 0
  INTERFACE = 1
  UNION = 2
  CLASS = 3
  ENUM = 4
  TYPENAME = 5
  NONE = 6

class EscapeChar(IntEnum):
  SINGLE = 0
  DOUBLE = 1
  SINGLE_AND_DOUBLE = 2

class ExceptionHandlingKind(IntEnum):
  NONE = 0
  SJ_LJ = 1
  WIN_EH = 2
  DWARF_CFI = 3
  WASM = 4

class ExceptionSpecificationType(IntEnum):
  NONE = 0
  DYNAMIC_NONE = 1
  DYNAMIC = 2
  MS_ANY = 3
  NO_THROW = 4
  BASIC_NOEXCEPT = 5
  DEPENDENT_NOEXCEPT = 6
  NOEXCEPT_FALSE = 7
  NOEXCEPT_TRUE = 8
  UNEVALUATED = 9
  UNINSTANTIATED = 10
  UNPARSED = 11

class ExcessPrecisionKind(IntEnum):
  FPP_STANDARD = 0
  FPP_FAST = 1
  FPP_NONE = 2

class ExplicitSpecKind(IntEnum):
  RESOLVED_FALSE = 0
  RESOLVED_TRUE = 1
  UNRESOLVED = 2

class ExprDependence(IntEnum):
  UNEXPANDED_PACK = 0
  INSTANTIATION = 1
  TYPE = 2
  VALUE = 3
  ERROR = 4
  NONE = 5
  ALL = 6
  TYPE_VALUE = 7
  TYPE_INSTANTIATION = 8
  VALUE_INSTANTIATION = 9
  TYPE_VALUE_INSTANTIATION = 10
  ERROR_DEPENDENT = 11

class ExprObjectKind(IntEnum):
  ORDINARY = 0
  BIT_FIELD = 1
  VECTOR_COMPONENT = 2
  OBJ_C_PROPERTY = 3
  OBJ_C_SUBSCRIPT = 4
  MATRIX_COMPONENT = 5

class ExprOffsets(IntEnum):
  ALLOCATOR = 0
  ALLOCATOR_TRAITS = 1
  TOTAL = 2

class ExprValueKind(IntEnum):
  PR_VALUE = 0
  L_VALUE = 1
  X_VALUE = 2

class ExpressionTrait(IntEnum):
  IS_L_VALUE_EXPRESSION = 0
  IS_R_VALUE_EXPRESSION = 1

class ExtKind(IntEnum):
  ALWAYS = 0
  NEVER = 1
  REPLY_HAZY = 2

class ExtendArgsKind(IntEnum):
  EXTEND_TO32 = 0
  EXTEND_TO64 = 1

class FPEvalMethodKind(IntEnum):
  FEM_INDETERMINABLE = 0
  FEM_SOURCE = 1
  FEM_DOUBLE = 2
  FEM_EXTENDED = 3
  FEM_UNSET_ON_COMMAND_LINE = 4

class FPExceptionModeKind(IntEnum):
  IGNORE = 0
  MAY_TRAP = 1
  STRICT = 2
  DEFAULT = 3

class FPModeKind(IntEnum):
  OFF = 0
  ON = 1
  FAST = 2
  FAST_HONOR_PRAGMAS = 3

class Flags(IntEnum):
  F_INLINE = 0
  F_NESTED = 1

class GC(IntEnum):
  GC_NONE = 0
  WEAK = 1
  STRONG = 2

class GCMode(IntEnum):
  NON_GC = 0
  GC_ONLY = 1
  HYBRID_GC = 2

class GPUDefaultStreamKind(IntEnum):
  LEGACY = 0
  PER_THREAD = 1

class GVALinkage(IntEnum):
  INTERNAL = 0
  AVAILABLE_EXTERNALLY = 1
  DISCARDABLE_ODR = 2
  STRONG_EXTERNAL = 3
  STRONG_ODR = 4

class GetBuiltinTypeError(IntEnum):
  NONE = 0
  MISSING_TYPE = 1
  MISSING_STDIO = 2
  MISSING = 3
  MISSING_UCONTEXT = 4

class HLSLLangStd(IntEnum):
  HLSL_UNSET = 0
  HLSL2015 = 1
  HLSL2016 = 2
  HLSL2017 = 3
  HLSL2018 = 4
  HLSL2021 = 5
  HLSL202X = 6

class ID(IntEnum):
  WORK_GROUP = 0
  DEVICE = 1
  ALL_SVM_DEVICES = 2
  SUB_GROUP = 3

class IdentifierInfoFlag(IntEnum):
  ZERO_ARGUMENT = 0
  ONE_ARGUMENT = 1
  MULTI_ARGUMENT = 2

class IfStatementKind(IntEnum):
  ORDINARY = 0
  CONSTEXPR = 1
  CONSTEVAL_NON_NEGATED = 2
  CONSTEVAL_NEGATED = 3

class ImplicitParamKind(IntEnum):
  OBJ_C_SELF = 0
  OBJ_C_CMD = 1
  CXX_THIS = 2
  CXXVTT = 3
  CAPTURED_CONTEXT = 4
  THREAD_PRIVATE_VARIABLE = 5
  OTHER = 6

class InClassInitStyle(IntEnum):
  NO_INITIALIZER = 0
  COPY_INITIALIZER = 1
  LIST_INITIALIZER = 2

class InheritedDesignatedInitializersState(IntEnum):
  UNKNOWN = 0
  INHERITED = 1
  NOT_INHERITED = 2

class InitStorageKind(IntEnum):
  NO_INITIALIZER = 0
  IN_CLASS_COPY_INITIALIZER = 1
  IN_CLASS_LIST_INITIALIZER = 2
  CAPTURED_VLA_TYPE = 3

class InlineVariableDefinitionKind(IntEnum):
  NONE = 0
  WEAK = 1
  WEAK_UNKNOWN = 2
  STRONG = 3

class InterestingIdentifierKind(IntEnum):
  NOT_INTERESTING = 0
  FILE = 1
  JMP_BUF = 2
  SIGJMP_BUF = 3
  UCONTEXT_T = 4
  FLOAT_T = 5
  DOUBLE_T = 6
  NUMINTERESTINGIDENTIFIERS = 7

class Kinds(IntEnum):
  L_VALUE = 0
  X_VALUE = 1
  FUNCTION = 2
  VOID = 3
  ADDRESSABLE_VOID = 4
  DUPLICATE_VECTOR_COMPONENTS = 5
  MEMBER_FUNCTION = 6
  SUB_OBJ_C_PROPERTY_SETTING = 7
  CLASS_TEMPORARY = 8
  ARRAY_TEMPORARY = 9
  OBJ_C_MESSAGE_R_VALUE = 10
  PR_VALUE = 11

class LambdaCaptureDefault(IntEnum):
  NONE = 0
  BY_COPY = 1
  BY_REFERENCE = 2

class LambdaCaptureKind(IntEnum):
  THIS = 0
  STAR_THIS = 1
  BY_COPY = 2
  BY_REFERENCE = 3
  VLA_TYPE = 4

class LangAS(IntEnum):
  DEFAULT = 0
  OPENCL_GLOBAL = 1
  OPENCL_LOCAL = 2
  OPENCL_CONSTANT = 3
  OPENCL_PRIVATE = 4
  OPENCL_GENERIC = 5
  OPENCL_GLOBAL_DEVICE = 6
  OPENCL_GLOBAL_HOST = 7
  CUDA_DEVICE = 8
  CUDA_CONSTANT = 9
  CUDA_SHARED = 10
  SYCL_GLOBAL = 11
  SYCL_GLOBAL_DEVICE = 12
  SYCL_GLOBAL_HOST = 13
  SYCL_LOCAL = 14
  SYCL_PRIVATE = 15
  PTR32_SPTR = 16
  PTR32_UPTR = 17
  PTR64 = 18
  HLSL_GROUPSHARED = 19
  WASM_FUNCREF = 20

class LangFeatures(IntEnum):
  LINE_COMMENT = 0
  C99 = 1
  C11 = 2
  C17 = 3
  C23 = 4
  C_PLUS_PLUS = 5
  C_PLUS_PLUS11 = 6
  C_PLUS_PLUS14 = 7
  C_PLUS_PLUS17 = 8
  C_PLUS_PLUS20 = 9
  C_PLUS_PLUS23 = 10
  C_PLUS_PLUS26 = 11
  DIGRAPHS = 12
  GNU_MODE = 13
  HEX_FLOAT = 14
  OPEN_CL = 15
  HLSL = 16

class Language(IntEnum):
  UNKNOWN = 0
  ASSEMBLY = 1
  LLVMIR = 2
  C = 3
  CXX = 4
  OBJ_C = 5
  OBJ_CXX = 6
  OPEN_CL = 7
  OPEN_CLCXX = 8
  CUDA = 9
  RENDER_SCRIPT = 10
  HIP = 11
  HLSL = 12

class LanguageLinkage(IntEnum):
  C_LANGUAGE_LINKAGE = 0
  CXX_LANGUAGE_LINKAGE = 1
  NO_LANGUAGE_LINKAGE = 2

class LaxVectorConversionKind(IntEnum):
  NONE = 0
  INTEGER = 1
  ALL = 2

class Level(IntEnum):
  IGNORED = 0
  NOTE = 1
  REMARK = 2
  WARNING = 3
  ERROR = 4
  FATAL = 5

class Linkage(IntEnum):
  INVALID = 0
  NONE = 1
  INTERNAL = 2
  UNIQUE_EXTERNAL = 3
  VISIBLE_NONE = 4
  MODULE = 5
  EXTERNAL = 6

class LinkageSpecLanguageIDs(IntEnum):
  C = 0
  CXX = 1

class MSInheritanceModel(IntEnum):
  SINGLE = 0
  MULTIPLE = 1
  VIRTUAL = 2
  UNSPECIFIED = 3

class MSVCMajorVersion(IntEnum):
  MSVC2010 = 0
  MSVC2012 = 1
  MSVC2013 = 2
  MSVC2015 = 3
  MSVC2017 = 4
  MSVC20175 = 5
  MSVC20177 = 6
  MSVC2019 = 7
  MSVC20195 = 8
  MSVC20198 = 9
  MSVC20223 = 10

class MSVtorDispMode(IntEnum):
  NEVER = 0
  FOR_VIRTUAL_BASE_OVERRIDE = 1
  FOR_VF_TABLE = 2

class MethodRefFlags(IntEnum):
  METHOD_REFERENCE_NONE = 0
  METHOD_REFERENCE_GETTER = 1
  METHOD_REFERENCE_SETTER = 2

class ModifiableType(IntEnum):
  UNTESTED = 0
  MODIFIABLE = 1
  R_VALUE = 2
  FUNCTION = 3
  L_VALUE_CAST = 4
  NO_SETTER_PROPERTY = 5
  CONST_QUALIFIED = 6
  CONST_QUALIFIED_FIELD = 7
  CONST_ADDRESS_SPACE = 8
  ARRAY_TYPE = 9
  INCOMPLETE_TYPE = 10

class MultiVersionKind(IntEnum):
  NONE = 0
  TARGET = 1
  CPU_SPECIFIC = 2
  CPU_DISPATCH = 3
  TARGET_CLONES = 4
  TARGET_VERSION = 5

class NameKind(IntEnum):
  TEMPLATE = 0
  OVERLOADED_TEMPLATE = 1
  ASSUMED_TEMPLATE = 2
  QUALIFIED_TEMPLATE = 3
  DEPENDENT_TEMPLATE = 4
  SUBST_TEMPLATE_TEMPLATE_PARM = 5
  SUBST_TEMPLATE_TEMPLATE_PARM_PACK = 6
  USING_TEMPLATE = 7

class NeedExtraManglingDecl(IntEnum):
  NEED_EXTRA_MANGLING_DECLARATION = 0

class NestedNameSpecifierDependence(IntEnum):
  UNEXPANDED_PACK = 0
  INSTANTIATION = 1
  DEPENDENT = 2
  ERROR = 3
  NONE = 4
  DEPENDENT_INSTANTIATION = 5
  ALL = 6

class NonOdrUseReason(IntEnum):
  NONE = 0
  UNEVALUATED = 1
  CONSTANT = 2
  DISCARDED = 3

class NonceObjCInterface(IntEnum):
  OBJ_C_INTERFACE = 0

class NullabilityKind(IntEnum):
  NON_NULL = 0
  NULLABLE = 1
  UNSPECIFIED = 2
  NULLABLE_RESULT = 3

class OMPDeclareReductionInitKind(IntEnum):
  CALL = 0
  DIRECT = 1
  COPY = 2

class ObjCBridgeCastKind(IntEnum):
  BRIDGE = 0
  BRIDGE_TRANSFER = 1
  BRIDGE_RETAINED = 2

class ObjCImplementationControl(IntEnum):
  NONE = 0
  REQUIRED = 1
  OPTIONAL = 2

class ObjCInstanceTypeFamily(IntEnum):
  NONE = 0
  ARRAY = 1
  DICTIONARY = 2
  SINGLETON = 3
  INITIALIZER = 4
  RETURNS_SELF = 5

class ObjCLifetime(IntEnum):
  NONE = 0
  EXPLICIT_NONE = 1
  STRONG = 2
  WEAK = 3
  AUTORELEASING = 4

class ObjCMethodFamily(IntEnum):
  NONE = 0
  ALLOC = 1
  COPY = 2
  INITIALIZER = 3
  MUTABLE_COPY = 4
  NEW = 5
  AUTORELEASE = 6
  DEALLOC = 7
  FINALIZE = 8
  RELEASE = 9
  RETAIN = 10
  RETAIN_COUNT = 11
  SELF = 12
  INITIALIZE = 13
  PERFORM_SELECTOR = 14

class ObjCPropertyQueryKind(IntEnum):
  QUERY_UNKNOWN = 0
  QUERY_INSTANCE = 1
  QUERY_CLASS = 2

class ObjCStringFormatFamily(IntEnum):
  NONE = 0
  NS_STRING = 1
  CF_STRING = 2

class ObjCSubstitutionContext(IntEnum):
  ORDINARY = 0
  RESULT = 1
  PARAMETER = 2
  PROPERTY = 3
  SUPERCLASS = 4

class ObjCTypeParamVariance(IntEnum):
  INVARIANT = 0
  COVARIANT = 1
  CONTRAVARIANT = 2

class OnOffSwitch(IntEnum):
  ON = 0
  OFF = 1
  DEFAULT = 2

class OnStackType(IntEnum):
  ON_STACK = 0

class OpenMPAdjustArgsOpKind(IntEnum):
  ADJUSTARGS_NOTHING = 0
  ADJUSTARGS_NEED_DEVICE_POINTER = 1
  ADJUSTARGS_UNKNOWN = 2

class OpenMPAtClauseKind(IntEnum):
  AT_COMPILATION = 0
  AT_EXECUTION = 1
  AT_UNKNOWN = 2

class OpenMPAtomicDefaultMemOrderClauseKind(IntEnum):
  SEQ_CST = 0
  ACQ_REL = 1
  RELAXED = 2
  UNKNOWN = 3

class OpenMPBindClauseKind(IntEnum):
  BIND_TEAMS = 0
  BIND_PARALLEL = 1
  BIND_THREAD = 2
  BIND_UNKNOWN = 3

class OpenMPDefaultmapClauseKind(IntEnum):
  SCALAR = 0
  AGGREGATE = 1
  POINTER = 2
  UNKNOWN = 3

class OpenMPDefaultmapClauseModifier(IntEnum):
  UNKNOWN = 0
  ALLOC = 1
  TO = 2
  FROM = 3
  TOFROM = 4
  NONE = 5
  DEFAULT = 6
  PRESENT = 7

class OpenMPDependClauseKind(IntEnum):
  IN = 0
  OUT = 1
  INOUT = 2
  MUTEXINOUTSET = 3
  DEPOBJ = 4
  SOURCE = 5
  SINK = 6
  INOUTSET = 7
  OUTALLMEMORY = 8
  INOUTALLMEMORY = 9
  UNKNOWN = 10

class OpenMPDeviceClauseModifier(IntEnum):
  ANCESTOR = 0
  DEVICE_NUM = 1
  UNKNOWN = 2

class OpenMPDeviceType(IntEnum):
  HOST = 0
  NOHOST = 1
  ANY = 2
  UNKNOWN = 3

class OpenMPDistScheduleClauseKind(IntEnum):
  STATIC = 0
  UNKNOWN = 1

class OpenMPDoacrossClauseModifier(IntEnum):
  DOACROSS_SOURCE = 0
  DOACROSS_SINK = 1
  DOACROSS_SINK_OMP_CUR_ITERATION = 2
  DOACROSS_SOURCE_OMP_CUR_ITERATION = 3
  DOACROSS_UNKNOWN = 4

class OpenMPGrainsizeClauseModifier(IntEnum):
  GRAINSIZE_STRICT = 0
  GRAINSIZE_UNKNOWN = 1

class OpenMPLastprivateModifier(IntEnum):
  CONDITIONAL = 0
  UNKNOWN = 1

class OpenMPLinearClauseKind(IntEnum):
  VALUE = 0
  REFERENCE = 1
  UVAL = 2
  STEP = 3
  UNKNOWN = 4

class OpenMPMapClauseKind(IntEnum):
  ALLOC = 0
  TO = 1
  FROM = 2
  TOFROM = 3
  DELETE = 4
  RELEASE = 5
  UNKNOWN = 6

class OpenMPMapModifierKind(IntEnum):
  UNKNOWN = 0
  ALWAYS = 1
  CLOSE = 2
  MAPPER = 3
  ITERATOR = 4
  PRESENT = 5
  OMPX_HOLD = 6

class OpenMPMotionModifierKind(IntEnum):
  MOTIONMODIFIER_MAPPER = 0
  MOTIONMODIFIER_PRESENT = 1
  MOTIONMODIFIER_UNKNOWN = 2

class OpenMPNumTasksClauseModifier(IntEnum):
  NUMTASKS_STRICT = 0
  NUMTASKS_UNKNOWN = 1

class OpenMPOrderClauseKind(IntEnum):
  CONCURRENT = 0
  UNKNOWN = 1

class OpenMPOrderClauseModifier(IntEnum):
  MODIFIER_UNKNOWN = 0
  MODIFIER_REPRODUCIBLE = 1
  MODIFIER_UNCONSTRAINED = 2
  MODIFIER_LAST = 3

class OpenMPReductionClauseModifier(IntEnum):
  DEFAULT = 0
  INSCAN = 1
  TASK = 2
  UNKNOWN = 3

class OpenMPScheduleClauseKind(IntEnum):
  STATIC = 0
  DYNAMIC = 1
  GUIDED = 2
  AUTO = 3
  RUNTIME = 4
  UNKNOWN = 5

class OpenMPScheduleClauseModifier(IntEnum):
  UNKNOWN = 0
  MONOTONIC = 1
  NONMONOTONIC = 2
  SIMD = 3

class OpenMPSeverityClauseKind(IntEnum):
  SEVERITY_FATAL = 0
  SEVERITY_WARNING = 1
  SEVERITY_UNKNOWN = 2

class OverloadedOperatorKind(IntEnum):
  NONE = 0
  NEW = 1
  DELETE = 2
  ARRAY_NEW = 3
  ARRAY_DELETE = 4
  PLUS = 5
  MINUS = 6
  STAR = 7
  SLASH = 8
  PERCENT = 9
  CARET = 10
  AMP = 11
  PIPE = 12
  TILDE = 13
  EXCLAIM = 14
  EQUAL = 15
  LESS = 16
  GREATER = 17
  PLUS_EQUAL = 18
  MINUS_EQUAL = 19
  STAR_EQUAL = 20
  SLASH_EQUAL = 21
  PERCENT_EQUAL = 22
  CARET_EQUAL = 23
  AMP_EQUAL = 24
  PIPE_EQUAL = 25
  LESS_LESS = 26
  GREATER_GREATER = 27
  LESS_LESS_EQUAL = 28
  GREATER_GREATER_EQUAL = 29
  EQUAL_EQUAL = 30
  EXCLAIM_EQUAL = 31
  LESS_EQUAL = 32
  GREATER_EQUAL = 33
  SPACESHIP = 34
  AMP_AMP = 35
  PIPE_PIPE = 36
  PLUS_PLUS = 37
  MINUS_MINUS = 38
  COMMA = 39
  ARROW_STAR = 40
  ARROW = 41
  CALL = 42
  SUBSCRIPT = 43
  CONDITIONAL = 44
  COAWAIT = 45

class OverloadsShown(IntEnum):
  ALL = 0
  BEST = 1

class ParameterABI(IntEnum):
  ORDINARY = 0
  SWIFT_INDIRECT_RESULT = 1
  SWIFT_ERROR_RESULT = 2
  SWIFT_CONTEXT = 3
  SWIFT_ASYNC_CONTEXT = 4

class ParenLocsOffsets(IntEnum):
  L_PAREN_TOKEN = 0
  R_PAREN_TOKEN = 1
  TOTAL = 2

class PragmaFPKind(IntEnum):
  PFK_CONTRACT = 0
  PFK_REASSOCIATE = 1
  PFK_RECIPROCAL = 2
  PFK_EXCEPTIONS = 3
  PFK_EVAL_METHOD = 4

class PragmaFloatControlKind(IntEnum):
  UNKNOWN = 0
  PRECISE = 1
  NO_PRECISE = 2
  EXCEPT = 3
  NO_EXCEPT = 4
  PUSH = 5
  POP = 6

class PragmaMSCommentKind(IntEnum):
  UNKNOWN = 0
  LINKER = 1
  LIB = 2
  COMPILER = 3
  EXE_STRING = 4
  USER = 5

class PragmaMSPointersToMembersKind(IntEnum):
  BEST_CASE = 0
  FULL_GENERALITY_SINGLE_INHERITANCE = 1
  FULL_GENERALITY_MULTIPLE_INHERITANCE = 2
  FULL_GENERALITY_VIRTUAL_INHERITANCE = 3

class PragmaMSStructKind(IntEnum):
  OFF = 0
  ON = 1

class PragmaSectionFlag(IntEnum):
  NONE = 0
  READ = 1
  WRITE = 2
  EXECUTE = 3
  IMPLICIT = 4
  ZERO_INITIALIZER = 5
  INVALID = 6

class PredefinedIdentKind(IntEnum):
  FUNC = 0
  FUNCTION = 1
  L_FUNCTION = 2
  FUNC_D_NAME = 3
  FUNC_SIG = 4
  L_FUNC_SIG = 5
  PRETTY_FUNCTION = 6
  PRETTY_FUNCTION_NO_VIRTUAL = 7

class Qualified(IntEnum):
  NONE = 0
  AS_WRITTEN = 1
  FULLY = 2

class RangeExprOffset(IntEnum):
  BEGIN = 0
  END = 1
  STEP = 2
  TOTAL = 3

class RangeLocOffset(IntEnum):
  ASSIGN_TOKEN = 0
  SECOND_COLON_TOKEN = 1
  TOTAL = 2

class RecordArgPassingKind(IntEnum):
  CAN_PASS_IN_REGS = 0
  CANNOT_PASS_IN_REGS = 1
  CAN_NEVER_PASS_IN_REGS = 2

class RefQualifierKind(IntEnum):
  NONE = 0
  L_VALUE = 1
  R_VALUE = 2

class ReservedIdentifierStatus(IntEnum):
  NOT_RESERVED = 0
  STARTS_WITH_UNDERSCORE_AT_GLOBAL_SCOPE = 1
  STARTS_WITH_UNDERSCORE_AND_IS_EXTERN_C = 2
  STARTS_WITH_DOUBLE_UNDERSCORE = 3
  STARTS_WITH_UNDERSCORE_FOLLOWED_BY_CAPITAL_LETTER = 4
  CONTAINS_DOUBLE_UNDERSCORE = 5

class ReservedLiteralSuffixIdStatus(IntEnum):
  NOT_RESERVED = 0
  NOT_STARTS_WITH_UNDERSCORE = 1
  CONTAINS_DOUBLE_UNDERSCORE = 2

class SFINAEResponse(IntEnum):
  SUBSTITUTION_FAILURE = 0
  SUPPRESS = 1
  REPORT = 2
  ACCESS_CONTROL = 3

class SYCLMajorVersion(IntEnum):
  VERSION_NONE = 0
  VERSION2017 = 1
  VERSION2020 = 2

class SanitizerOrdinal(IntEnum):
  ADDRESS = 0
  POINTER_COMPARE = 1
  POINTER_SUBTRACT = 2
  KERNEL_ADDRESS = 3
  HW_ADDRESS = 4
  KERNEL_HW_ADDRESS = 5
  MEMTAG_STACK = 6
  MEMTAG_HEAP = 7
  MEMTAG_GLOBALS = 8
  MEMORY_TAG_GROUP = 9
  MEMORY = 10
  KERNEL_MEMORY = 11
  FUZZER = 12
  FUZZER_NO_LINK = 13
  THREAD = 14
  LEAK = 15
  ALIGNMENT = 16
  ARRAY_BOUNDS = 17
  BOOLEAN = 18
  BUILTIN = 19
  ENUM = 20
  FLOAT_CAST_OVERFLOW = 21
  FLOAT_DIVIDE_BY_ZERO = 22
  FUNCTION = 23
  INTEGER_DIVIDE_BY_ZERO = 24
  NONNULL_ATTRIBUTE = 25
  NULL_ = 26
  NULLABILITY_ARGUMENT = 27
  NULLABILITY_ASSIGN = 28
  NULLABILITY_RETURN = 29
  NULLABILITY_GROUP = 30
  OBJECT_SIZE = 31
  POINTER_OVERFLOW = 32
  RETURN = 33
  RETURNS_NONNULL_ATTRIBUTE = 34
  SHIFT_BASE = 35
  SHIFT_EXPONENT = 36
  SHIFT_GROUP = 37
  SIGNED_INTEGER_OVERFLOW = 38
  UNREACHABLE = 39
  VLA_BOUND = 40
  VPTR = 41
  UNSIGNED_INTEGER_OVERFLOW = 42
  UNSIGNED_SHIFT_BASE = 43
  DATA_FLOW = 44
  CFI_CAST_STRICT = 45
  CFI_DERIVED_CAST = 46
  CFII_CALL = 47
  CFIMF_CALL = 48
  CFI_UNRELATED_CAST = 49
  CFINV_CALL = 50
  CFIV_CALL = 51
  CFI_GROUP = 52
  KCFI = 53
  SAFE_STACK = 54
  SHADOW_CALL_STACK = 55
  UNDEFINED_GROUP = 56
  UNDEFINED_TRAP_GROUP = 57
  IMPLICIT_UNSIGNED_INTEGER_TRUNCATION = 58
  IMPLICIT_SIGNED_INTEGER_TRUNCATION = 59
  IMPLICIT_INTEGER_TRUNCATION_GROUP = 60
  IMPLICIT_INTEGER_SIGN_CHANGE = 61
  IMPLICIT_INTEGER_ARITHMETIC_VALUE_CHANGE_GROUP = 62
  OBJ_C_CAST = 63
  IMPLICIT_CONVERSION_GROUP = 64
  INTEGER_GROUP = 65
  LOCAL_BOUNDS = 66
  BOUNDS_GROUP = 67
  SCUDO = 68
  ALL_GROUP = 69
  COUNT = 70

class SelectorLocationsKind(IntEnum):
  NON_STANDARD = 0
  STANDARD_NO_SPACE = 1
  STANDARD_WITH_SPACE = 2

class ShaderStage(IntEnum):
  PIXEL = 0
  VERTEX = 1
  GEOMETRY = 2
  HULL = 3
  DOMAIN_ = 4
  COMPUTE = 5
  LIBRARY = 6
  RAY_GENERATION = 7
  INTERSECTION = 8
  ANY_HIT = 9
  CLOSEST_HIT = 10
  MISS = 11
  CALLABLE = 12
  MESH = 13
  AMPLIFICATION = 14
  INVALID = 15

class SignReturnAddressKeyKind(IntEnum):
  A_KEY = 0
  B_KEY = 1

class SignReturnAddressScopeKind(IntEnum):
  NONE = 0
  NON_LEAF = 1
  ALL = 2

class SignedOverflowBehaviorTy(IntEnum):
  UNDEFINED = 0
  DEFINED = 1
  TRAPPING = 2

class SourceLocIdentKind(IntEnum):
  FUNCTION = 0
  FUNC_SIG = 1
  FILE = 2
  FILE_NAME = 3
  LINE = 4
  COLUMN = 5
  SOURCE_TOKEN_STRUCT = 6

class SpecialMemberFlags(IntEnum):
  DEFAULT_CONSTRUCTOR = 0
  COPY_CONSTRUCTOR = 1
  MOVE_CONSTRUCTOR = 2
  COPY_ASSIGNMENT = 3
  MOVE_ASSIGNMENT = 4
  DESTRUCTOR = 5
  ALL = 6

class SpecifierKind(IntEnum):
  IDENTIFIER = 0
  NAMESPACE = 1
  NAMESPACE_ALIAS = 2
  TYPE_SPEC = 3
  TYPE_SPEC_WITH_TEMPLATE = 4
  GLOBAL = 5
  SUPER = 6

class StackProtectorMode(IntEnum):
  OFF = 0
  ON = 1
  STRONG = 2
  REQ = 3

class StorageClass(IntEnum):
  NONE = 0
  EXTERN = 1
  STATIC = 2
  PRIVATE_EXTERN = 3
  AUTO = 4
  REGISTER = 5

class StorageDuration(IntEnum):
  FULL_EXPRESSION = 0
  AUTOMATIC = 1
  THREAD = 2
  STATIC = 3
  DYNAMIC = 4

class StoredNameKind(IntEnum):
  STORED_IDENTIFIER = 0
  STORED_OBJ_C_ZERO_ARGUMENT_SELECTOR = 1
  STORED_OBJ_C_ONE_ARGUMENT_SELECTOR = 2
  STORED_CXX_CONSTRUCTOR_NAME = 3
  STORED_CXX_DESTRUCTOR_NAME = 4
  STORED_CXX_CONVERSION_FUNCTION_NAME = 5
  STORED_CXX_OPERATOR_NAME = 6
  STORED_DECLARATION_NAME_EXTRA = 7
  UNCOMMON_NAME_KIND_OFFSET = 8

class StoredSpecifierKind(IntEnum):
  STORED_IDENTIFIER = 0
  STORED_DECLARATION = 1
  STORED_TYPE_SPEC = 2
  STORED_TYPE_SPEC_WITH_TEMPLATE = 3

class StrictFlexArraysLevelKind(IntEnum):
  DEFAULT = 0
  ONE_ZERO_OR_INCOMPLETE = 1
  ZERO_OR_INCOMPLETE = 2
  INCOMPLETE_ONLY = 3

class StringLiteralKind(IntEnum):
  ORDINARY = 0
  WIDE = 1
  UTF8 = 2
  UTF16 = 3
  UTF32 = 4
  UNEVALUATED = 5

class SubExpr(IntEnum):
  CALLEE = 0
  LHS = 1
  RHS = 2
  COUNT = 3

class SubStmt(IntEnum):
  BODY = 0
  PROMISE = 1
  INITIALIZER_SUSPEND = 2
  FINAL_SUSPEND = 3
  ON_EXCEPTION = 4
  ON_FALLTHROUGH = 5
  ALLOCATE = 6
  DEALLOCATE = 7
  RESULT_DECLARATION = 8
  RETURN_VALUE = 9
  RETURN_STATEMENT = 10
  RETURN_STATEMENT_ON_ALLOC_FAILURE = 11

class SyncScope(IntEnum):
  SYSTEM_SCOPE = 0
  DEVICE_SCOPE = 1
  WORKGROUP_SCOPE = 2
  WAVEFRONT_SCOPE = 3
  SINGLE_SCOPE = 4
  HIP_SINGLE_THREAD = 5
  HIP_WAVEFRONT = 6
  HIP_WORKGROUP = 7
  HIP_AGENT = 8
  HIP_SYSTEM = 9
  OPEN_CL_WORK_GROUP = 10
  OPEN_CL_DEVICE = 11
  OPEN_CL_ALL_SVM_DEVICES = 12
  OPEN_CL_SUB_GROUP = 13

class Syntax(IntEnum):
  GNU = 0
  CXX11 = 1
  C23 = 2
  DECLSPEC = 3
  MICROSOFT = 4
  KEYWORD = 5
  PRAGMA = 6
  CONTEXT_SENSITIVE_KEYWORD = 7
  HLSL_SEMANTIC = 8
  IMPLICIT = 9

class TQ(IntEnum):
  CONST = 0
  RESTRICT = 1
  VOLATILE = 2
  CVR_MASK = 3

class TagTypeKind(IntEnum):
  STRUCT = 0
  INTERFACE = 1
  UNION = 2
  CLASS = 3
  ENUM = 4

class TailPaddingUseRules(IntEnum):
  ALWAYS_USE_TAIL_PADDING = 0
  USE_TAIL_PADDING_UNLESS_POD03 = 1
  USE_TAIL_PADDING_UNLESS_POD11 = 2

class TemplateArgumentDependence(IntEnum):
  UNEXPANDED_PACK = 0
  INSTANTIATION = 1
  DEPENDENT = 2
  ERROR = 3
  NONE = 4
  DEPENDENT_INSTANTIATION = 5
  ALL = 6

class TemplateNameDependence(IntEnum):
  UNEXPANDED_PACK = 0
  INSTANTIATION = 1
  DEPENDENT = 2
  ERROR = 3
  NONE = 4
  DEPENDENT_INSTANTIATION = 5
  ALL = 6

class TemplateSpecializationKind(IntEnum):
  UNDECLARED = 0
  IMPLICIT_INSTANTIATION = 1
  EXPLICIT_SPECIALIZATION = 2
  EXPLICIT_INSTANTIATION_DECLARATION = 3
  EXPLICIT_INSTANTIATION_DEFINITION = 4

class TextDiagnosticFormat(IntEnum):
  CLANG = 0
  MSVC = 1
  VI = 2
  SARIF = 3

class ThreadModelKind(IntEnum):
  POSIX = 0
  SINGLE = 1

class ThreadStorageClassSpecifier(IntEnum):
  UNSPECIFIED = 0
  __THREAD = 1
  THREAD_LOCAL = 2
  _THREAD_LOCAL = 3

class TrailingAllocKind(IntEnum):
  TAK_INHERITS_CONSTRUCTOR = 0
  TAK_HAS_TAIL_EXPLICIT = 1

class TranslationUnitKind(IntEnum):
  COMPLETE = 0
  PREFIX = 1
  MODULE = 2
  INCREMENTAL = 3

class TrivialAutoVarInitKind(IntEnum):
  UNINITIALIZED = 0
  ZERO = 1
  PATTERN = 2

class TypeDependence(IntEnum):
  UNEXPANDED_PACK = 0
  INSTANTIATION = 1
  DEPENDENT = 2
  VARIABLY_MODIFIED = 3
  ERROR = 4
  NONE = 5
  ALL = 6
  DEPENDENT_INSTANTIATION = 7

class TypeLocClass(IntEnum):
  ADJUSTED = 0
  DECAYED = 1
  CONSTANT_ARRAY = 2
  DEPENDENT_SIZED_ARRAY = 3
  INCOMPLETE_ARRAY = 4
  VARIABLE_ARRAY = 5
  ATOMIC = 6
  ATTRIBUTED = 7
  BTF_TAG_ATTRIBUTED = 8
  BIT_INT = 9
  BLOCK_POINTER = 10
  BUILTIN = 11
  COMPLEX = 12
  DECLTYPE = 13
  AUTO = 14
  DEDUCED_TEMPLATE_SPECIALIZATION = 15
  DEPENDENT_ADDRESS_SPACE = 16
  DEPENDENT_BIT_INT = 17
  DEPENDENT_NAME = 18
  DEPENDENT_SIZED_EXT_VECTOR = 19
  DEPENDENT_TEMPLATE_SPECIALIZATION = 20
  DEPENDENT_VECTOR = 21
  ELABORATED = 22
  FUNCTION_NO_PROTO = 23
  FUNCTION_PROTO = 24
  INJECTED_CLASS_NAME = 25
  MACRO_QUALIFIED = 26
  CONSTANT_MATRIX = 27
  DEPENDENT_SIZED_MATRIX = 28
  MEMBER_POINTER = 29
  OBJ_C_OBJECT_POINTER = 30
  OBJ_C_OBJECT = 31
  OBJ_C_INTERFACE = 32
  OBJ_C_TYPE_PARAMETER = 33
  PACK_EXPANSION = 34
  PARENTHESIS = 35
  PIPE = 36
  POINTER = 37
  L_VALUE_REFERENCE = 38
  R_VALUE_REFERENCE = 39
  SUBST_TEMPLATE_TYPE_PARM_PACK = 40
  SUBST_TEMPLATE_TYPE_PARM = 41
  ENUM = 42
  RECORD = 43
  TEMPLATE_SPECIALIZATION = 44
  TEMPLATE_TYPE_PARM = 45
  TYPE_OF_EXPRESSION = 46
  TYPE_OF = 47
  TYPEDEF = 48
  UNARY_TRANSFORM = 49
  UNRESOLVED_USING = 50
  USING = 51
  VECTOR = 52
  EXT_VECTOR = 53
  QUALIFIED = 54

class TypeOfKind(IntEnum):
  QUALIFIED = 0
  UNQUALIFIED = 1

class TypeSpecifierSign(IntEnum):
  UNSPECIFIED = 0
  SIGNED = 1
  UNSIGNED = 2

class TypeSpecifierType(IntEnum):
  UNSPECIFIED = 0
  VOID = 1
  CHARACTER = 2
  WCHAR = 3
  CHAR8 = 4
  CHAR16 = 5
  CHAR32 = 6
  INT = 7
  INT128 = 8
  BITINT = 9
  HALF = 10
  FLOAT16 = 11
  ACCUM = 12
  FRACT = 13
  B_FLOAT16 = 14
  FLOAT = 15
  DOUBLE = 16
  FLOAT128 = 17
  IBM128 = 18
  BOOLEAN = 19
  DECIMAL32 = 20
  DECIMAL64 = 21
  DECIMAL128 = 22
  ENUM = 23
  UNION = 24
  STRUCT = 25
  CLASS = 26
  INTERFACE = 27
  TYPENAME = 28
  TYPEOF_TYPE = 29
  TYPEOF_EXPRESSION = 30
  TYPEOF_UNQUALIFIED_TYPE = 31
  TYPEOF_UNQUALIFIED_EXPRESSION = 32
  DECLTYPE = 33
  ADD_LVALUE_REFERENCE = 34
  ADD_POINTER = 35
  ADD_RVALUE_REFERENCE = 36
  DECAY = 37
  MAKE_SIGNED = 38
  MAKE_UNSIGNED = 39
  REMOVE_ALL_EXTENTS = 40
  REMOVE_CONST = 41
  REMOVE_CV = 42
  REMOVE_CVREF = 43
  REMOVE_EXTENT = 44
  REMOVE_POINTER = 45
  REMOVE_REFERENCE_T = 46
  REMOVE_RESTRICT = 47
  REMOVE_VOLATILE = 48
  UNDERLYING_TYPE = 49
  AUTO = 50
  DECLTYPE_AUTO = 51
  AUTO_TYPE = 52
  UNKNOWN_ANYTYPE = 53
  ATOMIC = 54
  IMAGE_1D_T = 55
  IMAGE_1D_ARRAY_T = 56
  IMAGE_1D_BUFFER_T = 57
  IMAGE_2D_T = 58
  IMAGE_2D_ARRAY_T = 59
  IMAGE_2D_DEPTH_T = 60
  IMAGE_2D_ARRAY_DEPTH_T = 61
  IMAGE_2D_MSAA_T = 62
  IMAGE_2D_ARRAY_MSAA_T = 63
  IMAGE_2D_MSAA_DEPTH_T = 64
  IMAGE_2D_ARRAY_MSAA_DEPTH_T = 65
  IMAGE_3D_T = 66
  ERROR = 67

class TypeSpecifierWidth(IntEnum):
  UNSPECIFIED = 0
  SHORT = 1
  LONG = 2
  LONG_LONG = 3

class TypeSpecifiersPipe(IntEnum):
  UNSPECIFIED = 0
  PIPE = 1

class TypeTrait(IntEnum):
  IS_INTERFACE_CLASS = 0
  IS_SEALED = 1
  IS_DESTRUCTIBLE = 2
  IS_TRIVIALLY_DESTRUCTIBLE = 3
  IS_NOTHROW_DESTRUCTIBLE = 4
  HAS_NOTHROW_MOVE_ASSIGN = 5
  HAS_TRIVIAL_MOVE_ASSIGN = 6
  HAS_TRIVIAL_MOVE_CONSTRUCTOR = 7
  HAS_NOTHROW_ASSIGN = 8
  HAS_NOTHROW_COPY = 9
  HAS_NOTHROW_CONSTRUCTOR = 10
  HAS_TRIVIAL_ASSIGN = 11
  HAS_TRIVIAL_COPY = 12
  HAS_TRIVIAL_DEFAULT_CONSTRUCTOR = 13
  HAS_TRIVIAL_DESTRUCTOR = 14
  HAS_VIRTUAL_DESTRUCTOR = 15
  IS_ABSTRACT = 16
  IS_AGGREGATE = 17
  IS_CLASS = 18
  IS_EMPTY = 19
  IS_ENUM = 20
  IS_FINAL = 21
  IS_LITERAL = 22
  IS_POD = 23
  IS_POLYMORPHIC = 24
  IS_STANDARD_LAYOUT = 25
  IS_TRIVIAL = 26
  IS_TRIVIALLY_COPYABLE = 27
  IS_UNION = 28
  HAS_UNIQUE_OBJECT_REPRESENTATIONS = 29
  IS_TRIVIALLY_RELOCATABLE = 30
  IS_TRIVIALLY_EQUALITY_COMPARABLE = 31
  IS_BOUNDED_ARRAY = 32
  IS_UNBOUNDED_ARRAY = 33
  IS_NULL_POINTER = 34
  IS_SCOPED_ENUM = 35
  IS_REFERENCEABLE = 36
  CAN_PASS_IN_REGS = 37
  IS_ARITHMETIC = 38
  IS_FLOATING_POINT = 39
  IS_INTEGRAL = 40
  IS_COMPLETE_TYPE = 41
  IS_VOID = 42
  IS_ARRAY = 43
  IS_FUNCTION = 44
  IS_REFERENCE = 45
  IS_LVALUE_REFERENCE = 46
  IS_RVALUE_REFERENCE = 47
  IS_FUNDAMENTAL = 48
  IS_OBJECT = 49
  IS_SCALAR = 50
  IS_COMPOUND = 51
  IS_POINTER = 52
  IS_MEMBER_OBJECT_POINTER = 53
  IS_MEMBER_FUNCTION_POINTER = 54
  IS_MEMBER_POINTER = 55
  IS_CONST = 56
  IS_VOLATILE = 57
  IS_SIGNED = 58
  IS_UNSIGNED = 59
  TYPE_COMPATIBLE = 60
  IS_NOTHROW_ASSIGNABLE = 61
  IS_ASSIGNABLE = 62
  IS_BASE_OF = 63
  IS_CONVERTIBLE_TO = 64
  IS_TRIVIALLY_ASSIGNABLE = 65
  REFERENCE_BINDS_TO_TEMPORARY = 66
  REFERENCE_CONSTRUCTS_FROM_TEMPORARY = 67
  IS_SAME = 68
  IS_CONVERTIBLE = 69
  XNU_TYPE_COMPATIBLE = 70
  IS_CONSTRUCTIBLE = 71
  IS_NOTHROW_CONSTRUCTIBLE = 72
  IS_TRIVIALLY_CONSTRUCTIBLE = 73

class UnaryExprOrTypeTrait(IntEnum):
  SIZE_OF = 0
  DATA_SIZE_OF = 1
  ALIGN_OF = 2
  PREFERRED_ALIGN_OF = 3
  POINTER_AUTH_TYPE_DISCRIMINATOR = 4
  XNU_TYPE_SIGNATURE = 5
  XNU_TYPE_SUMMARY = 6
  TMO_TYPE_GET_METADATA = 7
  VEC_STEP = 8
  OPEN_MP_REQUIRED_SIMD_ALIGN = 9
  VECTOR_ELEMENTS = 10

class UnaryOperatorKind(IntEnum):
  POST_INCREMENT = 0
  POST_DECREMENT = 1
  PRE_INCREMENT = 2
  PRE_DECREMENT = 3
  ADDRESS_OF = 4
  DEREF = 5
  PLUS = 6
  MINUS = 7
  NOT = 8
  L_NOT = 9
  REAL = 10
  IMAG = 11
  EXTENSION = 12
  COAWAIT = 13

class APValueKind(IntEnum):
  NONE = 0
  INDETERMINATE = 1
  INT = 2
  FLOAT = 3
  FIXED_POINT = 4
  COMPLEX_INT = 5
  COMPLEX_FLOAT = 6
  L_VALUE = 7
  VECTOR = 8
  ARRAY = 9
  STRUCT = 10
  UNION = 11
  MEMBER_POINTER = 12
  ADDRESS_LABEL_DIFF = 13

class VectorKind(IntEnum):
  GENERIC = 0
  ALTI_VEC_VECTOR = 1
  ALTI_VEC_PIXEL = 2
  ALTI_VEC_BOOLEAN = 3
  NEON = 4
  NEON_POLY = 5
  SVE_FIXED_LENGTH_DATA = 6
  SVE_FIXED_LENGTH_PREDICATE = 7
  RVV_FIXED_LENGTH_DATA = 8
  RVV_FIXED_LENGTH_MASK = 9

class Visibility(IntEnum):
  HIDDEN_VISIBILITY = 0
  PROTECTED_VISIBILITY = 1
  DEFAULT_VISIBILITY = 2

class VisibilityForcedKinds(IntEnum):
  FORCE_HIDDEN = 0
  FORCE_PROTECTED = 1
  FORCE_DEFAULT = 2
  SOURCE = 3

class VisibilityFromDLLStorageClassKinds(IntEnum):
  KEEP = 0
  DEFAULT = 1
  HIDDEN = 2
  PROTECTED = 3

class AttributeSyntax(IntEnum):
  GNU = 0
  CXX11 = 1
  C2X = 2
  DECLSPEC = 3
  MICROSOFT = 4
  KEYWORD = 5
  PRAGMA = 6
  CONTEXT_SENSITIVE_KEYWORD = 7

class DeclCategory(IntEnum):
  UNKNOWN = 0
  LOCAL_VARIABLE = 1
  GLOBAL_VARIABLE = 2
  PARAMETER_VARIABLE = 3
  FUNCTION = 4
  INSTANCE_METHOD = 5
  INSTANCE_MEMBER = 6
  CLASS_METHOD = 7
  CLASS_MEMBER = 8
  THIS = 9
  CLASS = 10
  STRUCTURE = 11
  UNION = 12
  CONCEPT = 13
  INTERFACE = 14
  ENUMERATION = 15
  ENUMERATOR = 16
  NAMESPACE = 17
  TYPE_ALIAS = 18
  TEMPLATE_TYPE_PARAMETER = 19
  TEMPLATE_VALUE_PARAMETER = 20
  LABEL = 21

class PseudoKind(IntEnum):
  TEMPLATE_ARGUMENT = 0
  TEMPLATE_PARAMETER_LIST = 1
  CXX_BASE_SPECIFIER = 2
  DESIGNATOR = 3
  CXX_CTOR_INITIALIZER = 4

class CXXCtorInitializer(multiplier.Entity):
  is_base_initializer: bool
  is_member_initializer: bool
  is_any_member_initializer: bool
  is_indirect_member_initializer: bool
  is_in_class_member_initializer: bool
  is_delegating_initializer: bool
  is_pack_expansion: bool
  is_base_virtual: Optional[bool]
  member: Optional[multiplier.ast.FieldDecl]
  any_member: Optional[multiplier.ast.FieldDecl]
  indirect_member: Optional[multiplier.ast.IndirectFieldDecl]
  initializer: Optional[multiplier.ast.Stmt]
  ellipsis_token: multiplier.frontend.Token
  member_token: multiplier.frontend.Token
  left_angle_token: multiplier.frontend.Token
  right_angle_token: multiplier.frontend.Token
  tokens: multiplier.frontend.TokenRange

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.CXXCtorInitializer) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.CXXCtorInitializer]) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

class Designator(multiplier.Entity):
  parent_declaration: Optional[multiplier.ast.Decl]
  parent_statement: Optional[multiplier.ast.Stmt]
  is_field_designator: bool
  is_array_designator: bool
  is_array_range_designator: bool
  field: Optional[multiplier.ast.FieldDecl]
  tokens: multiplier.frontend.TokenRange
  dot_token: multiplier.frontend.Token
  field_token: multiplier.frontend.Token
  left_bracket_token: multiplier.frontend.Token
  right_bracket_token: multiplier.frontend.Token
  ellipsis_token: multiplier.frontend.Token

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.Designator) -> Optional[multiplier.ast.Designator]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.Designator]) -> Optional[multiplier.ast.Designator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Designator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Designator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Designator]:
    ...

class CXXBaseSpecifier(multiplier.Entity):
  parent_declaration: Optional[multiplier.ast.Decl]
  tokens: multiplier.frontend.TokenRange
  base_type_token: multiplier.frontend.Token
  is_virtual: bool
  base_kind: multiplier.ast.TagTypeKind
  is_pack_expansion: bool
  constructors_are_inherited: bool
  ellipsis_token: multiplier.frontend.Token
  semantic_access_specifier: multiplier.ast.AccessSpecifier
  lexical_access_specifier: multiplier.ast.AccessSpecifier
  base_type: multiplier.ast.Type

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.CXXBaseSpecifier) -> Optional[multiplier.ast.CXXBaseSpecifier]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.CXXBaseSpecifier]) -> Optional[multiplier.ast.CXXBaseSpecifier]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXBaseSpecifier]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXBaseSpecifier]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXBaseSpecifier]:
    ...

class TemplateParameterList(multiplier.Entity):
  depth: int
  has_unexpanded_parameter_pack: bool
  has_parameter_pack: bool
  requires_clause: Optional[multiplier.ast.Expr]
  template_keyword_token: multiplier.frontend.Token
  left_angle_token: multiplier.frontend.Token
  right_angle_token: multiplier.frontend.Token
  tokens: multiplier.frontend.TokenRange
  num_parameters: int
  parameters: Iterable[multiplier.ast.NamedDecl]

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.TemplateParameterList) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.TemplateParameterList]) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

  def nth_parameter(self, n: int) -> Optional[multiplier.ast.NamedDecl]:
    ...

class TemplateArgument(multiplier.Entity):
  parent_declaration: Optional[multiplier.ast.Decl]
  parent_statement: Optional[multiplier.ast.Stmt]
  kind: multiplier.ast.TemplateArgumentKind
  is_empty: bool
  is_dependent: bool
  is_instantiation_dependent: bool
  contains_unexpanded_parameter_pack: bool
  is_pack_expansion: bool
  declaration: Optional[multiplier.ast.ValueDecl]
  type: Optional[multiplier.ast.Type]
  parameter_type_for_declaration: Optional[multiplier.ast.Type]
  null_pointer_type: Optional[multiplier.ast.Type]
  pack_elements: Optional[Sequence[multiplier.ast.TemplateArgument]]

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.TemplateArgument) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.TemplateArgument]) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class Attr(multiplier.Entity):
  token: multiplier.frontend.Token
  is_implicit: bool
  is_inherited: bool
  is_late_parsed: bool
  is_pack_expansion: bool
  kind: multiplier.ast.AttrKind
  tokens: multiplier.frontend.TokenRange

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index, kinds: Sequence[multiplier.ast.AttrKind]) -> Iterable[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment, kinds: Sequence[multiplier.ast.AttrKind]) -> Iterable[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File, kinds: Sequence[multiplier.ast.AttrKind]) -> Iterable[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Attr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Attr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.Attr) -> Optional[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Attr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Attr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlignValueAttr(multiplier.ast.Attr):
  alignment: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlignValueAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlignValueAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlignValueAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AliasAttr(multiplier.ast.Attr):
  aliasee: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AliasAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AliasAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AliasAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AbiTagAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AbiTagAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AbiTagAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AbiTagAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SPtrAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SPtrAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SPtrAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SPtrAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class Ptr64Attr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Ptr64Attr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Ptr64Attr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Ptr64Attr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class Ptr32Attr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Ptr32Attr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Ptr32Attr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Ptr32Attr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLPrivateAddressSpaceAttr(multiplier.ast.TypeAttr):
  semantic_spelling: multiplier.ast.OpenCLPrivateAddressSpaceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLPrivateAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLLocalAddressSpaceAttr(multiplier.ast.TypeAttr):
  semantic_spelling: multiplier.ast.OpenCLLocalAddressSpaceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLLocalAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLGlobalHostAddressSpaceAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLGlobalHostAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLGlobalDeviceAddressSpaceAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLGlobalDeviceAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLGlobalAddressSpaceAttr(multiplier.ast.TypeAttr):
  semantic_spelling: multiplier.ast.OpenCLGlobalAddressSpaceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLGlobalAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLGenericAddressSpaceAttr(multiplier.ast.TypeAttr):
  semantic_spelling: multiplier.ast.OpenCLGenericAddressSpaceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLGenericAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLConstantAddressSpaceAttr(multiplier.ast.TypeAttr):
  semantic_spelling: multiplier.ast.OpenCLConstantAddressSpaceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLConstantAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCKindOfAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCKindOfAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCKindOfAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCKindOfAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCInertUnsafeUnretainedAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCInertUnsafeUnretainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCGCAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCGCAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCGCAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCGCAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoDerefAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoDerefAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoDerefAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoDerefAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLParamModifierAttr(multiplier.ast.TypeAttr):
  merged_spelling: bool
  semantic_spelling: multiplier.ast.HLSLParamModifierAttrSpelling
  is_any_in: bool
  is_any_out: bool
  is_in: bool
  is_in_out: bool
  is_out: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLParamModifierAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLGroupSharedAddressSpaceAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLGroupSharedAddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CmseNSCallAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CmseNSCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CmseNSCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CmseNSCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BTFTypeTagAttr(multiplier.ast.TypeAttr):
  btf_type_tag: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BTFTypeTagAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BTFTypeTagAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BTFTypeTagAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmStreamingCompatibleAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmStreamingCompatibleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmStreamingAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmStreamingAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmStreamingAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmStreamingAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmPreservesAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmPreservesAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmPreservesAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmPreservesAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmOutAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmOutAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmOutAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmOutAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmMveStrictPolymorphismAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmMveStrictPolymorphismAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmInOutAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmInOutAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmInOutAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmInOutAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmInAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmInAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmInAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmInAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnnotateTypeAttr(multiplier.ast.TypeAttr):
  annotation: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnnotateTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnnotateTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnnotateTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AddressSpaceAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AddressSpaceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AddressSpaceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AddressSpaceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WebAssemblyFuncrefAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WebAssemblyFuncrefAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UPtrAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UPtrAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UPtrAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UPtrAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeNullableResultAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeNullableResultAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeNullableResultAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeNullableResultAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeNullableAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeNullableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeNullableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeNullableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeNullUnspecifiedAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeNullUnspecifiedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeNonNullAttr(multiplier.ast.TypeAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeNonNullAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeNonNullAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeNonNullAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ThreadAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ThreadAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ThreadAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ThreadAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftVersionedRemovalAttr(multiplier.ast.Attr):
  attribute_kind_to_remove: multiplier.ast.AttrKind
  is_replaced_by_active: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftVersionedRemovalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftVersionedAdditionAttr(multiplier.ast.Attr):
  additional_attribute: multiplier.ast.Attr
  is_replaced_by_active: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftVersionedAdditionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftObjCMembersAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftObjCMembersAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class StmtAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StmtAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StmtAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StmtAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLUnrollHintAttr(multiplier.ast.StmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLUnrollHintAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MustTailAttr(multiplier.ast.StmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MustTailAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MustTailAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MustTailAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LikelyAttr(multiplier.ast.StmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LikelyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LikelyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LikelyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FallThroughAttr(multiplier.ast.StmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FallThroughAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FallThroughAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FallThroughAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CodeAlignAttr(multiplier.ast.StmtAttr):
  alignment: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CodeAlignAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CodeAlignAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CodeAlignAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnlikelyAttr(multiplier.ast.StmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnlikelyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnlikelyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnlikelyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RenderScriptKernelAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RenderScriptKernelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OverloadableAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OverloadableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OverloadableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OverloadableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLAccessAttr(multiplier.ast.Attr):
  semantic_spelling: multiplier.ast.OpenCLAccessAttrSpelling
  is_read_only: bool
  is_read_write: bool
  is_write_only: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLAccessAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLAccessAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLAccessAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCRuntimeVisibleAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCRuntimeVisibleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCRuntimeNameAttr(multiplier.ast.Attr):
  metadata_name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCRuntimeNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCNonRuntimeProtocolAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCNonRuntimeProtocolAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCNonLazyClassAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCNonLazyClassAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCDirectMembersAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCDirectMembersAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCDirectAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCDirectAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCDirectAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCDirectAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCDesignatedInitializerAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCDesignatedInitializerAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCClassStubAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCClassStubAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCClassStubAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCClassStubAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCBoxableAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBoxableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBoxableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBoxableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPReferencedVarAttr(multiplier.ast.Attr):
  reference: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPReferencedVarAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPDeclareSimdDeclAttr(multiplier.ast.Attr):
  branch_state: multiplier.ast.OMPDeclareSimdDeclAttrBranchStateTy
  simdlen: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclareSimdDeclAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPCaptureKindAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCaptureKindAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoEscapeAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoEscapeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoEscapeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoEscapeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoBuiltinAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoBuiltinAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoBuiltinAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoBuiltinAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ModeAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ModeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ModeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ModeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ModeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LoopHintAttr(multiplier.ast.Attr):
  option: multiplier.ast.LoopHintAttrOptionType
  semantic_spelling: multiplier.ast.LoopHintAttrSpelling
  state: multiplier.ast.LoopHintAttrLoopHintState
  value: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LoopHintAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LoopHintAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LoopHintAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LoaderUninitializedAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LoaderUninitializedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InitSegAttr(multiplier.ast.Attr):
  section: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InitSegAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InitSegAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InitSegAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InheritableAttr(multiplier.ast.Attr):
  should_inherit_even_if_already_present: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InheritableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InheritableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InheritableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IBOutletCollectionAttr(multiplier.ast.InheritableAttr):
  interface: multiplier.ast.Type
  interface_token: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IBOutletCollectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IBOutletAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IBOutletAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IBOutletAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IBOutletAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IBActionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IBActionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IBActionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IBActionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HotAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HotAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HotAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HotAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HotAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HotAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLShaderAttr(multiplier.ast.InheritableAttr):
  type: multiplier.ast.HLSLShaderAttrShaderType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLShaderAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLShaderAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLShaderAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLResourceBindingAttr(multiplier.ast.InheritableAttr):
  slot: str
  space: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLResourceBindingAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLResourceAttr(multiplier.ast.InheritableAttr):
  is_rov: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLResourceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLResourceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLResourceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLNumThreadsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLNumThreadsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLAnnotationAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLAnnotationAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLSV_GroupIndexAttr(multiplier.ast.HLSLAnnotationAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLSV_GroupIndexAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HLSLSV_DispatchThreadIDAttr(multiplier.ast.HLSLAnnotationAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLSV_DispatchThreadIDAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class HIPManagedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HIPManagedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HIPManagedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HIPManagedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class GuardedVarAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GuardedVarAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GuardedVarAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GuardedVarAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class GuardedByAttr(multiplier.ast.InheritableAttr):
  argument: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GuardedByAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GuardedByAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GuardedByAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class GNUInlineAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GNUInlineAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GNUInlineAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GNUInlineAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FunctionReturnThunksAttr(multiplier.ast.InheritableAttr):
  thunk_type: multiplier.ast.FunctionReturnThunksAttrKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionReturnThunksAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FormatAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FormatAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FormatAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FormatAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FormatAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FormatArgAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FormatArgAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FormatArgAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FormatArgAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FlattenAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FlattenAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FlattenAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FlattenAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FlagEnumAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FlagEnumAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FlagEnumAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FlagEnumAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FinalAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.FinalAttrSpelling
  is_spelled_as_sealed: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FinalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FinalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FinalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FinalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FastCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FastCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FastCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FastCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ExternalSourceSymbolAttr(multiplier.ast.InheritableAttr):
  defined_in: str
  generated_declaration: bool
  language: str
  usr: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExternalSourceSymbolAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ExclusiveTrylockFunctionAttr(multiplier.ast.InheritableAttr):
  success_value: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExclusiveTrylockFunctionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ExcludeFromExplicitInstantiationAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExcludeFromExplicitInstantiationAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ErrorAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.ErrorAttrSpelling
  user_diagnostic: str
  is_error: bool
  is_warning: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ErrorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ErrorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ErrorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EnumExtensibilityAttr(multiplier.ast.InheritableAttr):
  extensibility: multiplier.ast.EnumExtensibilityAttrKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnumExtensibilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EnforceTCBLeafAttr(multiplier.ast.InheritableAttr):
  tcb_name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnforceTCBLeafAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EnforceTCBAttr(multiplier.ast.InheritableAttr):
  tcb_name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnforceTCBAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnforceTCBAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnforceTCBAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EnableIfAttr(multiplier.ast.InheritableAttr):
  condition: multiplier.ast.Expr
  message: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnableIfAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnableIfAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnableIfAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EmptyBasesAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EmptyBasesAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EmptyBasesAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EmptyBasesAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DisableTailCallsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DisableTailCallsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DisableTailCallsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DisableTailCallsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DisableSanitizerInstrumentationAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DisableSanitizerInstrumentationAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DiagnoseIfAttr(multiplier.ast.InheritableAttr):
  argument_dependent: bool
  condition: multiplier.ast.Expr
  diagnostic_type: multiplier.ast.DiagnoseIfAttrDiagnosticType
  message: str
  parent: multiplier.ast.NamedDecl
  is_error: bool
  is_warning: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DiagnoseIfAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DiagnoseIfAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DiagnoseIfAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DiagnoseAsBuiltinAttr(multiplier.ast.InheritableAttr):
  function: multiplier.ast.FunctionDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DiagnoseAsBuiltinAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DestructorAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DestructorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DestructorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DestructorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DeprecatedAttr(multiplier.ast.InheritableAttr):
  message: str
  replacement: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DeprecatedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeprecatedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeprecatedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DeclOrStmtAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DeclOrStmtAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeclOrStmtAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeclOrStmtAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlwaysInlineAttr(multiplier.ast.DeclOrStmtAttr):
  semantic_spelling: multiplier.ast.AlwaysInlineAttrSpelling
  is_clang_always_inline: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlwaysInlineAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlwaysInlineAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlwaysInlineAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SuppressAttr(multiplier.ast.DeclOrStmtAttr):
  is_gsl: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SuppressAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SuppressAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SuppressAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoMergeAttr(multiplier.ast.DeclOrStmtAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoMergeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoMergeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoMergeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoInlineAttr(multiplier.ast.DeclOrStmtAttr):
  is_clang_no_inline: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoInlineAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoInlineAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoInlineAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DLLImportStaticLocalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DLLImportStaticLocalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DLLImportAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DLLImportAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DLLImportAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DLLImportAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DLLExportStaticLocalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DLLExportStaticLocalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DLLExportAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DLLExportAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DLLExportAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DLLExportAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CountedByAttr(multiplier.ast.InheritableAttr):
  counted_by_field_token: multiplier.frontend.TokenRange

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CountedByAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CountedByAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CountedByAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CoroWrapperAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroWrapperAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroWrapperAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroWrapperAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CoroReturnTypeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroReturnTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CoroOnlyDestroyWhenCompleteAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroOnlyDestroyWhenCompleteAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CoroLifetimeBoundAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroLifetimeBoundAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CoroDisableLifetimeBoundAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroDisableLifetimeBoundAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConvergentAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConvergentAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConvergentAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConvergentAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConsumableSetOnReadAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConsumableSetOnReadAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConsumableAutoCastAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConsumableAutoCastAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConsumableAttr(multiplier.ast.InheritableAttr):
  default_state: multiplier.ast.ConsumableAttrConsumedState

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConsumableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConsumableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConsumableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConstructorAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConstructorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstructorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstructorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConstInitAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.ConstInitAttrSpelling
  is_constinit: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConstInitAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstInitAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstInitAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConstAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConstAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CommonAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CommonAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CommonAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CommonAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ColdAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ColdAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ColdAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ColdAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ColdAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CodeSegAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CodeSegAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CodeSegAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CodeSegAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CodeModelAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CodeModelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CodeModelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CodeModelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CmseNSEntryAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CmseNSEntryAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CmseNSEntryAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CmseNSEntryAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CleanupAttr(multiplier.ast.InheritableAttr):
  function_declaration: multiplier.ast.FunctionDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CleanupAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CleanupAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CleanupAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CapturedRecordAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CapturedRecordAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CapturedRecordAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CapturedRecordAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CapabilityAttr(multiplier.ast.InheritableAttr):
  name: str
  semantic_spelling: multiplier.ast.CapabilityAttrSpelling
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CallbackAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CallbackAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CallbackAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CallbackAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CallableWhenAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CallableWhenAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CallableWhenAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CallableWhenAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CXX11NoReturnAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.CXX11NoReturnAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXX11NoReturnAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDASharedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDASharedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDASharedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDASharedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDALaunchBoundsAttr(multiplier.ast.InheritableAttr):
  max_blocks: multiplier.ast.Expr
  max_threads: multiplier.ast.Expr
  min_blocks: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDALaunchBoundsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDAInvalidTargetAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDAInvalidTargetAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDAHostAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDAHostAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDAHostAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDAHostAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDAGlobalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDAGlobalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDAGlobalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDAGlobalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDADeviceBuiltinTextureTypeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDADeviceBuiltinTextureTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDADeviceBuiltinSurfaceTypeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDADeviceBuiltinSurfaceTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDADeviceAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDADeviceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDADeviceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDADeviceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CUDAConstantAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDAConstantAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDAConstantAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDAConstantAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CPUSpecificAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CPUSpecificAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CPUSpecificAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CPUSpecificAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CPUDispatchAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CPUDispatchAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CPUDispatchAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CPUDispatchAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFUnknownTransferAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFUnknownTransferAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFReturnsRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFReturnsRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFReturnsNotRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFReturnsNotRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFICanonicalJumpTableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFICanonicalJumpTableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFGuardAttr(multiplier.ast.InheritableAttr):
  guard: multiplier.ast.CFGuardAttrGuardArg

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFGuardAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFGuardAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFGuardAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFAuditedTransferAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFAuditedTransferAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CDeclAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CDeclAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CDeclAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CDeclAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class C11NoReturnAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.C11NoReturnAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.C11NoReturnAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.C11NoReturnAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BuiltinAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BuiltinAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BuiltinAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BuiltinAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BlocksAttr(multiplier.ast.InheritableAttr):
  type: multiplier.ast.BlocksAttrBlockType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BlocksAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BlocksAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BlocksAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BTFDeclTagAttr(multiplier.ast.InheritableAttr):
  btf_decl_tag: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BTFDeclTagAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BTFDeclTagAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BTFDeclTagAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BPFPreserveStaticOffsetAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BPFPreserveStaticOffsetAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BPFPreserveAccessIndexAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BPFPreserveAccessIndexAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AvailableOnlyInDefaultEvalMethodAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AvailableOnlyInDefaultEvalMethodAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AvailabilityAttr(multiplier.ast.InheritableAttr):
  message: str
  replacement: str
  strict: bool
  unavailable: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AvailabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AvailabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AvailabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AssumptionAttr(multiplier.ast.InheritableAttr):
  assumption: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AssumptionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AssumptionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AssumptionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AssumeAlignedAttr(multiplier.ast.InheritableAttr):
  alignment: multiplier.ast.Expr
  offset: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AssumeAlignedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AssumeAlignedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AssumeAlignedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AssertSharedLockAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AssertSharedLockAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AssertSharedLockAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AssertSharedLockAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AssertExclusiveLockAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AssertExclusiveLockAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AssertCapabilityAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.AssertCapabilityAttrSpelling
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AssertCapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AssertCapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AssertCapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AsmLabelAttr(multiplier.ast.InheritableAttr):
  is_literal_label: bool
  label: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AsmLabelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AsmLabelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AsmLabelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArtificialAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArtificialAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArtificialAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArtificialAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmNewAttr(multiplier.ast.InheritableAttr):
  is_new_za: bool
  is_new_zt0: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmNewAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmNewAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmNewAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmLocallyStreamingAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmLocallyStreamingAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArmBuiltinAliasAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArmBuiltinAliasAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArgumentWithTypeTagAttr(multiplier.ast.InheritableAttr):
  is_pointer: bool
  semantic_spelling: multiplier.ast.ArgumentWithTypeTagAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArgumentWithTypeTagAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArcWeakrefUnavailableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArcWeakrefUnavailableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnyX86NoCfCheckAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnyX86NoCfCheckAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnyX86NoCallerSavedRegistersAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnyX86NoCallerSavedRegistersAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnyX86InterruptAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnyX86InterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnalyzerNoReturnAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnalyzerNoReturnAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlwaysDestroyAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlwaysDestroyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AllocSizeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AllocSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AllocSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AllocSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AllocAlignAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AllocAlignAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AllocAlignAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AllocAlignAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlignedAttr(multiplier.ast.InheritableAttr):
  alignment_expression: Optional[multiplier.ast.Expr]
  alignment_type: Optional[multiplier.ast.Type]
  cached_alignment_value: Optional[int]
  semantic_spelling: multiplier.ast.AlignedAttrSpelling
  is_alignas: bool
  is_alignment_dependent: bool
  is_alignment_error_dependent: bool
  is_alignment_expression: bool
  is_c11: bool
  is_declspec: bool
  is_gnu: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlignedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlignedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlignedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlignNaturalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlignNaturalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlignNaturalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlignNaturalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AlignMac68kAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AlignMac68kAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AlignMac68kAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AlignMac68kAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AcquiredBeforeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AcquiredBeforeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AcquiredAfterAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AcquiredAfterAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AcquiredAfterAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AcquiredAfterAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AcquireHandleAttr(multiplier.ast.InheritableAttr):
  handle_type: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AcquireHandleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AcquireHandleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AcquireHandleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AcquireCapabilityAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.AcquireCapabilityAttrSpelling
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AcquireCapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AVRSignalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AVRSignalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AVRSignalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AVRSignalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AVRInterruptAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AVRInterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AVRInterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AVRInterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ARMInterruptAttr(multiplier.ast.InheritableAttr):
  interrupt: multiplier.ast.ARMInterruptAttrInterruptType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ARMInterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ARMInterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ARMInterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AMDGPUWavesPerEUAttr(multiplier.ast.InheritableAttr):
  max: multiplier.ast.Expr
  min: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AMDGPUWavesPerEUAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AMDGPUNumVGPRAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AMDGPUNumVGPRAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AMDGPUNumSGPRAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AMDGPUNumSGPRAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AMDGPUKernelCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AMDGPUKernelCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AMDGPUFlatWorkGroupSizeAttr(multiplier.ast.InheritableAttr):
  max: multiplier.ast.Expr
  min: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AMDGPUFlatWorkGroupSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AArch64VectorPcsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AArch64VectorPcsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AArch64SVEPcsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AArch64SVEPcsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ZeroCallUsedRegsAttr(multiplier.ast.InheritableAttr):
  zero_call_used_regs: multiplier.ast.ZeroCallUsedRegsAttrZeroCallUsedRegsKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ZeroCallUsedRegsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class XRayLogArgsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.XRayLogArgsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.XRayLogArgsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.XRayLogArgsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class XRayInstrumentAttr(multiplier.ast.InheritableAttr):
  always_x_ray_instrument: bool
  semantic_spelling: multiplier.ast.XRayInstrumentAttrSpelling
  never_x_ray_instrument: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.XRayInstrumentAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.XRayInstrumentAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.XRayInstrumentAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class X86ForceAlignArgPointerAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.X86ForceAlignArgPointerAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WorkGroupSizeHintAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WorkGroupSizeHintAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WebAssemblyImportNameAttr(multiplier.ast.InheritableAttr):
  import_name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WebAssemblyImportNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WebAssemblyImportModuleAttr(multiplier.ast.InheritableAttr):
  import_module: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WebAssemblyImportModuleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WebAssemblyExportNameAttr(multiplier.ast.InheritableAttr):
  export_name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WebAssemblyExportNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WeakRefAttr(multiplier.ast.InheritableAttr):
  aliasee: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WeakRefAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WeakRefAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WeakRefAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WeakImportAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WeakImportAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WeakImportAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WeakImportAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WeakAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WeakAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WeakAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WeakAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WeakAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WarnUnusedResultAttr(multiplier.ast.InheritableAttr):
  is_cxx11_no_discard: bool
  message: str
  semantic_spelling: multiplier.ast.WarnUnusedResultAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WarnUnusedResultAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class WarnUnusedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WarnUnusedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WarnUnusedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WarnUnusedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VisibilityAttr(multiplier.ast.InheritableAttr):
  visibility: multiplier.ast.VisibilityAttrVisibilityType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VisibilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VisibilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VisibilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VectorCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VectorCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VectorCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VectorCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VecTypeHintAttr(multiplier.ast.InheritableAttr):
  type_hint: multiplier.ast.Type
  type_hint_token: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VecTypeHintAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VecTypeHintAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VecTypeHintAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VecReturnAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VecReturnAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VecReturnAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VecReturnAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UuidAttr(multiplier.ast.InheritableAttr):
  guid: str
  guid_declaration: multiplier.ast.MSGuidDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UuidAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UuidAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UuidAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UuidAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UsingIfExistsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingIfExistsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingIfExistsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingIfExistsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UsedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnusedAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.UnusedAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnusedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnusedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnusedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnsafeBufferUsageAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnsafeBufferUsageAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UninitializedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UninitializedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UninitializedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UninitializedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnavailableAttr(multiplier.ast.InheritableAttr):
  implicit_reason: multiplier.ast.UnavailableAttrImplicitReason
  message: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnavailableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnavailableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnavailableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeVisibilityAttr(multiplier.ast.InheritableAttr):
  visibility: multiplier.ast.TypeVisibilityAttrVisibilityType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeVisibilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeVisibilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeVisibilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeTagForDatatypeAttr(multiplier.ast.InheritableAttr):
  layout_compatible: bool
  matching_c_type: multiplier.ast.Type
  matching_c_type_token: multiplier.ast.Type
  must_be_null: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeTagForDatatypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TryAcquireCapabilityAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.TryAcquireCapabilityAttrSpelling
  success_value: multiplier.ast.Expr
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TryAcquireCapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TrivialABIAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TrivialABIAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TrivialABIAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TrivialABIAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TransparentUnionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TransparentUnionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TransparentUnionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TransparentUnionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ThisCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ThisCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ThisCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ThisCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TestTypestateAttr(multiplier.ast.InheritableAttr):
  test_state: multiplier.ast.TestTypestateAttrConsumedState

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TestTypestateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TestTypestateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TestTypestateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TargetVersionAttr(multiplier.ast.InheritableAttr):
  name: str
  names_string: str
  is_default_version: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TargetVersionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TargetVersionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TargetVersionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TargetClonesAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TargetClonesAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TargetClonesAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TargetClonesAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TargetAttr(multiplier.ast.InheritableAttr):
  architecture: str
  features_string: str
  is_default_version: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TargetAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TargetAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TargetAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TargetAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TLSModelAttr(multiplier.ast.InheritableAttr):
  model: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TLSModelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TLSModelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TLSModelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SysVABIAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SysVABIAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SysVABIAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SysVABIAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftPrivateAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftPrivateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftPrivateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftPrivateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftNewTypeAttr(multiplier.ast.InheritableAttr):
  newtype_kind: multiplier.ast.SwiftNewTypeAttrNewtypeKind
  semantic_spelling: multiplier.ast.SwiftNewTypeAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftNewTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftNameAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftImportPropertyAsAccessorsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftImportPropertyAsAccessorsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftImportAsNonGenericAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftImportAsNonGenericAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftErrorAttr(multiplier.ast.InheritableAttr):
  convention: multiplier.ast.SwiftErrorAttrConventionKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftErrorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftErrorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftErrorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftBridgedTypedefAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftBridgedTypedefAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftBridgeAttr(multiplier.ast.InheritableAttr):
  swift_type: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftBridgeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftBridgeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftBridgeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAttrAttr(multiplier.ast.InheritableAttr):
  attribute: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAttrAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAttrAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAttrAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAsyncNameAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAsyncNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAsyncErrorAttr(multiplier.ast.InheritableAttr):
  convention: multiplier.ast.SwiftAsyncErrorAttrConventionKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAsyncErrorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAsyncCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAsyncCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAsyncAttr(multiplier.ast.InheritableAttr):
  attribute_kind: multiplier.ast.SwiftAsyncAttrKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAsyncAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAsyncAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAsyncAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class StrictGuardStackCheckAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StrictGuardStackCheckAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class StrictFPAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StrictFPAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StrictFPAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StrictFPAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class StdCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StdCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StdCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StdCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class StandaloneDebugAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StandaloneDebugAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StandaloneDebugAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StandaloneDebugAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SpeculativeLoadHardeningAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SpeculativeLoadHardeningAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SharedTrylockFunctionAttr(multiplier.ast.InheritableAttr):
  success_value: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SharedTrylockFunctionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SetTypestateAttr(multiplier.ast.InheritableAttr):
  new_state: multiplier.ast.SetTypestateAttrConsumedState

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SetTypestateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SetTypestateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SetTypestateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SentinelAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SentinelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SentinelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SentinelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SelectAnyAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SelectAnyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SelectAnyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SelectAnyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SectionAttr(multiplier.ast.InheritableAttr):
  name: str
  semantic_spelling: multiplier.ast.SectionAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ScopedLockableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ScopedLockableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ScopedLockableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ScopedLockableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SYCLSpecialClassAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SYCLSpecialClassAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SYCLKernelAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SYCLKernelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SYCLKernelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SYCLKernelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReturnsTwiceAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReturnsTwiceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReturnsNonNullAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReturnsNonNullAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReturnTypestateAttr(multiplier.ast.InheritableAttr):
  state: multiplier.ast.ReturnTypestateAttrConsumedState

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReturnTypestateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReturnTypestateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReturnTypestateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RetainAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RetainAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RetainAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RetainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RetainAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RestrictAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.RestrictAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RestrictAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RestrictAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RestrictAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RequiresCapabilityAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.RequiresCapabilityAttrSpelling
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RequiresCapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReqdWorkGroupSizeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReqdWorkGroupSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReleaseCapabilityAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.ReleaseCapabilityAttrSpelling
  is_generic: bool
  is_shared: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReleaseCapabilityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReinitializesAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReinitializesAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReinitializesAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReinitializesAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RegCallAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RegCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RegCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RegCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReadOnlyPlacementAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReadOnlyPlacementAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RandomizeLayoutAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RandomizeLayoutAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RISCVInterruptAttr(multiplier.ast.InheritableAttr):
  interrupt: multiplier.ast.RISCVInterruptAttrInterruptType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RISCVInterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RISCVInterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RISCVInterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PureAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PureAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PureAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PureAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PureAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PureAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PtGuardedVarAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PtGuardedVarAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PtGuardedVarAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PtGuardedVarAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PtGuardedByAttr(multiplier.ast.InheritableAttr):
  argument: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PtGuardedByAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PtGuardedByAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PtGuardedByAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PreserveMostAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PreserveMostAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PreserveMostAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PreserveMostAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PreserveAllAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PreserveAllAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PreserveAllAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PreserveAllAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PreferredTypeAttr(multiplier.ast.InheritableAttr):
  type: multiplier.ast.Type
  type_token: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PreferredTypeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PreferredTypeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PreferredTypeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PreferredNameAttr(multiplier.ast.InheritableAttr):
  typedef_type: multiplier.ast.Type
  typedef_type_token: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PreferredNameAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PreferredNameAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PreferredNameAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PragmaClangTextSectionAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaClangTextSectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PragmaClangRodataSectionAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaClangRodataSectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PragmaClangRelroSectionAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaClangRelroSectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PragmaClangDataSectionAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaClangDataSectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PragmaClangBSSSectionAttr(multiplier.ast.InheritableAttr):
  name: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaClangBSSSectionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PointerAttr(multiplier.ast.InheritableAttr):
  dereferenced_type: Optional[multiplier.ast.Type]
  dereferenced_type_token: Optional[multiplier.ast.Type]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PointerAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PointerAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PointerAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PcsAttr(multiplier.ast.InheritableAttr):
  pcs: multiplier.ast.PcsAttrPCSType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PcsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PcsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PcsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PcsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PatchableFunctionEntryAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PatchableFunctionEntryAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PascalAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PascalAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PascalAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PascalAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PascalAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ParamTypestateAttr(multiplier.ast.InheritableAttr):
  parameter_state: multiplier.ast.ParamTypestateAttrConsumedState

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ParamTypestateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParamTypestateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParamTypestateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PackedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PackedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PackedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PackedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PackedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OwnershipAttr(multiplier.ast.InheritableAttr):
  own_kind: multiplier.ast.OwnershipAttrOwnershipKind
  semantic_spelling: multiplier.ast.OwnershipAttrSpelling
  is_holds: bool
  is_returns: bool
  is_takes: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OwnershipAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OwnershipAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OwnershipAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OwnerAttr(multiplier.ast.InheritableAttr):
  dereferenced_type: Optional[multiplier.ast.Type]
  dereferenced_type_token: Optional[multiplier.ast.Type]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OwnerAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OwnerAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OwnerAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OverrideAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OverrideAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OverrideAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OverrideAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OptimizeNoneAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OptimizeNoneAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OptimizeNoneAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OptimizeNoneAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLKernelAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLKernelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLKernelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLKernelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OpenCLIntelReqdSubGroupSizeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpenCLIntelReqdSubGroupSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCSubclassingRestrictedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCSubclassingRestrictedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCRootClassAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCRootClassAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCRootClassAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCRootClassAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCReturnsInnerPointerAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCReturnsInnerPointerAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCRequiresSuperAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCRequiresSuperAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCRequiresPropertyDefsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCRequiresPropertyDefsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCPreciseLifetimeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCPreciseLifetimeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCOwnershipAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCOwnershipAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCNSObjectAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCNSObjectAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCMethodFamilyAttr(multiplier.ast.InheritableAttr):
  family: multiplier.ast.ObjCMethodFamilyAttrFamilyKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCMethodFamilyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCIndependentClassAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCIndependentClassAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCExternallyRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCExternallyRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCExplicitProtocolImplAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCExplicitProtocolImplAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCExceptionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCExceptionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCExceptionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCExceptionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCBridgeRelatedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBridgeRelatedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCBridgeMutableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBridgeMutableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCBridgeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBridgeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBridgeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBridgeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSReturnsRetainedOnZeroAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSReturnsRetainedOnZeroAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSReturnsRetainedOnNonZeroAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSReturnsRetainedOnNonZeroAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSReturnsRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSReturnsRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSReturnsNotRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSReturnsNotRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSConsumesThisAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSConsumesThisAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSConsumesThisAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSConsumesThisAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPThreadPrivateDeclAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPThreadPrivateDeclAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPDeclareVariantAttr(multiplier.ast.InheritableAttr):
  variant_func_reference: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclareVariantAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPDeclareTargetDeclAttr(multiplier.ast.InheritableAttr):
  dev_type: multiplier.ast.OMPDeclareTargetDeclAttrDevTypeTy
  indirect: bool
  indirect_expression: multiplier.ast.Expr
  map_type: multiplier.ast.OMPDeclareTargetDeclAttrMapTypeTy

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclareTargetDeclAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPCaptureNoInitAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCaptureNoInitAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OMPAllocateDeclAttr(multiplier.ast.InheritableAttr):
  alignment: multiplier.ast.Expr
  allocator: multiplier.ast.Expr
  allocator_type: multiplier.ast.OMPAllocateDeclAttrAllocatorTypeTy

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPAllocateDeclAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NotTailCalledAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NotTailCalledAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NotTailCalledAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NotTailCalledAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoUwtableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoUwtableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoUwtableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoUwtableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoUniqueAddressAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoUniqueAddressAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoThrowAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoThrowAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoThrowAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoThrowAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoThreadSafetyAnalysisAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoThreadSafetyAnalysisAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoStackProtectorAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.NoStackProtectorAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoStackProtectorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoStackProtectorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoStackProtectorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoSplitStackAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoSplitStackAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoSplitStackAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoSplitStackAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoSpeculativeLoadHardeningAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoSpeculativeLoadHardeningAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoSanitizeAttr(multiplier.ast.InheritableAttr):
  has_coverage: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoSanitizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoSanitizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoSanitizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoReturnAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoReturnAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoReturnAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoReturnAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoRandomizeLayoutAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoRandomizeLayoutAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoProfileFunctionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoProfileFunctionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoMips16Attr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoMips16Attr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoMips16Attr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoMips16Attr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoMicroMipsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoMicroMipsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoMicroMipsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoMicroMipsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoInstrumentFunctionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoInstrumentFunctionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoDuplicateAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoDuplicateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoDuplicateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoDuplicateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoDestroyAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoDestroyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoDestroyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoDestroyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoDebugAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoDebugAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoDebugAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoDebugAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoCommonAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoCommonAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoCommonAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoCommonAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NoAliasAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoAliasAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoAliasAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoAliasAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NakedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NakedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NakedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NakedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NakedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NVPTXKernelAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NVPTXKernelAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NVPTXKernelAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NVPTXKernelAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSReturnsRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSReturnsRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSReturnsNotRetainedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSReturnsNotRetainedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSReturnsAutoreleasedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSReturnsAutoreleasedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSErrorDomainAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSErrorDomainAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSErrorDomainAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSErrorDomainAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSConsumesSelfAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSConsumesSelfAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MipsShortCallAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.MipsShortCallAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MipsShortCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MipsShortCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MipsShortCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MipsLongCallAttr(multiplier.ast.InheritableAttr):
  semantic_spelling: multiplier.ast.MipsLongCallAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MipsLongCallAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MipsLongCallAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MipsLongCallAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MipsInterruptAttr(multiplier.ast.InheritableAttr):
  interrupt: multiplier.ast.MipsInterruptAttrInterruptType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MipsInterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MipsInterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MipsInterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class Mips16Attr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Mips16Attr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Mips16Attr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Mips16Attr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MinVectorWidthAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MinVectorWidthAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MinVectorWidthAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MinVectorWidthAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MinSizeAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MinSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MinSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MinSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MicroMipsAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MicroMipsAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MicroMipsAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MicroMipsAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MaybeUndefAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MaybeUndefAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MaybeUndefAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MaybeUndefAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MayAliasAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MayAliasAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MayAliasAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MayAliasAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MaxFieldAlignmentAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MaxFieldAlignmentAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSVtorDispAttr(multiplier.ast.InheritableAttr):
  vtor_disp_mode: multiplier.ast.MSVtorDispMode

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSVtorDispAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSVtorDispAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSVtorDispAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSStructAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSStructAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSStructAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSStructAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSP430InterruptAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSP430InterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSP430InterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSP430InterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSNoVTableAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSNoVTableAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSNoVTableAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSNoVTableAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSInheritanceAttr(multiplier.ast.InheritableAttr):
  best_case: bool
  inheritance_model: multiplier.ast.MSInheritanceModel
  semantic_spelling: multiplier.ast.MSInheritanceAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSInheritanceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSInheritanceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSInheritanceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSConstexprAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSConstexprAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSConstexprAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSConstexprAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSAllocatorAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSAllocatorAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSAllocatorAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSAllocatorAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MSABIAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSABIAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSABIAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSABIAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MIGServerRoutineAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MIGServerRoutineAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class M68kRTDAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.M68kRTDAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.M68kRTDAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.M68kRTDAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class M68kInterruptAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.M68kInterruptAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.M68kInterruptAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.M68kInterruptAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LocksExcludedAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LocksExcludedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LocksExcludedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LocksExcludedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LockReturnedAttr(multiplier.ast.InheritableAttr):
  argument: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LockReturnedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LockReturnedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LockReturnedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LifetimeBoundAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LifetimeBoundAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LifetimeBoundAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LifetimeBoundAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LeafAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LeafAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LeafAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LeafAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LeafAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LayoutVersionAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LayoutVersionAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LayoutVersionAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LayoutVersionAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LTOVisibilityPublicAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LTOVisibilityPublicAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InternalLinkageAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InternalLinkageAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InternalLinkageAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InternalLinkageAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IntelOclBiccAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IntelOclBiccAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IntelOclBiccAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IntelOclBiccAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InitPriorityAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InitPriorityAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InitPriorityAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InitPriorityAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InheritableParamAttr(multiplier.ast.InheritableAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InheritableParamAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InheritableParamAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InheritableParamAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CarriesDependencyAttr(multiplier.ast.InheritableParamAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CarriesDependencyAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CarriesDependencyAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CarriesDependencyAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CFConsumedAttr(multiplier.ast.InheritableParamAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CFConsumedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CFConsumedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CFConsumedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AnnotateAttr(multiplier.ast.InheritableParamAttr):
  annotation: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AnnotateAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AnnotateAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AnnotateAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UseHandleAttr(multiplier.ast.InheritableParamAttr):
  handle_type: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UseHandleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UseHandleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UseHandleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReleaseHandleAttr(multiplier.ast.InheritableParamAttr):
  handle_type: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReleaseHandleAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReleaseHandleAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReleaseHandleAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PassObjectSizeAttr(multiplier.ast.InheritableParamAttr):
  semantic_spelling: multiplier.ast.PassObjectSizeAttrSpelling
  is_dynamic: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PassObjectSizeAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PassObjectSizeAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PassObjectSizeAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ParameterABIAttr(multiplier.ast.InheritableParamAttr):
  abi: multiplier.ast.ParameterABI

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ParameterABIAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParameterABIAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParameterABIAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftIndirectResultAttr(multiplier.ast.ParameterABIAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftIndirectResultAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftErrorResultAttr(multiplier.ast.ParameterABIAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftErrorResultAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftContextAttr(multiplier.ast.ParameterABIAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftContextAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftContextAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftContextAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SwiftAsyncContextAttr(multiplier.ast.ParameterABIAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwiftAsyncContextAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class OSConsumedAttr(multiplier.ast.InheritableParamAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OSConsumedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OSConsumedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OSConsumedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NonNullAttr(multiplier.ast.InheritableParamAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NonNullAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NonNullAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NonNullAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class NSConsumedAttr(multiplier.ast.InheritableParamAttr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NSConsumedAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NSConsumedAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NSConsumedAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IFuncAttr(multiplier.ast.Attr):
  resolver: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IFuncAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IFuncAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IFuncAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class CalledOnceAttr(multiplier.ast.Attr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CalledOnceAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CalledOnceAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CalledOnceAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BuiltinAliasAttr(multiplier.ast.Attr):
  semantic_spelling: multiplier.ast.BuiltinAliasAttrSpelling

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BuiltinAliasAttr]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BuiltinAliasAttr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.AttrKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Attr) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Attr]) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BuiltinAliasAttr]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class Type(multiplier.Entity):
  tokens: multiplier.frontend.TokenRange
  desugared_type: multiplier.ast.Type
  canonical_type: multiplier.ast.Type
  is_qualified: bool
  unqualified_type: multiplier.ast.Type
  size_in_bits: Optional[int]
  alignment: Optional[int]
  accepts_obj_c_type_parameters: bool
  can_decay_to_pointer_type: bool
  can_have_nullability: bool
  contains_errors: bool
  contains_unexpanded_parameter_pack: bool
  linkage: multiplier.ast.Linkage
  kind: multiplier.ast.TypeKind
  unqualified_desugared_type: multiplier.ast.Type
  visibility: multiplier.ast.Visibility
  is_sizeless_vector_type: bool
  is_unresolved_type: bool

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index, kinds: Sequence[multiplier.ast.TypeKind]) -> Iterable[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Type]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Type]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.Type) -> Optional[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Type]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Type]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TemplateTypeParmType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  declaration: Optional[multiplier.ast.TemplateTypeParmDecl]
  is_parameter_pack: bool
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateTypeParmType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateTypeParmType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateTypeParmType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TemplateSpecializationType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  aliased_type: Optional[multiplier.ast.Type]
  is_current_instantiation: bool
  is_sugared: bool
  is_type_alias: bool
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateSpecializationType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateSpecializationType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateSpecializationType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class TagType(multiplier.ast.Type):
  declaration: multiplier.ast.TagDecl
  is_being_defined: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TagType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TagType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TagType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TagType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TagType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TagType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TagType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TagType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TagType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RecordType(multiplier.ast.TagType):
  desugar: multiplier.ast.Type
  has_const_fields: bool
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RecordType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RecordType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RecordType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.RecordType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.RecordType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.RecordType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RecordType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RecordType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RecordType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class EnumType(multiplier.ast.TagType):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnumType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnumType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnumType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.EnumType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.EnumType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.EnumType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnumType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnumType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnumType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SubstTemplateTypeParmType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  associated_declaration: multiplier.ast.Decl
  pack_index: Optional[int]
  replaced_parameter: multiplier.ast.TemplateTypeParmDecl
  replacement_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SubstTemplateTypeParmType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class SubstTemplateTypeParmPackType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  associated_declaration: multiplier.ast.Decl
  final: bool
  replaced_parameter: multiplier.ast.TemplateTypeParmDecl
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SubstTemplateTypeParmPackType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ReferenceType(multiplier.ast.Type):
  pointee_type: multiplier.ast.Type
  pointee_type_as_written: multiplier.ast.Type
  is_inner_reference: bool
  is_spelled_as_l_value: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReferenceType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReferenceType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReferenceType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class RValueReferenceType(multiplier.ast.ReferenceType):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RValueReferenceType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RValueReferenceType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RValueReferenceType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class LValueReferenceType(multiplier.ast.ReferenceType):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LValueReferenceType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LValueReferenceType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LValueReferenceType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class QualifiedType(multiplier.ast.Type):
  address_space: multiplier.ast.LangAS
  atomic_unqualified_type: multiplier.ast.Type
  has_address_space: bool
  has_non_trivial_obj_c_lifetime: bool
  has_non_trivial_to_primitive_copy_c_union: bool
  has_non_trivial_to_primitive_default_initialize_c_union: bool
  has_non_trivial_to_primitive_destruct_c_union: bool
  has_qualifiers: bool
  has_strong_or_weak_obj_c_lifetime: bool
  is_c_forbidden_l_value_type: bool
  is_cxx11_pod_type: bool
  is_cxx98_pod_type: bool
  is_canonical: bool
  is_canonical_as_parameter: bool
  is_const_qualified: bool
  is_constant: bool
  is_local_const_qualified: bool
  is_local_restrict_qualified: bool
  is_local_volatile_qualified: bool
  is_non_weak_in_mrr_with_obj_c_weak: bool
  is_null: bool
  is_obj_cgc_strong: bool
  is_obj_cgc_weak: bool
  is_pod_type: bool
  is_referenceable: bool
  is_restrict_qualified: bool
  is_trivial_type: bool
  is_trivially_copy_constructible_type: bool
  is_trivially_copyable_type: bool
  is_trivially_equality_comparable_type: bool
  is_trivially_relocatable_type: bool
  is_volatile_qualified: bool
  is_web_assembly_funcref_type: bool
  is_web_assembly_reference_type: bool
  may_be_dynamic_class: bool
  may_be_not_dynamic_class: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.QualifiedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.QualifiedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.QualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.QualifiedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PointerType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  pointee_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PointerType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PointerType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PointerType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.PointerType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PointerType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PointerType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PointerType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PipeType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  element_type: multiplier.ast.Type
  is_read_only: bool
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PipeType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PipeType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PipeType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PipeType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PipeType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.PipeType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PipeType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PipeType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PipeType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ParenType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  inner_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParenType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParenType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParenType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ParenType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ParenType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ParenType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParenType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParenType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParenType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class PackExpansionType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  pattern: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PackExpansionType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PackExpansionType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PackExpansionType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCTypeParamType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  declaration: multiplier.ast.ObjCTypeParamDecl
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCTypeParamType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCTypeParamType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCTypeParamType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCObjectType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  base_type: multiplier.ast.Type
  interface: multiplier.ast.ObjCInterfaceDecl
  super_class_type: Optional[multiplier.ast.Type]
  num_type_arguments: int
  type_arguments: Iterable[multiplier.ast.Type]
  type_arguments_as_written: Iterable[multiplier.ast.Type]
  is_kind_of_type: bool
  is_kind_of_type_as_written: bool
  is_obj_c_class: bool
  is_obj_c_id: bool
  is_obj_c_qualified_class: bool
  is_obj_c_qualified_id: bool
  is_obj_c_unqualified_class: bool
  is_obj_c_unqualified_id: bool
  is_obj_c_unqualified_id_or_class: bool
  is_specialized: bool
  is_specialized_as_written: bool
  is_sugared: bool
  is_unspecialized: bool
  is_unspecialized_as_written: bool
  strip_obj_c_kind_of_type_and_qualifiers: multiplier.ast.Type

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCObjectType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCObjectType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCObjectType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_type_argument(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

class ObjCInterfaceType(multiplier.ast.ObjCObjectType):
  declaration: multiplier.ast.ObjCInterfaceDecl

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCInterfaceType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCInterfaceType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCInterfaceType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ObjCObjectPointerType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  interface_declaration: multiplier.ast.ObjCInterfaceDecl
  interface_type: multiplier.ast.ObjCInterfaceType
  object_type: multiplier.ast.ObjCObjectType
  pointee_type: multiplier.ast.Type
  super_class_type: multiplier.ast.Type
  num_type_arguments: int
  type_arguments: Iterable[multiplier.ast.Type]
  type_arguments_as_written: Iterable[multiplier.ast.Type]
  is_kind_of_type: bool
  is_obj_c_id_or_class_type: bool
  is_specialized: bool
  is_specialized_as_written: bool
  is_sugared: bool
  is_unspecialized: bool
  is_unspecialized_as_written: bool
  num_qualifiers: int
  qualifiers: Iterable[multiplier.ast.ObjCProtocolDecl]
  strip_obj_c_kind_of_type_and_qualifiers: multiplier.ast.ObjCObjectPointerType
  num_protocols: int
  protocols: Iterable[multiplier.ast.ObjCProtocolDecl]

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCObjectPointerType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCObjectPointerType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCObjectPointerType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_type_argument(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

  def nth_qualifier(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  def nth_protocol(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

class MemberPointerType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  class_: multiplier.ast.Type
  pointee_type: multiplier.ast.Type
  is_member_data_pointer: bool
  is_member_function_pointer: bool
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MemberPointerType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MemberPointerType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MemberPointerType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MatrixType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  element_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MatrixType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MatrixType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MatrixType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.MatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MatrixType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentSizedMatrixType(multiplier.ast.MatrixType):
  attribute_token: multiplier.frontend.Token
  column_expression: multiplier.ast.Expr
  row_expression: multiplier.ast.Expr

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentSizedMatrixType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentSizedMatrixType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentSizedMatrixType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConstantMatrixType(multiplier.ast.MatrixType):

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstantMatrixType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstantMatrixType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstantMatrixType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class MacroQualifiedType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  modified_type: multiplier.ast.Type
  underlying_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MacroQualifiedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MacroQualifiedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MacroQualifiedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class InjectedClassNameType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  declaration: multiplier.ast.CXXRecordDecl
  injected_specialization_type: multiplier.ast.Type
  injected_tst: multiplier.ast.TemplateSpecializationType
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InjectedClassNameType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InjectedClassNameType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InjectedClassNameType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FunctionType(multiplier.ast.Type):
  call_conv: multiplier.ast.CallingConv
  call_result_type: multiplier.ast.Type
  cmse_ns_call_attribute: bool
  has_reg_parm: bool
  no_return_attribute: bool
  return_type: multiplier.ast.Type
  is_const: bool
  is_restrict: bool
  is_volatile: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.FunctionType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class FunctionProtoType(multiplier.ast.FunctionType):
  can_throw: Optional[multiplier.ast.CanThrowResult]
  desugar: multiplier.ast.Type
  ellipsis_token: multiplier.frontend.Token
  exception_spec_declaration: Optional[multiplier.ast.FunctionDecl]
  exception_spec_template: Optional[multiplier.ast.FunctionDecl]
  exception_spec_type: multiplier.ast.ExceptionSpecificationType
  noexcept_expression: Optional[multiplier.ast.Expr]
  num_parameter_types: int
  parameter_types: Iterable[multiplier.ast.Type]
  reference_qualifier: multiplier.ast.RefQualifierKind
  has_dependent_exception_spec: bool
  has_dynamic_exception_spec: bool
  has_exception_spec: bool
  has_ext_parameter_infos: bool
  has_instantiation_dependent_exception_spec: bool
  has_noexcept_exception_spec: bool
  has_trailing_return: bool
  is_nothrow: Optional[bool]
  is_sugared: bool
  is_template_variadic: bool
  is_variadic: bool
  num_exception_types: int
  exception_types: Iterable[multiplier.ast.Type]

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionProtoType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionProtoType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionProtoType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_parameter_type(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

  def nth_exception_type(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

class FunctionNoProtoType(multiplier.ast.FunctionType):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionNoProtoType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionNoProtoType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionNoProtoType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentVectorType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  attribute_token: multiplier.frontend.Token
  element_type: multiplier.ast.Type
  size_expression: multiplier.ast.Expr
  vector_kind: multiplier.ast.VectorKind
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentVectorType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentVectorType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentVectorType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentSizedExtVectorType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  attribute_token: multiplier.frontend.Token
  element_type: multiplier.ast.Type
  size_expression: multiplier.ast.Expr
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentSizedExtVectorType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentBitIntType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  num_bits_expression: multiplier.ast.Expr
  is_signed: bool
  is_sugared: bool
  is_unsigned: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentBitIntType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentBitIntType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentBitIntType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentAddressSpaceType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  address_space_expression: multiplier.ast.Expr
  attribute_token: multiplier.frontend.Token
  pointee_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentAddressSpaceType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentAddressSpaceType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentAddressSpaceType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DeducedType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  resolved_type: Optional[multiplier.ast.Type]
  is_deduced: bool
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeducedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeducedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeducedType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DeducedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DeducedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DeducedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeducedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeducedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeducedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DeducedTemplateSpecializationType(multiplier.ast.DeducedType):

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeducedTemplateSpecializationType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AutoType(multiplier.ast.DeducedType):
  keyword: multiplier.ast.AutoTypeKeyword
  num_type_constraint_arguments: int
  type_constraint_arguments: Iterable[multiplier.ast.TemplateArgument]
  type_constraint_concept: Optional[multiplier.ast.ConceptDecl]
  is_constrained: bool
  is_decltype_auto: bool
  is_gnu_auto_type: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AutoType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AutoType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AutoType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AutoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AutoType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.AutoType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AutoType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AutoType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AutoType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_type_constraint_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class DecltypeType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  underlying_expression: multiplier.ast.Expr
  underlying_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DecltypeType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DecltypeType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DecltypeType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DecltypeType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ComplexType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  element_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ComplexType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ComplexType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ComplexType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ComplexType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ComplexType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ComplexType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ComplexType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ComplexType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ComplexType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BuiltinType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  builtin_kind: multiplier.ast.BuiltinTypeKind
  is_floating_point: bool
  is_integer: bool
  is_sve_bool: bool
  is_sve_count: bool
  is_signed_integer: bool
  is_sugared: bool
  is_unsigned_integer: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BuiltinType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BuiltinType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BuiltinType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BuiltinType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BlockPointerType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  pointee_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BlockPointerType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BlockPointerType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BlockPointerType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BitIntType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  is_signed: bool
  is_sugared: bool
  is_unsigned: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BitIntType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BitIntType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BitIntType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.BitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BitIntType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BitIntType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class BTFTagAttributedType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  attribute: multiplier.ast.BTFTypeTagAttr
  wrapped_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BTFTagAttributedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BTFTagAttributedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BTFTagAttributedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AttributedType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  attribute: Optional[multiplier.ast.Attr]
  attribute_kind: multiplier.ast.AttrKind
  equivalent_type: multiplier.ast.Type
  immediate_nullability: Optional[multiplier.ast.NullabilityKind]
  modified_type: multiplier.ast.Type
  has_attribute: bool
  is_calling_conv: bool
  is_ms_type_spec: bool
  is_qualifier: bool
  is_sugared: bool
  is_web_assembly_funcref_spec: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AttributedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AttributedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AttributedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.AttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AttributedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AttributedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AtomicType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  value_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AtomicType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AtomicType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AtomicType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AtomicType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AtomicType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.AtomicType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AtomicType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AtomicType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AtomicType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ArrayType(multiplier.ast.Type):
  element_type: multiplier.ast.Type
  size_modifier: multiplier.ast.ArraySizeModifier

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArrayType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArrayType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArrayType]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArrayType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VariableArrayType(multiplier.ast.ArrayType):
  desugar: multiplier.ast.Type
  brackets_range: multiplier.frontend.TokenRange
  l_bracket_token: multiplier.frontend.Token
  r_bracket_token: multiplier.frontend.Token
  size_expression: multiplier.ast.Expr
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VariableArrayType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VariableArrayType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VariableArrayType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class IncompleteArrayType(multiplier.ast.ArrayType):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IncompleteArrayType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IncompleteArrayType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IncompleteArrayType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentSizedArrayType(multiplier.ast.ArrayType):
  desugar: multiplier.ast.Type
  brackets_range: multiplier.frontend.TokenRange
  l_bracket_token: multiplier.frontend.Token
  r_bracket_token: multiplier.frontend.Token
  size_expression: Optional[multiplier.ast.Expr]
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentSizedArrayType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentSizedArrayType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentSizedArrayType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ConstantArrayType(multiplier.ast.ArrayType):
  desugar: multiplier.ast.Type
  size_expression: Optional[multiplier.ast.Expr]
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstantArrayType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstantArrayType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstantArrayType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class AdjustedType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  resolved_type: multiplier.ast.Type
  original_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AdjustedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AdjustedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AdjustedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AdjustedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DecayedType(multiplier.ast.AdjustedType):
  pointee_type: multiplier.ast.Type

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DecayedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DecayedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DecayedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DecayedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DecayedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DecayedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DecayedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DecayedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DecayedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeWithKeyword(multiplier.ast.Type):
  keyword: multiplier.ast.ElaboratedTypeKeyword

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeWithKeyword]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeWithKeyword]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeWithKeyword]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ElaboratedType(multiplier.ast.TypeWithKeyword):
  desugar: multiplier.ast.Type
  named_type: multiplier.ast.Type
  owned_tag_declaration: Optional[multiplier.ast.TagDecl]
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ElaboratedType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ElaboratedType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ElaboratedType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class DependentTemplateSpecializationType(multiplier.ast.TypeWithKeyword):
  desugar: multiplier.ast.Type
  is_sugared: bool
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentTemplateSpecializationType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class DependentNameType(multiplier.ast.TypeWithKeyword):
  desugar: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentNameType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentNameType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentNameType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentNameType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class VectorType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  element_type: multiplier.ast.Type
  vector_kind: multiplier.ast.VectorKind
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VectorType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VectorType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VectorType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.VectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.VectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.VectorType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VectorType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VectorType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VectorType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class ExtVectorType(multiplier.ast.VectorType):

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExtVectorType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExtVectorType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExtVectorType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UsingType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  found_declaration: multiplier.ast.UsingShadowDecl
  underlying_type: multiplier.ast.Type
  is_sugared: bool
  type_matches_declaration: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UsingType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UsingType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.UsingType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnresolvedUsingType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  declaration: multiplier.ast.UnresolvedUsingTypenameDecl
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedUsingType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedUsingType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedUsingType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class UnaryTransformType(multiplier.ast.Type):
  desugar: Optional[multiplier.ast.Type]
  base_type: Optional[multiplier.ast.Type]
  utt_kind: multiplier.ast.UnaryTransformTypeUTTKind
  underlying_type: Optional[multiplier.ast.Type]
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnaryTransformType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnaryTransformType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnaryTransformType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypedefType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  declaration: multiplier.ast.TypedefNameDecl
  is_sugared: bool
  type_matches_declaration: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypedefType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypedefType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypedefType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypedefType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypedefType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TypedefType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypedefType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypedefType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypedefType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeOfType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  type_kind: multiplier.ast.TypeOfKind
  unmodified_type: multiplier.ast.Type
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeOfType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeOfType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeOfType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeOfType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class TypeOfExprType(multiplier.ast.Type):
  desugar: multiplier.ast.Type
  type_kind: multiplier.ast.TypeOfKind
  underlying_expression: multiplier.ast.Expr
  is_sugared: bool

  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeOfExprType]:
    ...

  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeOfExprType]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.TypeKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Type) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Type]) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeOfExprType]:
    ...

  def contains(self, tok: multiplier.frontend.Token) -> bool:
    ...

class Stmt(multiplier.Entity):
  parent_declaration: Optional[multiplier.ast.Decl]
  parent_statement: Optional[multiplier.ast.Stmt]
  referenced_declaration_id: Optional[multiplier.DeclId]
  referenced_declaration: Optional[multiplier.ast.Decl]
  ignore_containers: multiplier.ast.Stmt
  children: Iterable[multiplier.ast.Stmt]
  tokens: multiplier.frontend.TokenRange
  kind: multiplier.ast.StmtKind
  strip_label_like_statements: multiplier.ast.Stmt

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index, kinds: Sequence[multiplier.ast.StmtKind]) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment, kinds: Sequence[multiplier.ast.StmtKind]) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File, kinds: Sequence[multiplier.ast.StmtKind]) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.Stmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation, kinds: Sequence[multiplier.ast.StmtKind]) -> Iterable[Tuple[multiplier.ast.Stmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.Stmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.Stmt) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Stmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Stmt]:
    ...

class SEHTryStmt(multiplier.ast.Stmt):
  except_handler: multiplier.ast.SEHExceptStmt
  finally_handler: multiplier.ast.SEHFinallyStmt
  handler: multiplier.ast.Stmt
  is_cxx_try: bool
  try_block: multiplier.ast.CompoundStmt
  try_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SEHTryStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SEHTryStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHTryStmt]:
    ...

class SEHLeaveStmt(multiplier.ast.Stmt):
  leave_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SEHLeaveStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SEHLeaveStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHLeaveStmt]:
    ...

class SEHFinallyStmt(multiplier.ast.Stmt):
  block: multiplier.ast.CompoundStmt
  finally_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SEHFinallyStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SEHFinallyStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHFinallyStmt]:
    ...

class SEHExceptStmt(multiplier.ast.Stmt):
  block: multiplier.ast.CompoundStmt
  except_token: multiplier.frontend.Token
  filter_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SEHExceptStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SEHExceptStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SEHExceptStmt]:
    ...

class ReturnStmt(multiplier.ast.Stmt):
  nrvo_candidate: Optional[multiplier.ast.VarDecl]
  return_value: Optional[multiplier.ast.Expr]
  return_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ReturnStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ReturnStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ReturnStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ReturnStmt]:
    ...

class ObjCForCollectionStmt(multiplier.ast.Stmt):
  body: multiplier.ast.Stmt
  collection: multiplier.ast.Expr
  element: multiplier.ast.Stmt
  for_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCForCollectionStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCForCollectionStmt]:
    ...

class ObjCAutoreleasePoolStmt(multiplier.ast.Stmt):
  at_token: multiplier.frontend.Token
  sub_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAutoreleasePoolStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAutoreleasePoolStmt]:
    ...

class ObjCAtTryStmt(multiplier.ast.Stmt):
  at_try_token: multiplier.frontend.Token
  finally_statement: multiplier.ast.ObjCAtFinallyStmt
  try_body: multiplier.ast.Stmt
  num_catch_statements: int
  catch_statements: Iterable[multiplier.ast.ObjCAtCatchStmt]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtTryStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtTryStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtTryStmt]:
    ...

  def nth_catch_statement(self, n: int) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

class ObjCAtThrowStmt(multiplier.ast.Stmt):
  throw_expression: multiplier.ast.Expr
  throw_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtThrowStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtThrowStmt]:
    ...

class ObjCAtSynchronizedStmt(multiplier.ast.Stmt):
  at_synchronized_token: multiplier.frontend.Token
  synch_body: multiplier.ast.CompoundStmt
  synch_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtSynchronizedStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtSynchronizedStmt]:
    ...

class ObjCAtFinallyStmt(multiplier.ast.Stmt):
  at_finally_token: multiplier.frontend.Token
  finally_body: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtFinallyStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtFinallyStmt]:
    ...

class ObjCAtCatchStmt(multiplier.ast.Stmt):
  at_catch_token: multiplier.frontend.Token
  catch_body: multiplier.ast.Stmt
  catch_parameter_declaration: multiplier.ast.VarDecl
  r_paren_token: multiplier.frontend.Token
  has_ellipsis: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtCatchStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAtCatchStmt]:
    ...

class OMPExecutableDirective(multiplier.ast.Stmt):
  associated_statement: multiplier.ast.Stmt
  innermost_captured_statement: multiplier.ast.CapturedStmt
  raw_statement: multiplier.ast.Stmt
  structured_block: multiplier.ast.Stmt
  has_associated_statement: bool
  is_standalone_directive: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPExecutableDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPExecutableDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPExecutableDirective]:
    ...

class OMPErrorDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPErrorDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPErrorDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPErrorDirective]:
    ...

class OMPDispatchDirective(multiplier.ast.OMPExecutableDirective):
  target_call_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDispatchDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDispatchDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDispatchDirective]:
    ...

class OMPDepobjDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDepobjDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDepobjDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDepobjDirective]:
    ...

class OMPCriticalDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPCriticalDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPCriticalDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCriticalDirective]:
    ...

class OMPCancellationPointDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPCancellationPointDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCancellationPointDirective]:
    ...

class OMPCancelDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPCancelDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPCancelDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCancelDirective]:
    ...

class OMPBarrierDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPBarrierDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPBarrierDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPBarrierDirective]:
    ...

class OMPAtomicDirective(multiplier.ast.OMPExecutableDirective):
  condition_expression: multiplier.ast.Expr
  d: multiplier.ast.Expr
  expression: multiplier.ast.Expr
  r: multiplier.ast.Expr
  update_expression: multiplier.ast.Expr
  v: multiplier.ast.Expr
  x: multiplier.ast.Expr
  is_fail_only: bool
  is_postfix_update: bool
  is_xlhs_in_rhs_part: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPAtomicDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPAtomicDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPAtomicDirective]:
    ...

class OMPTeamsDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDirective]:
    ...

class OMPTaskyieldDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskyieldDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskyieldDirective]:
    ...

class OMPTaskwaitDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskwaitDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskwaitDirective]:
    ...

class OMPTaskgroupDirective(multiplier.ast.OMPExecutableDirective):
  reduction_reference: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskgroupDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskgroupDirective]:
    ...

class OMPTaskDirective(multiplier.ast.OMPExecutableDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskDirective]:
    ...

class OMPTargetUpdateDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetUpdateDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetUpdateDirective]:
    ...

class OMPTargetTeamsDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDirective]:
    ...

class OMPTargetParallelDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetParallelDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelDirective]:
    ...

class OMPTargetExitDataDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetExitDataDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetExitDataDirective]:
    ...

class OMPTargetEnterDataDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetEnterDataDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetEnterDataDirective]:
    ...

class OMPTargetDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetDirective]:
    ...

class OMPTargetDataDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetDataDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetDataDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetDataDirective]:
    ...

class OMPSingleDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPSingleDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPSingleDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSingleDirective]:
    ...

class OMPSectionsDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPSectionsDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPSectionsDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSectionsDirective]:
    ...

class OMPSectionDirective(multiplier.ast.OMPExecutableDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPSectionDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPSectionDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSectionDirective]:
    ...

class OMPScopeDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPScopeDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPScopeDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPScopeDirective]:
    ...

class OMPScanDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPScanDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPScanDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPScanDirective]:
    ...

class OMPParallelSectionsDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelSectionsDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelSectionsDirective]:
    ...

class OMPParallelMasterDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMasterDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterDirective]:
    ...

class OMPParallelMaskedDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMaskedDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedDirective]:
    ...

class OMPParallelDirective(multiplier.ast.OMPExecutableDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelDirective]:
    ...

class OMPOrderedDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPOrderedDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPOrderedDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPOrderedDirective]:
    ...

class OMPMetaDirective(multiplier.ast.OMPExecutableDirective):
  if_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMetaDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMetaDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMetaDirective]:
    ...

class OMPMasterDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMasterDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMasterDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterDirective]:
    ...

class OMPMaskedDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMaskedDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMaskedDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedDirective]:
    ...

class OMPLoopBasedDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPLoopBasedDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopBasedDirective]:
    ...

class OMPLoopTransformationDirective(multiplier.ast.OMPLoopBasedDirective):
  pre_initializers: multiplier.ast.Stmt
  transformed_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPLoopTransformationDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopTransformationDirective]:
    ...

class OMPUnrollDirective(multiplier.ast.OMPLoopTransformationDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPUnrollDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPUnrollDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPUnrollDirective]:
    ...

class OMPTileDirective(multiplier.ast.OMPLoopTransformationDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTileDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTileDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTileDirective]:
    ...

class OMPLoopDirective(multiplier.ast.OMPLoopBasedDirective):
  num_counters: int
  counters: Iterable[multiplier.ast.Expr]
  num_dependent_counters: int
  dependent_counters: Iterable[multiplier.ast.Expr]
  num_dependent_initializers: int
  dependent_initializers: Iterable[multiplier.ast.Expr]
  num_finals: int
  finals: Iterable[multiplier.ast.Expr]
  num_finals_conditions: int
  finals_conditions: Iterable[multiplier.ast.Expr]
  body: multiplier.ast.Stmt
  calculate_last_iteration: multiplier.ast.Expr
  combined_condition: multiplier.ast.Expr
  combined_distance_condition: multiplier.ast.Expr
  combined_ensure_upper_bound: multiplier.ast.Expr
  combined_initializer: multiplier.ast.Expr
  combined_lower_bound_variable: multiplier.ast.Expr
  combined_next_lower_bound: multiplier.ast.Expr
  combined_next_upper_bound: multiplier.ast.Expr
  combined_parallel_for_in_distance_condition: multiplier.ast.Expr
  combined_upper_bound_variable: multiplier.ast.Expr
  condition: multiplier.ast.Expr
  distance_increment: multiplier.ast.Expr
  ensure_upper_bound: multiplier.ast.Expr
  increment: multiplier.ast.Expr
  initializer: multiplier.ast.Expr
  is_last_iteration_variable: multiplier.ast.Expr
  iteration_variable: multiplier.ast.Expr
  last_iteration: multiplier.ast.Expr
  lower_bound_variable: multiplier.ast.Expr
  next_lower_bound: multiplier.ast.Expr
  next_upper_bound: multiplier.ast.Expr
  pre_condition: multiplier.ast.Expr
  pre_initializers: multiplier.ast.Stmt
  prev_ensure_upper_bound: multiplier.ast.Expr
  prev_lower_bound_variable: multiplier.ast.Expr
  prev_upper_bound_variable: multiplier.ast.Expr
  stride_variable: multiplier.ast.Expr
  upper_bound_variable: multiplier.ast.Expr
  num_initializers: int
  initializers: Iterable[multiplier.ast.Expr]
  num_private_counters: int
  private_counters: Iterable[multiplier.ast.Expr]
  num_updates: int
  updates: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPLoopDirective]:
    ...

  def nth_counter(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_dependent_counter(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_dependent_initializer(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_final(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_finals_condition(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_initializer(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_private_counter(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_update(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class OMPGenericLoopDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPGenericLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPGenericLoopDirective]:
    ...

class OMPForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPForSimdDirective]:
    ...

class OMPForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPForDirective]:
    ...

class OMPDistributeSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDistributeSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeSimdDirective]:
    ...

class OMPDistributeParallelForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDistributeParallelForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeParallelForSimdDirective]:
    ...

class OMPDistributeParallelForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDistributeParallelForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeParallelForDirective]:
    ...

class OMPDistributeDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDistributeDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDistributeDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPDistributeDirective]:
    ...

class OMPTeamsGenericLoopDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsGenericLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsGenericLoopDirective]:
    ...

class OMPTeamsDistributeSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsDistributeSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeSimdDirective]:
    ...

class OMPTeamsDistributeParallelForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForSimdDirective]:
    ...

class OMPTeamsDistributeParallelForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsDistributeParallelForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeParallelForDirective]:
    ...

class OMPTeamsDistributeDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTeamsDistributeDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTeamsDistributeDirective]:
    ...

class OMPTaskLoopSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskLoopSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskLoopSimdDirective]:
    ...

class OMPTaskLoopDirective(multiplier.ast.OMPLoopDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTaskLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTaskLoopDirective]:
    ...

class OMPTargetTeamsGenericLoopDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsGenericLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsGenericLoopDirective]:
    ...

class OMPTargetTeamsDistributeSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsDistributeSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeSimdDirective]:
    ...

class OMPTargetTeamsDistributeParallelForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForSimdDirective]:
    ...

class OMPTargetTeamsDistributeParallelForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeParallelForDirective]:
    ...

class OMPTargetTeamsDistributeDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetTeamsDistributeDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetTeamsDistributeDirective]:
    ...

class OMPTargetSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetSimdDirective]:
    ...

class OMPTargetParallelGenericLoopDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetParallelGenericLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelGenericLoopDirective]:
    ...

class OMPTargetParallelForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetParallelForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelForSimdDirective]:
    ...

class OMPTargetParallelForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPTargetParallelForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPTargetParallelForDirective]:
    ...

class OMPSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPSimdDirective]:
    ...

class OMPParallelMasterTaskLoopSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopSimdDirective]:
    ...

class OMPParallelMasterTaskLoopDirective(multiplier.ast.OMPLoopDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMasterTaskLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMasterTaskLoopDirective]:
    ...

class OMPParallelMaskedTaskLoopSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopSimdDirective]:
    ...

class OMPParallelMaskedTaskLoopDirective(multiplier.ast.OMPLoopDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelMaskedTaskLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelMaskedTaskLoopDirective]:
    ...

class OMPParallelGenericLoopDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelGenericLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelGenericLoopDirective]:
    ...

class OMPParallelForSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelForSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelForSimdDirective]:
    ...

class OMPParallelForDirective(multiplier.ast.OMPLoopDirective):
  task_reduction_reference_expression: multiplier.ast.Expr
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPParallelForDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPParallelForDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPParallelForDirective]:
    ...

class OMPMasterTaskLoopSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMasterTaskLoopSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterTaskLoopSimdDirective]:
    ...

class OMPMasterTaskLoopDirective(multiplier.ast.OMPLoopDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMasterTaskLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMasterTaskLoopDirective]:
    ...

class OMPMaskedTaskLoopSimdDirective(multiplier.ast.OMPLoopDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMaskedTaskLoopSimdDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedTaskLoopSimdDirective]:
    ...

class OMPMaskedTaskLoopDirective(multiplier.ast.OMPLoopDirective):
  has_cancel: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPMaskedTaskLoopDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPMaskedTaskLoopDirective]:
    ...

class OMPInteropDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPInteropDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPInteropDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPInteropDirective]:
    ...

class OMPFlushDirective(multiplier.ast.OMPExecutableDirective):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPFlushDirective, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPFlushDirective]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPFlushDirective]:
    ...

class OMPCanonicalLoop(multiplier.ast.Stmt):
  distance_func: multiplier.ast.CapturedStmt
  loop_statement: multiplier.ast.Stmt
  loop_variable_func: multiplier.ast.CapturedStmt
  loop_variable_reference: multiplier.ast.DeclRefExpr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPCanonicalLoop, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPCanonicalLoop]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPCanonicalLoop]:
    ...

class NullStmt(multiplier.ast.Stmt):
  semi_token: multiplier.frontend.Token
  has_leading_empty_macro: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NullStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NullStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NullStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NullStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.NullStmt]:
    ...

class MSDependentExistsStmt(multiplier.ast.Stmt):
  keyword_token: multiplier.frontend.Token
  sub_statement: multiplier.ast.CompoundStmt
  is_if_exists: bool
  is_if_not_exists: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSDependentExistsStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSDependentExistsStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSDependentExistsStmt]:
    ...

class IndirectGotoStmt(multiplier.ast.Stmt):
  constant_target: Optional[multiplier.ast.LabelDecl]
  goto_token: multiplier.frontend.Token
  star_token: multiplier.frontend.Token
  target: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.IndirectGotoStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.IndirectGotoStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IndirectGotoStmt]:
    ...

class IfStmt(multiplier.ast.Stmt):
  condition: multiplier.ast.Expr
  condition_variable: Optional[multiplier.ast.VarDecl]
  condition_variable_declaration_statement: Optional[multiplier.ast.DeclStmt]
  else_: Optional[multiplier.ast.Stmt]
  else_token: multiplier.frontend.Token
  if_token: multiplier.frontend.Token
  initializer: Optional[multiplier.ast.Stmt]
  l_paren_token: multiplier.frontend.Token
  nondiscarded_case: Optional[multiplier.ast.Stmt]
  r_paren_token: multiplier.frontend.Token
  statement_kind: multiplier.ast.IfStatementKind
  then: multiplier.ast.Stmt
  has_else_storage: bool
  has_initializer_storage: bool
  has_variable_storage: bool
  is_consteval: bool
  is_constexpr: bool
  is_negated_consteval: bool
  is_non_negated_consteval: bool
  is_obj_c_availability_check: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.IfStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.IfStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IfStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IfStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IfStmt]:
    ...

class GotoStmt(multiplier.ast.Stmt):
  goto_token: multiplier.frontend.Token
  label: multiplier.ast.LabelDecl
  label_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.GotoStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.GotoStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GotoStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GotoStmt]:
    ...

class ForStmt(multiplier.ast.Stmt):
  body: multiplier.ast.Stmt
  condition: Optional[multiplier.ast.Expr]
  condition_variable: Optional[multiplier.ast.VarDecl]
  condition_variable_declaration_statement: Optional[multiplier.ast.DeclStmt]
  for_token: multiplier.frontend.Token
  increment: Optional[multiplier.ast.Expr]
  initializer: Optional[multiplier.ast.Stmt]
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ForStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ForStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ForStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ForStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ForStmt]:
    ...

class DoStmt(multiplier.ast.Stmt):
  body: multiplier.ast.Stmt
  condition: multiplier.ast.Expr
  do_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  while_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DoStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DoStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DoStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DoStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DoStmt]:
    ...

class DeclStmt(multiplier.ast.Stmt):
  num_declarations: int
  declarations: Iterable[multiplier.ast.Decl]
  single_declaration: Optional[multiplier.ast.Decl]
  is_single_declaration: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DeclStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DeclStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeclStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DeclStmt]:
    ...

  def nth_declaration(self, n: int) -> Optional[multiplier.ast.Decl]:
    ...

class CoroutineBodyStmt(multiplier.ast.Stmt):
  children_excl_body: Iterable[multiplier.ast.Stmt]
  allocate: multiplier.ast.Expr
  body: multiplier.ast.CompoundStmt
  deallocate: multiplier.ast.Expr
  exception_handler: multiplier.ast.Stmt
  fallthrough_handler: multiplier.ast.Stmt
  final_suspend_statement: multiplier.ast.Stmt
  initializer_suspend_statement: multiplier.ast.Stmt
  num_parameter_moves: int
  parameter_moves: Iterable[multiplier.ast.Stmt]
  promise_declaration: multiplier.ast.VarDecl
  promise_declaration_statement: multiplier.ast.Stmt
  result_declaration: Optional[multiplier.ast.Stmt]
  return_statement: multiplier.ast.Stmt
  return_statement_on_alloc_failure: Optional[multiplier.ast.Stmt]
  return_value: multiplier.ast.Expr
  return_value_initializer: multiplier.ast.Expr
  has_dependent_promise_type: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CoroutineBodyStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CoroutineBodyStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoroutineBodyStmt]:
    ...

  def nth_parameter_move(self, n: int) -> Optional[multiplier.ast.Stmt]:
    ...

class CoreturnStmt(multiplier.ast.Stmt):
  keyword_token: multiplier.frontend.Token
  operand: Optional[multiplier.ast.Expr]
  promise_call: multiplier.ast.Expr
  is_implicit: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CoreturnStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CoreturnStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoreturnStmt]:
    ...

class ContinueStmt(multiplier.ast.Stmt):
  continue_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ContinueStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ContinueStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ContinueStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ContinueStmt]:
    ...

class CompoundStmt(multiplier.ast.Stmt):
  left_brace_token: multiplier.frontend.Token
  right_brace_token: multiplier.frontend.Token
  statement_expression_result: Optional[multiplier.ast.Stmt]
  has_stored_fp_features: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CompoundStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CompoundStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CompoundStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundStmt]:
    ...

class CapturedStmt(multiplier.ast.Stmt):
  captured_declaration: multiplier.ast.CapturedDecl
  captured_record_declaration: multiplier.ast.RecordDecl
  captured_region_kind: multiplier.ast.CapturedRegionKind
  captured_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CapturedStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CapturedStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CapturedStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CapturedStmt]:
    ...

class CXXTryStmt(multiplier.ast.Stmt):
  try_block: multiplier.ast.CompoundStmt
  try_token: multiplier.frontend.Token
  num_handlers: int
  handlers: Iterable[multiplier.ast.CXXCatchStmt]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXTryStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXTryStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTryStmt]:
    ...

  def nth_handler(self, n: int) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

class CXXForRangeStmt(multiplier.ast.Stmt):
  begin_statement: Optional[multiplier.ast.DeclStmt]
  body: multiplier.ast.Stmt
  coawait_token: multiplier.frontend.Token
  colon_token: multiplier.frontend.Token
  condition: Optional[multiplier.ast.Expr]
  end_statement: Optional[multiplier.ast.DeclStmt]
  for_token: multiplier.frontend.Token
  increment: Optional[multiplier.ast.Expr]
  initializer: Optional[multiplier.ast.Stmt]
  loop_variable_statement: multiplier.ast.DeclStmt
  loop_variable: multiplier.ast.VarDecl
  r_paren_token: multiplier.frontend.Token
  range_initializer: multiplier.ast.Expr
  range_statement: multiplier.ast.DeclStmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXForRangeStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXForRangeStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXForRangeStmt]:
    ...

class CXXCatchStmt(multiplier.ast.Stmt):
  catch_token: multiplier.frontend.Token
  caught_type: Optional[multiplier.ast.Type]
  exception_declaration: Optional[multiplier.ast.VarDecl]
  handler_block: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXCatchStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXCatchStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXCatchStmt]:
    ...

class BreakStmt(multiplier.ast.Stmt):
  break_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BreakStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BreakStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BreakStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BreakStmt]:
    ...

class AsmStmt(multiplier.ast.Stmt):
  generate_assembly_string: str
  assembly_token: multiplier.frontend.Token
  num_inputs: int
  inputs: Iterable[multiplier.ast.Expr]
  is_simple: bool
  is_volatile: bool
  num_outputs: int
  outputs: Iterable[multiplier.ast.Expr]
  output_constraints: Iterable[str]
  num_output_expressions: int
  output_expressions: Iterable[multiplier.ast.Expr]
  input_constraints: Iterable[str]
  num_input_expressions: int
  input_expressions: Iterable[multiplier.ast.Expr]
  clobbers: Iterable[str]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AsmStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AsmStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AsmStmt]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AsmStmt]:
    ...

  def nth_input(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_output(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_output_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_input_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class MSAsmStmt(multiplier.ast.AsmStmt):
  all_constraints: Iterable[str]
  num_all_expressions: int
  all_expressions: Iterable[multiplier.ast.Expr]
  assembly_string: str
  l_brace_token: multiplier.frontend.Token
  has_braces: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSAsmStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSAsmStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSAsmStmt]:
    ...

  def nth_all_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class GCCAsmStmt(multiplier.ast.AsmStmt):
  assembly_string: multiplier.ast.StringLiteral
  r_paren_token: multiplier.frontend.Token
  is_assembly_goto: bool
  num_labels: int
  labels: Iterable[multiplier.ast.AddrLabelExpr]
  num_output_constraint_literals: int
  output_constraint_literals: Iterable[multiplier.ast.StringLiteral]
  output_names: Iterable[str]
  num_input_constraint_literals: int
  input_constraint_literals: Iterable[multiplier.ast.StringLiteral]
  input_names: Iterable[str]
  num_clobber_string_literals: int
  clobber_string_literals: Iterable[multiplier.ast.StringLiteral]
  num_label_expressions: int
  label_expressions: Iterable[multiplier.ast.AddrLabelExpr]
  label_names: Iterable[str]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.GCCAsmStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.GCCAsmStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GCCAsmStmt]:
    ...

  def nth_label(self, n: int) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  def nth_output_constraint_literal(self, n: int) -> Optional[multiplier.ast.StringLiteral]:
    ...

  def nth_input_constraint_literal(self, n: int) -> Optional[multiplier.ast.StringLiteral]:
    ...

  def nth_clobber_string_literal(self, n: int) -> Optional[multiplier.ast.StringLiteral]:
    ...

  def nth_label_expression(self, n: int) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

class WhileStmt(multiplier.ast.Stmt):
  body: multiplier.ast.Stmt
  condition: multiplier.ast.Expr
  condition_variable: Optional[multiplier.ast.VarDecl]
  condition_variable_declaration_statement: Optional[multiplier.ast.DeclStmt]
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  while_token: multiplier.frontend.Token
  has_variable_storage: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.WhileStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.WhileStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.WhileStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.WhileStmt]:
    ...

class ValueStmt(multiplier.ast.Stmt):
  expression_statement: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ValueStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ValueStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ValueStmt]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ValueStmt]:
    ...

class LabelStmt(multiplier.ast.ValueStmt):
  declaration: multiplier.ast.LabelDecl
  identifier_token: multiplier.frontend.Token
  name: str
  sub_statement: multiplier.ast.Stmt
  is_side_entry: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.LabelStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.LabelStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LabelStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.LabelStmt]:
    ...

class Expr(multiplier.ast.ValueStmt):
  has_side_effects: bool
  ignore_casts: multiplier.ast.Expr
  ignore_conversion_operator_single_step: multiplier.ast.Expr
  ignore_implicit_casts: multiplier.ast.Expr
  ignore_implicit: multiplier.ast.Expr
  ignore_implicit_as_written: multiplier.ast.Expr
  ignore_parenthesis_base_casts: multiplier.ast.Expr
  ignore_parenthesis_casts: multiplier.ast.Expr
  ignore_parenthesis_implicit_casts: multiplier.ast.Expr
  ignore_parenthesis_l_value_casts: multiplier.ast.Expr
  ignore_parenthesis_noop_casts: Optional[multiplier.ast.Expr]
  ignore_parentheses: multiplier.ast.Expr
  ignore_unless_spelled_in_source: multiplier.ast.Expr
  contains_errors: bool
  contains_unexpanded_parameter_pack: bool
  expression_token: multiplier.frontend.Token
  obj_c_property: Optional[multiplier.ast.ObjCPropertyRefExpr]
  object_kind: multiplier.ast.ExprObjectKind
  referenced_declaration_of_callee: Optional[multiplier.ast.Decl]
  source_bit_field: Optional[multiplier.ast.FieldDecl]
  type: Optional[multiplier.ast.Type]
  value_kind: multiplier.ast.ExprValueKind
  has_non_trivial_call: bool
  is_default_argument: bool
  is_gl_value: bool
  is_implicit_cxx_this: bool
  is_instantiation_dependent: bool
  is_l_value: bool
  is_objcgc_candidate: bool
  is_obj_c_self_expression: bool
  is_ordinary_or_bit_field_object: bool
  is_pr_value: bool
  is_read_if_discarded_in_c_plus_plus11: Optional[bool]
  is_type_dependent: bool
  is_value_dependent: bool
  is_x_value: bool
  refers_to_bit_field: bool
  refers_to_global_register_variable: bool
  refers_to_matrix_element: bool
  refers_to_vector_element: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.Expr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.Expr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Expr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Expr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.Expr]:
    ...

class DesignatedInitUpdateExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  updater: multiplier.ast.InitListExpr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DesignatedInitUpdateExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DesignatedInitUpdateExpr]:
    ...

class DesignatedInitExpr(multiplier.ast.Expr):
  num_designators: int
  designators: Iterable[multiplier.ast.Designator]
  designators_tokens: multiplier.frontend.TokenRange
  equal_or_colon_token: multiplier.frontend.Token
  initializer: multiplier.ast.Expr
  is_direct_initializer: bool
  uses_gnu_syntax: bool
  num_sub_expressions: int
  sub_expressions: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DesignatedInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DesignatedInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DesignatedInitExpr]:
    ...

  def nth_designator(self, n: int) -> Optional[multiplier.ast.Designator]:
    ...

  def nth_sub_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class DependentScopeDeclRefExpr(multiplier.ast.Expr):
  l_angle_token: multiplier.frontend.Token
  r_angle_token: multiplier.frontend.Token
  template_keyword_token: multiplier.frontend.Token
  has_explicit_template_arguments: bool
  has_template_keyword: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DependentScopeDeclRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DependentScopeDeclRefExpr]:
    ...

class DependentCoawaitExpr(multiplier.ast.Expr):
  keyword_token: multiplier.frontend.Token
  operand: multiplier.ast.Expr
  operator_coawait_lookup: multiplier.ast.UnresolvedLookupExpr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DependentCoawaitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DependentCoawaitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DependentCoawaitExpr]:
    ...

class DeclRefExpr(multiplier.ast.Expr):
  declaration: multiplier.ast.ValueDecl
  found_declaration: multiplier.ast.NamedDecl
  l_angle_token: multiplier.frontend.Token
  r_angle_token: multiplier.frontend.Token
  template_keyword_token: multiplier.frontend.Token
  had_multiple_candidates: bool
  has_explicit_template_arguments: bool
  has_qualifier: bool
  has_template_keyword_and_arguments_info: bool
  has_template_keyword: bool
  is_captured_by_copy_in_lambda_with_explicit_object_parameter: bool
  is_immediate_escalating: bool
  is_non_odr_use: multiplier.ast.NonOdrUseReason
  refers_to_enclosing_variable_or_capture: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DeclRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DeclRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DeclRefExpr]:
    ...

class CoroutineSuspendExpr(multiplier.ast.Expr):
  common_expression: multiplier.ast.Expr
  keyword_token: multiplier.frontend.Token
  opaque_value: multiplier.ast.OpaqueValueExpr
  operand: multiplier.ast.Expr
  ready_expression: multiplier.ast.Expr
  resume_expression: multiplier.ast.Expr
  suspend_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CoroutineSuspendExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoroutineSuspendExpr]:
    ...

class CoawaitExpr(multiplier.ast.CoroutineSuspendExpr):
  is_implicit: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CoawaitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CoawaitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoawaitExpr]:
    ...

class CoyieldExpr(multiplier.ast.CoroutineSuspendExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CoyieldExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CoyieldExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CoyieldExpr]:
    ...

class ConvertVectorExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  src_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConvertVectorExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConvertVectorExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConvertVectorExpr]:
    ...

class ConceptSpecializationExpr(multiplier.ast.Expr):
  concept_name_token: multiplier.frontend.Token
  found_declaration: multiplier.ast.NamedDecl
  named_concept: multiplier.ast.ConceptDecl
  specialization_declaration: multiplier.ast.ImplicitConceptSpecializationDecl
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]
  template_keyword_token: multiplier.frontend.Token
  has_explicit_template_arguments: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConceptSpecializationExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConceptSpecializationExpr]:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class CompoundLiteralExpr(multiplier.ast.Expr):
  initializer: multiplier.ast.Expr
  l_paren_token: multiplier.frontend.Token
  is_file_scope: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CompoundLiteralExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CompoundLiteralExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundLiteralExpr]:
    ...

class ChooseExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  chosen_sub_expression: multiplier.ast.Expr
  condition: multiplier.ast.Expr
  lhs: multiplier.ast.Expr
  rhs: multiplier.ast.Expr
  r_paren_token: multiplier.frontend.Token
  is_condition_dependent: bool
  is_condition_true: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ChooseExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ChooseExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ChooseExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ChooseExpr]:
    ...

class CharacterLiteral(multiplier.ast.Expr):
  literal_kind: multiplier.ast.CharacterLiteralKind
  token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CharacterLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CharacterLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CharacterLiteral]:
    ...

class CastExpr(multiplier.ast.Expr):
  changes_volatile_qualification: bool
  cast_kind: multiplier.ast.CastKind
  cast_kind_name: str
  conversion_function: Optional[multiplier.ast.NamedDecl]
  sub_expression: multiplier.ast.Expr
  sub_expression_as_written: multiplier.ast.Expr
  target_union_field: Optional[multiplier.ast.FieldDecl]
  has_stored_fp_features: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CastExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CastExpr]:
    ...

class ImplicitCastExpr(multiplier.ast.CastExpr):
  is_part_of_explicit_cast: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImplicitCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImplicitCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImplicitCastExpr]:
    ...

class ExplicitCastExpr(multiplier.ast.CastExpr):
  type_as_written: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExplicitCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExplicitCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExplicitCastExpr]:
    ...

class CXXNamedCastExpr(multiplier.ast.ExplicitCastExpr):
  angle_brackets: multiplier.frontend.TokenRange
  cast_name: str
  operator_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXNamedCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXNamedCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNamedCastExpr]:
    ...

class CXXDynamicCastExpr(multiplier.ast.CXXNamedCastExpr):
  is_always_null: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDynamicCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDynamicCastExpr]:
    ...

class CXXConstCastExpr(multiplier.ast.CXXNamedCastExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXConstCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXConstCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXConstCastExpr]:
    ...

class CXXAddrspaceCastExpr(multiplier.ast.CXXNamedCastExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXAddrspaceCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXAddrspaceCastExpr]:
    ...

class CXXStaticCastExpr(multiplier.ast.CXXNamedCastExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXStaticCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXStaticCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXStaticCastExpr]:
    ...

class CXXReinterpretCastExpr(multiplier.ast.CXXNamedCastExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXReinterpretCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXReinterpretCastExpr]:
    ...

class CXXFunctionalCastExpr(multiplier.ast.ExplicitCastExpr):
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  is_list_initialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXFunctionalCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXFunctionalCastExpr]:
    ...

class CStyleCastExpr(multiplier.ast.ExplicitCastExpr):
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CStyleCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CStyleCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CStyleCastExpr]:
    ...

class BuiltinBitCastExpr(multiplier.ast.ExplicitCastExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BuiltinBitCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BuiltinBitCastExpr]:
    ...

class ObjCBridgedCastExpr(multiplier.ast.ExplicitCastExpr):
  bridge_keyword_token: multiplier.frontend.Token
  bridge_kind: multiplier.ast.ObjCBridgeCastKind
  bridge_kind_name: str
  l_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCBridgedCastExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBridgedCastExpr]:
    ...

class CallExpr(multiplier.ast.Expr):
  num_arguments: int
  arguments: Iterable[multiplier.ast.Expr]
  adl_call_kind: multiplier.ast.CallExprADLCallKind
  call_return_type: multiplier.ast.Type
  callee: multiplier.ast.Expr
  callee_declaration: Optional[multiplier.ast.Decl]
  direct_callee: Optional[multiplier.ast.FunctionDecl]
  r_paren_token: multiplier.frontend.Token
  has_stored_fp_features: bool
  has_unused_result_attribute: bool
  is_builtin_assume_false: bool
  is_call_to_std_move: bool
  is_unevaluated_builtin_call: bool
  uses_adl: bool
  casted_return_type: Optional[multiplier.ast.Type]
  casted_return_value: Optional[multiplier.ast.CastExpr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CallExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CallExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CallExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CallExpr]:
    ...

  def nth_argument(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class CXXOperatorCallExpr(multiplier.ast.CallExpr):
  operator_: multiplier.ast.OverloadedOperatorKind
  operator_token: multiplier.frontend.Token
  is_assignment_operation: bool
  is_comparison_operation: bool
  is_infix_binary_operation: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXOperatorCallExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXOperatorCallExpr]:
    ...

class CXXMemberCallExpr(multiplier.ast.CallExpr):
  implicit_object_argument: multiplier.ast.Expr
  method_declaration: Optional[multiplier.ast.CXXMethodDecl]
  object_type: multiplier.ast.Type
  record_declaration: multiplier.ast.CXXRecordDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXMemberCallExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXMemberCallExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXMemberCallExpr]:
    ...

class CUDAKernelCallExpr(multiplier.ast.CallExpr):
  config: multiplier.ast.CallExpr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CUDAKernelCallExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CUDAKernelCallExpr]:
    ...

class UserDefinedLiteral(multiplier.ast.CallExpr):
  cooked_literal: Optional[multiplier.ast.Expr]
  literal_operator_kind: multiplier.ast.UserDefinedLiteralLiteralOperatorKind
  ud_suffix_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UserDefinedLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UserDefinedLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UserDefinedLiteral]:
    ...

class CXXUuidofExpr(multiplier.ast.Expr):
  expression_operand: Optional[multiplier.ast.Expr]
  guid_declaration: multiplier.ast.MSGuidDecl
  type_operand: Optional[multiplier.ast.Type]
  type_operand_source_info: multiplier.ast.Type
  is_type_operand: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXUuidofExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXUuidofExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXUuidofExpr]:
    ...

class CXXUnresolvedConstructExpr(multiplier.ast.Expr):
  num_arguments: int
  arguments: Iterable[multiplier.ast.Expr]
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  type_as_written: multiplier.ast.Type
  is_list_initialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXUnresolvedConstructExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXUnresolvedConstructExpr]:
    ...

  def nth_argument(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class CXXTypeidExpr(multiplier.ast.Expr):
  expression_operand: Optional[multiplier.ast.Expr]
  type_operand: Optional[multiplier.ast.Type]
  type_operand_source_info: Optional[multiplier.ast.Type]
  is_most_derived: Optional[bool]
  is_potentially_evaluated: bool
  is_type_operand: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXTypeidExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXTypeidExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTypeidExpr]:
    ...

class CXXThrowExpr(multiplier.ast.Expr):
  sub_expression: Optional[multiplier.ast.Expr]
  throw_token: multiplier.frontend.Token
  is_thrown_variable_in_scope: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXThrowExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXThrowExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXThrowExpr]:
    ...

class CXXThisExpr(multiplier.ast.Expr):
  token: multiplier.frontend.Token
  is_implicit: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXThisExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXThisExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXThisExpr]:
    ...

class CXXStdInitializerListExpr(multiplier.ast.Expr):
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXStdInitializerListExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXStdInitializerListExpr]:
    ...

class CXXScalarValueInitExpr(multiplier.ast.Expr):
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXScalarValueInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXScalarValueInitExpr]:
    ...

class CXXRewrittenBinaryOperator(multiplier.ast.Expr):
  lhs: multiplier.ast.Expr
  opcode: multiplier.ast.BinaryOperatorKind
  opcode_string: str
  operator_: multiplier.ast.BinaryOperatorKind
  operator_token: multiplier.frontend.Token
  rhs: multiplier.ast.Expr
  semantic_form: multiplier.ast.Expr
  is_assignment_operation: bool
  is_comparison_operation: bool
  is_reversed: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXRewrittenBinaryOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXRewrittenBinaryOperator]:
    ...

class CXXPseudoDestructorExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  colon_colon_token: multiplier.frontend.Token
  destroyed_type: multiplier.ast.Type
  destroyed_type_token: multiplier.frontend.Token
  operator_token: multiplier.frontend.Token
  tilde_token: multiplier.frontend.Token
  has_qualifier: bool
  is_arrow: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXPseudoDestructorExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXPseudoDestructorExpr]:
    ...

class CXXParenListInitExpr(multiplier.ast.Expr):
  array_filler: multiplier.ast.Expr
  initializer_token: multiplier.frontend.Token
  initialized_field_in_union: multiplier.ast.FieldDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXParenListInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXParenListInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXParenListInitExpr]:
    ...

class CXXNullPtrLiteralExpr(multiplier.ast.Expr):
  token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXNullPtrLiteralExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNullPtrLiteralExpr]:
    ...

class CXXNoexceptExpr(multiplier.ast.Expr):
  operand: multiplier.ast.Expr
  value: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXNoexceptExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXNoexceptExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNoexceptExpr]:
    ...

class CXXNewExpr(multiplier.ast.Expr):
  does_usual_array_delete_want_size: bool
  allocated_type: multiplier.ast.Type
  array_size: Optional[multiplier.ast.Expr]
  construct_expression: Optional[multiplier.ast.CXXConstructExpr]
  direct_initializer_range: multiplier.frontend.TokenRange
  initialization_style: multiplier.ast.CXXNewInitializationStyle
  initializer: Optional[multiplier.ast.Expr]
  operator_delete: Optional[multiplier.ast.FunctionDecl]
  operator_new: Optional[multiplier.ast.FunctionDecl]
  type_id_parentheses: multiplier.frontend.TokenRange
  has_initializer: bool
  is_array: bool
  is_global_new: bool
  is_parenthesis_type_id: bool
  pass_alignment: bool
  num_placement_arguments: int
  placement_arguments: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXNewExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXNewExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXNewExpr]:
    ...

  def nth_placement_argument(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class CXXInheritedCtorInitExpr(multiplier.ast.Expr):
  constructs_virtual_base: bool
  construction_kind: multiplier.ast.CXXConstructionKind
  constructor: multiplier.ast.CXXConstructorDecl
  token: multiplier.frontend.Token
  inherited_from_virtual_base: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXInheritedCtorInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXInheritedCtorInitExpr]:
    ...

class CXXFoldExpr(multiplier.ast.Expr):
  callee: Optional[multiplier.ast.UnresolvedLookupExpr]
  ellipsis_token: multiplier.frontend.Token
  initializer: Optional[multiplier.ast.Expr]
  lhs: Optional[multiplier.ast.Expr]
  l_paren_token: multiplier.frontend.Token
  operator_: multiplier.ast.BinaryOperatorKind
  pattern: multiplier.ast.Expr
  rhs: Optional[multiplier.ast.Expr]
  r_paren_token: multiplier.frontend.Token
  is_left_fold: bool
  is_right_fold: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXFoldExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXFoldExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXFoldExpr]:
    ...

class CXXDependentScopeMemberExpr(multiplier.ast.Expr):
  base: Optional[multiplier.ast.Expr]
  base_type: multiplier.ast.Type
  first_qualifier_found_in_scope: Optional[multiplier.ast.NamedDecl]
  l_angle_token: multiplier.frontend.Token
  member_token: multiplier.frontend.Token
  operator_token: multiplier.frontend.Token
  r_angle_token: multiplier.frontend.Token
  template_keyword_token: multiplier.frontend.Token
  has_explicit_template_arguments: bool
  has_template_keyword: bool
  is_arrow: bool
  is_implicit_access: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDependentScopeMemberExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDependentScopeMemberExpr]:
    ...

class CXXDeleteExpr(multiplier.ast.Expr):
  does_usual_array_delete_want_size: bool
  argument: multiplier.ast.Expr
  destroyed_type: Optional[multiplier.ast.Type]
  operator_delete: Optional[multiplier.ast.FunctionDecl]
  is_array_form: bool
  is_array_form_as_written: bool
  is_global_delete: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDeleteExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDeleteExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDeleteExpr]:
    ...

class CXXDefaultInitExpr(multiplier.ast.Expr):
  expression: Optional[multiplier.ast.Expr]
  field: multiplier.ast.FieldDecl
  rewritten_expression: multiplier.ast.Expr
  used_token: multiplier.frontend.Token
  has_rewritten_initializer: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDefaultInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDefaultInitExpr]:
    ...

class CXXDefaultArgExpr(multiplier.ast.Expr):
  expression: multiplier.ast.Expr
  parameter: multiplier.ast.ParmVarDecl
  rewritten_expression: Optional[multiplier.ast.Expr]
  used_token: multiplier.frontend.Token
  has_rewritten_initializer: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDefaultArgExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXDefaultArgExpr]:
    ...

class CXXConstructExpr(multiplier.ast.Expr):
  num_arguments: int
  arguments: Iterable[multiplier.ast.Expr]
  construction_kind: multiplier.ast.CXXConstructionKind
  constructor: multiplier.ast.CXXConstructorDecl
  token: multiplier.frontend.Token
  parenthesis_or_brace_range: multiplier.frontend.TokenRange
  had_multiple_candidates: bool
  is_elidable: bool
  is_immediate_escalating: bool
  is_list_initialization: bool
  is_std_initializer_list_initialization: bool
  requires_zero_initialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXConstructExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXConstructExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXConstructExpr]:
    ...

  def nth_argument(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class CXXTemporaryObjectExpr(multiplier.ast.CXXConstructExpr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXTemporaryObjectExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXTemporaryObjectExpr]:
    ...

class CXXBoolLiteralExpr(multiplier.ast.Expr):
  token: multiplier.frontend.Token
  value: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXBoolLiteralExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXBoolLiteralExpr]:
    ...

class CXXBindTemporaryExpr(multiplier.ast.Expr):
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXBindTemporaryExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CXXBindTemporaryExpr]:
    ...

class BlockExpr(multiplier.ast.Expr):
  block_declaration: multiplier.ast.BlockDecl
  body: multiplier.ast.Stmt
  caret_token: multiplier.frontend.Token
  function_type: multiplier.ast.FunctionProtoType

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BlockExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BlockExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BlockExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BlockExpr]:
    ...

class BinaryOperator(multiplier.ast.Expr):
  lhs: multiplier.ast.Expr
  opcode: multiplier.ast.BinaryOperatorKind
  opcode_string: str
  operator_token: multiplier.frontend.Token
  rhs: multiplier.ast.Expr
  has_stored_fp_features: bool
  is_additive_operation: bool
  is_assignment_operation: bool
  is_bitwise_operation: bool
  is_comma_operation: bool
  is_comparison_operation: bool
  is_compound_assignment_operation: bool
  is_equality_operation: bool
  is_logical_operation: bool
  is_multiplicative_operation: bool
  is_pointer_memory_operation: bool
  is_relational_operation: bool
  is_shift_assign_operation: bool
  is_shift_operation: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BinaryOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BinaryOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BinaryOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BinaryOperator]:
    ...

class CompoundAssignOperator(multiplier.ast.BinaryOperator):
  computation_lhs_type: multiplier.ast.Type
  computation_result_type: multiplier.ast.Type

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CompoundAssignOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CompoundAssignOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CompoundAssignOperator]:
    ...

class AtomicExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  operation: multiplier.ast.AtomicExprAtomicOp
  operation_as_string: str
  order: multiplier.ast.Expr
  order_fail: Optional[multiplier.ast.Expr]
  pointer: multiplier.ast.Expr
  r_paren_token: multiplier.frontend.Token
  scope: Optional[multiplier.ast.Expr]
  value1: Optional[multiplier.ast.Expr]
  value2: Optional[multiplier.ast.Expr]
  value_type: multiplier.ast.Type
  weak: Optional[multiplier.ast.Expr]
  is_cmp_x_chg: bool
  is_open_cl: bool
  is_volatile: bool
  num_sub_expressions: int
  sub_expressions: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AtomicExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AtomicExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AtomicExpr]:
    ...

  def nth_sub_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class AsTypeExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  src_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AsTypeExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AsTypeExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AsTypeExpr]:
    ...

class ArrayTypeTraitExpr(multiplier.ast.Expr):
  dimension_expression: multiplier.ast.Expr
  queried_type: multiplier.ast.Type
  trait: multiplier.ast.ArrayTypeTrait

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ArrayTypeTraitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayTypeTraitExpr]:
    ...

class ArraySubscriptExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  index: multiplier.ast.Expr
  lhs: multiplier.ast.Expr
  r_bracket_token: multiplier.frontend.Token
  rhs: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ArraySubscriptExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ArraySubscriptExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArraySubscriptExpr]:
    ...

class ArrayInitLoopExpr(multiplier.ast.Expr):
  common_expression: multiplier.ast.OpaqueValueExpr
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ArrayInitLoopExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayInitLoopExpr]:
    ...

class ArrayInitIndexExpr(multiplier.ast.Expr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ArrayInitIndexExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ArrayInitIndexExpr]:
    ...

class AddrLabelExpr(multiplier.ast.Expr):
  amp_amp_token: multiplier.frontend.Token
  label: multiplier.ast.LabelDecl
  label_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AddrLabelExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AddrLabelExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AddrLabelExpr]:
    ...

class AbstractConditionalOperator(multiplier.ast.Expr):
  colon_token: multiplier.frontend.Token
  condition: multiplier.ast.Expr
  false_expression: multiplier.ast.Expr
  question_token: multiplier.frontend.Token
  true_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AbstractConditionalOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AbstractConditionalOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AbstractConditionalOperator]:
    ...

class ConditionalOperator(multiplier.ast.AbstractConditionalOperator):
  lhs: multiplier.ast.Expr
  rhs: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConditionalOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConditionalOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConditionalOperator]:
    ...

class BinaryConditionalOperator(multiplier.ast.AbstractConditionalOperator):
  common: multiplier.ast.Expr
  opaque_value: multiplier.ast.OpaqueValueExpr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BinaryConditionalOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BinaryConditionalOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.BinaryConditionalOperator]:
    ...

class VAArgExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  sub_expression: multiplier.ast.Expr
  is_microsoft_abi: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.VAArgExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.VAArgExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VAArgExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.VAArgExpr]:
    ...

class UnaryOperator(multiplier.ast.Expr):
  can_overflow: bool
  opcode: multiplier.ast.UnaryOperatorKind
  operator_token: multiplier.frontend.Token
  sub_expression: multiplier.ast.Expr
  has_stored_fp_features: bool
  is_arithmetic_operation: bool
  is_decrement_operation: bool
  is_increment_decrement_operation: bool
  is_increment_operation: bool
  is_postfix: bool
  is_prefix: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnaryOperator, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnaryOperator]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnaryOperator]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnaryOperator]:
    ...

class UnaryExprOrTypeTraitExpr(multiplier.ast.Expr):
  argument_expression: Optional[multiplier.ast.Expr]
  argument_type: Optional[multiplier.ast.Type]
  keyword_kind: multiplier.ast.UnaryExprOrTypeTrait
  operator_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  type_of_argument: multiplier.ast.Type
  is_argument_type: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnaryExprOrTypeTraitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnaryExprOrTypeTraitExpr]:
    ...

class TypoExpr(multiplier.ast.Expr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypoExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypoExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypoExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.TypoExpr]:
    ...

class TypeTraitExpr(multiplier.ast.Expr):
  trait: multiplier.ast.TypeTrait
  value: Optional[bool]
  num_arguments: int
  arguments: Iterable[multiplier.ast.Type]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypeTraitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypeTraitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.TypeTraitExpr]:
    ...

  def nth_argument(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

class SubstNonTypeTemplateParmPackExpr(multiplier.ast.Expr):
  associated_declaration: multiplier.ast.Decl
  parameter_pack: multiplier.ast.NonTypeTemplateParmDecl
  parameter_pack_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SubstNonTypeTemplateParmPackExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SubstNonTypeTemplateParmPackExpr]:
    ...

class SubstNonTypeTemplateParmExpr(multiplier.ast.Expr):
  associated_declaration: multiplier.ast.Decl
  name_token: multiplier.frontend.Token
  pack_index: Optional[int]
  parameter: multiplier.ast.NonTypeTemplateParmDecl
  parameter_type: multiplier.ast.Type
  replacement: multiplier.ast.Expr
  is_reference_parameter: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SubstNonTypeTemplateParmExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SubstNonTypeTemplateParmExpr]:
    ...

class StringLiteral(multiplier.ast.Expr):
  contains_non_ascii: Optional[bool]
  contains_non_ascii_or_null: Optional[bool]
  bytes: str
  literal_kind: multiplier.ast.StringLiteralKind
  string: Optional[str]
  is_ordinary: bool
  is_pascal: bool
  is_utf16: bool
  is_utf32: bool
  is_utf8: bool
  is_unevaluated: bool
  is_wide: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.StringLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.StringLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StringLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.StringLiteral]:
    ...

class StmtExpr(multiplier.ast.Expr):
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  sub_statement: multiplier.ast.CompoundStmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.StmtExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.StmtExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StmtExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.StmtExpr]:
    ...

class SourceLocExpr(multiplier.ast.Expr):
  builtin_string: str
  identifier_kind: multiplier.ast.SourceLocIdentKind
  token: multiplier.frontend.Token
  is_int_type: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SourceLocExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SourceLocExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SourceLocExpr]:
    ...

class SizeOfPackExpr(multiplier.ast.Expr):
  operator_token: multiplier.frontend.Token
  pack: multiplier.ast.NamedDecl
  pack_length: Optional[int]
  pack_token: multiplier.frontend.Token
  partial_arguments: Optional[Sequence[multiplier.ast.TemplateArgument]]
  r_paren_token: multiplier.frontend.Token
  is_partially_substituted: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SizeOfPackExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SizeOfPackExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SizeOfPackExpr]:
    ...

class ShuffleVectorExpr(multiplier.ast.Expr):
  builtin_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ShuffleVectorExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ShuffleVectorExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ShuffleVectorExpr]:
    ...

class SYCLUniqueStableNameExpr(multiplier.ast.Expr):
  compute_name: str
  l_paren_token: multiplier.frontend.Token
  token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SYCLUniqueStableNameExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SYCLUniqueStableNameExpr]:
    ...

class RequiresExpr(multiplier.ast.Expr):
  body: multiplier.ast.RequiresExprBodyDecl
  l_paren_token: multiplier.frontend.Token
  num_local_parameters: int
  local_parameters: Iterable[multiplier.ast.ParmVarDecl]
  r_brace_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  requires_keyword_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.RequiresExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.RequiresExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.RequiresExpr]:
    ...

  def nth_local_parameter(self, n: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

class RecoveryExpr(multiplier.ast.Expr):
  num_sub_expressions: int
  sub_expressions: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.RecoveryExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.RecoveryExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.RecoveryExpr]:
    ...

  def nth_sub_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class PseudoObjectExpr(multiplier.ast.Expr):
  result_expression: multiplier.ast.Expr
  syntactic_form: multiplier.ast.Expr
  num_semantics: int
  semantics: Iterable[multiplier.ast.Expr]
  num_semantic_expressions: int
  semantic_expressions: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.PseudoObjectExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.PseudoObjectExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PseudoObjectExpr]:
    ...

  def nth_semantic(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_semantic_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class PredefinedExpr(multiplier.ast.Expr):
  function_name: Optional[multiplier.ast.StringLiteral]
  identifier_kind: multiplier.ast.PredefinedIdentKind
  identifier_kind_name: str
  token: multiplier.frontend.Token
  is_transparent: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.PredefinedExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.PredefinedExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PredefinedExpr]:
    ...

class ParenListExpr(multiplier.ast.Expr):
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  num_expressions: int
  expressions: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ParenListExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ParenListExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ParenListExpr]:
    ...

  def nth_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class ParenExpr(multiplier.ast.Expr):
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ParenExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ParenExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParenExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ParenExpr]:
    ...

class PackExpansionExpr(multiplier.ast.Expr):
  ellipsis_token: multiplier.frontend.Token
  pattern: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.PackExpansionExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.PackExpansionExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.PackExpansionExpr]:
    ...

class OverloadExpr(multiplier.ast.Expr):
  num_declarations: int
  declarations: Iterable[multiplier.ast.NamedDecl]
  l_angle_token: multiplier.frontend.Token
  name_token: multiplier.frontend.Token
  naming_class: Optional[multiplier.ast.CXXRecordDecl]
  r_angle_token: multiplier.frontend.Token
  template_keyword_token: multiplier.frontend.Token
  has_explicit_template_arguments: bool
  has_template_keyword: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OverloadExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OverloadExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OverloadExpr]:
    ...

  def nth_declaration(self, n: int) -> Optional[multiplier.ast.NamedDecl]:
    ...

class UnresolvedMemberExpr(multiplier.ast.OverloadExpr):
  base_type: multiplier.ast.Type
  member_token: multiplier.frontend.Token
  operator_token: multiplier.frontend.Token
  has_unresolved_using: bool
  is_arrow: bool
  is_implicit_access: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnresolvedMemberExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnresolvedMemberExpr]:
    ...

class UnresolvedLookupExpr(multiplier.ast.OverloadExpr):
  is_overloaded: bool
  requires_adl: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnresolvedLookupExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.UnresolvedLookupExpr]:
    ...

class OpaqueValueExpr(multiplier.ast.Expr):
  token: multiplier.frontend.Token
  source_expression: Optional[multiplier.ast.Expr]
  is_unique: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OpaqueValueExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OpaqueValueExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OpaqueValueExpr]:
    ...

class OffsetOfExpr(multiplier.ast.Expr):
  operator_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OffsetOfExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OffsetOfExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OffsetOfExpr]:
    ...

class ObjCSubscriptRefExpr(multiplier.ast.Expr):
  at_index_method_declaration: multiplier.ast.ObjCMethodDecl
  base_expression: multiplier.ast.Expr
  key_expression: multiplier.ast.Expr
  r_bracket_token: multiplier.frontend.Token
  is_array_subscript_reference_expression: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCSubscriptRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCSubscriptRefExpr]:
    ...

class ObjCStringLiteral(multiplier.ast.Expr):
  at_token: multiplier.frontend.Token
  string: multiplier.ast.StringLiteral

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCStringLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCStringLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCStringLiteral]:
    ...

class ObjCSelectorExpr(multiplier.ast.Expr):
  at_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCSelectorExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCSelectorExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCSelectorExpr]:
    ...

class ObjCProtocolExpr(multiplier.ast.Expr):
  at_token: multiplier.frontend.Token
  protocol: multiplier.ast.ObjCProtocolDecl
  protocol_id_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCProtocolExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCProtocolExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCProtocolExpr]:
    ...

class ObjCPropertyRefExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  class_receiver: multiplier.ast.ObjCInterfaceDecl
  explicit_property: multiplier.ast.ObjCPropertyDecl
  implicit_property_getter: multiplier.ast.ObjCMethodDecl
  implicit_property_setter: multiplier.ast.ObjCMethodDecl
  token: multiplier.frontend.Token
  receiver_token: multiplier.frontend.Token
  receiver_type: multiplier.ast.Type
  super_receiver_type: multiplier.ast.Type
  is_class_receiver: bool
  is_explicit_property: bool
  is_implicit_property: bool
  is_messaging_getter: bool
  is_messaging_setter: bool
  is_object_receiver: bool
  is_super_receiver: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCPropertyRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCPropertyRefExpr]:
    ...

class ObjCMessageExpr(multiplier.ast.Expr):
  num_arguments: int
  arguments: Iterable[multiplier.ast.Expr]
  call_return_type: multiplier.ast.Type
  class_receiver: multiplier.ast.Type
  instance_receiver: multiplier.ast.Expr
  left_token: multiplier.frontend.Token
  method_declaration: multiplier.ast.ObjCMethodDecl
  method_family: multiplier.ast.ObjCMethodFamily
  receiver_interface: multiplier.ast.ObjCInterfaceDecl
  receiver_kind: multiplier.ast.ObjCMessageExprReceiverKind
  receiver_range: multiplier.frontend.TokenRange
  receiver_type: multiplier.ast.Type
  right_token: multiplier.frontend.Token
  selector_start_token: multiplier.frontend.Token
  super_token: multiplier.frontend.Token
  super_type: multiplier.ast.Type
  is_class_message: bool
  is_delegate_initializer_call: bool
  is_implicit: bool
  is_instance_message: bool
  num_selector_tokens: int
  selector_tokens: Iterable[multiplier.frontend.Token]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCMessageExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCMessageExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCMessageExpr]:
    ...

  def nth_argument(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

  def nth_selector_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

class ObjCIvarRefExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  declaration: multiplier.ast.ObjCIvarDecl
  token: multiplier.frontend.Token
  operation_token: multiplier.frontend.Token
  is_arrow: bool
  is_free_instance_variable: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCIvarRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIvarRefExpr]:
    ...

class ObjCIsaExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  base_token_end: multiplier.frontend.Token
  isa_member_token: multiplier.frontend.Token
  operation_token: multiplier.frontend.Token
  is_arrow: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCIsaExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCIsaExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIsaExpr]:
    ...

class ObjCIndirectCopyRestoreExpr(multiplier.ast.Expr):
  sub_expression: multiplier.ast.Expr
  should_copy: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCIndirectCopyRestoreExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCIndirectCopyRestoreExpr]:
    ...

class ObjCEncodeExpr(multiplier.ast.Expr):
  at_token: multiplier.frontend.Token
  encoded_type: multiplier.ast.Type
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCEncodeExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCEncodeExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCEncodeExpr]:
    ...

class ObjCDictionaryLiteral(multiplier.ast.Expr):
  dictionary_with_objects_method: multiplier.ast.ObjCMethodDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCDictionaryLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCDictionaryLiteral]:
    ...

class ObjCBoxedExpr(multiplier.ast.Expr):
  at_token: multiplier.frontend.Token
  boxing_method: multiplier.ast.ObjCMethodDecl
  sub_expression: multiplier.ast.Expr
  is_expressible_as_constant_initializer: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCBoxedExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCBoxedExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBoxedExpr]:
    ...

class ObjCBoolLiteralExpr(multiplier.ast.Expr):
  token: multiplier.frontend.Token
  value: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCBoolLiteralExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCBoolLiteralExpr]:
    ...

class ObjCAvailabilityCheckExpr(multiplier.ast.Expr):
  has_version: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAvailabilityCheckExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCAvailabilityCheckExpr]:
    ...

class ObjCArrayLiteral(multiplier.ast.Expr):
  array_with_objects_method: multiplier.ast.ObjCMethodDecl
  num_elements: int
  elements: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCArrayLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCArrayLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ObjCArrayLiteral]:
    ...

  def nth_element(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class OMPIteratorExpr(multiplier.ast.Expr):
  iterator_kw_token: multiplier.frontend.Token
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPIteratorExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPIteratorExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPIteratorExpr]:
    ...

class OMPArrayShapingExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  num_dimensions: int
  dimensions: Iterable[multiplier.ast.Expr]
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPArrayShapingExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPArrayShapingExpr]:
    ...

  def nth_dimension(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class OMPArraySectionExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  first_colon_token: multiplier.frontend.Token
  second_colon_token: multiplier.frontend.Token
  length: multiplier.ast.Expr
  lower_bound: multiplier.ast.Expr
  r_bracket_token: multiplier.frontend.Token
  stride: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPArraySectionExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPArraySectionExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.OMPArraySectionExpr]:
    ...

class NoInitExpr(multiplier.ast.Expr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NoInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NoInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NoInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.NoInitExpr]:
    ...

class MemberExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  l_angle_token: multiplier.frontend.Token
  member_declaration: multiplier.ast.ValueDecl
  member_token: multiplier.frontend.Token
  operator_token: multiplier.frontend.Token
  r_angle_token: multiplier.frontend.Token
  template_keyword_token: multiplier.frontend.Token
  had_multiple_candidates: bool
  has_explicit_template_arguments: bool
  has_qualifier: bool
  has_template_keyword: bool
  is_arrow: bool
  is_implicit_access: bool
  is_non_odr_use: multiplier.ast.NonOdrUseReason

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MemberExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MemberExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MemberExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MemberExpr]:
    ...

class MatrixSubscriptExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  column_index: multiplier.ast.Expr
  r_bracket_token: multiplier.frontend.Token
  row_index: multiplier.ast.Expr
  is_incomplete: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MatrixSubscriptExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MatrixSubscriptExpr]:
    ...

class MaterializeTemporaryExpr(multiplier.ast.Expr):
  extending_declaration: Optional[multiplier.ast.ValueDecl]
  lifetime_extended_temporary_declaration: Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]
  storage_duration: multiplier.ast.StorageDuration
  sub_expression: multiplier.ast.Expr
  is_bound_to_lvalue_reference: bool
  is_usable_in_constant_expressions: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MaterializeTemporaryExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MaterializeTemporaryExpr]:
    ...

class MSPropertySubscriptExpr(multiplier.ast.Expr):
  base: multiplier.ast.Expr
  index: multiplier.ast.Expr
  r_bracket_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSPropertySubscriptExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSPropertySubscriptExpr]:
    ...

class MSPropertyRefExpr(multiplier.ast.Expr):
  base_expression: multiplier.ast.Expr
  member_token: multiplier.frontend.Token
  property_declaration: multiplier.ast.MSPropertyDecl
  is_arrow: bool
  is_implicit_access: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSPropertyRefExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSPropertyRefExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.MSPropertyRefExpr]:
    ...

class LambdaExpr(multiplier.ast.Expr):
  body: multiplier.ast.Stmt
  call_operator: multiplier.ast.CXXMethodDecl
  capture_default: multiplier.ast.LambdaCaptureDefault
  capture_default_token: multiplier.frontend.Token
  compound_statement_body: multiplier.ast.CompoundStmt
  dependent_call_operator: Optional[multiplier.ast.FunctionTemplateDecl]
  num_explicit_template_parameters: int
  explicit_template_parameters: Iterable[multiplier.ast.NamedDecl]
  introducer_range: multiplier.frontend.TokenRange
  lambda_class: multiplier.ast.CXXRecordDecl
  template_parameter_list: Optional[multiplier.ast.TemplateParameterList]
  trailing_requires_clause: Optional[multiplier.ast.Expr]
  has_explicit_parameters: bool
  has_explicit_result_type: bool
  is_generic_lambda: bool
  is_mutable: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.LambdaExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.LambdaExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.LambdaExpr]:
    ...

  def nth_explicit_template_parameter(self, n: int) -> Optional[multiplier.ast.NamedDecl]:
    ...

class IntegerLiteral(multiplier.ast.Expr):
  token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.IntegerLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.IntegerLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.IntegerLiteral]:
    ...

class InitListExpr(multiplier.ast.Expr):
  array_filler: Optional[multiplier.ast.Expr]
  initialized_field_in_union: Optional[multiplier.ast.FieldDecl]
  l_brace_token: multiplier.frontend.Token
  r_brace_token: multiplier.frontend.Token
  semantic_form: Optional[multiplier.ast.InitListExpr]
  syntactic_form: Optional[multiplier.ast.InitListExpr]
  had_array_range_designator: bool
  has_array_filler: bool
  has_designated_initializer: bool
  num_initializers: int
  initializers: Iterable[multiplier.ast.Expr]
  is_explicit: bool
  is_semantic_form: bool
  is_string_literal_initializer: bool
  is_syntactic_form: bool
  is_transparent: Optional[bool]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.InitListExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.InitListExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.InitListExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.InitListExpr]:
    ...

  def nth_initializer(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class ImplicitValueInitExpr(multiplier.ast.Expr):

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImplicitValueInitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImplicitValueInitExpr]:
    ...

class ImaginaryLiteral(multiplier.ast.Expr):
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImaginaryLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImaginaryLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ImaginaryLiteral]:
    ...

class GenericSelectionExpr(multiplier.ast.Expr):
  num_association_expressions: int
  association_expressions: Iterable[multiplier.ast.Expr]
  controlling_expression: Optional[multiplier.ast.Expr]
  controlling_type: Optional[multiplier.ast.Type]
  default_token: multiplier.frontend.Token
  generic_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  result_expression: Optional[multiplier.ast.Expr]
  is_expression_predicate: bool
  is_result_dependent: bool
  is_type_predicate: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.GenericSelectionExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.GenericSelectionExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GenericSelectionExpr]:
    ...

  def nth_association_expression(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class GNUNullExpr(multiplier.ast.Expr):
  token_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.GNUNullExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.GNUNullExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.GNUNullExpr]:
    ...

class FunctionParmPackExpr(multiplier.ast.Expr):
  parameter_pack: multiplier.ast.VarDecl
  parameter_pack_token: multiplier.frontend.Token
  num_expansions: int
  expansions: Iterable[multiplier.ast.VarDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FunctionParmPackExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FunctionParmPackExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FunctionParmPackExpr]:
    ...

  def nth_expansion(self, n: int) -> Optional[multiplier.ast.VarDecl]:
    ...

class FullExpr(multiplier.ast.Expr):
  sub_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FullExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FullExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FullExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FullExpr]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FullExpr]:
    ...

class ExprWithCleanups(multiplier.ast.FullExpr):
  cleanups_have_side_effects: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExprWithCleanups, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExprWithCleanups]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExprWithCleanups]:
    ...

class ConstantExpr(multiplier.ast.FullExpr):
  result_storage_kind: multiplier.ast.ConstantResultStorageKind
  has_ap_value_result: bool
  is_immediate_invocation: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConstantExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConstantExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstantExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ConstantExpr]:
    ...

class FloatingLiteral(multiplier.ast.Expr):
  token: multiplier.frontend.Token
  is_exact: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FloatingLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FloatingLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FloatingLiteral]:
    ...

class FixedPointLiteral(multiplier.ast.Expr):
  token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FixedPointLiteral, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FixedPointLiteral]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.FixedPointLiteral]:
    ...

class ExtVectorElementExpr(multiplier.ast.Expr):
  contains_duplicate_elements: bool
  accessor_token: multiplier.frontend.Token
  base: multiplier.ast.Expr
  is_arrow: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExtVectorElementExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExtVectorElementExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExtVectorElementExpr]:
    ...

class ExpressionTraitExpr(multiplier.ast.Expr):
  queried_expression: multiplier.ast.Expr
  trait: multiplier.ast.ExpressionTrait
  value: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExpressionTraitExpr, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExpressionTraitExpr]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.ExpressionTraitExpr]:
    ...

class AttributedStmt(multiplier.ast.ValueStmt):
  attribute_token: multiplier.frontend.Token
  num_attributes: int
  attributes: Iterable[multiplier.ast.Attr]
  sub_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AttributedStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AttributedStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.AttributedStmt]:
    ...

  def nth_attribute(self, n: int) -> Optional[multiplier.ast.Attr]:
    ...

class SwitchStmt(multiplier.ast.Stmt):
  body: multiplier.ast.Stmt
  condition: multiplier.ast.Expr
  condition_variable: Optional[multiplier.ast.VarDecl]
  condition_variable_declaration_statement: Optional[multiplier.ast.DeclStmt]
  initializer: Optional[multiplier.ast.Stmt]
  l_paren_token: multiplier.frontend.Token
  r_paren_token: multiplier.frontend.Token
  first_switch_case: Optional[multiplier.ast.SwitchCase]
  switch_token: multiplier.frontend.Token
  has_initializer_storage: bool
  has_variable_storage: bool
  is_all_enum_cases_covered: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SwitchStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SwitchStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwitchStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SwitchStmt]:
    ...

class SwitchCase(multiplier.ast.Stmt):
  colon_token: multiplier.frontend.Token
  keyword_token: multiplier.frontend.Token
  next_switch_case: Optional[multiplier.ast.SwitchCase]
  sub_statement: multiplier.ast.Stmt

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.SwitchCase, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.SwitchCase]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.SwitchCase]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.SwitchCase]:
    ...

class DefaultStmt(multiplier.ast.SwitchCase):
  default_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DefaultStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DefaultStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DefaultStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.DefaultStmt]:
    ...

class CaseStmt(multiplier.ast.SwitchCase):
  case_statement_is_gnu_range: bool
  case_token: multiplier.frontend.Token
  ellipsis_token: multiplier.frontend.Token
  lhs: multiplier.ast.Expr
  rhs: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CaseStmt, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CaseStmt]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Stmt]) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CaseStmt]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.StmtKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Stmt) -> Optional[multiplier.ast.CaseStmt]:
    ...

class Decl(multiplier.Entity):
  parent_declaration: Optional[multiplier.ast.Decl]
  parent_statement: Optional[multiplier.ast.Stmt]
  definition: Optional[multiplier.ast.Decl]
  is_definition: bool
  canonical_declaration: multiplier.ast.Decl
  redeclarations: Iterable[multiplier.ast.Decl]
  specializations: Iterable[multiplier.ast.Decl]
  num_attributes: int
  attributes: Iterable[multiplier.ast.Attr]
  availability: multiplier.ast.AvailabilityResult
  defining_attribute: Optional[multiplier.ast.Attr]
  described_template: Optional[multiplier.ast.TemplateDecl]
  described_template_parameters: Optional[multiplier.ast.TemplateParameterList]
  external_source_symbol_attribute: Optional[multiplier.ast.ExternalSourceSymbolAttr]
  friend_object_kind: multiplier.ast.DeclFriendObjectKind
  max_alignment: Optional[int]
  module_ownership_kind: multiplier.ast.DeclModuleOwnershipKind
  non_closure_context: Optional[multiplier.ast.Decl]
  has_attributes: bool
  has_owning_module: bool
  has_tag_identifier_namespace: bool
  is_defined_outside_function_or_method: bool
  is_deprecated: bool
  is_discarded_in_global_module_fragment: bool
  is_file_context_declaration: bool
  is_function_or_function_template: bool
  is_function_pointer_type: bool
  is_implicit: bool
  is_in_anonymous_namespace: bool
  is_in_another_module_unit: bool
  is_in_export_declaration_context: bool
  is_in_local_scope_for_instantiation: Optional[bool]
  is_in_std_namespace: bool
  is_invisible_outside_the_owning_module: bool
  is_local_extern_declaration: bool
  is_module_private: bool
  is_out_of_line: bool
  is_parameter_pack: bool
  is_template_declaration: bool
  is_template_parameter: bool
  is_template_parameter_pack: bool
  is_templated: bool
  is_top_level_declaration_in_obj_c_container: bool
  is_unavailable: bool
  is_unconditionally_visible: bool
  is_weak_imported: bool
  should_skip_checking_odr: bool
  kind: multiplier.ast.DeclKind
  category: multiplier.ast.DeclCategory
  token: multiplier.frontend.Token
  tokens: multiplier.frontend.TokenRange

  @staticmethod
  def static_category() -> multiplier.EntityCategory:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index, kinds: Sequence[multiplier.ast.DeclKind]) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment, kinds: Sequence[multiplier.ast.DeclKind]) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File, kinds: Sequence[multiplier.ast.DeclKind]) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.Decl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation, kinds: Sequence[multiplier.ast.DeclKind]) -> Iterable[Tuple[multiplier.ast.Decl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.Decl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(self: multiplier.ast.Decl) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(self: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.Decl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.Decl]:
    ...

  def nth_attribute(self, n: int) -> Optional[multiplier.ast.Attr]:
    ...

class CapturedDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.CapturedDecl
  definition: Optional[multiplier.ast.CapturedDecl]
  redeclarations: Iterable[multiplier.ast.CapturedDecl]
  context_parameter: multiplier.ast.ImplicitParamDecl
  is_nothrow: bool
  num_parameters: int
  parameters: Iterable[multiplier.ast.ImplicitParamDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CapturedDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CapturedDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CapturedDecl]:
    ...

  def nth_parameter(self, n: int) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

class BlockDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.BlockDecl
  definition: Optional[multiplier.ast.BlockDecl]
  redeclarations: Iterable[multiplier.ast.BlockDecl]
  block_missing_return_type: bool
  can_avoid_copy_to_heap: bool
  captures_cxx_this: bool
  does_not_escape: bool
  block_mangling_context_declaration: Optional[multiplier.ast.Decl]
  caret_token: multiplier.frontend.Token
  compound_body: multiplier.ast.CompoundStmt
  signature_as_written: multiplier.ast.Type
  has_captures: bool
  is_conversion_from_lambda: bool
  is_variadic: bool
  num_parameters: int
  parameters: Iterable[multiplier.ast.ParmVarDecl]
  num_parameter_declarations: int
  parameter_declarations: Iterable[multiplier.ast.ParmVarDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BlockDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BlockDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BlockDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BlockDecl]:
    ...

  def nth_parameter(self, n: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  def nth_parameter_declaration(self, n: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

class AccessSpecDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.AccessSpecDecl
  definition: Optional[multiplier.ast.AccessSpecDecl]
  redeclarations: Iterable[multiplier.ast.AccessSpecDecl]
  access_specifier_token: multiplier.frontend.Token
  colon_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.AccessSpecDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.AccessSpecDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.AccessSpecDecl]:
    ...

class OMPDeclarativeDirectiveDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.OMPDeclarativeDirectiveDecl
  definition: Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]
  redeclarations: Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDeclarativeDirectiveDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclarativeDirectiveDecl]:
    ...

class OMPThreadPrivateDecl(multiplier.ast.OMPDeclarativeDirectiveDecl):
  canonical_declaration: multiplier.ast.OMPThreadPrivateDecl
  definition: Optional[multiplier.ast.OMPThreadPrivateDecl]
  redeclarations: Iterable[multiplier.ast.OMPThreadPrivateDecl]
  num_varlists: int
  varlists: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPThreadPrivateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPThreadPrivateDecl]:
    ...

  def nth_varlist(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class OMPRequiresDecl(multiplier.ast.OMPDeclarativeDirectiveDecl):
  canonical_declaration: multiplier.ast.OMPRequiresDecl
  definition: Optional[multiplier.ast.OMPRequiresDecl]
  redeclarations: Iterable[multiplier.ast.OMPRequiresDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPRequiresDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPRequiresDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPRequiresDecl]:
    ...

class OMPAllocateDecl(multiplier.ast.OMPDeclarativeDirectiveDecl):
  canonical_declaration: multiplier.ast.OMPAllocateDecl
  definition: Optional[multiplier.ast.OMPAllocateDecl]
  redeclarations: Iterable[multiplier.ast.OMPAllocateDecl]
  num_varlists: int
  varlists: Iterable[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPAllocateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPAllocateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPAllocateDecl]:
    ...

  def nth_varlist(self, n: int) -> Optional[multiplier.ast.Expr]:
    ...

class TranslationUnitDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.TranslationUnitDecl
  definition: Optional[multiplier.ast.TranslationUnitDecl]
  redeclarations: Iterable[multiplier.ast.TranslationUnitDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TranslationUnitDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TranslationUnitDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TranslationUnitDecl]:
    ...

class TopLevelStmtDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.TopLevelStmtDecl
  definition: Optional[multiplier.ast.TopLevelStmtDecl]
  redeclarations: Iterable[multiplier.ast.TopLevelStmtDecl]
  statement: multiplier.ast.Stmt
  is_semi_missing: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TopLevelStmtDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TopLevelStmtDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TopLevelStmtDecl]:
    ...

class StaticAssertDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.StaticAssertDecl
  definition: Optional[multiplier.ast.StaticAssertDecl]
  redeclarations: Iterable[multiplier.ast.StaticAssertDecl]
  assert_expression: multiplier.ast.Expr
  message: Optional[multiplier.ast.Expr]
  r_paren_token: multiplier.frontend.Token
  is_failed: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.StaticAssertDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.StaticAssertDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.StaticAssertDecl]:
    ...

class RequiresExprBodyDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.RequiresExprBodyDecl
  definition: Optional[multiplier.ast.RequiresExprBodyDecl]
  redeclarations: Iterable[multiplier.ast.RequiresExprBodyDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.RequiresExprBodyDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RequiresExprBodyDecl]:
    ...

class PragmaDetectMismatchDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.PragmaDetectMismatchDecl
  definition: Optional[multiplier.ast.PragmaDetectMismatchDecl]
  redeclarations: Iterable[multiplier.ast.PragmaDetectMismatchDecl]
  name: str
  value: str

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.PragmaDetectMismatchDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.PragmaDetectMismatchDecl]:
    ...

class PragmaCommentDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.PragmaCommentDecl
  definition: Optional[multiplier.ast.PragmaCommentDecl]
  redeclarations: Iterable[multiplier.ast.PragmaCommentDecl]
  argument: str
  comment_kind: multiplier.ast.PragmaMSCommentKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.PragmaCommentDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.PragmaCommentDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.PragmaCommentDecl]:
    ...

class ObjCPropertyImplDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.ObjCPropertyImplDecl
  definition: Optional[multiplier.ast.ObjCPropertyImplDecl]
  redeclarations: Iterable[multiplier.ast.ObjCPropertyImplDecl]
  getter_cxx_constructor: multiplier.ast.Expr
  getter_method_declaration: multiplier.ast.ObjCMethodDecl
  property_declaration: multiplier.ast.ObjCPropertyDecl
  property_implementation: multiplier.ast.ObjCPropertyImplDeclKind
  property_instance_variable_declaration: multiplier.ast.ObjCIvarDecl
  property_instance_variable_declaration_token: multiplier.frontend.Token
  setter_cxx_assignment: multiplier.ast.Expr
  setter_method_declaration: multiplier.ast.ObjCMethodDecl
  is_instance_variable_name_specified: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCPropertyImplDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

class NamedDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.NamedDecl
  definition: Optional[multiplier.ast.NamedDecl]
  redeclarations: Iterable[multiplier.ast.NamedDecl]
  formal_linkage: multiplier.ast.Linkage
  name: str
  obj_cf_string_formatting_family: Optional[multiplier.ast.ObjCStringFormatFamily]
  qualified_name_as_string: str
  underlying_declaration: multiplier.ast.NamedDecl
  visibility: Optional[multiplier.ast.Visibility]
  has_external_formal_linkage: bool
  has_linkage: bool
  has_linkage_been_computed: bool
  is_cxx_class_member: bool
  is_cxx_instance_member: bool
  is_externally_declarable: bool
  is_externally_visible: bool
  is_linkage_valid: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NamedDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NamedDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NamedDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamedDecl]:
    ...

class LabelDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.LabelDecl
  definition: Optional[multiplier.ast.LabelDecl]
  redeclarations: Iterable[multiplier.ast.LabelDecl]
  ms_assembly_label: str
  statement: multiplier.ast.LabelStmt
  is_gnu_local: bool
  is_ms_assembly_label: bool
  is_resolved_ms_assembly_label: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.LabelDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.LabelDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LabelDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LabelDecl]:
    ...

class HLSLBufferDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.HLSLBufferDecl
  definition: Optional[multiplier.ast.HLSLBufferDecl]
  redeclarations: Iterable[multiplier.ast.HLSLBufferDecl]
  l_brace_token: multiplier.frontend.Token
  token_start: multiplier.frontend.Token
  r_brace_token: multiplier.frontend.Token
  is_c_buffer: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.HLSLBufferDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.HLSLBufferDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.HLSLBufferDecl]:
    ...

class BaseUsingDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.BaseUsingDecl
  definition: Optional[multiplier.ast.BaseUsingDecl]
  redeclarations: Iterable[multiplier.ast.BaseUsingDecl]
  num_shadows: int
  shadows: Iterable[multiplier.ast.UsingShadowDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BaseUsingDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BaseUsingDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BaseUsingDecl]:
    ...

  def nth_shadow(self, n: int) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

class UsingEnumDecl(multiplier.ast.BaseUsingDecl):
  canonical_declaration: multiplier.ast.UsingEnumDecl
  definition: Optional[multiplier.ast.UsingEnumDecl]
  redeclarations: Iterable[multiplier.ast.UsingEnumDecl]
  enum_declaration: multiplier.ast.EnumDecl
  enum_token: multiplier.frontend.Token
  enum_type: multiplier.ast.Type
  using_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UsingEnumDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UsingEnumDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingEnumDecl]:
    ...

class UsingDecl(multiplier.ast.BaseUsingDecl):
  canonical_declaration: multiplier.ast.UsingDecl
  definition: Optional[multiplier.ast.UsingDecl]
  redeclarations: Iterable[multiplier.ast.UsingDecl]
  using_token: multiplier.frontend.Token
  has_typename: bool
  is_access_declaration: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UsingDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UsingDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingDecl]:
    ...

class ValueDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.ValueDecl
  definition: Optional[multiplier.ast.ValueDecl]
  redeclarations: Iterable[multiplier.ast.ValueDecl]
  potentially_decomposed_variable_declaration: Optional[multiplier.ast.VarDecl]
  type: multiplier.ast.Type
  is_initializer_capture: bool
  is_weak: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ValueDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ValueDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ValueDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ValueDecl]:
    ...

class UnresolvedUsingValueDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.UnresolvedUsingValueDecl
  definition: Optional[multiplier.ast.UnresolvedUsingValueDecl]
  redeclarations: Iterable[multiplier.ast.UnresolvedUsingValueDecl]
  ellipsis_token: multiplier.frontend.Token
  using_token: multiplier.frontend.Token
  is_access_declaration: bool
  is_pack_expansion: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnresolvedUsingValueDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingValueDecl]:
    ...

class UnnamedGlobalConstantDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.UnnamedGlobalConstantDecl
  definition: Optional[multiplier.ast.UnnamedGlobalConstantDecl]
  redeclarations: Iterable[multiplier.ast.UnnamedGlobalConstantDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnnamedGlobalConstantDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnnamedGlobalConstantDecl]:
    ...

class TemplateParamObjectDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.TemplateParamObjectDecl
  definition: Optional[multiplier.ast.TemplateParamObjectDecl]
  redeclarations: Iterable[multiplier.ast.TemplateParamObjectDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TemplateParamObjectDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateParamObjectDecl]:
    ...

class OMPDeclareReductionDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.OMPDeclareReductionDecl
  definition: Optional[multiplier.ast.OMPDeclareReductionDecl]
  redeclarations: Iterable[multiplier.ast.OMPDeclareReductionDecl]
  combiner: multiplier.ast.Expr
  combiner_in: multiplier.ast.Expr
  combiner_out: multiplier.ast.Expr
  initializer_original: multiplier.ast.Expr
  initializer_private: multiplier.ast.Expr
  initializer: multiplier.ast.Expr
  initializer_kind: multiplier.ast.OMPDeclareReductionInitKind
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDeclareReductionDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclareReductionDecl]:
    ...

class MSGuidDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.MSGuidDecl
  definition: Optional[multiplier.ast.MSGuidDecl]
  redeclarations: Iterable[multiplier.ast.MSGuidDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSGuidDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSGuidDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.MSGuidDecl]:
    ...

class IndirectFieldDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.IndirectFieldDecl
  definition: Optional[multiplier.ast.IndirectFieldDecl]
  redeclarations: Iterable[multiplier.ast.IndirectFieldDecl]
  chain: Iterable[multiplier.ast.NamedDecl]
  anonymous_field: Optional[multiplier.ast.FieldDecl]
  variable_declaration: Optional[multiplier.ast.VarDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.IndirectFieldDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.IndirectFieldDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.IndirectFieldDecl]:
    ...

class EnumConstantDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.EnumConstantDecl
  definition: Optional[multiplier.ast.EnumConstantDecl]
  redeclarations: Iterable[multiplier.ast.EnumConstantDecl]
  initializer_expression: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.EnumConstantDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.EnumConstantDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

class DeclaratorDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.DeclaratorDecl
  definition: Optional[multiplier.ast.DeclaratorDecl]
  redeclarations: Iterable[multiplier.ast.DeclaratorDecl]
  first_inner_token: multiplier.frontend.Token
  first_outer_token: multiplier.frontend.Token
  trailing_requires_clause: Optional[multiplier.ast.Expr]
  type_spec_end_token: multiplier.frontend.Token
  type_spec_start_token: multiplier.frontend.Token
  num_template_parameter_lists: int
  template_parameter_lists: Iterable[multiplier.ast.TemplateParameterList]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DeclaratorDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DeclaratorDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.DeclaratorDecl]:
    ...

  def nth_template_parameter_list(self, n: int) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

class VarDecl(multiplier.ast.DeclaratorDecl):
  canonical_declaration: multiplier.ast.VarDecl
  definition: Optional[multiplier.ast.VarDecl]
  redeclarations: Iterable[multiplier.ast.VarDecl]
  acting_definition: Optional[multiplier.ast.VarDecl]
  described_variable_template: Optional[multiplier.ast.VarTemplateDecl]
  initializer: Optional[multiplier.ast.Expr]
  initializer_style: multiplier.ast.VarDeclInitializationStyle
  initializing_declaration: Optional[multiplier.ast.VarDecl]
  language_linkage: multiplier.ast.LanguageLinkage
  point_of_instantiation: multiplier.frontend.Token
  storage_class: multiplier.ast.StorageClass
  storage_duration: multiplier.ast.StorageDuration
  tls_kind: multiplier.ast.VarDeclTLSKind
  tsc_spec: multiplier.ast.ThreadStorageClassSpecifier
  template_instantiation_pattern: Optional[multiplier.ast.VarDecl]
  template_specialization_kind: multiplier.ast.TemplateSpecializationKind
  template_specialization_kind_for_instantiation: multiplier.ast.TemplateSpecializationKind
  has_constant_initialization: bool
  has_dependent_alignment: bool
  has_external_storage: bool
  has_flexible_array_initializer: Optional[bool]
  has_global_storage: bool
  has_initializer: bool
  has_local_storage: bool
  is_arc_pseudo_strong: bool
  is_cxx_for_range_declaration: bool
  is_constexpr: bool
  is_direct_initializer: bool
  is_escaping_byref: bool
  is_exception_variable: bool
  is_extern_c: bool
  is_file_variable_declaration: bool
  is_function_or_method_variable_declaration: bool
  is_in_extern_c_context: bool
  is_in_extern_cxx_context: bool
  is_inline: bool
  is_inline_specified: bool
  is_known_to_be_defined: bool
  is_local_variable_declaration: bool
  is_local_variable_declaration_or_parm: bool
  is_nrvo_variable: bool
  is_no_destroy: bool
  is_non_escaping_byref: bool
  is_obj_c_for_declaration: bool
  is_previous_declaration_in_same_block_scope: bool
  is_static_data_member: bool
  is_static_local: bool
  is_this_declaration_a_demoted_definition: bool
  is_usable_in_constant_expressions: bool
  might_be_usable_in_constant_expressions: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.VarDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.VarDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VarDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarDecl]:
    ...

class ParmVarDecl(multiplier.ast.VarDecl):
  canonical_declaration: multiplier.ast.ParmVarDecl
  definition: Optional[multiplier.ast.ParmVarDecl]
  redeclarations: Iterable[multiplier.ast.ParmVarDecl]
  default_argument: Optional[multiplier.ast.Expr]
  default_argument_range: multiplier.frontend.TokenRange
  explicit_object_parameter_this_token: multiplier.frontend.Token
  obj_c_decl_qualifier: multiplier.ast.DeclObjCDeclQualifier
  original_type: multiplier.ast.Type
  uninstantiated_default_argument: Optional[multiplier.ast.Expr]
  has_default_argument: bool
  has_inherited_default_argument: bool
  has_uninstantiated_default_argument: bool
  has_unparsed_default_argument: bool
  is_destroyed_in_callee: bool
  is_explicit_object_parameter: bool
  is_knr_promoted: bool
  is_obj_c_method_parameter: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ParmVarDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ParmVarDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

class OMPCapturedExprDecl(multiplier.ast.VarDecl):
  canonical_declaration: multiplier.ast.OMPCapturedExprDecl
  definition: Optional[multiplier.ast.OMPCapturedExprDecl]
  redeclarations: Iterable[multiplier.ast.OMPCapturedExprDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPCapturedExprDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPCapturedExprDecl]:
    ...

class ImplicitParamDecl(multiplier.ast.VarDecl):
  canonical_declaration: multiplier.ast.ImplicitParamDecl
  definition: Optional[multiplier.ast.ImplicitParamDecl]
  redeclarations: Iterable[multiplier.ast.ImplicitParamDecl]
  parameter_kind: multiplier.ast.ImplicitParamKind

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImplicitParamDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImplicitParamDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImplicitParamDecl]:
    ...

class DecompositionDecl(multiplier.ast.VarDecl):
  canonical_declaration: multiplier.ast.DecompositionDecl
  definition: Optional[multiplier.ast.DecompositionDecl]
  redeclarations: Iterable[multiplier.ast.DecompositionDecl]
  num_bindings: int
  bindings: Iterable[multiplier.ast.BindingDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.DecompositionDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.DecompositionDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.DecompositionDecl]:
    ...

  def nth_binding(self, n: int) -> Optional[multiplier.ast.BindingDecl]:
    ...

class VarTemplateSpecializationDecl(multiplier.ast.VarDecl):
  canonical_declaration: multiplier.ast.VarTemplateSpecializationDecl
  definition: Optional[multiplier.ast.VarTemplateSpecializationDecl]
  redeclarations: Iterable[multiplier.ast.VarTemplateSpecializationDecl]
  extern_token: multiplier.frontend.Token
  specialization_kind: multiplier.ast.TemplateSpecializationKind
  specialized_template: multiplier.ast.VarTemplateDecl
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]
  num_template_instantiation_arguments: int
  template_instantiation_arguments: Iterable[multiplier.ast.TemplateArgument]
  template_keyword_token: multiplier.frontend.Token
  type_as_written: Optional[multiplier.ast.Type]
  is_class_scope_explicit_specialization: bool
  is_explicit_instantiation_or_specialization: bool
  is_explicit_specialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.VarTemplateSpecializationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplateSpecializationDecl]:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  def nth_template_instantiation_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class VarTemplatePartialSpecializationDecl(multiplier.ast.VarTemplateSpecializationDecl):
  canonical_declaration: multiplier.ast.VarTemplatePartialSpecializationDecl
  definition: Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]
  redeclarations: Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]
  instantiated_from_member: Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]
  template_parameters: multiplier.ast.TemplateParameterList
  has_associated_constraints: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.VarTemplatePartialSpecializationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplatePartialSpecializationDecl]:
    ...

class NonTypeTemplateParmDecl(multiplier.ast.DeclaratorDecl):
  canonical_declaration: multiplier.ast.NonTypeTemplateParmDecl
  definition: Optional[multiplier.ast.NonTypeTemplateParmDecl]
  redeclarations: Iterable[multiplier.ast.NonTypeTemplateParmDecl]
  default_argument_was_inherited: bool
  default_argument: Optional[multiplier.ast.Expr]
  default_argument_token: multiplier.frontend.Token
  placeholder_type_constraint: Optional[multiplier.ast.Expr]
  has_default_argument: bool
  has_placeholder_type_constraint: bool
  is_expanded_parameter_pack: bool
  is_pack_expansion: bool
  num_expansion_types: int
  expansion_types: Iterable[multiplier.ast.Type]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NonTypeTemplateParmDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NonTypeTemplateParmDecl]:
    ...

  def nth_expansion_type(self, n: int) -> Optional[multiplier.ast.Type]:
    ...

class MSPropertyDecl(multiplier.ast.DeclaratorDecl):
  canonical_declaration: multiplier.ast.MSPropertyDecl
  definition: Optional[multiplier.ast.MSPropertyDecl]
  redeclarations: Iterable[multiplier.ast.MSPropertyDecl]
  has_getter: bool
  has_setter: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.MSPropertyDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.MSPropertyDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.MSPropertyDecl]:
    ...

class FunctionDecl(multiplier.ast.DeclaratorDecl):
  canonical_declaration: multiplier.ast.FunctionDecl
  definition: Optional[multiplier.ast.FunctionDecl]
  redeclarations: Iterable[multiplier.ast.FunctionDecl]
  body_contains_immediate_escalating_expressions: bool
  friend_constraint_refers_to_enclosing_template: bool
  uses_fp_intrin: bool
  does_declaration_force_externally_visible_definition: Optional[bool]
  does_this_declaration_have_a_body: bool
  call_result_type: multiplier.ast.Type
  constexpr_kind: multiplier.ast.ConstexprSpecKind
  declared_return_type: multiplier.ast.Type
  default_token: multiplier.frontend.Token
  described_function_template: Optional[multiplier.ast.FunctionTemplateDecl]
  ellipsis_token: multiplier.frontend.Token
  exception_spec_tokens: multiplier.frontend.TokenRange
  exception_spec_type: multiplier.ast.ExceptionSpecificationType
  language_linkage: multiplier.ast.LanguageLinkage
  multi_version_kind: multiplier.ast.MultiVersionKind
  overloaded_operator: multiplier.ast.OverloadedOperatorKind
  parameters_tokens: multiplier.frontend.TokenRange
  point_of_instantiation: multiplier.frontend.Token
  primary_template: Optional[multiplier.ast.FunctionTemplateDecl]
  return_type: multiplier.ast.Type
  storage_class: multiplier.ast.StorageClass
  template_instantiation_pattern: Optional[multiplier.ast.FunctionDecl]
  template_specialization_kind: multiplier.ast.TemplateSpecializationKind
  template_specialization_kind_for_instantiation: multiplier.ast.TemplateSpecializationKind
  templated_kind: multiplier.ast.FunctionDeclTemplatedKind
  has_cxx_explicit_function_object_parameter: bool
  has_implicit_return_zero: bool
  has_inherited_prototype: bool
  has_one_parameter_or_default_arguments: bool
  has_prototype: bool
  has_skipped_body: bool
  has_trivial_body: bool
  has_written_prototype: bool
  instantiation_is_pending: bool
  is_cpu_dispatch_multi_version: bool
  is_cpu_specific_multi_version: bool
  is_consteval: bool
  is_constexpr: bool
  is_constexpr_specified: bool
  is_defaulted: bool
  is_deleted: bool
  is_deleted_as_written: bool
  is_destroying_operator_delete: bool
  is_explicitly_defaulted: bool
  is_extern_c: bool
  is_function_template_specialization: bool
  is_global: bool
  is_immediate_escalating: bool
  is_immediate_function: bool
  is_implicitly_instantiable: bool
  is_in_extern_c_context: bool
  is_in_extern_cxx_context: bool
  is_ineligible_or_not_selected: bool
  is_inline_builtin_declaration: bool
  is_inline_definition_externally_visible: Optional[bool]
  is_inline_specified: bool
  is_inlined: bool
  is_late_template_parsed: bool
  is_ms_extern_inline: Optional[bool]
  is_msvcrt_entry_point: bool
  is_main: bool
  is_member_like_constrained_friend: bool
  is_multi_version: bool
  is_no_return: bool
  is_overloaded_operator: bool
  is_pure_virtual: bool
  is_replaceable_global_allocation_function: bool
  is_reserved_global_placement_operator: Optional[bool]
  is_static: bool
  is_target_clones_multi_version: bool
  is_target_multi_version: bool
  is_template_instantiation: bool
  is_this_declaration_a_definition: bool
  is_trivial: bool
  is_trivial_for_call: bool
  is_user_provided: bool
  is_variadic: bool
  is_virtual_as_written: bool
  num_parameters: int
  parameters: Iterable[multiplier.ast.ParmVarDecl]
  uses_seh_try: bool
  body: Optional[multiplier.ast.Stmt]
  contained_declarations: Iterable[multiplier.ast.Decl]
  callers: Iterable[multiplier.ast.Stmt]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FunctionDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FunctionDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FunctionDecl]:
    ...

  def nth_parameter(self, n: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

class CXXMethodDecl(multiplier.ast.FunctionDecl):
  canonical_declaration: multiplier.ast.CXXMethodDecl
  definition: Optional[multiplier.ast.CXXMethodDecl]
  redeclarations: Iterable[multiplier.ast.CXXMethodDecl]
  function_object_parameter_reference_type: multiplier.ast.Type
  function_object_parameter_type: multiplier.ast.Type
  reference_qualifier: multiplier.ast.RefQualifierKind
  this_type: Optional[multiplier.ast.Type]
  has_inline_body: bool
  is_const: bool
  is_copy_assignment_operator: bool
  is_explicit_object_member_function: bool
  is_implicit_object_member_function: bool
  is_instance: bool
  is_lambda_static_invoker: bool
  is_move_assignment_operator: bool
  is_virtual: bool
  is_volatile: bool
  num_overridden_methods: int
  overridden_methods: Iterable[multiplier.ast.CXXMethodDecl]
  overridden_by_methods: Iterable[multiplier.ast.CXXMethodDecl]
  transitive_overridden_by_methods: Iterable[multiplier.ast.CXXMethodDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXMethodDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXMethodDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

  def nth_overridden_method(self, n: int) -> Optional[multiplier.ast.CXXMethodDecl]:
    ...

class CXXDestructorDecl(multiplier.ast.CXXMethodDecl):
  canonical_declaration: multiplier.ast.CXXDestructorDecl
  definition: Optional[multiplier.ast.CXXDestructorDecl]
  redeclarations: Iterable[multiplier.ast.CXXDestructorDecl]
  operator_delete: Optional[multiplier.ast.FunctionDecl]
  operator_delete_this_argument: Optional[multiplier.ast.Expr]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDestructorDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDestructorDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXDestructorDecl]:
    ...

class CXXConversionDecl(multiplier.ast.CXXMethodDecl):
  canonical_declaration: multiplier.ast.CXXConversionDecl
  definition: Optional[multiplier.ast.CXXConversionDecl]
  redeclarations: Iterable[multiplier.ast.CXXConversionDecl]
  conversion_type: multiplier.ast.Type
  is_explicit: bool
  is_lambda_to_block_pointer_conversion: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXConversionDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXConversionDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXConversionDecl]:
    ...

class CXXConstructorDecl(multiplier.ast.CXXMethodDecl):
  canonical_declaration: multiplier.ast.CXXConstructorDecl
  definition: Optional[multiplier.ast.CXXConstructorDecl]
  redeclarations: Iterable[multiplier.ast.CXXConstructorDecl]
  target_constructor: Optional[multiplier.ast.CXXConstructorDecl]
  num_initializers: int
  initializers: Iterable[multiplier.ast.CXXCtorInitializer]
  is_default_constructor: bool
  is_delegating_constructor: bool
  is_explicit: bool
  is_inheriting_constructor: bool
  is_specialization_copying_object: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXConstructorDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXConstructorDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

  def nth_initializer(self, n: int) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

class CXXDeductionGuideDecl(multiplier.ast.FunctionDecl):
  canonical_declaration: multiplier.ast.CXXDeductionGuideDecl
  definition: Optional[multiplier.ast.CXXDeductionGuideDecl]
  redeclarations: Iterable[multiplier.ast.CXXDeductionGuideDecl]
  corresponding_constructor: Optional[multiplier.ast.CXXConstructorDecl]
  deduced_template: multiplier.ast.TemplateDecl
  deduction_candidate_kind: multiplier.ast.DeductionCandidate
  is_explicit: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXDeductionGuideDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXDeductionGuideDecl]:
    ...

class FieldDecl(multiplier.ast.DeclaratorDecl):
  canonical_declaration: multiplier.ast.FieldDecl
  definition: Optional[multiplier.ast.FieldDecl]
  redeclarations: Iterable[multiplier.ast.FieldDecl]
  bit_width: Optional[multiplier.ast.Expr]
  captured_vla_type: Optional[multiplier.ast.VariableArrayType]
  in_class_initializer_style: multiplier.ast.InClassInitStyle
  in_class_initializer: Optional[multiplier.ast.Expr]
  has_captured_vla_type: bool
  has_in_class_initializer: bool
  has_non_null_in_class_initializer: bool
  is_anonymous_struct_or_union: bool
  is_bit_field: bool
  is_mutable: bool
  is_potentially_overlapping: bool
  is_unnamed_bitfield: bool
  is_zero_length_bit_field: bool
  is_zero_size: bool
  offset_in_bits: Optional[int]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FieldDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FieldDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FieldDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FieldDecl]:
    ...

class ObjCIvarDecl(multiplier.ast.FieldDecl):
  canonical_declaration: multiplier.ast.ObjCIvarDecl
  definition: Optional[multiplier.ast.ObjCIvarDecl]
  redeclarations: Iterable[multiplier.ast.ObjCIvarDecl]
  access_control: multiplier.ast.ObjCIvarDeclAccessControl
  canonical_access_control: multiplier.ast.ObjCIvarDeclAccessControl
  containing_interface: multiplier.ast.ObjCInterfaceDecl
  next_instance_variable: multiplier.ast.ObjCIvarDecl
  synthesize: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCIvarDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCIvarDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

class ObjCAtDefsFieldDecl(multiplier.ast.FieldDecl):
  canonical_declaration: multiplier.ast.ObjCAtDefsFieldDecl
  definition: Optional[multiplier.ast.ObjCAtDefsFieldDecl]
  redeclarations: Iterable[multiplier.ast.ObjCAtDefsFieldDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCAtDefsFieldDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCAtDefsFieldDecl]:
    ...

class BindingDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.BindingDecl
  definition: Optional[multiplier.ast.BindingDecl]
  redeclarations: Iterable[multiplier.ast.BindingDecl]
  binding: Optional[multiplier.ast.Expr]
  decomposed_declaration: multiplier.ast.ValueDecl
  holding_variable: Optional[multiplier.ast.VarDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BindingDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BindingDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BindingDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BindingDecl]:
    ...

class OMPDeclarativeDirectiveValueDecl(multiplier.ast.ValueDecl):
  canonical_declaration: multiplier.ast.OMPDeclarativeDirectiveValueDecl
  definition: Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]
  redeclarations: Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDeclarativeDirectiveValueDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclarativeDirectiveValueDecl]:
    ...

class OMPDeclareMapperDecl(multiplier.ast.OMPDeclarativeDirectiveValueDecl):
  canonical_declaration: multiplier.ast.OMPDeclareMapperDecl
  definition: Optional[multiplier.ast.OMPDeclareMapperDecl]
  redeclarations: Iterable[multiplier.ast.OMPDeclareMapperDecl]
  mapper_variable_reference: multiplier.ast.Expr
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.OMPDeclareMapperDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.OMPDeclareMapperDecl]:
    ...

class UsingShadowDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.UsingShadowDecl
  definition: Optional[multiplier.ast.UsingShadowDecl]
  redeclarations: Iterable[multiplier.ast.UsingShadowDecl]
  introducer: multiplier.ast.BaseUsingDecl
  next_using_shadow_declaration: Optional[multiplier.ast.UsingShadowDecl]
  target_declaration: multiplier.ast.NamedDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UsingShadowDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UsingShadowDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingShadowDecl]:
    ...

class ConstructorUsingShadowDecl(multiplier.ast.UsingShadowDecl):
  canonical_declaration: multiplier.ast.ConstructorUsingShadowDecl
  definition: Optional[multiplier.ast.ConstructorUsingShadowDecl]
  redeclarations: Iterable[multiplier.ast.ConstructorUsingShadowDecl]
  constructs_virtual_base: bool
  constructed_base_class: multiplier.ast.CXXRecordDecl
  constructed_base_class_shadow_declaration: Optional[multiplier.ast.ConstructorUsingShadowDecl]
  nominated_base_class: multiplier.ast.CXXRecordDecl
  nominated_base_class_shadow_declaration: Optional[multiplier.ast.ConstructorUsingShadowDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConstructorUsingShadowDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ConstructorUsingShadowDecl]:
    ...

class UsingPackDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.UsingPackDecl
  definition: Optional[multiplier.ast.UsingPackDecl]
  redeclarations: Iterable[multiplier.ast.UsingPackDecl]
  num_expansions: int
  expansions: Iterable[multiplier.ast.NamedDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UsingPackDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UsingPackDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingPackDecl]:
    ...

  def nth_expansion(self, n: int) -> Optional[multiplier.ast.NamedDecl]:
    ...

class UsingDirectiveDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.UsingDirectiveDecl
  definition: Optional[multiplier.ast.UsingDirectiveDecl]
  redeclarations: Iterable[multiplier.ast.UsingDirectiveDecl]
  identifier_token: multiplier.frontend.Token
  namespace_key_token: multiplier.frontend.Token
  nominated_namespace: multiplier.ast.NamespaceDecl
  nominated_namespace_as_written: multiplier.ast.NamedDecl
  using_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UsingDirectiveDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UsingDirectiveDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UsingDirectiveDecl]:
    ...

class UnresolvedUsingIfExistsDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.UnresolvedUsingIfExistsDecl
  definition: Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]
  redeclarations: Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnresolvedUsingIfExistsDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingIfExistsDecl]:
    ...

class TypeDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.TypeDecl
  definition: Optional[multiplier.ast.TypeDecl]
  redeclarations: Iterable[multiplier.ast.TypeDecl]
  type_for_declaration: Optional[multiplier.ast.Type]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypeDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypeDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeDecl]:
    ...

class TemplateTypeParmDecl(multiplier.ast.TypeDecl):
  canonical_declaration: multiplier.ast.TemplateTypeParmDecl
  definition: Optional[multiplier.ast.TemplateTypeParmDecl]
  redeclarations: Iterable[multiplier.ast.TemplateTypeParmDecl]
  default_argument_was_inherited: bool
  default_argument: Optional[multiplier.ast.Type]
  default_argument_info: Optional[multiplier.ast.Type]
  default_argument_token: multiplier.frontend.Token
  has_default_argument: bool
  has_type_constraint: bool
  is_expanded_parameter_pack: bool
  is_pack_expansion: bool
  was_declared_with_typename: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TemplateTypeParmDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateTypeParmDecl]:
    ...

class TagDecl(multiplier.ast.TypeDecl):
  canonical_declaration: multiplier.ast.TagDecl
  definition: Optional[multiplier.ast.TagDecl]
  redeclarations: Iterable[multiplier.ast.TagDecl]
  brace_range: multiplier.frontend.TokenRange
  first_inner_token: multiplier.frontend.Token
  first_outer_token: multiplier.frontend.Token
  tag_kind: multiplier.ast.TagTypeKind
  typedef_name_for_anonymous_declaration: Optional[multiplier.ast.TypedefNameDecl]
  has_name_for_linkage: bool
  is_being_defined: bool
  is_class: bool
  is_complete_definition: bool
  is_complete_definition_required: bool
  is_dependent_type: bool
  is_enum: bool
  is_free_standing: bool
  is_interface: bool
  is_struct: bool
  is_this_declaration_a_definition: bool
  is_this_declaration_a_demoted_definition: bool
  is_union: bool
  may_have_out_of_date_definition: bool
  num_template_parameter_lists: int
  template_parameter_lists: Iterable[multiplier.ast.TemplateParameterList]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TagDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TagDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TagDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TagDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TagDecl]:
    ...

  def nth_template_parameter_list(self, n: int) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

class RecordDecl(multiplier.ast.TagDecl):
  canonical_declaration: multiplier.ast.RecordDecl
  definition: Optional[multiplier.ast.RecordDecl]
  redeclarations: Iterable[multiplier.ast.RecordDecl]
  can_pass_in_registers: bool
  num_fields: int
  fields: Iterable[multiplier.ast.FieldDecl]
  argument_passing_restrictions: multiplier.ast.RecordArgPassingKind
  has_flexible_array_member: bool
  has_loaded_fields_from_external_storage: bool
  has_non_trivial_to_primitive_copy_c_union: bool
  has_non_trivial_to_primitive_default_initialize_c_union: bool
  has_non_trivial_to_primitive_destruct_c_union: bool
  has_object_member: bool
  has_volatile_member: bool
  is_anonymous_struct_or_union: bool
  is_captured_record: bool
  is_injected_class_name: bool
  is_lambda: bool
  is_ms_struct: bool
  is_non_trivial_to_primitive_copy: bool
  is_non_trivial_to_primitive_default_initialize: bool
  is_non_trivial_to_primitive_destroy: bool
  is_or_contains_union: bool
  is_parameter_destroyed_in_callee: bool
  is_randomized: bool
  may_insert_extra_padding: bool
  size: Optional[int]
  alignment: Optional[int]
  size_without_trailing_padding: Optional[int]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.RecordDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.RecordDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RecordDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RecordDecl]:
    ...

  def nth_field(self, n: int) -> Optional[multiplier.ast.FieldDecl]:
    ...

class CXXRecordDecl(multiplier.ast.RecordDecl):
  canonical_declaration: multiplier.ast.CXXRecordDecl
  definition: Optional[multiplier.ast.CXXRecordDecl]
  redeclarations: Iterable[multiplier.ast.CXXRecordDecl]
  allow_const_default_initializer: Optional[bool]
  bases: Optional[Sequence[multiplier.ast.CXXBaseSpecifier]]
  inheritance_model: Optional[multiplier.ast.MSInheritanceModel]
  num_constructors: int
  constructors: Iterable[multiplier.ast.CXXConstructorDecl]
  friends: Optional[Sequence[multiplier.ast.FriendDecl]]
  dependent_lambda_call_operator: Optional[multiplier.ast.FunctionTemplateDecl]
  described_class_template: Optional[multiplier.ast.ClassTemplateDecl]
  destructor: Optional[multiplier.ast.CXXDestructorDecl]
  generic_lambda_template_parameter_list: Optional[multiplier.ast.TemplateParameterList]
  instantiated_from_member_class: Optional[multiplier.ast.CXXRecordDecl]
  lambda_call_operator: Optional[multiplier.ast.CXXMethodDecl]
  lambda_capture_default: Optional[multiplier.ast.LambdaCaptureDefault]
  lambda_context_declaration: Optional[multiplier.ast.Decl]
  lambda_explicit_template_parameters: Optional[Sequence[multiplier.ast.NamedDecl]]
  lambda_mangling_number: Optional[int]
  lambda_static_invoker: Optional[multiplier.ast.CXXMethodDecl]
  ms_inheritance_model: Optional[multiplier.ast.MSInheritanceModel]
  ms_vtor_disp_mode: multiplier.ast.MSVtorDispMode
  template_instantiation_pattern: Optional[multiplier.ast.CXXRecordDecl]
  template_specialization_kind: multiplier.ast.TemplateSpecializationKind
  has_any_dependent_bases: Optional[bool]
  has_constexpr_default_constructor: Optional[bool]
  has_constexpr_destructor: Optional[bool]
  has_constexpr_non_copy_move_constructor: Optional[bool]
  has_copy_assignment_with_const_parameter: Optional[bool]
  has_copy_constructor_with_const_parameter: Optional[bool]
  has_default_constructor: Optional[bool]
  has_definition: Optional[bool]
  has_direct_fields: Optional[bool]
  has_friends: Optional[bool]
  has_in_class_initializer: Optional[bool]
  has_inherited_assignment: Optional[bool]
  has_inherited_constructor: Optional[bool]
  has_initializer_method: Optional[bool]
  has_irrelevant_destructor: Optional[bool]
  has_known_lambda_internal_linkage: Optional[bool]
  has_move_assignment: Optional[bool]
  has_move_constructor: Optional[bool]
  has_mutable_fields: Optional[bool]
  has_non_literal_type_fields_or_bases: Optional[bool]
  has_non_trivial_copy_assignment: Optional[bool]
  has_non_trivial_copy_constructor: Optional[bool]
  has_non_trivial_copy_constructor_for_call: Optional[bool]
  has_non_trivial_default_constructor: Optional[bool]
  has_non_trivial_destructor: Optional[bool]
  has_non_trivial_destructor_for_call: Optional[bool]
  has_non_trivial_move_assignment: Optional[bool]
  has_non_trivial_move_constructor: Optional[bool]
  has_non_trivial_move_constructor_for_call: Optional[bool]
  has_private_fields: Optional[bool]
  has_protected_fields: Optional[bool]
  has_simple_copy_assignment: Optional[bool]
  has_simple_copy_constructor: Optional[bool]
  has_simple_destructor: Optional[bool]
  has_simple_move_assignment: Optional[bool]
  has_simple_move_constructor: Optional[bool]
  has_trivial_copy_assignment: Optional[bool]
  has_trivial_copy_constructor: Optional[bool]
  has_trivial_copy_constructor_for_call: Optional[bool]
  has_trivial_default_constructor: Optional[bool]
  has_trivial_destructor: Optional[bool]
  has_trivial_destructor_for_call: Optional[bool]
  has_trivial_move_assignment: Optional[bool]
  has_trivial_move_constructor: Optional[bool]
  has_trivial_move_constructor_for_call: Optional[bool]
  has_uninitialized_reference_member: Optional[bool]
  has_user_declared_constructor: Optional[bool]
  has_user_declared_copy_assignment: Optional[bool]
  has_user_declared_copy_constructor: Optional[bool]
  has_user_declared_destructor: Optional[bool]
  has_user_declared_move_assignment: Optional[bool]
  has_user_declared_move_constructor: Optional[bool]
  has_user_declared_move_operation: Optional[bool]
  has_user_provided_default_constructor: Optional[bool]
  has_variant_members: Optional[bool]
  implicit_copy_assignment_has_const_parameter: Optional[bool]
  implicit_copy_constructor_has_const_parameter: Optional[bool]
  is_abstract: Optional[bool]
  is_aggregate: Optional[bool]
  is_any_destructor_no_return: Optional[bool]
  is_c_like: Optional[bool]
  is_cxx11_standard_layout: Optional[bool]
  is_captureless_lambda: bool
  is_dependent_lambda: bool
  is_dynamic_class: Optional[bool]
  is_effectively_final: Optional[bool]
  is_empty: Optional[bool]
  is_generic_lambda: bool
  is_interface_like: Optional[bool]
  is_literal: Optional[bool]
  is_local_class: Optional[multiplier.ast.FunctionDecl]
  is_never_dependent_lambda: bool
  is_pod: Optional[bool]
  is_polymorphic: Optional[bool]
  is_standard_layout: Optional[bool]
  is_structural: Optional[bool]
  is_trivial: Optional[bool]
  is_trivially_copy_constructible: bool
  is_trivially_copyable: Optional[bool]
  lambda_is_default_constructible_and_assignable: Optional[bool]
  may_be_abstract: Optional[bool]
  may_be_dynamic_class: Optional[bool]
  may_be_non_dynamic_class: Optional[bool]
  needs_implicit_copy_assignment: Optional[bool]
  needs_implicit_copy_constructor: Optional[bool]
  needs_implicit_default_constructor: Optional[bool]
  needs_implicit_destructor: Optional[bool]
  needs_implicit_move_assignment: Optional[bool]
  needs_implicit_move_constructor: Optional[bool]
  needs_overload_resolution_for_copy_assignment: Optional[bool]
  needs_overload_resolution_for_copy_constructor: Optional[bool]
  needs_overload_resolution_for_destructor: Optional[bool]
  needs_overload_resolution_for_move_assignment: Optional[bool]
  needs_overload_resolution_for_move_constructor: Optional[bool]
  null_field_offset_is_zero: Optional[bool]
  virtual_bases: Optional[Sequence[multiplier.ast.CXXBaseSpecifier]]
  size_without_virtual_bases: Optional[int]
  primary_base: Optional[multiplier.ast.CXXRecordDecl]
  has_own_virtual_function_table_pointer: Optional[bool]
  has_extendable_virtual_function_table_pointer: Optional[bool]
  has_virtual_base_table_pointer: Optional[bool]
  has_own_virtual_base_table_pointer: Optional[bool]
  derived_classes: Iterable[multiplier.ast.CXXRecordDecl]
  base_classes: Iterable[multiplier.ast.CXXRecordDecl]
  methods: Iterable[multiplier.ast.CXXMethodDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.CXXRecordDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.CXXRecordDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.CXXRecordDecl]:
    ...

  def nth_constructor(self, n: int) -> Optional[multiplier.ast.CXXConstructorDecl]:
    ...

class ClassTemplateSpecializationDecl(multiplier.ast.CXXRecordDecl):
  canonical_declaration: multiplier.ast.ClassTemplateSpecializationDecl
  definition: Optional[multiplier.ast.ClassTemplateSpecializationDecl]
  redeclarations: Iterable[multiplier.ast.ClassTemplateSpecializationDecl]
  extern_token: multiplier.frontend.Token
  point_of_instantiation: multiplier.frontend.Token
  specialization_kind: multiplier.ast.TemplateSpecializationKind
  specialized_template: multiplier.ast.ClassTemplateDecl
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]
  num_template_instantiation_arguments: int
  template_instantiation_arguments: Iterable[multiplier.ast.TemplateArgument]
  template_keyword_token: multiplier.frontend.Token
  type_as_written: Optional[multiplier.ast.Type]
  is_class_scope_explicit_specialization: bool
  is_explicit_instantiation_or_specialization: bool
  is_explicit_specialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ClassTemplateSpecializationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplateSpecializationDecl]:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

  def nth_template_instantiation_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class ClassTemplatePartialSpecializationDecl(multiplier.ast.ClassTemplateSpecializationDecl):
  canonical_declaration: multiplier.ast.ClassTemplatePartialSpecializationDecl
  definition: Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]
  redeclarations: Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]
  injected_specialization_type: multiplier.ast.Type
  instantiated_from_member: Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]
  instantiated_from_member_template: Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]
  template_parameters: multiplier.ast.TemplateParameterList
  has_associated_constraints: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ClassTemplatePartialSpecializationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplatePartialSpecializationDecl]:
    ...

class EnumDecl(multiplier.ast.TagDecl):
  canonical_declaration: multiplier.ast.EnumDecl
  definition: Optional[multiplier.ast.EnumDecl]
  redeclarations: Iterable[multiplier.ast.EnumDecl]
  num_enumerators: int
  enumerators: Iterable[multiplier.ast.EnumConstantDecl]
  integer_type: Optional[multiplier.ast.Type]
  integer_type_range: multiplier.frontend.TokenRange
  promotion_type: Optional[multiplier.ast.Type]
  template_instantiation_pattern: Optional[multiplier.ast.EnumDecl]
  template_specialization_kind: multiplier.ast.TemplateSpecializationKind
  is_closed: bool
  is_closed_flag: bool
  is_closed_non_flag: bool
  is_complete: bool
  is_fixed: bool
  is_scoped: bool
  is_scoped_using_class_tag: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.EnumDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.EnumDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EnumDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EnumDecl]:
    ...

  def nth_enumerator(self, n: int) -> Optional[multiplier.ast.EnumConstantDecl]:
    ...

class UnresolvedUsingTypenameDecl(multiplier.ast.TypeDecl):
  canonical_declaration: multiplier.ast.UnresolvedUsingTypenameDecl
  definition: Optional[multiplier.ast.UnresolvedUsingTypenameDecl]
  redeclarations: Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]
  ellipsis_token: multiplier.frontend.Token
  typename_token: multiplier.frontend.Token
  using_token: multiplier.frontend.Token
  is_pack_expansion: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.UnresolvedUsingTypenameDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.UnresolvedUsingTypenameDecl]:
    ...

class TypedefNameDecl(multiplier.ast.TypeDecl):
  canonical_declaration: multiplier.ast.TypedefNameDecl
  definition: Optional[multiplier.ast.TypedefNameDecl]
  redeclarations: Iterable[multiplier.ast.TypedefNameDecl]
  anonymous_declaration_with_typedef_name: Optional[multiplier.ast.TagDecl]
  underlying_type: multiplier.ast.Type
  is_moded: bool
  is_transparent_tag: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypedefNameDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypedefNameDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypedefNameDecl]:
    ...

class TypedefDecl(multiplier.ast.TypedefNameDecl):
  canonical_declaration: multiplier.ast.TypedefDecl
  definition: Optional[multiplier.ast.TypedefDecl]
  redeclarations: Iterable[multiplier.ast.TypedefDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypedefDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypedefDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypedefDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypedefDecl]:
    ...

class TypeAliasDecl(multiplier.ast.TypedefNameDecl):
  canonical_declaration: multiplier.ast.TypeAliasDecl
  definition: Optional[multiplier.ast.TypeAliasDecl]
  redeclarations: Iterable[multiplier.ast.TypeAliasDecl]
  described_alias_template: Optional[multiplier.ast.TypeAliasTemplateDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypeAliasDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypeAliasDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeAliasDecl]:
    ...

class ObjCTypeParamDecl(multiplier.ast.TypedefNameDecl):
  canonical_declaration: multiplier.ast.ObjCTypeParamDecl
  definition: Optional[multiplier.ast.ObjCTypeParamDecl]
  redeclarations: Iterable[multiplier.ast.ObjCTypeParamDecl]
  colon_token: multiplier.frontend.Token
  variance: multiplier.ast.ObjCTypeParamVariance
  variance_token: multiplier.frontend.Token
  has_explicit_bound: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCTypeParamDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCTypeParamDecl]:
    ...

class TemplateDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.TemplateDecl
  definition: Optional[multiplier.ast.TemplateDecl]
  redeclarations: Iterable[multiplier.ast.TemplateDecl]
  template_parameters: multiplier.ast.TemplateParameterList
  templated_declaration: Optional[multiplier.ast.NamedDecl]
  has_associated_constraints: bool
  is_type_alias: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateDecl]:
    ...

class RedeclarableTemplateDecl(multiplier.ast.TemplateDecl):
  canonical_declaration: multiplier.ast.RedeclarableTemplateDecl
  definition: Optional[multiplier.ast.RedeclarableTemplateDecl]
  redeclarations: Iterable[multiplier.ast.RedeclarableTemplateDecl]
  instantiated_from_member_template: Optional[multiplier.ast.RedeclarableTemplateDecl]
  is_member_specialization: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.RedeclarableTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.RedeclarableTemplateDecl]:
    ...

class FunctionTemplateDecl(multiplier.ast.RedeclarableTemplateDecl):
  canonical_declaration: multiplier.ast.FunctionTemplateDecl
  definition: Optional[multiplier.ast.FunctionTemplateDecl]
  redeclarations: Iterable[multiplier.ast.FunctionTemplateDecl]
  is_abbreviated: bool
  is_this_declaration_a_definition: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FunctionTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FunctionTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FunctionTemplateDecl]:
    ...

class ClassTemplateDecl(multiplier.ast.RedeclarableTemplateDecl):
  canonical_declaration: multiplier.ast.ClassTemplateDecl
  definition: Optional[multiplier.ast.ClassTemplateDecl]
  redeclarations: Iterable[multiplier.ast.ClassTemplateDecl]
  is_this_declaration_a_definition: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ClassTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ClassTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ClassTemplateDecl]:
    ...

class VarTemplateDecl(multiplier.ast.RedeclarableTemplateDecl):
  canonical_declaration: multiplier.ast.VarTemplateDecl
  definition: Optional[multiplier.ast.VarTemplateDecl]
  redeclarations: Iterable[multiplier.ast.VarTemplateDecl]
  is_this_declaration_a_definition: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.VarTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.VarTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.VarTemplateDecl]:
    ...

class TypeAliasTemplateDecl(multiplier.ast.RedeclarableTemplateDecl):
  canonical_declaration: multiplier.ast.TypeAliasTemplateDecl
  definition: Optional[multiplier.ast.TypeAliasTemplateDecl]
  redeclarations: Iterable[multiplier.ast.TypeAliasTemplateDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TypeAliasTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TypeAliasTemplateDecl]:
    ...

class ConceptDecl(multiplier.ast.TemplateDecl):
  canonical_declaration: multiplier.ast.ConceptDecl
  definition: Optional[multiplier.ast.ConceptDecl]
  redeclarations: Iterable[multiplier.ast.ConceptDecl]
  constraint_expression: multiplier.ast.Expr
  is_type_concept: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ConceptDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ConceptDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ConceptDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ConceptDecl]:
    ...

class BuiltinTemplateDecl(multiplier.ast.TemplateDecl):
  canonical_declaration: multiplier.ast.BuiltinTemplateDecl
  definition: Optional[multiplier.ast.BuiltinTemplateDecl]
  redeclarations: Iterable[multiplier.ast.BuiltinTemplateDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.BuiltinTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.BuiltinTemplateDecl]:
    ...

class TemplateTemplateParmDecl(multiplier.ast.TemplateDecl):
  canonical_declaration: multiplier.ast.TemplateTemplateParmDecl
  definition: Optional[multiplier.ast.TemplateTemplateParmDecl]
  redeclarations: Iterable[multiplier.ast.TemplateTemplateParmDecl]
  default_argument_was_inherited: bool
  default_argument_token: multiplier.frontend.Token
  has_default_argument: bool
  is_expanded_parameter_pack: bool
  is_pack_expansion: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.TemplateTemplateParmDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.TemplateTemplateParmDecl]:
    ...

class ObjCPropertyDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.ObjCPropertyDecl
  definition: Optional[multiplier.ast.ObjCPropertyDecl]
  redeclarations: Iterable[multiplier.ast.ObjCPropertyDecl]
  at_token: multiplier.frontend.Token
  getter_method_declaration: multiplier.ast.ObjCMethodDecl
  getter_name_token: multiplier.frontend.Token
  l_paren_token: multiplier.frontend.Token
  property_implementation: multiplier.ast.ObjCPropertyDeclPropertyControl
  property_instance_variable_declaration: multiplier.ast.ObjCIvarDecl
  query_kind: multiplier.ast.ObjCPropertyQueryKind
  setter_kind: multiplier.ast.ObjCPropertyDeclSetterKind
  setter_method_declaration: multiplier.ast.ObjCMethodDecl
  setter_name_token: multiplier.frontend.Token
  type: multiplier.ast.Type
  is_atomic: bool
  is_class_property: bool
  is_direct_property: bool
  is_instance_property: bool
  is_optional: bool
  is_read_only: bool
  is_retaining: bool

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCPropertyDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCPropertyDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

class ObjCMethodDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.ObjCMethodDecl
  definition: Optional[multiplier.ast.ObjCMethodDecl]
  redeclarations: Iterable[multiplier.ast.ObjCMethodDecl]
  defined_in_ns_object: bool
  find_property_declaration: multiplier.ast.ObjCPropertyDecl
  class_interface: multiplier.ast.ObjCInterfaceDecl
  command_declaration: multiplier.ast.ImplicitParamDecl
  declarator_end_token: multiplier.frontend.Token
  implementation_control: multiplier.ast.ObjCImplementationControl
  method_family: multiplier.ast.ObjCMethodFamily
  obj_c_decl_qualifier: multiplier.ast.DeclObjCDeclQualifier
  return_type: multiplier.ast.Type
  return_type_tokens: multiplier.frontend.TokenRange
  selector_start_token: multiplier.frontend.Token
  self_declaration: multiplier.ast.ImplicitParamDecl
  has_parameter_destroyed_in_callee: bool
  has_redeclaration: bool
  has_related_result_type: bool
  has_skipped_body: bool
  is_class_method: bool
  is_defined: bool
  is_designated_initializer_for_the_interface: bool
  is_direct_method: bool
  is_instance_method: bool
  is_optional: bool
  is_overriding: bool
  is_property_accessor: bool
  is_redeclaration: bool
  is_synthesized_accessor_stub: bool
  is_this_declaration_a_definition: bool
  is_this_declaration_a_designated_initializer: bool
  is_variadic: bool
  num_parameters: int
  parameters: Iterable[multiplier.ast.ParmVarDecl]
  num_selector_tokens: int
  selector_tokens: Iterable[multiplier.frontend.Token]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCMethodDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCMethodDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  def nth_parameter(self, n: int) -> Optional[multiplier.ast.ParmVarDecl]:
    ...

  def nth_selector_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

class ObjCContainerDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.ObjCContainerDecl
  definition: Optional[multiplier.ast.ObjCContainerDecl]
  redeclarations: Iterable[multiplier.ast.ObjCContainerDecl]
  num_class_methods: int
  class_methods: Iterable[multiplier.ast.ObjCMethodDecl]
  num_class_properties: int
  class_properties: Iterable[multiplier.ast.ObjCPropertyDecl]
  at_end_range: multiplier.frontend.TokenRange
  at_start_token: multiplier.frontend.Token
  num_instance_methods: int
  instance_methods: Iterable[multiplier.ast.ObjCMethodDecl]
  num_instance_properties: int
  instance_properties: Iterable[multiplier.ast.ObjCPropertyDecl]
  num_methods: int
  methods: Iterable[multiplier.ast.ObjCMethodDecl]
  num_properties: int
  properties: Iterable[multiplier.ast.ObjCPropertyDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCContainerDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCContainerDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCContainerDecl]:
    ...

  def nth_class_method(self, n: int) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  def nth_class_propertie(self, n: int) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  def nth_instance_method(self, n: int) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  def nth_instance_propertie(self, n: int) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

  def nth_method(self, n: int) -> Optional[multiplier.ast.ObjCMethodDecl]:
    ...

  def nth_propertie(self, n: int) -> Optional[multiplier.ast.ObjCPropertyDecl]:
    ...

class ObjCCategoryDecl(multiplier.ast.ObjCContainerDecl):
  canonical_declaration: multiplier.ast.ObjCCategoryDecl
  definition: Optional[multiplier.ast.ObjCCategoryDecl]
  redeclarations: Iterable[multiplier.ast.ObjCCategoryDecl]
  is_class_extension: bool
  category_name_token: multiplier.frontend.Token
  class_interface: multiplier.ast.ObjCInterfaceDecl
  implementation: multiplier.ast.ObjCCategoryImplDecl
  instance_variable_l_brace_token: multiplier.frontend.Token
  instance_variable_r_brace_token: multiplier.frontend.Token
  next_class_category: multiplier.ast.ObjCCategoryDecl
  num_instance_variables: int
  instance_variables: Iterable[multiplier.ast.ObjCIvarDecl]
  num_protocol_tokens: int
  protocol_tokens: Iterable[multiplier.frontend.Token]
  num_protocols: int
  protocols: Iterable[multiplier.ast.ObjCProtocolDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCCategoryDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCCategoryDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  def nth_instance_variable(self, n: int) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  def nth_protocol_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

  def nth_protocol(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

class ObjCProtocolDecl(multiplier.ast.ObjCContainerDecl):
  canonical_declaration: multiplier.ast.ObjCProtocolDecl
  definition: Optional[multiplier.ast.ObjCProtocolDecl]
  redeclarations: Iterable[multiplier.ast.ObjCProtocolDecl]
  obj_c_runtime_name_as_string: str
  has_definition: bool
  is_non_runtime_protocol: bool
  is_this_declaration_a_definition: bool
  num_protocol_tokens: int
  protocol_tokens: Iterable[multiplier.frontend.Token]
  num_protocols: int
  protocols: Iterable[multiplier.ast.ObjCProtocolDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCProtocolDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCProtocolDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  def nth_protocol_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

  def nth_protocol(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

class ObjCInterfaceDecl(multiplier.ast.ObjCContainerDecl):
  canonical_declaration: multiplier.ast.ObjCInterfaceDecl
  definition: Optional[multiplier.ast.ObjCInterfaceDecl]
  redeclarations: Iterable[multiplier.ast.ObjCInterfaceDecl]
  num_all_referenced_protocols: int
  all_referenced_protocols: Iterable[multiplier.ast.ObjCProtocolDecl]
  declares_or_inherits_designated_initializers: bool
  end_of_definition_token: multiplier.frontend.Token
  implementation: multiplier.ast.ObjCImplementationDecl
  obj_c_runtime_name_as_string: str
  super_class: Optional[multiplier.ast.ObjCInterfaceDecl]
  super_class_token: multiplier.frontend.Token
  super_class_type: Optional[multiplier.ast.Type]
  type_for_declaration: multiplier.ast.Type
  has_definition: bool
  has_designated_initializers: bool
  is_arc_weakref_unavailable: bool
  is_implicit_interface_declaration: bool
  is_obj_c_requires_property_definitions: multiplier.ast.ObjCInterfaceDecl
  is_this_declaration_a_definition: bool
  num_instance_variables: int
  instance_variables: Iterable[multiplier.ast.ObjCIvarDecl]
  num_known_categories: int
  known_categories: Iterable[multiplier.ast.ObjCCategoryDecl]
  num_known_extensions: int
  known_extensions: Iterable[multiplier.ast.ObjCCategoryDecl]
  num_protocol_tokens: int
  protocol_tokens: Iterable[multiplier.frontend.Token]
  num_protocols: int
  protocols: Iterable[multiplier.ast.ObjCProtocolDecl]
  num_visible_categories: int
  visible_categories: Iterable[multiplier.ast.ObjCCategoryDecl]
  num_visible_extensions: int
  visible_extensions: Iterable[multiplier.ast.ObjCCategoryDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCInterfaceDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCInterfaceDecl]:
    ...

  def nth_all_referenced_protocol(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  def nth_instance_variable(self, n: int) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

  def nth_known_categorie(self, n: int) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  def nth_known_extension(self, n: int) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  def nth_protocol_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

  def nth_protocol(self, n: int) -> Optional[multiplier.ast.ObjCProtocolDecl]:
    ...

  def nth_visible_categorie(self, n: int) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

  def nth_visible_extension(self, n: int) -> Optional[multiplier.ast.ObjCCategoryDecl]:
    ...

class ObjCImplDecl(multiplier.ast.ObjCContainerDecl):
  canonical_declaration: multiplier.ast.ObjCImplDecl
  definition: Optional[multiplier.ast.ObjCImplDecl]
  redeclarations: Iterable[multiplier.ast.ObjCImplDecl]
  class_interface: multiplier.ast.ObjCInterfaceDecl
  num_property_implementations: int
  property_implementations: Iterable[multiplier.ast.ObjCPropertyImplDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCImplDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCImplDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCImplDecl]:
    ...

  def nth_property_implementation(self, n: int) -> Optional[multiplier.ast.ObjCPropertyImplDecl]:
    ...

class ObjCCategoryImplDecl(multiplier.ast.ObjCImplDecl):
  canonical_declaration: multiplier.ast.ObjCCategoryImplDecl
  definition: Optional[multiplier.ast.ObjCCategoryImplDecl]
  redeclarations: Iterable[multiplier.ast.ObjCCategoryImplDecl]
  category_declaration: multiplier.ast.ObjCCategoryDecl
  category_name_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCCategoryImplDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCategoryImplDecl]:
    ...

class ObjCImplementationDecl(multiplier.ast.ObjCImplDecl):
  canonical_declaration: multiplier.ast.ObjCImplementationDecl
  definition: Optional[multiplier.ast.ObjCImplementationDecl]
  redeclarations: Iterable[multiplier.ast.ObjCImplementationDecl]
  instance_variable_l_brace_token: multiplier.frontend.Token
  instance_variable_r_brace_token: multiplier.frontend.Token
  obj_c_runtime_name_as_string: str
  super_class: multiplier.ast.ObjCInterfaceDecl
  super_class_token: multiplier.frontend.Token
  has_destructors: bool
  has_non_zero_constructors: bool
  num_initializers: int
  initializers: Iterable[multiplier.ast.CXXCtorInitializer]
  num_instance_variables: int
  instance_variables: Iterable[multiplier.ast.ObjCIvarDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCImplementationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCImplementationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCImplementationDecl]:
    ...

  def nth_initializer(self, n: int) -> Optional[multiplier.ast.CXXCtorInitializer]:
    ...

  def nth_instance_variable(self, n: int) -> Optional[multiplier.ast.ObjCIvarDecl]:
    ...

class ObjCCompatibleAliasDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.ObjCCompatibleAliasDecl
  definition: Optional[multiplier.ast.ObjCCompatibleAliasDecl]
  redeclarations: Iterable[multiplier.ast.ObjCCompatibleAliasDecl]
  class_interface: multiplier.ast.ObjCInterfaceDecl

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ObjCCompatibleAliasDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ObjCCompatibleAliasDecl]:
    ...

class NamespaceDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.NamespaceDecl
  definition: Optional[multiplier.ast.NamespaceDecl]
  redeclarations: Iterable[multiplier.ast.NamespaceDecl]
  anonymous_namespace: Optional[multiplier.ast.NamespaceDecl]
  original_namespace: multiplier.ast.NamespaceDecl
  r_brace_token: multiplier.frontend.Token
  is_anonymous_namespace: bool
  is_inline: bool
  is_nested: bool
  is_original_namespace: bool
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NamespaceDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NamespaceDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamespaceDecl]:
    ...

class NamespaceAliasDecl(multiplier.ast.NamedDecl):
  canonical_declaration: multiplier.ast.NamespaceAliasDecl
  definition: Optional[multiplier.ast.NamespaceAliasDecl]
  redeclarations: Iterable[multiplier.ast.NamespaceAliasDecl]
  alias_token: multiplier.frontend.Token
  aliased_namespace: multiplier.ast.NamedDecl
  namespace_: multiplier.ast.NamespaceDecl
  namespace_token: multiplier.frontend.Token
  target_name_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.NamespaceAliasDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.NamespaceAliasDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.NamespaceAliasDecl]:
    ...

class LinkageSpecDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.LinkageSpecDecl
  definition: Optional[multiplier.ast.LinkageSpecDecl]
  redeclarations: Iterable[multiplier.ast.LinkageSpecDecl]
  extern_token: multiplier.frontend.Token
  language: multiplier.ast.LinkageSpecLanguageIDs
  r_brace_token: multiplier.frontend.Token
  has_braces: bool
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.LinkageSpecDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.LinkageSpecDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LinkageSpecDecl]:
    ...

class LifetimeExtendedTemporaryDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.LifetimeExtendedTemporaryDecl
  definition: Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]
  redeclarations: Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]
  children: Iterable[multiplier.ast.Stmt]
  extending_declaration: multiplier.ast.ValueDecl
  storage_duration: multiplier.ast.StorageDuration
  temporary_expression: multiplier.ast.Expr

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.LifetimeExtendedTemporaryDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.LifetimeExtendedTemporaryDecl]:
    ...

class ImportDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.ImportDecl
  definition: Optional[multiplier.ast.ImportDecl]
  redeclarations: Iterable[multiplier.ast.ImportDecl]
  num_identifier_tokens: int
  identifier_tokens: Iterable[multiplier.frontend.Token]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImportDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImportDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImportDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImportDecl]:
    ...

  def nth_identifier_token(self, n: int) -> Optional[multiplier.frontend.Token]:
    ...

class ImplicitConceptSpecializationDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.ImplicitConceptSpecializationDecl
  definition: Optional[multiplier.ast.ImplicitConceptSpecializationDecl]
  redeclarations: Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]
  num_template_arguments: int
  template_arguments: Iterable[multiplier.ast.TemplateArgument]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ImplicitConceptSpecializationDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ImplicitConceptSpecializationDecl]:
    ...

  def nth_template_argument(self, n: int) -> Optional[multiplier.ast.TemplateArgument]:
    ...

class FriendTemplateDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.FriendTemplateDecl
  definition: Optional[multiplier.ast.FriendTemplateDecl]
  redeclarations: Iterable[multiplier.ast.FriendTemplateDecl]
  friend_declaration: multiplier.ast.NamedDecl
  friend_token: multiplier.frontend.Token
  friend_type: multiplier.ast.Type
  num_template_parameter_lists: int
  template_parameter_lists: Iterable[multiplier.ast.TemplateParameterList]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FriendTemplateDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FriendTemplateDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FriendTemplateDecl]:
    ...

  def nth_template_parameter_list(self, n: int) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

class FriendDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.FriendDecl
  definition: Optional[multiplier.ast.FriendDecl]
  redeclarations: Iterable[multiplier.ast.FriendDecl]
  friend_declaration: Optional[multiplier.ast.NamedDecl]
  friend_token: multiplier.frontend.Token
  friend_type: Optional[multiplier.ast.Type]
  is_unsupported_friend: bool
  num_friend_type_template_parameter_lists: int
  friend_type_template_parameter_lists: Iterable[multiplier.ast.TemplateParameterList]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FriendDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FriendDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FriendDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FriendDecl]:
    ...

  def nth_friend_type_template_parameter_list(self, n: int) -> Optional[multiplier.ast.TemplateParameterList]:
    ...

class FileScopeAsmDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.FileScopeAsmDecl
  definition: Optional[multiplier.ast.FileScopeAsmDecl]
  redeclarations: Iterable[multiplier.ast.FileScopeAsmDecl]
  assembly_token: multiplier.frontend.Token
  assembly_string: multiplier.ast.StringLiteral
  r_paren_token: multiplier.frontend.Token

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.FileScopeAsmDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.FileScopeAsmDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.FileScopeAsmDecl]:
    ...

class ExternCContextDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.ExternCContextDecl
  definition: Optional[multiplier.ast.ExternCContextDecl]
  redeclarations: Iterable[multiplier.ast.ExternCContextDecl]
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExternCContextDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExternCContextDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ExternCContextDecl]:
    ...

class ExportDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.ExportDecl
  definition: Optional[multiplier.ast.ExportDecl]
  redeclarations: Iterable[multiplier.ast.ExportDecl]
  export_token: multiplier.frontend.Token
  r_brace_token: multiplier.frontend.Token
  has_braces: bool
  contained_declarations: Iterable[multiplier.ast.Decl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.ExportDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.ExportDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.ExportDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.ExportDecl]:
    ...

class EmptyDecl(multiplier.ast.Decl):
  canonical_declaration: multiplier.ast.EmptyDecl
  definition: Optional[multiplier.ast.EmptyDecl]
  redeclarations: Iterable[multiplier.ast.EmptyDecl]

  @overload
  @staticmethod
  def IN(index: multiplier.Index) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def IN(frag: multiplier.Fragment) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def IN(file: multiplier.frontend.File) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def IN(tu: multiplier.frontend.Compilation) -> Iterable[Tuple[multiplier.ast.EmptyDecl, multiplier.ir.Operation]]:
    ...

  @overload
  @staticmethod
  def containing(tok: multiplier.frontend.Token) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: multiplier.ast.Decl) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def containing(decl: Optional[multiplier.ast.Decl]) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: multiplier.ast.Stmt) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def containing(stmt: Optional[multiplier.ast.Stmt]) -> Iterable[multiplier.ast.EmptyDecl]:
    ...

  @staticmethod
  def by_id(arg_0: multiplier.Index, arg_1: int) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(op: multiplier.ir.Operation) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(parent: Optional[multiplier.ast.Decl]) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(r: multiplier.Reference) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(e: Optional[multiplier.Fragment | multiplier.ast.Decl | multiplier.ast.Stmt | multiplier.ast.Attr | multiplier.frontend.Macro | multiplier.ast.Type | multiplier.frontend.File | multiplier.frontend.Token | multiplier.ast.TemplateArgument | multiplier.ast.TemplateParameterList | multiplier.ast.CXXBaseSpecifier | multiplier.ast.Designator | multiplier.ast.CXXCtorInitializer | multiplier.frontend.Compilation | multiplier.ir.Operation]) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @overload
  @staticmethod
  def FROM(t: multiplier.frontend.TokenContext) -> Optional[multiplier.ast.EmptyDecl]:
    ...

  @staticmethod
  def static_kind() -> multiplier.ast.DeclKind:
    ...

  @staticmethod
  def from_base(parent: multiplier.ast.Decl) -> Optional[multiplier.ast.EmptyDecl]:
    ...
