// Copyright (c) 2022-present, Trail of Bits, Inc.
// All rights reserved.
//
// This source code is licensed in accordance with the terms specified in
// the LICENSE file found in the root directory of this source tree.

// Auto-generated file; do not modify!

#pragma once

#include <cstdint>
#include <filesystem>
#include <memory>
#include <optional>
#include <vector>

#include "Iterator.h"
#include "Types.h"
#include "Use.h"

namespace mx {

class AttrIterator;
class DeclIterator;
class FragmentImpl;
class FileImpl;
class ReferenceRange;
class StmtIterator;
class Token;
class TokenContext;
class TokenContextIterator;
class TokenRange;
class TypeIterator;
class UseBase;

enum class DeclKind : unsigned char {
  ACCESS_SPEC,
  BASE_USING,
  BINDING,
  BLOCK,
  BUILTIN_TEMPLATE,
  CXX_CONSTRUCTOR,
  CXX_CONVERSION,
  CXX_DEDUCTION_GUIDE,
  CXX_DESTRUCTOR,
  CXX_METHOD,
  CXX_RECORD,
  CAPTURED,
  CLASS_SCOPE_FUNCTION_SPECIALIZATION,
  CLASS_TEMPLATE,
  CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,
  CLASS_TEMPLATE_SPECIALIZATION,
  CONCEPT,
  CONSTRUCTOR_USING_SHADOW,
  DECLARATOR,
  DECOMPOSITION,
  EMPTY,
  ENUM_CONSTANT,
  ENUM,
  EXPORT,
  EXTERN_C_CONTEXT,
  FIELD,
  FILE_SCOPE_ASM,
  FRIEND,
  FRIEND_TEMPLATE,
  FUNCTION,
  FUNCTION_TEMPLATE,
  IMPLICIT_PARAM,
  IMPORT,
  INDIRECT_FIELD,
  LABEL,
  LIFETIME_EXTENDED_TEMPORARY,
  LINKAGE_SPEC,
  MS_GUID,
  MS_PROPERTY,
  NAMED,
  NAMESPACE_ALIAS,
  NAMESPACE,
  NON_TYPE_TEMPLATE_PARM,
  OMP_ALLOCATE,
  OMP_CAPTURED_EXPR,
  OMP_DECLARE_MAPPER,
  OMP_DECLARE_REDUCTION,
  OMP_REQUIRES,
  OMP_THREAD_PRIVATE,
  OBJ_C_AT_DEFS_FIELD,
  OBJ_C_CATEGORY,
  OBJ_C_CATEGORY_IMPL,
  OBJ_C_COMPATIBLE_ALIAS,
  OBJ_C_CONTAINER,
  OBJ_C_IMPL,
  OBJ_C_IMPLEMENTATION,
  OBJ_C_INTERFACE,
  OBJ_C_IVAR,
  OBJ_C_METHOD,
  OBJ_C_PROPERTY,
  OBJ_C_PROPERTY_IMPL,
  OBJ_C_PROTOCOL,
  OBJ_C_TYPE_PARAM,
  PARM_VAR,
  PRAGMA_COMMENT,
  PRAGMA_DETECT_MISMATCH,
  RECORD,
  REDECLARABLE_TEMPLATE,
  REQUIRES_EXPR_BODY,
  STATIC_ASSERT,
  TAG,
  TEMPLATE,
  TEMPLATE_PARAM_OBJECT,
  TEMPLATE_TEMPLATE_PARM,
  TEMPLATE_TYPE_PARM,
  TRANSLATION_UNIT,
  TYPE_ALIAS,
  TYPE_ALIAS_TEMPLATE,
  TYPE,
  TYPEDEF,
  TYPEDEF_NAME,
  UNRESOLVED_USING_IF_EXISTS,
  UNRESOLVED_USING_TYPENAME,
  UNRESOLVED_USING_VALUE,
  USING,
  USING_DIRECTIVE,
  USING_ENUM,
  USING_PACK,
  USING_SHADOW,
  VALUE,
  VAR,
  VAR_TEMPLATE,
  VAR_TEMPLATE_PARTIAL_SPECIALIZATION,
  VAR_TEMPLATE_SPECIALIZATION,
};

inline static const char *EnumerationName(DeclKind) {
  return "DeclKind";
}

inline static constexpr unsigned NumEnumerators(DeclKind) {
  return 94;
}

const char *EnumeratorName(DeclKind);

enum class AttrKind : unsigned short {
  A_ARCH64_VECTOR_PCS,
  AMDGPU_FLAT_WORK_GROUP_SIZE,
  AMDGPU_NUM_SGPR,
  AMDGPU_NUM_VGPR,
  AMDGPU_WAVES_PER_EU,
  ARM_INTERRUPT,
  AVR_INTERRUPT,
  AVR_SIGNAL,
  ABI_TAG,
  ACQUIRE_CAPABILITY,
  ACQUIRE_HANDLE,
  ACQUIRED_AFTER,
  ACQUIRED_BEFORE,
  ADDRESS_SPACE,
  ALIAS,
  ALIGN_MAC68K,
  ALIGN_NATURAL,
  ALIGN_VALUE,
  ALIGNED,
  ALLOC_ALIGN,
  ALLOC_SIZE,
  ALWAYS_DESTROY,
  ALWAYS_INLINE,
  ANALYZER_NO_RETURN,
  ANNOTATE,
  ANY_X86_INTERRUPT,
  ANY_X86_NO_CALLER_SAVED_REGISTERS,
  ANY_X86_NO_CF_CHECK,
  ARC_WEAKREF_UNAVAILABLE,
  ARGUMENT_WITH_TYPE_TAG,
  ARM_BUILTIN_ALIAS,
  ARM_MVE_STRICT_POLYMORPHISM,
  ARTIFICIAL,
  ASM_LABEL,
  ASSERT_CAPABILITY,
  ASSERT_EXCLUSIVE_LOCK,
  ASSERT_SHARED_LOCK,
  ASSUME_ALIGNED,
  ASSUMPTION,
  AVAILABILITY,
  BPF_PRESERVE_ACCESS_INDEX,
  BTF_DECL_TAG,
  BTF_TYPE_TAG,
  BLOCKS,
  BUILTIN_ALIAS,
  BUILTIN,
  C11_NO_RETURN,
  C_DECL,
  CF_AUDITED_TRANSFER,
  CF_CONSUMED,
  CF_GUARD,
  CFI_CANONICAL_JUMP_TABLE,
  CF_RETURNS_NOT_RETAINED,
  CF_RETURNS_RETAINED,
  CF_UNKNOWN_TRANSFER,
  CPU_DISPATCH,
  CPU_SPECIFIC,
  CUDA_CONSTANT,
  CUDA_DEVICE,
  CUDA_DEVICE_BUILTIN_SURFACE_TYPE,
  CUDA_DEVICE_BUILTIN_TEXTURE_TYPE,
  CUDA_GLOBAL,
  CUDA_HOST,
  CUDA_INVALID_TARGET,
  CUDA_LAUNCH_BOUNDS,
  CUDA_SHARED,
  CXX11_NO_RETURN,
  CALLABLE_WHEN,
  CALLBACK,
  CALLED_ONCE,
  CAPABILITY,
  CAPTURED_RECORD,
  CARRIES_DEPENDENCY,
  CLEANUP,
  CMSE_NS_CALL,
  CMSE_NS_ENTRY,
  CODE_SEG,
  COLD,
  COMMON,
  CONST,
  CONST_INIT,
  CONSTRUCTOR,
  CONSUMABLE,
  CONSUMABLE_AUTO_CAST,
  CONSUMABLE_SET_ON_READ,
  CONVERGENT,
  DLL_EXPORT,
  DLL_EXPORT_STATIC_LOCAL,
  DLL_IMPORT,
  DLL_IMPORT_STATIC_LOCAL,
  DEPRECATED,
  DESTRUCTOR,
  DIAGNOSE_AS_BUILTIN,
  DIAGNOSE_IF,
  DISABLE_SANITIZER_INSTRUMENTATION,
  DISABLE_TAIL_CALLS,
  EMPTY_BASES,
  ENABLE_IF,
  ENFORCE_TCB,
  ENFORCE_TCB_LEAF,
  ENUM_EXTENSIBILITY,
  ERROR,
  EXCLUDE_FROM_EXPLICIT_INSTANTIATION,
  EXCLUSIVE_TRYLOCK_FUNCTION,
  EXTERNAL_SOURCE_SYMBOL,
  FALL_THROUGH,
  FAST_CALL,
  FINAL,
  FLAG_ENUM,
  FLATTEN,
  FORMAT_ARG,
  FORMAT,
  GNU_INLINE,
  GUARDED_BY,
  GUARDED_VAR,
  HIP_MANAGED,
  HOT,
  IB_ACTION,
  IB_OUTLET,
  IB_OUTLET_COLLECTION,
  I_FUNC,
  INIT_PRIORITY,
  INIT_SEG,
  INTEL_OCL_BICC,
  INTERNAL_LINKAGE,
  LTO_VISIBILITY_PUBLIC,
  LAYOUT_VERSION,
  LEAF,
  LIFETIME_BOUND,
  LIKELY,
  LOADER_UNINITIALIZED,
  LOCK_RETURNED,
  LOCKS_EXCLUDED,
  LOOP_HINT,
  M68K_INTERRUPT,
  MIG_SERVER_ROUTINE_,
  MSABI,
  MS_ALLOCATOR,
  MS_INHERITANCE,
  MS_NO_V_TABLE,
  MSP430_INTERRUPT,
  MS_STRUCT,
  MS_VTOR_DISP,
  MAX_FIELD_ALIGNMENT,
  MAY_ALIAS,
  MICRO_MIPS,
  MIN_SIZE,
  MIN_VECTOR_WIDTH,
  MIPS16,
  MIPS_INTERRUPT,
  MIPS_LONG_CALL,
  MIPS_SHORT_CALL,
  MODE,
  MUST_TAIL,
  NS_CONSUMED,
  NS_CONSUMES_SELF,
  NS_ERROR_DOMAIN,
  NS_RETURNS_AUTORELEASED,
  NS_RETURNS_NOT_RETAINED,
  NS_RETURNS_RETAINED,
  NAKED,
  NO_ALIAS,
  NO_BUILTIN,
  NO_COMMON,
  NO_DEBUG,
  NO_DEREF,
  NO_DESTROY,
  NO_DUPLICATE,
  NO_ESCAPE,
  NO_INLINE,
  NO_INSTRUMENT_FUNCTION,
  NO_MERGE,
  NO_MICRO_MIPS,
  NO_MIPS16,
  NO_PROFILE_FUNCTION,
  NO_RETURN,
  NO_SANITIZE,
  NO_SPECULATIVE_LOAD_HARDENING,
  NO_SPLIT_STACK,
  NO_STACK_PROTECTOR,
  NO_THREAD_SAFETY_ANALYSIS,
  NO_THROW,
  NO_UNIQUE_ADDRESS,
  NON_NULL,
  NOT_TAIL_CALLED,
  OMP_ALLOCATE_DECL,
  OMP_CAPTURE_KIND,
  OMP_CAPTURE_NO_INIT,
  OMP_DECLARE_SIMD_DECL,
  OMP_DECLARE_TARGET_DECL,
  OMP_DECLARE_VARIANT,
  OMP_REFERENCED_VAR,
  OMP_THREAD_PRIVATE_DECL,
  OS_CONSUMED,
  OS_CONSUMES_THIS,
  OS_RETURNS_NOT_RETAINED,
  OS_RETURNS_RETAINED,
  OS_RETURNS_RETAINED_ON_NON_ZERO,
  OS_RETURNS_RETAINED_ON_ZERO,
  OBJ_C_BOXABLE,
  OBJ_C_BRIDGE,
  OBJ_C_BRIDGE_MUTABLE,
  OBJ_C_BRIDGE_RELATED,
  OBJ_C_CLASS_STUB,
  OBJ_C_DESIGNATED_INITIALIZER,
  OBJ_C_DIRECT,
  OBJ_C_DIRECT_MEMBERS,
  OBJ_C_EXCEPTION,
  OBJ_C_EXPLICIT_PROTOCOL_IMPL,
  OBJ_C_EXTERNALLY_RETAINED,
  OBJ_CGC,
  OBJ_C_INDEPENDENT_CLASS,
  OBJ_C_INERT_UNSAFE_UNRETAINED,
  OBJ_C_KIND_OF,
  OBJ_C_METHOD_FAMILY,
  OBJ_CNS_OBJECT,
  OBJ_C_NON_LAZY_CLASS,
  OBJ_C_NON_RUNTIME_PROTOCOL,
  OBJ_C_OWNERSHIP,
  OBJ_C_PRECISE_LIFETIME,
  OBJ_C_REQUIRES_PROPERTY_DEFS,
  OBJ_C_REQUIRES_SUPER,
  OBJ_C_RETURNS_INNER_POINTER,
  OBJ_C_ROOT_CLASS,
  OBJ_C_RUNTIME_NAME,
  OBJ_C_RUNTIME_VISIBLE,
  OBJ_C_SUBCLASSING_RESTRICTED,
  OPEN_CL_ACCESS,
  OPEN_CL_CONSTANT_ADDRESS_SPACE,
  OPEN_CL_GENERIC_ADDRESS_SPACE,
  OPEN_CL_GLOBAL_ADDRESS_SPACE,
  OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE,
  OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE,
  OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE,
  OPEN_CL_KERNEL,
  OPEN_CL_LOCAL_ADDRESS_SPACE,
  OPEN_CL_PRIVATE_ADDRESS_SPACE,
  OPEN_CL_UNROLL_HINT,
  OPTIMIZE_NONE,
  OVERLOADABLE,
  OVERRIDE,
  OWNER,
  OWNERSHIP,
  PACKED,
  PARAM_TYPESTATE,
  PASCAL,
  PASS_OBJECT_SIZE,
  PATCHABLE_FUNCTION_ENTRY,
  PCS,
  POINTER,
  PRAGMA_CLANG_BSS_SECTION,
  PRAGMA_CLANG_DATA_SECTION,
  PRAGMA_CLANG_RELRO_SECTION,
  PRAGMA_CLANG_RODATA_SECTION,
  PRAGMA_CLANG_TEXT_SECTION,
  PREFERRED_NAME,
  PRESERVE_ALL,
  PRESERVE_MOST,
  PT_GUARDED_BY,
  PT_GUARDED_VAR,
  PTR32,
  PTR64,
  PURE,
  RISCV_INTERRUPT,
  REG_CALL,
  REINITIALIZES,
  RELEASE_CAPABILITY,
  RELEASE_HANDLE,
  RENDER_SCRIPT_KERNEL,
  REQD_WORK_GROUP_SIZE,
  REQUIRES_CAPABILITY,
  RESTRICT,
  RETAIN,
  RETURN_TYPESTATE,
  RETURNS_NON_NULL,
  RETURNS_TWICE,
  S_PTR,
  SYCL_KERNEL,
  SYCL_SPECIAL_CLASS,
  SCOPED_LOCKABLE,
  SECTION,
  SELECT_ANY,
  SENTINEL,
  SET_TYPESTATE,
  SHARED_TRYLOCK_FUNCTION,
  SPECULATIVE_LOAD_HARDENING,
  STANDALONE_DEBUG,
  STD_CALL,
  STRICT_FP,
  SUPPRESS,
  SWIFT_ASYNC,
  SWIFT_ASYNC_CALL,
  SWIFT_ASYNC_CONTEXT,
  SWIFT_ASYNC_ERROR,
  SWIFT_ASYNC_NAME,
  SWIFT_ATTR,
  SWIFT_BRIDGE,
  SWIFT_BRIDGED_TYPEDEF,
  SWIFT_CALL,
  SWIFT_CONTEXT,
  SWIFT_ERROR,
  SWIFT_ERROR_RESULT,
  SWIFT_INDIRECT_RESULT,
  SWIFT_NAME,
  SWIFT_NEW_TYPE,
  SWIFT_OBJ_C_MEMBERS,
  SWIFT_PRIVATE,
  SYS_VABI,
  TLS_MODEL,
  TARGET,
  TARGET_CLONES,
  TEST_TYPESTATE,
  THIS_CALL,
  THREAD,
  TRANSPARENT_UNION,
  TRIVIAL_ABI,
  TRY_ACQUIRE_CAPABILITY,
  TYPE_NON_NULL,
  TYPE_NULL_UNSPECIFIED,
  TYPE_NULLABLE,
  TYPE_NULLABLE_RESULT,
  TYPE_TAG_FOR_DATATYPE,
  TYPE_VISIBILITY,
  U_PTR,
  UNAVAILABLE,
  UNINITIALIZED,
  UNLIKELY,
  UNUSED,
  USE_HANDLE,
  USED,
  USING_IF_EXISTS,
  UUID,
  VEC_RETURN,
  VEC_TYPE_HINT,
  VECTOR_CALL,
  VISIBILITY,
  WARN_UNUSED,
  WARN_UNUSED_RESULT,
  WEAK,
  WEAK_IMPORT,
  WEAK_REF,
  WEB_ASSEMBLY_EXPORT_NAME,
  WEB_ASSEMBLY_IMPORT_MODULE,
  WEB_ASSEMBLY_IMPORT_NAME,
  WORK_GROUP_SIZE_HINT,
  X86_FORCE_ALIGN_ARG_POINTER,
  X_RAY_INSTRUMENT,
  X_RAY_LOG_ARGS,
};

inline static const char *EnumerationName(AttrKind) {
  return "AttrKind";
}

inline static constexpr unsigned NumEnumerators(AttrKind) {
  return 348;
}

const char *EnumeratorName(AttrKind);

enum class AArch64VectorPcsAttrSpelling : unsigned char {
  GNU_AARCH64_VECTOR_PCS,
  CXX11_CLANG_AARCH64_VECTOR_PCS,
  C2X_CLANG_AARCH64_VECTOR_PCS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AArch64VectorPcsAttrSpelling) {
  return "AArch64VectorPcsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AArch64VectorPcsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AArch64VectorPcsAttrSpelling);

enum class AMDGPUFlatWorkGroupSizeAttrSpelling : unsigned char {
  GNU_AMDGPU_FLAT_WORK_GROUP_SIZE,
  CXX11_CLANG_AMDGPU_FLAT_WORK_GROUP_SIZE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AMDGPUFlatWorkGroupSizeAttrSpelling) {
  return "AMDGPUFlatWorkGroupSizeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AMDGPUFlatWorkGroupSizeAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AMDGPUFlatWorkGroupSizeAttrSpelling);

enum class AMDGPUNumSGPRAttrSpelling : unsigned char {
  GNU_AMDGPU_NUM_SGPR,
  CXX11_CLANG_AMDGPU_NUM_SGPR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AMDGPUNumSGPRAttrSpelling) {
  return "AMDGPUNumSGPRAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AMDGPUNumSGPRAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AMDGPUNumSGPRAttrSpelling);

enum class AMDGPUNumVGPRAttrSpelling : unsigned char {
  GNU_AMDGPU_NUM_VGPR,
  CXX11_CLANG_AMDGPU_NUM_VGPR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AMDGPUNumVGPRAttrSpelling) {
  return "AMDGPUNumVGPRAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AMDGPUNumVGPRAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AMDGPUNumVGPRAttrSpelling);

enum class AMDGPUWavesPerEUAttrSpelling : unsigned char {
  GNU_AMDGPU_WAVES_PER_EU,
  CXX11_CLANG_AMDGPU_WAVES_PER_EU,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AMDGPUWavesPerEUAttrSpelling) {
  return "AMDGPUWavesPerEUAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AMDGPUWavesPerEUAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AMDGPUWavesPerEUAttrSpelling);

enum class ARMInterruptAttrInterruptType : unsigned char {
  IRQ,
  FIQ,
  SWI,
  ABORT,
  UNDEF,
  GENERIC,
};

inline static const char *EnumerationName(ARMInterruptAttrInterruptType) {
  return "ARMInterruptAttrInterruptType";
}

inline static constexpr unsigned NumEnumerators(ARMInterruptAttrInterruptType) {
  return 6;
}

const char *EnumeratorName(ARMInterruptAttrInterruptType);

enum class ARMInterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ARMInterruptAttrSpelling) {
  return "ARMInterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ARMInterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ARMInterruptAttrSpelling);

enum class AVRInterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AVRInterruptAttrSpelling) {
  return "AVRInterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AVRInterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AVRInterruptAttrSpelling);

enum class AVRSignalAttrSpelling : unsigned char {
  GNU_SIGNAL,
  CXX11_GNU_SIGNAL,
  C2X_GNU_SIGNAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AVRSignalAttrSpelling) {
  return "AVRSignalAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AVRSignalAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AVRSignalAttrSpelling);

enum class AbiTagAttrSpelling : unsigned char {
  GNU_ABI_TAG,
  CXX11_GNU_ABI_TAG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AbiTagAttrSpelling) {
  return "AbiTagAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AbiTagAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AbiTagAttrSpelling);

enum class AcquireCapabilityAttrSpelling : unsigned char {
  GNU_ACQUIRE_CAPABILITY,
  CXX11_CLANG_ACQUIRE_CAPABILITY,
  GNU_ACQUIRE_SHARED_CAPABILITY,
  CXX11_CLANG_ACQUIRE_SHARED_CAPABILITY,
  GNU_EXCLUSIVE_LOCK_FUNCTION,
  GNU_SHARED_LOCK_FUNCTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AcquireCapabilityAttrSpelling) {
  return "AcquireCapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AcquireCapabilityAttrSpelling) {
  return 7;
}

const char *EnumeratorName(AcquireCapabilityAttrSpelling);

enum class AcquireHandleAttrSpelling : unsigned char {
  GNU_ACQUIRE_HANDLE,
  CXX11_CLANG_ACQUIRE_HANDLE,
  C2X_CLANG_ACQUIRE_HANDLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AcquireHandleAttrSpelling) {
  return "AcquireHandleAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AcquireHandleAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AcquireHandleAttrSpelling);

enum class AddressSpaceAttrSpelling : unsigned char {
  GNU_ADDRESS_SPACE,
  CXX11_CLANG_ADDRESS_SPACE,
  C2X_CLANG_ADDRESS_SPACE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AddressSpaceAttrSpelling) {
  return "AddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AddressSpaceAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AddressSpaceAttrSpelling);

enum class AliasAttrSpelling : unsigned char {
  GNU_ALIAS,
  CXX11_GNU_ALIAS,
  C2X_GNU_ALIAS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AliasAttrSpelling) {
  return "AliasAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AliasAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AliasAttrSpelling);

enum class AlignedAttrSpelling : unsigned char {
  GNU_ALIGNED,
  CXX11_GNU_ALIGNED,
  C2X_GNU_ALIGNED,
  DECLSPEC_ALIGN,
  KEYWORD_ALIGNAS,
  KEYWORD__ALIGNAS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AlignedAttrSpelling) {
  return "AlignedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AlignedAttrSpelling) {
  return 7;
}

const char *EnumeratorName(AlignedAttrSpelling);

enum class AllocAlignAttrSpelling : unsigned char {
  GNU_ALLOC_ALIGN,
  CXX11_GNU_ALLOC_ALIGN,
  C2X_GNU_ALLOC_ALIGN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AllocAlignAttrSpelling) {
  return "AllocAlignAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AllocAlignAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AllocAlignAttrSpelling);

enum class AllocSizeAttrSpelling : unsigned char {
  GNU_ALLOC_SIZE,
  CXX11_GNU_ALLOC_SIZE,
  C2X_GNU_ALLOC_SIZE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AllocSizeAttrSpelling) {
  return "AllocSizeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AllocSizeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AllocSizeAttrSpelling);

enum class AlwaysDestroyAttrSpelling : unsigned char {
  GNU_ALWAYS_DESTROY,
  CXX11_CLANG_ALWAYS_DESTROY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AlwaysDestroyAttrSpelling) {
  return "AlwaysDestroyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AlwaysDestroyAttrSpelling) {
  return 3;
}

const char *EnumeratorName(AlwaysDestroyAttrSpelling);

enum class AlwaysInlineAttrSpelling : unsigned char {
  GNU_ALWAYS_INLINE,
  CXX11_GNU_ALWAYS_INLINE,
  C2X_GNU_ALWAYS_INLINE,
  KEYWORD_FORCEINLINE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AlwaysInlineAttrSpelling) {
  return "AlwaysInlineAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AlwaysInlineAttrSpelling) {
  return 5;
}

const char *EnumeratorName(AlwaysInlineAttrSpelling);

enum class AnnotateAttrSpelling : unsigned char {
  GNU_ANNOTATE,
  CXX11_CLANG_ANNOTATE,
  C2X_CLANG_ANNOTATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AnnotateAttrSpelling) {
  return "AnnotateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AnnotateAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AnnotateAttrSpelling);

enum class AnyX86InterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AnyX86InterruptAttrSpelling) {
  return "AnyX86InterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AnyX86InterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AnyX86InterruptAttrSpelling);

enum class AnyX86NoCallerSavedRegistersAttrSpelling : unsigned char {
  GNU_NO_CALLER_SAVED_REGISTERS,
  CXX11_GNU_NO_CALLER_SAVED_REGISTERS,
  C2X_GNU_NO_CALLER_SAVED_REGISTERS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AnyX86NoCallerSavedRegistersAttrSpelling) {
  return "AnyX86NoCallerSavedRegistersAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AnyX86NoCallerSavedRegistersAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AnyX86NoCallerSavedRegistersAttrSpelling);

enum class AnyX86NoCfCheckAttrSpelling : unsigned char {
  GNU_NOCF_CHECK,
  CXX11_GNU_NOCF_CHECK,
  C2X_GNU_NOCF_CHECK,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AnyX86NoCfCheckAttrSpelling) {
  return "AnyX86NoCfCheckAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AnyX86NoCfCheckAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AnyX86NoCfCheckAttrSpelling);

enum class ArcWeakrefUnavailableAttrSpelling : unsigned char {
  GNU_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE,
  CXX11_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE,
  C2X_CLANG_OBJC_ARC_WEAK_REFERENCE_UNAVAILABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ArcWeakrefUnavailableAttrSpelling) {
  return "ArcWeakrefUnavailableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ArcWeakrefUnavailableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ArcWeakrefUnavailableAttrSpelling);

enum class ArgumentWithTypeTagAttrSpelling : unsigned char {
  GNU_ARGUMENT_WITH_TYPE_TAG,
  CXX11_CLANG_ARGUMENT_WITH_TYPE_TAG,
  C2X_CLANG_ARGUMENT_WITH_TYPE_TAG,
  GNU_POINTER_WITH_TYPE_TAG,
  CXX11_CLANG_POINTER_WITH_TYPE_TAG,
  C2X_CLANG_POINTER_WITH_TYPE_TAG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ArgumentWithTypeTagAttrSpelling) {
  return "ArgumentWithTypeTagAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ArgumentWithTypeTagAttrSpelling) {
  return 7;
}

const char *EnumeratorName(ArgumentWithTypeTagAttrSpelling);

enum class ArmBuiltinAliasAttrSpelling : unsigned char {
  GNU_CLANG_ARM_BUILTIN_ALIAS,
  CXX11_CLANG_CLANG_ARM_BUILTIN_ALIAS,
  C2X_CLANG_CLANG_ARM_BUILTIN_ALIAS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ArmBuiltinAliasAttrSpelling) {
  return "ArmBuiltinAliasAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ArmBuiltinAliasAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ArmBuiltinAliasAttrSpelling);

enum class ArmMveStrictPolymorphismAttrSpelling : unsigned char {
  GNU_CLANG_ARM_MVE_STRICT_POLYMORPHISM,
  CXX11_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM,
  C2X_CLANG_CLANG_ARM_MVE_STRICT_POLYMORPHISM,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ArmMveStrictPolymorphismAttrSpelling) {
  return "ArmMveStrictPolymorphismAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ArmMveStrictPolymorphismAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ArmMveStrictPolymorphismAttrSpelling);

enum class ArrayTypeArraySizeModifier : unsigned char {
  NORMAL,
  STATIC,
  STAR,
};

inline static const char *EnumerationName(ArrayTypeArraySizeModifier) {
  return "ArrayTypeArraySizeModifier";
}

inline static constexpr unsigned NumEnumerators(ArrayTypeArraySizeModifier) {
  return 3;
}

const char *EnumeratorName(ArrayTypeArraySizeModifier);

enum class ArtificialAttrSpelling : unsigned char {
  GNU_ARTIFICIAL,
  CXX11_GNU_ARTIFICIAL,
  C2X_GNU_ARTIFICIAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ArtificialAttrSpelling) {
  return "ArtificialAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ArtificialAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ArtificialAttrSpelling);

enum class AsmLabelAttrSpelling : unsigned char {
  KEYWORD_ASSEMBLY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AsmLabelAttrSpelling) {
  return "AsmLabelAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AsmLabelAttrSpelling) {
  return 2;
}

const char *EnumeratorName(AsmLabelAttrSpelling);

enum class AssertCapabilityAttrSpelling : unsigned char {
  GNU_ASSERT_CAPABILITY,
  CXX11_CLANG_ASSERT_CAPABILITY,
  GNU_ASSERT_SHARED_CAPABILITY,
  CXX11_CLANG_ASSERT_SHARED_CAPABILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AssertCapabilityAttrSpelling) {
  return "AssertCapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AssertCapabilityAttrSpelling) {
  return 5;
}

const char *EnumeratorName(AssertCapabilityAttrSpelling);

enum class AssumeAlignedAttrSpelling : unsigned char {
  GNU_ASSUME_ALIGNED,
  CXX11_GNU_ASSUME_ALIGNED,
  C2X_GNU_ASSUME_ALIGNED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AssumeAlignedAttrSpelling) {
  return "AssumeAlignedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AssumeAlignedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AssumeAlignedAttrSpelling);

enum class AssumptionAttrSpelling : unsigned char {
  GNU_ASSUME,
  CXX11_CLANG_ASSUME,
  C2X_CLANG_ASSUME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AssumptionAttrSpelling) {
  return "AssumptionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AssumptionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AssumptionAttrSpelling);

enum class AtomicExprAtomicOp : unsigned char {
  C11_ATOMIC_INITIALIZER,
  C11_ATOMIC_LOAD,
  C11_ATOMIC_STORE,
  C11_ATOMIC_EXCHANGE,
  C11_ATOMIC_COMPARE_EXCHANGE_STRONG,
  C11_ATOMIC_COMPARE_EXCHANGE_WEAK,
  C11_ATOMIC_FETCH_ADD,
  C11_ATOMIC_FETCH_SUB,
  C11_ATOMIC_FETCH_AND,
  C11_ATOMIC_FETCH_OR,
  C11_ATOMIC_FETCH_XOR,
  C11_ATOMIC_FETCH_NAND,
  C11_ATOMIC_FETCH_MAX,
  C11_ATOMIC_FETCH_MIN,
  ATOMIC_LOAD,
  ATOMIC_LOAD_N,
  ATOMIC_STORE,
  ATOMIC_STORE_N,
  ATOMIC_EXCHANGE,
  ATOMIC_EXCHANGE_N,
  ATOMIC_COMPARE_EXCHANGE,
  ATOMIC_COMPARE_EXCHANGE_N,
  ATOMIC_FETCH_ADD,
  ATOMIC_FETCH_SUB,
  ATOMIC_FETCH_AND,
  ATOMIC_FETCH_OR,
  ATOMIC_FETCH_XOR,
  ATOMIC_FETCH_NAND,
  ATOMIC_ADD_FETCH,
  ATOMIC_SUB_FETCH,
  ATOMIC_AND_FETCH,
  ATOMIC_OR_FETCH,
  ATOMIC_XOR_FETCH,
  ATOMIC_MAX_FETCH,
  ATOMIC_MIN_FETCH,
  ATOMIC_NAND_FETCH,
  OPENCL_ATOMIC_INITIALIZER,
  OPENCL_ATOMIC_LOAD,
  OPENCL_ATOMIC_STORE,
  OPENCL_ATOMIC_EXCHANGE,
  OPENCL_ATOMIC_COMPARE_EXCHANGE_STRONG,
  OPENCL_ATOMIC_COMPARE_EXCHANGE_WEAK,
  OPENCL_ATOMIC_FETCH_ADD,
  OPENCL_ATOMIC_FETCH_SUB,
  OPENCL_ATOMIC_FETCH_AND,
  OPENCL_ATOMIC_FETCH_OR,
  OPENCL_ATOMIC_FETCH_XOR,
  OPENCL_ATOMIC_FETCH_MIN,
  OPENCL_ATOMIC_FETCH_MAX,
  ATOMIC_FETCH_MIN,
  ATOMIC_FETCH_MAX,
  HIP_ATOMIC_LOAD,
  HIP_ATOMIC_STORE,
  HIP_ATOMIC_COMPARE_EXCHANGE_WEAK,
  HIP_ATOMIC_COMPARE_EXCHANGE_STRONG,
  HIP_ATOMIC_EXCHANGE,
  HIP_ATOMIC_FETCH_ADD,
  HIP_ATOMIC_FETCH_AND,
  HIP_ATOMIC_FETCH_OR,
  HIP_ATOMIC_FETCH_XOR,
  HIP_ATOMIC_FETCH_MIN,
  HIP_ATOMIC_FETCH_MAX,
};

inline static const char *EnumerationName(AtomicExprAtomicOp) {
  return "AtomicExprAtomicOp";
}

inline static constexpr unsigned NumEnumerators(AtomicExprAtomicOp) {
  return 62;
}

const char *EnumeratorName(AtomicExprAtomicOp);

enum class AvailabilityAttrSpelling : unsigned char {
  GNU_AVAILABILITY,
  CXX11_CLANG_AVAILABILITY,
  C2X_CLANG_AVAILABILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(AvailabilityAttrSpelling) {
  return "AvailabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(AvailabilityAttrSpelling) {
  return 4;
}

const char *EnumeratorName(AvailabilityAttrSpelling);

enum class BPFPreserveAccessIndexAttrSpelling : unsigned char {
  GNU_PRESERVE_ACCESS_INDEX,
  CXX11_CLANG_PRESERVE_ACCESS_INDEX,
  C2X_CLANG_PRESERVE_ACCESS_INDEX,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(BPFPreserveAccessIndexAttrSpelling) {
  return "BPFPreserveAccessIndexAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(BPFPreserveAccessIndexAttrSpelling) {
  return 4;
}

const char *EnumeratorName(BPFPreserveAccessIndexAttrSpelling);

enum class BTFDeclTagAttrSpelling : unsigned char {
  GNU_BTF_DECLARATION_TAG,
  CXX11_CLANG_BTF_DECLARATION_TAG,
  C2X_CLANG_BTF_DECLARATION_TAG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(BTFDeclTagAttrSpelling) {
  return "BTFDeclTagAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(BTFDeclTagAttrSpelling) {
  return 4;
}

const char *EnumeratorName(BTFDeclTagAttrSpelling);

enum class BTFTypeTagAttrSpelling : unsigned char {
  GNU_BTF_TYPE_TAG,
  CXX11_CLANG_BTF_TYPE_TAG,
  C2X_CLANG_BTF_TYPE_TAG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(BTFTypeTagAttrSpelling) {
  return "BTFTypeTagAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(BTFTypeTagAttrSpelling) {
  return 4;
}

const char *EnumeratorName(BTFTypeTagAttrSpelling);

enum class BlocksAttrBlockType : unsigned char {
  BY_REFERENCE,
};

inline static const char *EnumerationName(BlocksAttrBlockType) {
  return "BlocksAttrBlockType";
}

inline static constexpr unsigned NumEnumerators(BlocksAttrBlockType) {
  return 1;
}

const char *EnumeratorName(BlocksAttrBlockType);

enum class BlocksAttrSpelling : unsigned char {
  GNU_BLOCKS,
  CXX11_CLANG_BLOCKS,
  C2X_CLANG_BLOCKS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(BlocksAttrSpelling) {
  return "BlocksAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(BlocksAttrSpelling) {
  return 4;
}

const char *EnumeratorName(BlocksAttrSpelling);

enum class BuiltinAliasAttrSpelling : unsigned char {
  CXX11_CLANG_BUILTIN_ALIAS,
  C2X_CLANG_BUILTIN_ALIAS,
  GNU_CLANG_BUILTIN_ALIAS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(BuiltinAliasAttrSpelling) {
  return "BuiltinAliasAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(BuiltinAliasAttrSpelling) {
  return 4;
}

const char *EnumeratorName(BuiltinAliasAttrSpelling);

enum class BuiltinTypeKind : unsigned char {
  OCL_IMAGE_1D_RO,
  OCL_IMAGE_1D_ARRAY_RO,
  OCL_IMAGE_1D_BUFFER_RO,
  OCL_IMAGE_2D_RO,
  OCL_IMAGE_2D_ARRAY_RO,
  OCL_IMAGE_2D_DEPTH_RO,
  OCL_IMAGE_2D_ARRAY_DEPTH_RO,
  OCL_IMAGE_2D_MSAARO,
  OCL_IMAGE_2D_ARRAY_MSAARO,
  OCL_IMAGE_2D_MSAA_DEPTH_RO,
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RO,
  OCL_IMAGE_3D_RO,
  OCL_IMAGE_1D_WO,
  OCL_IMAGE_1D_ARRAY_WO,
  OCL_IMAGE_1D_BUFFER_WO,
  OCL_IMAGE_2D_WO,
  OCL_IMAGE_2D_ARRAY_WO,
  OCL_IMAGE_2D_DEPTH_WO,
  OCL_IMAGE_2D_ARRAY_DEPTH_WO,
  OCL_IMAGE_2D_MSAAWO,
  OCL_IMAGE_2D_ARRAY_MSAAWO,
  OCL_IMAGE_2D_MSAA_DEPTH_WO,
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_WO,
  OCL_IMAGE_3D_WO,
  OCL_IMAGE_1D_RW,
  OCL_IMAGE_1D_ARRAY_RW,
  OCL_IMAGE_1D_BUFFER_RW,
  OCL_IMAGE_2D_RW,
  OCL_IMAGE_2D_ARRAY_RW,
  OCL_IMAGE_2D_DEPTH_RW,
  OCL_IMAGE_2D_ARRAY_DEPTH_RW,
  OCL_IMAGE_2D_MSAARW,
  OCL_IMAGE_2D_ARRAY_MSAARW,
  OCL_IMAGE_2D_MSAA_DEPTH_RW,
  OCL_IMAGE_2D_ARRAY_MSAA_DEPTH_RW,
  OCL_IMAGE_3D_RW,
  OCL_INTEL_SUBGROUP_AVC_MCE_PAYLOAD,
  OCL_INTEL_SUBGROUP_AVC_IME_PAYLOAD,
  OCL_INTEL_SUBGROUP_AVC_REF_PAYLOAD,
  OCL_INTEL_SUBGROUP_AVC_SIC_PAYLOAD,
  OCL_INTEL_SUBGROUP_AVC_MCE_RESULT,
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT,
  OCL_INTEL_SUBGROUP_AVC_REF_RESULT,
  OCL_INTEL_SUBGROUP_AVC_SIC_RESULT,
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT_SINGLE_REFERENCE_STREAMOUT,
  OCL_INTEL_SUBGROUP_AVC_IME_RESULT_DUAL_REFERENCE_STREAMOUT,
  OCL_INTEL_SUBGROUP_AVC_IME_SINGLE_REFERENCE_STREAMIN,
  OCL_INTEL_SUBGROUP_AVC_IME_DUAL_REFERENCE_STREAMIN,
  SVE_INT8,
  SVE_INT16,
  SVE_INT32,
  SVE_INT64,
  SVE_UINT8,
  SVE_UINT16,
  SVE_UINT32,
  SVE_UINT64,
  SVE_FLOAT16,
  SVE_FLOAT32,
  SVE_FLOAT64,
  SVE_B_FLOAT16,
  SVE_INT8X2,
  SVE_INT16X2,
  SVE_INT32X2,
  SVE_INT64X2,
  SVE_UINT8X2,
  SVE_UINT16X2,
  SVE_UINT32X2,
  SVE_UINT64X2,
  SVE_FLOAT16X2,
  SVE_FLOAT32X2,
  SVE_FLOAT64X2,
  SVE_B_FLOAT16X2,
  SVE_INT8X3,
  SVE_INT16X3,
  SVE_INT32X3,
  SVE_INT64X3,
  SVE_UINT8X3,
  SVE_UINT16X3,
  SVE_UINT32X3,
  SVE_UINT64X3,
  SVE_FLOAT16X3,
  SVE_FLOAT32X3,
  SVE_FLOAT64X3,
  SVE_B_FLOAT16X3,
  SVE_INT8X4,
  SVE_INT16X4,
  SVE_INT32X4,
  SVE_INT64X4,
  SVE_UINT8X4,
  SVE_UINT16X4,
  SVE_UINT32X4,
  SVE_UINT64X4,
  SVE_FLOAT16X4,
  SVE_FLOAT32X4,
  SVE_FLOAT64X4,
  SVE_B_FLOAT16X4,
  SVE_BOOLEAN,
  VECTOR_QUAD,
  VECTOR_PAIR,
  RVV_INT8MF8,
  RVV_INT8MF4,
  RVV_INT8MF2,
  RVV_INT8M1,
  RVV_INT8M2,
  RVV_INT8M4,
  RVV_INT8M8,
  RVV_UINT8MF8,
  RVV_UINT8MF4,
  RVV_UINT8MF2,
  RVV_UINT8M1,
  RVV_UINT8M2,
  RVV_UINT8M4,
  RVV_UINT8M8,
  RVV_INT16MF4,
  RVV_INT16MF2,
  RVV_INT16M1,
  RVV_INT16M2,
  RVV_INT16M4,
  RVV_INT16M8,
  RVV_UINT16MF4,
  RVV_UINT16MF2,
  RVV_UINT16M1,
  RVV_UINT16M2,
  RVV_UINT16M4,
  RVV_UINT16M8,
  RVV_INT32MF2,
  RVV_INT32M1,
  RVV_INT32M2,
  RVV_INT32M4,
  RVV_INT32M8,
  RVV_UINT32MF2,
  RVV_UINT32M1,
  RVV_UINT32M2,
  RVV_UINT32M4,
  RVV_UINT32M8,
  RVV_INT64M1,
  RVV_INT64M2,
  RVV_INT64M4,
  RVV_INT64M8,
  RVV_UINT64M1,
  RVV_UINT64M2,
  RVV_UINT64M4,
  RVV_UINT64M8,
  RVV_FLOAT16MF4,
  RVV_FLOAT16MF2,
  RVV_FLOAT16M1,
  RVV_FLOAT16M2,
  RVV_FLOAT16M4,
  RVV_FLOAT16M8,
  RVV_FLOAT32MF2,
  RVV_FLOAT32M1,
  RVV_FLOAT32M2,
  RVV_FLOAT32M4,
  RVV_FLOAT32M8,
  RVV_FLOAT64M1,
  RVV_FLOAT64M2,
  RVV_FLOAT64M4,
  RVV_FLOAT64M8,
  RVV_BOOL1,
  RVV_BOOL2,
  RVV_BOOL4,
  RVV_BOOL8,
  RVV_BOOL16,
  RVV_BOOL32,
  RVV_BOOL64,
  VOID,
  BOOLEAN,
  CHARACTER_U,
  U_CHAR,
  W_CHAR_U,
  CHAR8,
  CHAR16,
  CHAR32,
  U_SHORT,
  U_INT,
  U_LONG,
  U_LONG_LONG,
  U_INT128,
  CHARACTER_S,
  S_CHAR,
  W_CHAR_S,
  SHORT,
  INT,
  LONG,
  LONG_LONG,
  INT128,
  SHORT_ACCUM,
  ACCUM,
  LONG_ACCUM,
  U_SHORT_ACCUM,
  U_ACCUM,
  U_LONG_ACCUM,
  SHORT_FRACT,
  FRACT,
  LONG_FRACT,
  U_SHORT_FRACT,
  U_FRACT,
  U_LONG_FRACT,
  SAT_SHORT_ACCUM,
  SAT_ACCUM,
  SAT_LONG_ACCUM,
  SAT_U_SHORT_ACCUM,
  SAT_U_ACCUM,
  SAT_U_LONG_ACCUM,
  SAT_SHORT_FRACT,
  SAT_FRACT,
  SAT_LONG_FRACT,
  SAT_U_SHORT_FRACT,
  SAT_U_FRACT,
  SAT_U_LONG_FRACT,
  HALF,
  FLOAT,
  DOUBLE,
  LONG_DOUBLE,
  FLOAT16,
  B_FLOAT16,
  FLOAT128,
  IBM128,
  NULL_POINTER,
  OBJ_C_ID,
  OBJ_C_CLASS,
  OBJ_C_SEL,
  OCL_SAMPLER,
  OCL_EVENT,
  OCL_CLK_EVENT,
  OCL_QUEUE,
  OCL_RESERVE_ID,
  DEPENDENT,
  OVERLOAD,
  BOUND_MEMBER,
  PSEUDO_OBJECT,
  UNKNOWN_ANY,
  BUILTIN_FN,
  ARC_UNBRIDGED_CAST,
  INCOMPLETE_MATRIX_INDEX,
  OMP_ARRAY_SECTION,
  OMP_ARRAY_SHAPING,
  OMP_ITERATOR,
};

inline static const char *EnumerationName(BuiltinTypeKind) {
  return "BuiltinTypeKind";
}

inline static constexpr unsigned NumEnumerators(BuiltinTypeKind) {
  return 238;
}

const char *EnumeratorName(BuiltinTypeKind);

enum class CDeclAttrSpelling : unsigned char {
  GNU_CDECL,
  CXX11_GNU_CDECL,
  C2X_GNU_CDECL,
  KEYWORD_CDECL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CDeclAttrSpelling) {
  return "CDeclAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CDeclAttrSpelling) {
  return 5;
}

const char *EnumeratorName(CDeclAttrSpelling);

enum class CFAuditedTransferAttrSpelling : unsigned char {
  GNU_CF_AUDITED_TRANSFER,
  CXX11_CLANG_CF_AUDITED_TRANSFER,
  C2X_CLANG_CF_AUDITED_TRANSFER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFAuditedTransferAttrSpelling) {
  return "CFAuditedTransferAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFAuditedTransferAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFAuditedTransferAttrSpelling);

enum class CFConsumedAttrSpelling : unsigned char {
  GNU_CF_CONSUMED,
  CXX11_CLANG_CF_CONSUMED,
  C2X_CLANG_CF_CONSUMED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFConsumedAttrSpelling) {
  return "CFConsumedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFConsumedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFConsumedAttrSpelling);

enum class CFGuardAttrGuardArg : unsigned char {
  NOCF,
};

inline static const char *EnumerationName(CFGuardAttrGuardArg) {
  return "CFGuardAttrGuardArg";
}

inline static constexpr unsigned NumEnumerators(CFGuardAttrGuardArg) {
  return 1;
}

const char *EnumeratorName(CFGuardAttrGuardArg);

enum class CFICanonicalJumpTableAttrSpelling : unsigned char {
  GNU_CFI_CANONICAL_JUMP_TABLE,
  CXX11_CLANG_CFI_CANONICAL_JUMP_TABLE,
  C2X_CLANG_CFI_CANONICAL_JUMP_TABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFICanonicalJumpTableAttrSpelling) {
  return "CFICanonicalJumpTableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFICanonicalJumpTableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFICanonicalJumpTableAttrSpelling);

enum class CFReturnsNotRetainedAttrSpelling : unsigned char {
  GNU_CF_RETURNS_NOT_RETAINED,
  CXX11_CLANG_CF_RETURNS_NOT_RETAINED,
  C2X_CLANG_CF_RETURNS_NOT_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFReturnsNotRetainedAttrSpelling) {
  return "CFReturnsNotRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFReturnsNotRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFReturnsNotRetainedAttrSpelling);

enum class CFReturnsRetainedAttrSpelling : unsigned char {
  GNU_CF_RETURNS_RETAINED,
  CXX11_CLANG_CF_RETURNS_RETAINED,
  C2X_CLANG_CF_RETURNS_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFReturnsRetainedAttrSpelling) {
  return "CFReturnsRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFReturnsRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFReturnsRetainedAttrSpelling);

enum class CFUnknownTransferAttrSpelling : unsigned char {
  GNU_CF_UNKNOWN_TRANSFER,
  CXX11_CLANG_CF_UNKNOWN_TRANSFER,
  C2X_CLANG_CF_UNKNOWN_TRANSFER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CFUnknownTransferAttrSpelling) {
  return "CFUnknownTransferAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CFUnknownTransferAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CFUnknownTransferAttrSpelling);

enum class CPUDispatchAttrSpelling : unsigned char {
  GNU_CPU_DISPATCH,
  CXX11_CLANG_CPU_DISPATCH,
  C2X_CLANG_CPU_DISPATCH,
  DECLSPEC_CPU_DISPATCH,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CPUDispatchAttrSpelling) {
  return "CPUDispatchAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CPUDispatchAttrSpelling) {
  return 5;
}

const char *EnumeratorName(CPUDispatchAttrSpelling);

enum class CPUSpecificAttrSpelling : unsigned char {
  GNU_CPU_SPECIFIC,
  CXX11_CLANG_CPU_SPECIFIC,
  C2X_CLANG_CPU_SPECIFIC,
  DECLSPEC_CPU_SPECIFIC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CPUSpecificAttrSpelling) {
  return "CPUSpecificAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CPUSpecificAttrSpelling) {
  return 5;
}

const char *EnumeratorName(CPUSpecificAttrSpelling);

enum class CUDAConstantAttrSpelling : unsigned char {
  GNU_CONSTANT,
  DECLSPEC_CONSTANT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDAConstantAttrSpelling) {
  return "CUDAConstantAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDAConstantAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDAConstantAttrSpelling);

enum class CUDADeviceAttrSpelling : unsigned char {
  GNU_DEVICE,
  DECLSPEC_DEVICE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDADeviceAttrSpelling) {
  return "CUDADeviceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDADeviceAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDADeviceAttrSpelling);

enum class CUDADeviceBuiltinSurfaceTypeAttrSpelling : unsigned char {
  GNU_DEVICE_BUILTIN_SURFACE_TYPE,
  DECLSPEC_DEVICE_BUILTIN_SURFACE_TYPE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDADeviceBuiltinSurfaceTypeAttrSpelling) {
  return "CUDADeviceBuiltinSurfaceTypeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDADeviceBuiltinSurfaceTypeAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDADeviceBuiltinSurfaceTypeAttrSpelling);

enum class CUDADeviceBuiltinTextureTypeAttrSpelling : unsigned char {
  GNU_DEVICE_BUILTIN_TEXTURE_TYPE,
  DECLSPEC_DEVICE_BUILTIN_TEXTURE_TYPE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDADeviceBuiltinTextureTypeAttrSpelling) {
  return "CUDADeviceBuiltinTextureTypeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDADeviceBuiltinTextureTypeAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDADeviceBuiltinTextureTypeAttrSpelling);

enum class CUDAGlobalAttrSpelling : unsigned char {
  GNU_GLOBAL,
  DECLSPEC_GLOBAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDAGlobalAttrSpelling) {
  return "CUDAGlobalAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDAGlobalAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDAGlobalAttrSpelling);

enum class CUDAHostAttrSpelling : unsigned char {
  GNU_HOST,
  DECLSPEC_HOST,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDAHostAttrSpelling) {
  return "CUDAHostAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDAHostAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDAHostAttrSpelling);

enum class CUDALaunchBoundsAttrSpelling : unsigned char {
  GNU_LAUNCH_BOUNDS,
  DECLSPEC_LAUNCH_BOUNDS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDALaunchBoundsAttrSpelling) {
  return "CUDALaunchBoundsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDALaunchBoundsAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDALaunchBoundsAttrSpelling);

enum class CUDASharedAttrSpelling : unsigned char {
  GNU_SHARED,
  DECLSPEC_SHARED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CUDASharedAttrSpelling) {
  return "CUDASharedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CUDASharedAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CUDASharedAttrSpelling);

enum class CXXConstructExprConstructionKind : unsigned char {
  COMPLETE,
  NON_VIRTUAL_BASE,
  VIRTUAL_BASE,
  DELEGATING,
};

inline static const char *EnumerationName(CXXConstructExprConstructionKind) {
  return "CXXConstructExprConstructionKind";
}

inline static constexpr unsigned NumEnumerators(CXXConstructExprConstructionKind) {
  return 4;
}

const char *EnumeratorName(CXXConstructExprConstructionKind);

enum class CXXNewExprInitializationStyle : unsigned char {
  NO_INITIALIZER,
  CALL_INITIALIZER,
  LIST_INITIALIZER,
};

inline static const char *EnumerationName(CXXNewExprInitializationStyle) {
  return "CXXNewExprInitializationStyle";
}

inline static constexpr unsigned NumEnumerators(CXXNewExprInitializationStyle) {
  return 3;
}

const char *EnumeratorName(CXXNewExprInitializationStyle);

enum class CallExprADLCallKind : unsigned char {
  NOT_ADL,
  USES_ADL,
};

inline static const char *EnumerationName(CallExprADLCallKind) {
  return "CallExprADLCallKind";
}

inline static constexpr unsigned NumEnumerators(CallExprADLCallKind) {
  return 2;
}

const char *EnumeratorName(CallExprADLCallKind);

enum class CallableWhenAttrConsumedState : unsigned char {
  UNKNOWN,
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(CallableWhenAttrConsumedState) {
  return "CallableWhenAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(CallableWhenAttrConsumedState) {
  return 3;
}

const char *EnumeratorName(CallableWhenAttrConsumedState);

enum class CallableWhenAttrSpelling : unsigned char {
  GNU_CALLABLE_WHEN,
  CXX11_CLANG_CALLABLE_WHEN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CallableWhenAttrSpelling) {
  return "CallableWhenAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CallableWhenAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CallableWhenAttrSpelling);

enum class CallbackAttrSpelling : unsigned char {
  GNU_CALLBACK,
  CXX11_CLANG_CALLBACK,
  C2X_CLANG_CALLBACK,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CallbackAttrSpelling) {
  return "CallbackAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CallbackAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CallbackAttrSpelling);

enum class CalledOnceAttrSpelling : unsigned char {
  GNU_CALLED_ONCE,
  CXX11_CLANG_CALLED_ONCE,
  C2X_CLANG_CALLED_ONCE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CalledOnceAttrSpelling) {
  return "CalledOnceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CalledOnceAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CalledOnceAttrSpelling);

enum class CapabilityAttrSpelling : unsigned char {
  GNU_CAPABILITY,
  CXX11_CLANG_CAPABILITY,
  GNU_SHARED_CAPABILITY,
  CXX11_CLANG_SHARED_CAPABILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CapabilityAttrSpelling) {
  return "CapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CapabilityAttrSpelling) {
  return 5;
}

const char *EnumeratorName(CapabilityAttrSpelling);

enum class CapturedStmtVariableCaptureKind : unsigned char {
  THIS,
  BY_REFERENCE,
  BY_COPY,
  VLA_TYPE,
};

inline static const char *EnumerationName(CapturedStmtVariableCaptureKind) {
  return "CapturedStmtVariableCaptureKind";
}

inline static constexpr unsigned NumEnumerators(CapturedStmtVariableCaptureKind) {
  return 4;
}

const char *EnumeratorName(CapturedStmtVariableCaptureKind);

enum class CarriesDependencyAttrSpelling : unsigned char {
  GNU_CARRIES_DEPENDENCY,
  CXX11_CARRIES_DEPENDENCY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CarriesDependencyAttrSpelling) {
  return "CarriesDependencyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CarriesDependencyAttrSpelling) {
  return 3;
}

const char *EnumeratorName(CarriesDependencyAttrSpelling);

enum class CharacterLiteralCharacterKind : unsigned char {
  ASCII,
  WIDE,
  UTF8,
  UTF16,
  UTF32,
};

inline static const char *EnumerationName(CharacterLiteralCharacterKind) {
  return "CharacterLiteralCharacterKind";
}

inline static constexpr unsigned NumEnumerators(CharacterLiteralCharacterKind) {
  return 5;
}

const char *EnumeratorName(CharacterLiteralCharacterKind);

enum class CleanupAttrSpelling : unsigned char {
  GNU_CLEANUP,
  CXX11_GNU_CLEANUP,
  C2X_GNU_CLEANUP,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CleanupAttrSpelling) {
  return "CleanupAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CleanupAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CleanupAttrSpelling);

enum class ColdAttrSpelling : unsigned char {
  GNU_COLD,
  CXX11_GNU_COLD,
  C2X_GNU_COLD,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ColdAttrSpelling) {
  return "ColdAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ColdAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ColdAttrSpelling);

enum class CommonAttrSpelling : unsigned char {
  GNU_COMMON,
  CXX11_GNU_COMMON,
  C2X_GNU_COMMON,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(CommonAttrSpelling) {
  return "CommonAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(CommonAttrSpelling) {
  return 4;
}

const char *EnumeratorName(CommonAttrSpelling);

enum class ConstAttrSpelling : unsigned char {
  GNU_CONST,
  CXX11_GNU_CONST,
  C2X_GNU_CONST,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConstAttrSpelling) {
  return "ConstAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConstAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ConstAttrSpelling);

enum class ConstInitAttrSpelling : unsigned char {
  KEYWORD_CONSTINIT,
  GNU_REQUIRE_CONSTANT_INITIALIZATION,
  CXX11_CLANG_REQUIRE_CONSTANT_INITIALIZATION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConstInitAttrSpelling) {
  return "ConstInitAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConstInitAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ConstInitAttrSpelling);

enum class ConstantExprResultStorageKind : unsigned char {
  NONE,
  INT64,
  AP_VALUE,
};

inline static const char *EnumerationName(ConstantExprResultStorageKind) {
  return "ConstantExprResultStorageKind";
}

inline static constexpr unsigned NumEnumerators(ConstantExprResultStorageKind) {
  return 3;
}

const char *EnumeratorName(ConstantExprResultStorageKind);

enum class ConstructorAttrSpelling : unsigned char {
  GNU_CONSTRUCTOR,
  CXX11_GNU_CONSTRUCTOR,
  C2X_GNU_CONSTRUCTOR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConstructorAttrSpelling) {
  return "ConstructorAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConstructorAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ConstructorAttrSpelling);

enum class ConsumableAttrConsumedState : unsigned char {
  UNKNOWN,
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(ConsumableAttrConsumedState) {
  return "ConsumableAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(ConsumableAttrConsumedState) {
  return 3;
}

const char *EnumeratorName(ConsumableAttrConsumedState);

enum class ConsumableAttrSpelling : unsigned char {
  GNU_CONSUMABLE,
  CXX11_CLANG_CONSUMABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConsumableAttrSpelling) {
  return "ConsumableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConsumableAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ConsumableAttrSpelling);

enum class ConsumableAutoCastAttrSpelling : unsigned char {
  GNU_CONSUMABLE_AUTO_CAST_STATE,
  CXX11_CLANG_CONSUMABLE_AUTO_CAST_STATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConsumableAutoCastAttrSpelling) {
  return "ConsumableAutoCastAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConsumableAutoCastAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ConsumableAutoCastAttrSpelling);

enum class ConsumableSetOnReadAttrSpelling : unsigned char {
  GNU_CONSUMABLE_STATE_ON_READ,
  CXX11_CLANG_CONSUMABLE_STATE_ON_READ,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConsumableSetOnReadAttrSpelling) {
  return "ConsumableSetOnReadAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConsumableSetOnReadAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ConsumableSetOnReadAttrSpelling);

enum class ConvergentAttrSpelling : unsigned char {
  GNU_CONVERGENT,
  CXX11_CLANG_CONVERGENT,
  C2X_CLANG_CONVERGENT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ConvergentAttrSpelling) {
  return "ConvergentAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ConvergentAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ConvergentAttrSpelling);

enum class DLLExportAttrSpelling : unsigned char {
  DECLSPEC_DLLEXPORT,
  GNU_DLLEXPORT,
  CXX11_GNU_DLLEXPORT,
  C2X_GNU_DLLEXPORT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DLLExportAttrSpelling) {
  return "DLLExportAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DLLExportAttrSpelling) {
  return 5;
}

const char *EnumeratorName(DLLExportAttrSpelling);

enum class DLLImportAttrSpelling : unsigned char {
  DECLSPEC_DLLIMPORT,
  GNU_DLLIMPORT,
  CXX11_GNU_DLLIMPORT,
  C2X_GNU_DLLIMPORT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DLLImportAttrSpelling) {
  return "DLLImportAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DLLImportAttrSpelling) {
  return 5;
}

const char *EnumeratorName(DLLImportAttrSpelling);

enum class DeclFriendObjectKind : unsigned char {
  NONE,
  DECLARED,
  UNDECLARED,
};

inline static const char *EnumerationName(DeclFriendObjectKind) {
  return "DeclFriendObjectKind";
}

inline static constexpr unsigned NumEnumerators(DeclFriendObjectKind) {
  return 3;
}

const char *EnumeratorName(DeclFriendObjectKind);

enum class DeclIdentifierNamespace : unsigned char {
  LABEL,
  TAG,
  TYPE,
  MEMBER,
  NAMESPACE,
  ORDINARY,
  OBJ_C_PROTOCOL,
  ORDINARY_FRIEND,
  TAG_FRIEND,
  USING,
  NON_MEMBER_OPERATOR,
  LOCAL_EXTERN,
  OMP_REDUCTION,
  OMP_MAPPER,
};

inline static const char *EnumerationName(DeclIdentifierNamespace) {
  return "DeclIdentifierNamespace";
}

inline static constexpr unsigned NumEnumerators(DeclIdentifierNamespace) {
  return 14;
}

const char *EnumeratorName(DeclIdentifierNamespace);

enum class DeclModuleOwnershipKind : unsigned char {
  UNOWNED,
  VISIBLE,
  VISIBLE_WHEN_IMPORTED,
  MODULE_PRIVATE,
};

inline static const char *EnumerationName(DeclModuleOwnershipKind) {
  return "DeclModuleOwnershipKind";
}

inline static constexpr unsigned NumEnumerators(DeclModuleOwnershipKind) {
  return 4;
}

const char *EnumeratorName(DeclModuleOwnershipKind);

enum class DeclObjCDeclQualifier : unsigned char {
  NONE,
  IN,
  INOUT,
  OUT,
  BYCOPY,
  BYREF,
  ONEWAY,
  CS_NULLABILITY,
};

inline static const char *EnumerationName(DeclObjCDeclQualifier) {
  return "DeclObjCDeclQualifier";
}

inline static constexpr unsigned NumEnumerators(DeclObjCDeclQualifier) {
  return 8;
}

const char *EnumeratorName(DeclObjCDeclQualifier);

enum class DeprecatedAttrSpelling : unsigned char {
  GNU_DEPRECATED,
  CXX11_GNU_DEPRECATED,
  C2X_GNU_DEPRECATED,
  DECLSPEC_DEPRECATED,
  CXX11_DEPRECATED,
  C2X_DEPRECATED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DeprecatedAttrSpelling) {
  return "DeprecatedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DeprecatedAttrSpelling) {
  return 7;
}

const char *EnumeratorName(DeprecatedAttrSpelling);

enum class DestructorAttrSpelling : unsigned char {
  GNU_DESTRUCTOR,
  CXX11_GNU_DESTRUCTOR,
  C2X_GNU_DESTRUCTOR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DestructorAttrSpelling) {
  return "DestructorAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DestructorAttrSpelling) {
  return 4;
}

const char *EnumeratorName(DestructorAttrSpelling);

enum class DiagnoseAsBuiltinAttrSpelling : unsigned char {
  GNU_DIAGNOSE_AS_BUILTIN,
  CXX11_CLANG_DIAGNOSE_AS_BUILTIN,
  C2X_CLANG_DIAGNOSE_AS_BUILTIN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DiagnoseAsBuiltinAttrSpelling) {
  return "DiagnoseAsBuiltinAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DiagnoseAsBuiltinAttrSpelling) {
  return 4;
}

const char *EnumeratorName(DiagnoseAsBuiltinAttrSpelling);

enum class DiagnoseIfAttrDiagnosticType : unsigned char {
  ERROR,
  WARNING,
};

inline static const char *EnumerationName(DiagnoseIfAttrDiagnosticType) {
  return "DiagnoseIfAttrDiagnosticType";
}

inline static constexpr unsigned NumEnumerators(DiagnoseIfAttrDiagnosticType) {
  return 2;
}

const char *EnumeratorName(DiagnoseIfAttrDiagnosticType);

enum class DisableSanitizerInstrumentationAttrSpelling : unsigned char {
  GNU_DISABLE_SANITIZER_INSTRUMENTATION,
  CXX11_CLANG_DISABLE_SANITIZER_INSTRUMENTATION,
  C2X_CLANG_DISABLE_SANITIZER_INSTRUMENTATION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DisableSanitizerInstrumentationAttrSpelling) {
  return "DisableSanitizerInstrumentationAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DisableSanitizerInstrumentationAttrSpelling) {
  return 4;
}

const char *EnumeratorName(DisableSanitizerInstrumentationAttrSpelling);

enum class DisableTailCallsAttrSpelling : unsigned char {
  GNU_DISABLE_TAIL_CALLS,
  CXX11_CLANG_DISABLE_TAIL_CALLS,
  C2X_CLANG_DISABLE_TAIL_CALLS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(DisableTailCallsAttrSpelling) {
  return "DisableTailCallsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(DisableTailCallsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(DisableTailCallsAttrSpelling);

enum class EnforceTCBAttrSpelling : unsigned char {
  GNU_ENFORCE_TCB,
  CXX11_CLANG_ENFORCE_TCB,
  C2X_CLANG_ENFORCE_TCB,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(EnforceTCBAttrSpelling) {
  return "EnforceTCBAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(EnforceTCBAttrSpelling) {
  return 4;
}

const char *EnumeratorName(EnforceTCBAttrSpelling);

enum class EnforceTCBLeafAttrSpelling : unsigned char {
  GNU_ENFORCE_TCB_LEAF,
  CXX11_CLANG_ENFORCE_TCB_LEAF,
  C2X_CLANG_ENFORCE_TCB_LEAF,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(EnforceTCBLeafAttrSpelling) {
  return "EnforceTCBLeafAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(EnforceTCBLeafAttrSpelling) {
  return 4;
}

const char *EnumeratorName(EnforceTCBLeafAttrSpelling);

enum class EnumExtensibilityAttrKind : unsigned char {
  CLOSED,
  OPEN,
};

inline static const char *EnumerationName(EnumExtensibilityAttrKind) {
  return "EnumExtensibilityAttrKind";
}

inline static constexpr unsigned NumEnumerators(EnumExtensibilityAttrKind) {
  return 2;
}

const char *EnumeratorName(EnumExtensibilityAttrKind);

enum class EnumExtensibilityAttrSpelling : unsigned char {
  GNU_ENUM_EXTENSIBILITY,
  CXX11_CLANG_ENUM_EXTENSIBILITY,
  C2X_CLANG_ENUM_EXTENSIBILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(EnumExtensibilityAttrSpelling) {
  return "EnumExtensibilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(EnumExtensibilityAttrSpelling) {
  return 4;
}

const char *EnumeratorName(EnumExtensibilityAttrSpelling);

enum class ErrorAttrSpelling : unsigned char {
  GNU_ERROR,
  CXX11_GNU_ERROR,
  C2X_GNU_ERROR,
  GNU_WARNING,
  CXX11_GNU_WARNING,
  C2X_GNU_WARNING,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ErrorAttrSpelling) {
  return "ErrorAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ErrorAttrSpelling) {
  return 7;
}

const char *EnumeratorName(ErrorAttrSpelling);

enum class ExcludeFromExplicitInstantiationAttrSpelling : unsigned char {
  GNU_EXCLUDE_FROM_EXPLICIT_INSTANTIATION,
  CXX11_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION,
  C2X_CLANG_EXCLUDE_FROM_EXPLICIT_INSTANTIATION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ExcludeFromExplicitInstantiationAttrSpelling) {
  return "ExcludeFromExplicitInstantiationAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ExcludeFromExplicitInstantiationAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ExcludeFromExplicitInstantiationAttrSpelling);

enum class ExprConstantExprKind : unsigned char {
  NORMAL,
  NON_CLASS_TEMPLATE_ARGUMENT,
  CLASS_TEMPLATE_ARGUMENT,
  IMMEDIATE_INVOCATION,
};

inline static const char *EnumerationName(ExprConstantExprKind) {
  return "ExprConstantExprKind";
}

inline static constexpr unsigned NumEnumerators(ExprConstantExprKind) {
  return 4;
}

const char *EnumeratorName(ExprConstantExprKind);

enum class ExprLValueClassification : unsigned char {
  VALID,
  NOT_OBJECT_TYPE,
  INCOMPLETE_VOID_TYPE,
  DUPLICATE_VECTOR_COMPONENTS,
  INVALID_EXPRESSION,
  INVALID_MESSAGE_EXPRESSION,
  MEMBER_FUNCTION,
  SUB_OBJ_C_PROPERTY_SETTING,
  CLASS_TEMPORARY,
  ARRAY_TEMPORARY,
};

inline static const char *EnumerationName(ExprLValueClassification) {
  return "ExprLValueClassification";
}

inline static constexpr unsigned NumEnumerators(ExprLValueClassification) {
  return 10;
}

const char *EnumeratorName(ExprLValueClassification);

enum class ExprNullPointerConstantKind : unsigned char {
  NOT_NULL,
  ZERO_EXPRESSION,
  ZERO_LITERAL,
  CXX11_NULLPTR,
  GNU_NULL,
};

inline static const char *EnumerationName(ExprNullPointerConstantKind) {
  return "ExprNullPointerConstantKind";
}

inline static constexpr unsigned NumEnumerators(ExprNullPointerConstantKind) {
  return 5;
}

const char *EnumeratorName(ExprNullPointerConstantKind);

enum class ExprNullPointerConstantValueDependence : unsigned char {
  NEVER_VALUE_DEPENDENT,
  VALUE_DEPENDENT_IS_NULL,
  VALUE_DEPENDENT_IS_NOT_NULL,
};

inline static const char *EnumerationName(ExprNullPointerConstantValueDependence) {
  return "ExprNullPointerConstantValueDependence";
}

inline static constexpr unsigned NumEnumerators(ExprNullPointerConstantValueDependence) {
  return 3;
}

const char *EnumeratorName(ExprNullPointerConstantValueDependence);

enum class ExprSideEffectsKind : unsigned char {
  NO_SIDE_EFFECTS,
  ALLOW_UNDEFINED_BEHAVIOR,
  ALLOW_SIDE_EFFECTS,
};

inline static const char *EnumerationName(ExprSideEffectsKind) {
  return "ExprSideEffectsKind";
}

inline static constexpr unsigned NumEnumerators(ExprSideEffectsKind) {
  return 3;
}

const char *EnumeratorName(ExprSideEffectsKind);

enum class ExprisModifiableLvalueResult : unsigned char {
  VALID,
  NOT_OBJECT_TYPE,
  INCOMPLETE_VOID_TYPE,
  DUPLICATE_VECTOR_COMPONENTS,
  INVALID_EXPRESSION,
  L_VALUE_CAST,
  INCOMPLETE_TYPE,
  CONST_QUALIFIED,
  CONST_QUALIFIED_FIELD,
  CONST_ADDRESS_SPACE,
  ARRAY_TYPE,
  NO_SETTER_PROPERTY,
  MEMBER_FUNCTION,
  SUB_OBJ_C_PROPERTY_SETTING,
  INVALID_MESSAGE_EXPRESSION,
  CLASS_TEMPORARY,
  ARRAY_TEMPORARY,
};

inline static const char *EnumerationName(ExprisModifiableLvalueResult) {
  return "ExprisModifiableLvalueResult";
}

inline static constexpr unsigned NumEnumerators(ExprisModifiableLvalueResult) {
  return 17;
}

const char *EnumeratorName(ExprisModifiableLvalueResult);

enum class ExternalSourceSymbolAttrSpelling : unsigned char {
  GNU_EXTERNAL_SOURCE_SYMBOL,
  CXX11_CLANG_EXTERNAL_SOURCE_SYMBOL,
  C2X_CLANG_EXTERNAL_SOURCE_SYMBOL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ExternalSourceSymbolAttrSpelling) {
  return "ExternalSourceSymbolAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ExternalSourceSymbolAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ExternalSourceSymbolAttrSpelling);

enum class FallThroughAttrSpelling : unsigned char {
  CXX11_FALLTHROUGH,
  C2X_FALLTHROUGH,
  CXX11_CLANG_FALLTHROUGH,
  GNU_FALLTHROUGH,
  CXX11_GNU_FALLTHROUGH,
  C2X_GNU_FALLTHROUGH,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FallThroughAttrSpelling) {
  return "FallThroughAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FallThroughAttrSpelling) {
  return 7;
}

const char *EnumeratorName(FallThroughAttrSpelling);

enum class FastCallAttrSpelling : unsigned char {
  GNU_FASTCALL,
  CXX11_GNU_FASTCALL,
  C2X_GNU_FASTCALL,
  KEYWORD_FASTCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FastCallAttrSpelling) {
  return "FastCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FastCallAttrSpelling) {
  return 5;
}

const char *EnumeratorName(FastCallAttrSpelling);

enum class FinalAttrSpelling : unsigned char {
  KEYWORD_FINAL,
  KEYWORD_SEALED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FinalAttrSpelling) {
  return "FinalAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FinalAttrSpelling) {
  return 3;
}

const char *EnumeratorName(FinalAttrSpelling);

enum class FlagEnumAttrSpelling : unsigned char {
  GNU_FLAG_ENUM,
  CXX11_CLANG_FLAG_ENUM,
  C2X_CLANG_FLAG_ENUM,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FlagEnumAttrSpelling) {
  return "FlagEnumAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FlagEnumAttrSpelling) {
  return 4;
}

const char *EnumeratorName(FlagEnumAttrSpelling);

enum class FlattenAttrSpelling : unsigned char {
  GNU_FLATTEN,
  CXX11_GNU_FLATTEN,
  C2X_GNU_FLATTEN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FlattenAttrSpelling) {
  return "FlattenAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FlattenAttrSpelling) {
  return 4;
}

const char *EnumeratorName(FlattenAttrSpelling);

enum class FormatArgAttrSpelling : unsigned char {
  GNU_FORMAT_ARGUMENT,
  CXX11_GNU_FORMAT_ARGUMENT,
  C2X_GNU_FORMAT_ARGUMENT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FormatArgAttrSpelling) {
  return "FormatArgAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FormatArgAttrSpelling) {
  return 4;
}

const char *EnumeratorName(FormatArgAttrSpelling);

enum class FormatAttrSpelling : unsigned char {
  GNU_FORMAT,
  CXX11_GNU_FORMAT,
  C2X_GNU_FORMAT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(FormatAttrSpelling) {
  return "FormatAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(FormatAttrSpelling) {
  return 4;
}

const char *EnumeratorName(FormatAttrSpelling);

enum class FunctionDeclTemplatedKind : unsigned char {
  NON_TEMPLATE,
  FUNCTION_TEMPLATE,
  MEMBER_SPECIALIZATION,
  FUNCTION_TEMPLATE_SPECIALIZATION,
  DEPENDENT_FUNCTION_TEMPLATE_SPECIALIZATION,
};

inline static const char *EnumerationName(FunctionDeclTemplatedKind) {
  return "FunctionDeclTemplatedKind";
}

inline static constexpr unsigned NumEnumerators(FunctionDeclTemplatedKind) {
  return 5;
}

const char *EnumeratorName(FunctionDeclTemplatedKind);

enum class GNUInlineAttrSpelling : unsigned char {
  GNU_GNU_INLINE,
  CXX11_GNU_GNU_INLINE,
  C2X_GNU_GNU_INLINE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(GNUInlineAttrSpelling) {
  return "GNUInlineAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(GNUInlineAttrSpelling) {
  return 4;
}

const char *EnumeratorName(GNUInlineAttrSpelling);

enum class GuardedVarAttrSpelling : unsigned char {
  GNU_GUARDED_VARIABLE,
  CXX11_CLANG_GUARDED_VARIABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(GuardedVarAttrSpelling) {
  return "GuardedVarAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(GuardedVarAttrSpelling) {
  return 3;
}

const char *EnumeratorName(GuardedVarAttrSpelling);

enum class HIPManagedAttrSpelling : unsigned char {
  GNU_MANAGED,
  DECLSPEC_MANAGED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(HIPManagedAttrSpelling) {
  return "HIPManagedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(HIPManagedAttrSpelling) {
  return 3;
}

const char *EnumeratorName(HIPManagedAttrSpelling);

enum class HotAttrSpelling : unsigned char {
  GNU_HOT,
  CXX11_GNU_HOT,
  C2X_GNU_HOT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(HotAttrSpelling) {
  return "HotAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(HotAttrSpelling) {
  return 4;
}

const char *EnumeratorName(HotAttrSpelling);

enum class IBActionAttrSpelling : unsigned char {
  GNU_IBACTION,
  CXX11_CLANG_IBACTION,
  C2X_CLANG_IBACTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(IBActionAttrSpelling) {
  return "IBActionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(IBActionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(IBActionAttrSpelling);

enum class IBOutletAttrSpelling : unsigned char {
  GNU_IBOUTLET,
  CXX11_CLANG_IBOUTLET,
  C2X_CLANG_IBOUTLET,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(IBOutletAttrSpelling) {
  return "IBOutletAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(IBOutletAttrSpelling) {
  return 4;
}

const char *EnumeratorName(IBOutletAttrSpelling);

enum class IBOutletCollectionAttrSpelling : unsigned char {
  GNU_IBOUTLETCOLLECTION,
  CXX11_CLANG_IBOUTLETCOLLECTION,
  C2X_CLANG_IBOUTLETCOLLECTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(IBOutletCollectionAttrSpelling) {
  return "IBOutletCollectionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(IBOutletCollectionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(IBOutletCollectionAttrSpelling);

enum class IFuncAttrSpelling : unsigned char {
  GNU_IFUNC,
  CXX11_GNU_IFUNC,
  C2X_GNU_IFUNC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(IFuncAttrSpelling) {
  return "IFuncAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(IFuncAttrSpelling) {
  return 4;
}

const char *EnumeratorName(IFuncAttrSpelling);

enum class ImplicitCastExprOnStack : unsigned char {
  ON_STACK,
};

inline static const char *EnumerationName(ImplicitCastExprOnStack) {
  return "ImplicitCastExprOnStack";
}

inline static constexpr unsigned NumEnumerators(ImplicitCastExprOnStack) {
  return 1;
}

const char *EnumeratorName(ImplicitCastExprOnStack);

enum class ImplicitParamDeclImplicitParamKind : unsigned char {
  OBJ_C_SELF,
  OBJ_C_CMD,
  CXX_THIS,
  CXXVTT,
  CAPTURED_CONTEXT,
  OTHER,
};

inline static const char *EnumerationName(ImplicitParamDeclImplicitParamKind) {
  return "ImplicitParamDeclImplicitParamKind";
}

inline static constexpr unsigned NumEnumerators(ImplicitParamDeclImplicitParamKind) {
  return 6;
}

const char *EnumeratorName(ImplicitParamDeclImplicitParamKind);

enum class InitPriorityAttrSpelling : unsigned char {
  GNU_INITIALIZER_PRIORITY,
  CXX11_GNU_INITIALIZER_PRIORITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(InitPriorityAttrSpelling) {
  return "InitPriorityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(InitPriorityAttrSpelling) {
  return 3;
}

const char *EnumeratorName(InitPriorityAttrSpelling);

enum class IntelOclBiccAttrSpelling : unsigned char {
  GNU_INTEL_OCL_BICC,
  CXX11_CLANG_INTEL_OCL_BICC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(IntelOclBiccAttrSpelling) {
  return "IntelOclBiccAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(IntelOclBiccAttrSpelling) {
  return 3;
}

const char *EnumeratorName(IntelOclBiccAttrSpelling);

enum class InternalLinkageAttrSpelling : unsigned char {
  GNU_INTERNAL_LINKAGE,
  CXX11_CLANG_INTERNAL_LINKAGE,
  C2X_CLANG_INTERNAL_LINKAGE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(InternalLinkageAttrSpelling) {
  return "InternalLinkageAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(InternalLinkageAttrSpelling) {
  return 4;
}

const char *EnumeratorName(InternalLinkageAttrSpelling);

enum class LTOVisibilityPublicAttrSpelling : unsigned char {
  GNU_LTO_VISIBILITY_PUBLIC,
  CXX11_CLANG_LTO_VISIBILITY_PUBLIC,
  C2X_CLANG_LTO_VISIBILITY_PUBLIC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LTOVisibilityPublicAttrSpelling) {
  return "LTOVisibilityPublicAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LTOVisibilityPublicAttrSpelling) {
  return 4;
}

const char *EnumeratorName(LTOVisibilityPublicAttrSpelling);

enum class LeafAttrSpelling : unsigned char {
  GNU_LEAF,
  CXX11_GNU_LEAF,
  C2X_GNU_LEAF,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LeafAttrSpelling) {
  return "LeafAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LeafAttrSpelling) {
  return 4;
}

const char *EnumeratorName(LeafAttrSpelling);

enum class LifetimeBoundAttrSpelling : unsigned char {
  GNU_LIFETIMEBOUND,
  CXX11_CLANG_LIFETIMEBOUND,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LifetimeBoundAttrSpelling) {
  return "LifetimeBoundAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LifetimeBoundAttrSpelling) {
  return 3;
}

const char *EnumeratorName(LifetimeBoundAttrSpelling);

enum class LikelyAttrSpelling : unsigned char {
  CXX11_LIKELY,
  C2X_CLANG_LIKELY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LikelyAttrSpelling) {
  return "LikelyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LikelyAttrSpelling) {
  return 3;
}

const char *EnumeratorName(LikelyAttrSpelling);

enum class LinkageSpecDeclLanguageIDs : unsigned char {
  C,
  CXX,
};

inline static const char *EnumerationName(LinkageSpecDeclLanguageIDs) {
  return "LinkageSpecDeclLanguageIDs";
}

inline static constexpr unsigned NumEnumerators(LinkageSpecDeclLanguageIDs) {
  return 2;
}

const char *EnumeratorName(LinkageSpecDeclLanguageIDs);

enum class LoaderUninitializedAttrSpelling : unsigned char {
  GNU_LOADER_UNINITIALIZED,
  CXX11_CLANG_LOADER_UNINITIALIZED,
  C2X_CLANG_LOADER_UNINITIALIZED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LoaderUninitializedAttrSpelling) {
  return "LoaderUninitializedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LoaderUninitializedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(LoaderUninitializedAttrSpelling);

enum class LoopHintAttrLoopHintState : unsigned char {
  ENABLE,
  DISABLE,
  NUMERIC,
  FIXED_WIDTH,
  SCALABLE_WIDTH,
  ASSUME_SAFETY,
  FULL,
};

inline static const char *EnumerationName(LoopHintAttrLoopHintState) {
  return "LoopHintAttrLoopHintState";
}

inline static constexpr unsigned NumEnumerators(LoopHintAttrLoopHintState) {
  return 7;
}

const char *EnumeratorName(LoopHintAttrLoopHintState);

enum class LoopHintAttrOptionType : unsigned char {
  VECTORIZE,
  VECTORIZE_WIDTH,
  INTERLEAVE,
  INTERLEAVE_COUNT,
  UNROLL,
  UNROLL_COUNT,
  UNROLL_AND_JAM,
  UNROLL_AND_JAM_COUNT,
  PIPELINE_DISABLED,
  PIPELINE_INITIATION_INTERVAL,
  DISTRIBUTE,
  VECTORIZE_PREDICATE,
};

inline static const char *EnumerationName(LoopHintAttrOptionType) {
  return "LoopHintAttrOptionType";
}

inline static constexpr unsigned NumEnumerators(LoopHintAttrOptionType) {
  return 12;
}

const char *EnumeratorName(LoopHintAttrOptionType);

enum class LoopHintAttrSpelling : unsigned char {
  PRAGMA_CLANG_LOOP,
  PRAGMA_UNROLL,
  PRAGMA_NOUNROLL,
  PRAGMA_UNROLL_AND_JAM,
  PRAGMA_NOUNROLL_AND_JAM,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(LoopHintAttrSpelling) {
  return "LoopHintAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(LoopHintAttrSpelling) {
  return 6;
}

const char *EnumeratorName(LoopHintAttrSpelling);

enum class MIGServerRoutineAttrSpelling : unsigned char {
  GNU_MIG_SERVER_ROUTINE,
  CXX11_CLANG_MIG_SERVER_ROUTINE,
  C2X_CLANG_MIG_SERVER_ROUTINE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MIGServerRoutineAttrSpelling) {
  return "MIGServerRoutineAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MIGServerRoutineAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MIGServerRoutineAttrSpelling);

enum class MSABIAttrSpelling : unsigned char {
  GNU_MS_ABI,
  CXX11_GNU_MS_ABI,
  C2X_GNU_MS_ABI,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MSABIAttrSpelling) {
  return "MSABIAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MSABIAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MSABIAttrSpelling);

enum class MSInheritanceAttrSpelling : unsigned char {
  KEYWORD_SINGLE_INHERITANCE,
  KEYWORD_MULTIPLE_INHERITANCE,
  KEYWORD_VIRTUAL_INHERITANCE,
  KEYWORD_UNSPECIFIED_INHERITANCE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MSInheritanceAttrSpelling) {
  return "MSInheritanceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MSInheritanceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(MSInheritanceAttrSpelling);

enum class MSP430InterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MSP430InterruptAttrSpelling) {
  return "MSP430InterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MSP430InterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MSP430InterruptAttrSpelling);

enum class MSStructAttrSpelling : unsigned char {
  GNU_MS_STRUCT,
  CXX11_GNU_MS_STRUCT,
  C2X_GNU_MS_STRUCT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MSStructAttrSpelling) {
  return "MSStructAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MSStructAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MSStructAttrSpelling);

enum class MayAliasAttrSpelling : unsigned char {
  GNU_MAY_ALIAS,
  CXX11_GNU_MAY_ALIAS,
  C2X_GNU_MAY_ALIAS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MayAliasAttrSpelling) {
  return "MayAliasAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MayAliasAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MayAliasAttrSpelling);

enum class MicroMipsAttrSpelling : unsigned char {
  GNU_MICROMIPS,
  CXX11_GNU_MICROMIPS,
  C2X_GNU_MICROMIPS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MicroMipsAttrSpelling) {
  return "MicroMipsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MicroMipsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MicroMipsAttrSpelling);

enum class MinSizeAttrSpelling : unsigned char {
  GNU_MINSIZE,
  CXX11_CLANG_MINSIZE,
  C2X_CLANG_MINSIZE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MinSizeAttrSpelling) {
  return "MinSizeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MinSizeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MinSizeAttrSpelling);

enum class MinVectorWidthAttrSpelling : unsigned char {
  GNU_MIN_VECTOR_WIDTH,
  CXX11_CLANG_MIN_VECTOR_WIDTH,
  C2X_CLANG_MIN_VECTOR_WIDTH,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MinVectorWidthAttrSpelling) {
  return "MinVectorWidthAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MinVectorWidthAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MinVectorWidthAttrSpelling);

enum class Mips16AttrSpelling : unsigned char {
  GNU_MIPS16,
  CXX11_GNU_MIPS16,
  C2X_GNU_MIPS16,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(Mips16AttrSpelling) {
  return "Mips16AttrSpelling";
}

inline static constexpr unsigned NumEnumerators(Mips16AttrSpelling) {
  return 4;
}

const char *EnumeratorName(Mips16AttrSpelling);

enum class MipsInterruptAttrInterruptType : unsigned char {
  SW0,
  SW1,
  HW0,
  HW1,
  HW2,
  HW3,
  HW4,
  HW5,
  EIC,
};

inline static const char *EnumerationName(MipsInterruptAttrInterruptType) {
  return "MipsInterruptAttrInterruptType";
}

inline static constexpr unsigned NumEnumerators(MipsInterruptAttrInterruptType) {
  return 9;
}

const char *EnumeratorName(MipsInterruptAttrInterruptType);

enum class MipsInterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MipsInterruptAttrSpelling) {
  return "MipsInterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MipsInterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MipsInterruptAttrSpelling);

enum class MipsLongCallAttrSpelling : unsigned char {
  GNU_LONG_CALL,
  CXX11_GNU_LONG_CALL,
  C2X_GNU_LONG_CALL,
  GNU_FAR,
  CXX11_GNU_FAR,
  C2X_GNU_FAR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MipsLongCallAttrSpelling) {
  return "MipsLongCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MipsLongCallAttrSpelling) {
  return 7;
}

const char *EnumeratorName(MipsLongCallAttrSpelling);

enum class MipsShortCallAttrSpelling : unsigned char {
  GNU_SHORT_CALL,
  CXX11_GNU_SHORT_CALL,
  C2X_GNU_SHORT_CALL,
  GNU_NEAR,
  CXX11_GNU_NEAR,
  C2X_GNU_NEAR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MipsShortCallAttrSpelling) {
  return "MipsShortCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MipsShortCallAttrSpelling) {
  return 7;
}

const char *EnumeratorName(MipsShortCallAttrSpelling);

enum class ModeAttrSpelling : unsigned char {
  GNU_MODE,
  CXX11_GNU_MODE,
  C2X_GNU_MODE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ModeAttrSpelling) {
  return "ModeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ModeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ModeAttrSpelling);

enum class MustTailAttrSpelling : unsigned char {
  GNU_MUSTTAIL,
  CXX11_CLANG_MUSTTAIL,
  C2X_CLANG_MUSTTAIL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(MustTailAttrSpelling) {
  return "MustTailAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(MustTailAttrSpelling) {
  return 4;
}

const char *EnumeratorName(MustTailAttrSpelling);

enum class NSConsumedAttrSpelling : unsigned char {
  GNU_NS_CONSUMED,
  CXX11_CLANG_NS_CONSUMED,
  C2X_CLANG_NS_CONSUMED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NSConsumedAttrSpelling) {
  return "NSConsumedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NSConsumedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NSConsumedAttrSpelling);

enum class NSConsumesSelfAttrSpelling : unsigned char {
  GNU_NS_CONSUMES_SELF,
  CXX11_CLANG_NS_CONSUMES_SELF,
  C2X_CLANG_NS_CONSUMES_SELF,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NSConsumesSelfAttrSpelling) {
  return "NSConsumesSelfAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NSConsumesSelfAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NSConsumesSelfAttrSpelling);

enum class NSReturnsAutoreleasedAttrSpelling : unsigned char {
  GNU_NS_RETURNS_AUTORELEASED,
  CXX11_CLANG_NS_RETURNS_AUTORELEASED,
  C2X_CLANG_NS_RETURNS_AUTORELEASED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NSReturnsAutoreleasedAttrSpelling) {
  return "NSReturnsAutoreleasedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NSReturnsAutoreleasedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NSReturnsAutoreleasedAttrSpelling);

enum class NSReturnsNotRetainedAttrSpelling : unsigned char {
  GNU_NS_RETURNS_NOT_RETAINED,
  CXX11_CLANG_NS_RETURNS_NOT_RETAINED,
  C2X_CLANG_NS_RETURNS_NOT_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NSReturnsNotRetainedAttrSpelling) {
  return "NSReturnsNotRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NSReturnsNotRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NSReturnsNotRetainedAttrSpelling);

enum class NSReturnsRetainedAttrSpelling : unsigned char {
  GNU_NS_RETURNS_RETAINED,
  CXX11_CLANG_NS_RETURNS_RETAINED,
  C2X_CLANG_NS_RETURNS_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NSReturnsRetainedAttrSpelling) {
  return "NSReturnsRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NSReturnsRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NSReturnsRetainedAttrSpelling);

enum class NakedAttrSpelling : unsigned char {
  GNU_NAKED,
  CXX11_GNU_NAKED,
  C2X_GNU_NAKED,
  DECLSPEC_NAKED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NakedAttrSpelling) {
  return "NakedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NakedAttrSpelling) {
  return 5;
}

const char *EnumeratorName(NakedAttrSpelling);

enum class NamedDeclExplicitVisibilityKind : unsigned char {
  VISIBILITY_FOR_TYPE,
  VISIBILITY_FOR_VALUE,
};

inline static const char *EnumerationName(NamedDeclExplicitVisibilityKind) {
  return "NamedDeclExplicitVisibilityKind";
}

inline static constexpr unsigned NumEnumerators(NamedDeclExplicitVisibilityKind) {
  return 2;
}

const char *EnumeratorName(NamedDeclExplicitVisibilityKind);

enum class NoBuiltinAttrSpelling : unsigned char {
  GNU_NO_BUILTIN,
  CXX11_CLANG_NO_BUILTIN,
  C2X_CLANG_NO_BUILTIN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoBuiltinAttrSpelling) {
  return "NoBuiltinAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoBuiltinAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoBuiltinAttrSpelling);

enum class NoCommonAttrSpelling : unsigned char {
  GNU_NOCOMMON,
  CXX11_GNU_NOCOMMON,
  C2X_GNU_NOCOMMON,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoCommonAttrSpelling) {
  return "NoCommonAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoCommonAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoCommonAttrSpelling);

enum class NoDebugAttrSpelling : unsigned char {
  GNU_NODEBUG,
  CXX11_GNU_NODEBUG,
  C2X_GNU_NODEBUG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoDebugAttrSpelling) {
  return "NoDebugAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoDebugAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoDebugAttrSpelling);

enum class NoDerefAttrSpelling : unsigned char {
  GNU_NODEREF,
  CXX11_CLANG_NODEREF,
  C2X_CLANG_NODEREF,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoDerefAttrSpelling) {
  return "NoDerefAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoDerefAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoDerefAttrSpelling);

enum class NoDestroyAttrSpelling : unsigned char {
  GNU_NO_DESTROY,
  CXX11_CLANG_NO_DESTROY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoDestroyAttrSpelling) {
  return "NoDestroyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoDestroyAttrSpelling) {
  return 3;
}

const char *EnumeratorName(NoDestroyAttrSpelling);

enum class NoDuplicateAttrSpelling : unsigned char {
  GNU_NODUPLICATE,
  CXX11_CLANG_NODUPLICATE,
  C2X_CLANG_NODUPLICATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoDuplicateAttrSpelling) {
  return "NoDuplicateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoDuplicateAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoDuplicateAttrSpelling);

enum class NoEscapeAttrSpelling : unsigned char {
  GNU_NOESCAPE,
  CXX11_CLANG_NOESCAPE,
  C2X_CLANG_NOESCAPE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoEscapeAttrSpelling) {
  return "NoEscapeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoEscapeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoEscapeAttrSpelling);

enum class NoInlineAttrSpelling : unsigned char {
  GNU_NOINLINE,
  CXX11_GNU_NOINLINE,
  C2X_GNU_NOINLINE,
  DECLSPEC_NOINLINE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoInlineAttrSpelling) {
  return "NoInlineAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoInlineAttrSpelling) {
  return 5;
}

const char *EnumeratorName(NoInlineAttrSpelling);

enum class NoInstrumentFunctionAttrSpelling : unsigned char {
  GNU_NO_INSTRUMENT_FUNCTION,
  CXX11_GNU_NO_INSTRUMENT_FUNCTION,
  C2X_GNU_NO_INSTRUMENT_FUNCTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoInstrumentFunctionAttrSpelling) {
  return "NoInstrumentFunctionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoInstrumentFunctionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoInstrumentFunctionAttrSpelling);

enum class NoMergeAttrSpelling : unsigned char {
  GNU_NOMERGE,
  CXX11_CLANG_NOMERGE,
  C2X_CLANG_NOMERGE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoMergeAttrSpelling) {
  return "NoMergeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoMergeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoMergeAttrSpelling);

enum class NoMicroMipsAttrSpelling : unsigned char {
  GNU_NOMICROMIPS,
  CXX11_GNU_NOMICROMIPS,
  C2X_GNU_NOMICROMIPS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoMicroMipsAttrSpelling) {
  return "NoMicroMipsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoMicroMipsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoMicroMipsAttrSpelling);

enum class NoMips16AttrSpelling : unsigned char {
  GNU_NOMIPS16,
  CXX11_GNU_NOMIPS16,
  C2X_GNU_NOMIPS16,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoMips16AttrSpelling) {
  return "NoMips16AttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoMips16AttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoMips16AttrSpelling);

enum class NoProfileFunctionAttrSpelling : unsigned char {
  GNU_NO_PROFILE_INSTRUMENT_FUNCTION,
  CXX11_GNU_NO_PROFILE_INSTRUMENT_FUNCTION,
  C2X_GNU_NO_PROFILE_INSTRUMENT_FUNCTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoProfileFunctionAttrSpelling) {
  return "NoProfileFunctionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoProfileFunctionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoProfileFunctionAttrSpelling);

enum class NoReturnAttrSpelling : unsigned char {
  GNU_NORETURN,
  CXX11_GNU_NORETURN,
  C2X_GNU_NORETURN,
  DECLSPEC_NORETURN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoReturnAttrSpelling) {
  return "NoReturnAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoReturnAttrSpelling) {
  return 5;
}

const char *EnumeratorName(NoReturnAttrSpelling);

enum class NoSanitizeAttrSpelling : unsigned char {
  GNU_NO_SANITIZE,
  CXX11_CLANG_NO_SANITIZE,
  C2X_CLANG_NO_SANITIZE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoSanitizeAttrSpelling) {
  return "NoSanitizeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoSanitizeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoSanitizeAttrSpelling);

enum class NoSpeculativeLoadHardeningAttrSpelling : unsigned char {
  GNU_NO_SPECULATIVE_LOAD_HARDENING,
  CXX11_CLANG_NO_SPECULATIVE_LOAD_HARDENING,
  C2X_CLANG_NO_SPECULATIVE_LOAD_HARDENING,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoSpeculativeLoadHardeningAttrSpelling) {
  return "NoSpeculativeLoadHardeningAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoSpeculativeLoadHardeningAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoSpeculativeLoadHardeningAttrSpelling);

enum class NoSplitStackAttrSpelling : unsigned char {
  GNU_NO_SPLIT_STACK,
  CXX11_GNU_NO_SPLIT_STACK,
  C2X_GNU_NO_SPLIT_STACK,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoSplitStackAttrSpelling) {
  return "NoSplitStackAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoSplitStackAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoSplitStackAttrSpelling);

enum class NoStackProtectorAttrSpelling : unsigned char {
  GNU_NO_STACK_PROTECTOR,
  CXX11_CLANG_NO_STACK_PROTECTOR,
  C2X_CLANG_NO_STACK_PROTECTOR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoStackProtectorAttrSpelling) {
  return "NoStackProtectorAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoStackProtectorAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoStackProtectorAttrSpelling);

enum class NoThreadSafetyAnalysisAttrSpelling : unsigned char {
  GNU_NO_THREAD_SAFETY_ANALYSIS,
  CXX11_CLANG_NO_THREAD_SAFETY_ANALYSIS,
  C2X_CLANG_NO_THREAD_SAFETY_ANALYSIS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoThreadSafetyAnalysisAttrSpelling) {
  return "NoThreadSafetyAnalysisAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoThreadSafetyAnalysisAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NoThreadSafetyAnalysisAttrSpelling);

enum class NoThrowAttrSpelling : unsigned char {
  GNU_NOTHROW,
  CXX11_GNU_NOTHROW,
  C2X_GNU_NOTHROW,
  DECLSPEC_NOTHROW,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NoThrowAttrSpelling) {
  return "NoThrowAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NoThrowAttrSpelling) {
  return 5;
}

const char *EnumeratorName(NoThrowAttrSpelling);

enum class NonNullAttrSpelling : unsigned char {
  GNU_NONNULL,
  CXX11_GNU_NONNULL,
  C2X_GNU_NONNULL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NonNullAttrSpelling) {
  return "NonNullAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NonNullAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NonNullAttrSpelling);

enum class NotTailCalledAttrSpelling : unsigned char {
  GNU_NOT_TAIL_CALLED,
  CXX11_CLANG_NOT_TAIL_CALLED,
  C2X_CLANG_NOT_TAIL_CALLED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(NotTailCalledAttrSpelling) {
  return "NotTailCalledAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(NotTailCalledAttrSpelling) {
  return 4;
}

const char *EnumeratorName(NotTailCalledAttrSpelling);

enum class OMPAllocateDeclAttrAllocatorTypeTy : unsigned char {
  OMP_NULL_MEMORY_ALLOC,
  OMP_DEFAULT_MEMORY_ALLOC,
  OMP_LARGE_CAP_MEMORY_ALLOC,
  OMP_CONST_MEMORY_ALLOC,
  OMP_HIGH_BW_MEMORY_ALLOC,
  OMP_LOW_LAT_MEMORY_ALLOC,
  OMPC_GROUP_MEMORY_ALLOC,
  OMPP_TEAM_MEMORY_ALLOC,
  OMP_THREAD_MEMORY_ALLOC,
  OMP_USER_DEFINED_MEMORY_ALLOC,
};

inline static const char *EnumerationName(OMPAllocateDeclAttrAllocatorTypeTy) {
  return "OMPAllocateDeclAttrAllocatorTypeTy";
}

inline static constexpr unsigned NumEnumerators(OMPAllocateDeclAttrAllocatorTypeTy) {
  return 10;
}

const char *EnumeratorName(OMPAllocateDeclAttrAllocatorTypeTy);

enum class OMPDeclareReductionDeclInitKind : unsigned char {
  CALL_INITIALIZER,
  DIRECT_INITIALIZER,
  COPY_INITIALIZER,
};

inline static const char *EnumerationName(OMPDeclareReductionDeclInitKind) {
  return "OMPDeclareReductionDeclInitKind";
}

inline static constexpr unsigned NumEnumerators(OMPDeclareReductionDeclInitKind) {
  return 3;
}

const char *EnumeratorName(OMPDeclareReductionDeclInitKind);

enum class OMPDeclareSimdDeclAttrBranchStateTy : unsigned char {
  UNDEFINED,
  INBRANCH,
  NOTINBRANCH,
};

inline static const char *EnumerationName(OMPDeclareSimdDeclAttrBranchStateTy) {
  return "OMPDeclareSimdDeclAttrBranchStateTy";
}

inline static constexpr unsigned NumEnumerators(OMPDeclareSimdDeclAttrBranchStateTy) {
  return 3;
}

const char *EnumeratorName(OMPDeclareSimdDeclAttrBranchStateTy);

enum class OMPDeclareTargetDeclAttrDevTypeTy : unsigned char {
  HOST,
  NO_HOST,
  ANY,
};

inline static const char *EnumerationName(OMPDeclareTargetDeclAttrDevTypeTy) {
  return "OMPDeclareTargetDeclAttrDevTypeTy";
}

inline static constexpr unsigned NumEnumerators(OMPDeclareTargetDeclAttrDevTypeTy) {
  return 3;
}

const char *EnumeratorName(OMPDeclareTargetDeclAttrDevTypeTy);

enum class OMPDeclareTargetDeclAttrMapTypeTy : unsigned char {
  TO,
  LINK,
};

inline static const char *EnumerationName(OMPDeclareTargetDeclAttrMapTypeTy) {
  return "OMPDeclareTargetDeclAttrMapTypeTy";
}

inline static constexpr unsigned NumEnumerators(OMPDeclareTargetDeclAttrMapTypeTy) {
  return 2;
}

const char *EnumeratorName(OMPDeclareTargetDeclAttrMapTypeTy);

enum class OMPDeclareVariantAttrInteropType : unsigned char {
  TARGET,
  TARGET_SYNC,
  TARGET_TARGET_SYNC,
};

inline static const char *EnumerationName(OMPDeclareVariantAttrInteropType) {
  return "OMPDeclareVariantAttrInteropType";
}

inline static constexpr unsigned NumEnumerators(OMPDeclareVariantAttrInteropType) {
  return 3;
}

const char *EnumeratorName(OMPDeclareVariantAttrInteropType);

enum class OSConsumedAttrSpelling : unsigned char {
  GNU_OS_CONSUMED,
  CXX11_CLANG_OS_CONSUMED,
  C2X_CLANG_OS_CONSUMED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSConsumedAttrSpelling) {
  return "OSConsumedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSConsumedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSConsumedAttrSpelling);

enum class OSConsumesThisAttrSpelling : unsigned char {
  GNU_OS_CONSUMES_THIS,
  CXX11_CLANG_OS_CONSUMES_THIS,
  C2X_CLANG_OS_CONSUMES_THIS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSConsumesThisAttrSpelling) {
  return "OSConsumesThisAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSConsumesThisAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSConsumesThisAttrSpelling);

enum class OSReturnsNotRetainedAttrSpelling : unsigned char {
  GNU_OS_RETURNS_NOT_RETAINED,
  CXX11_CLANG_OS_RETURNS_NOT_RETAINED,
  C2X_CLANG_OS_RETURNS_NOT_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSReturnsNotRetainedAttrSpelling) {
  return "OSReturnsNotRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSReturnsNotRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSReturnsNotRetainedAttrSpelling);

enum class OSReturnsRetainedAttrSpelling : unsigned char {
  GNU_OS_RETURNS_RETAINED,
  CXX11_CLANG_OS_RETURNS_RETAINED,
  C2X_CLANG_OS_RETURNS_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSReturnsRetainedAttrSpelling) {
  return "OSReturnsRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSReturnsRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSReturnsRetainedAttrSpelling);

enum class OSReturnsRetainedOnNonZeroAttrSpelling : unsigned char {
  GNU_OS_RETURNS_RETAINED_ON_NON_ZERO,
  CXX11_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO,
  C2X_CLANG_OS_RETURNS_RETAINED_ON_NON_ZERO,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSReturnsRetainedOnNonZeroAttrSpelling) {
  return "OSReturnsRetainedOnNonZeroAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSReturnsRetainedOnNonZeroAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSReturnsRetainedOnNonZeroAttrSpelling);

enum class OSReturnsRetainedOnZeroAttrSpelling : unsigned char {
  GNU_OS_RETURNS_RETAINED_ON_ZERO,
  CXX11_CLANG_OS_RETURNS_RETAINED_ON_ZERO,
  C2X_CLANG_OS_RETURNS_RETAINED_ON_ZERO,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OSReturnsRetainedOnZeroAttrSpelling) {
  return "OSReturnsRetainedOnZeroAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OSReturnsRetainedOnZeroAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OSReturnsRetainedOnZeroAttrSpelling);

enum class ObjCBoxableAttrSpelling : unsigned char {
  GNU_OBJC_BOXABLE,
  CXX11_CLANG_OBJC_BOXABLE,
  C2X_CLANG_OBJC_BOXABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCBoxableAttrSpelling) {
  return "ObjCBoxableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCBoxableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCBoxableAttrSpelling);

enum class ObjCBridgeAttrSpelling : unsigned char {
  GNU_OBJC_BRIDGE,
  CXX11_CLANG_OBJC_BRIDGE,
  C2X_CLANG_OBJC_BRIDGE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCBridgeAttrSpelling) {
  return "ObjCBridgeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCBridgeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCBridgeAttrSpelling);

enum class ObjCBridgeMutableAttrSpelling : unsigned char {
  GNU_OBJC_BRIDGE_MUTABLE,
  CXX11_CLANG_OBJC_BRIDGE_MUTABLE,
  C2X_CLANG_OBJC_BRIDGE_MUTABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCBridgeMutableAttrSpelling) {
  return "ObjCBridgeMutableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCBridgeMutableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCBridgeMutableAttrSpelling);

enum class ObjCBridgeRelatedAttrSpelling : unsigned char {
  GNU_OBJC_BRIDGE_RELATED,
  CXX11_CLANG_OBJC_BRIDGE_RELATED,
  C2X_CLANG_OBJC_BRIDGE_RELATED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCBridgeRelatedAttrSpelling) {
  return "ObjCBridgeRelatedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCBridgeRelatedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCBridgeRelatedAttrSpelling);

enum class ObjCClassStubAttrSpelling : unsigned char {
  GNU_OBJC_CLASS_STUB,
  CXX11_CLANG_OBJC_CLASS_STUB,
  C2X_CLANG_OBJC_CLASS_STUB,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCClassStubAttrSpelling) {
  return "ObjCClassStubAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCClassStubAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCClassStubAttrSpelling);

enum class ObjCDesignatedInitializerAttrSpelling : unsigned char {
  GNU_OBJC_DESIGNATED_INITIALIZER,
  CXX11_CLANG_OBJC_DESIGNATED_INITIALIZER,
  C2X_CLANG_OBJC_DESIGNATED_INITIALIZER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCDesignatedInitializerAttrSpelling) {
  return "ObjCDesignatedInitializerAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCDesignatedInitializerAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCDesignatedInitializerAttrSpelling);

enum class ObjCDirectAttrSpelling : unsigned char {
  GNU_OBJC_DIRECT,
  CXX11_CLANG_OBJC_DIRECT,
  C2X_CLANG_OBJC_DIRECT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCDirectAttrSpelling) {
  return "ObjCDirectAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCDirectAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCDirectAttrSpelling);

enum class ObjCDirectMembersAttrSpelling : unsigned char {
  GNU_OBJC_DIRECT_MEMBERS,
  CXX11_CLANG_OBJC_DIRECT_MEMBERS,
  C2X_CLANG_OBJC_DIRECT_MEMBERS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCDirectMembersAttrSpelling) {
  return "ObjCDirectMembersAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCDirectMembersAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCDirectMembersAttrSpelling);

enum class ObjCExceptionAttrSpelling : unsigned char {
  GNU_OBJC_EXCEPTION,
  CXX11_CLANG_OBJC_EXCEPTION,
  C2X_CLANG_OBJC_EXCEPTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCExceptionAttrSpelling) {
  return "ObjCExceptionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCExceptionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCExceptionAttrSpelling);

enum class ObjCExplicitProtocolImplAttrSpelling : unsigned char {
  GNU_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION,
  CXX11_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION,
  C2X_CLANG_OBJC_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCExplicitProtocolImplAttrSpelling) {
  return "ObjCExplicitProtocolImplAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCExplicitProtocolImplAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCExplicitProtocolImplAttrSpelling);

enum class ObjCExternallyRetainedAttrSpelling : unsigned char {
  GNU_OBJC_EXTERNALLY_RETAINED,
  CXX11_CLANG_OBJC_EXTERNALLY_RETAINED,
  C2X_CLANG_OBJC_EXTERNALLY_RETAINED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCExternallyRetainedAttrSpelling) {
  return "ObjCExternallyRetainedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCExternallyRetainedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCExternallyRetainedAttrSpelling);

enum class ObjCGCAttrSpelling : unsigned char {
  GNU_OBJC_GC,
  CXX11_CLANG_OBJC_GC,
  C2X_CLANG_OBJC_GC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCGCAttrSpelling) {
  return "ObjCGCAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCGCAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCGCAttrSpelling);

enum class ObjCIndependentClassAttrSpelling : unsigned char {
  GNU_OBJC_INDEPENDENT_CLASS,
  CXX11_CLANG_OBJC_INDEPENDENT_CLASS,
  C2X_CLANG_OBJC_INDEPENDENT_CLASS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCIndependentClassAttrSpelling) {
  return "ObjCIndependentClassAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCIndependentClassAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCIndependentClassAttrSpelling);

enum class ObjCIvarDeclAccessControl : unsigned char {
  NONE,
  PRIVATE,
  PROTECTED,
  PUBLIC,
  PACKAGE,
};

inline static const char *EnumerationName(ObjCIvarDeclAccessControl) {
  return "ObjCIvarDeclAccessControl";
}

inline static constexpr unsigned NumEnumerators(ObjCIvarDeclAccessControl) {
  return 5;
}

const char *EnumeratorName(ObjCIvarDeclAccessControl);

enum class ObjCMessageExprReceiverKind : unsigned char {
  CLASS,
  INSTANCE,
  SUPER_CLASS,
  SUPER_INSTANCE,
};

inline static const char *EnumerationName(ObjCMessageExprReceiverKind) {
  return "ObjCMessageExprReceiverKind";
}

inline static constexpr unsigned NumEnumerators(ObjCMessageExprReceiverKind) {
  return 4;
}

const char *EnumeratorName(ObjCMessageExprReceiverKind);

enum class ObjCMethodDeclImplementationControl : unsigned char {
  NONE,
  REQUIRED,
  OPTIONAL,
};

inline static const char *EnumerationName(ObjCMethodDeclImplementationControl) {
  return "ObjCMethodDeclImplementationControl";
}

inline static constexpr unsigned NumEnumerators(ObjCMethodDeclImplementationControl) {
  return 3;
}

const char *EnumeratorName(ObjCMethodDeclImplementationControl);

enum class ObjCMethodFamilyAttrFamilyKind : unsigned char {
  NONE,
  ALLOC,
  COPY,
  INITIALIZER,
  MUTABLE_COPY,
  NEW,
};

inline static const char *EnumerationName(ObjCMethodFamilyAttrFamilyKind) {
  return "ObjCMethodFamilyAttrFamilyKind";
}

inline static constexpr unsigned NumEnumerators(ObjCMethodFamilyAttrFamilyKind) {
  return 6;
}

const char *EnumeratorName(ObjCMethodFamilyAttrFamilyKind);

enum class ObjCMethodFamilyAttrSpelling : unsigned char {
  GNU_OBJC_METHOD_FAMILY,
  CXX11_CLANG_OBJC_METHOD_FAMILY,
  C2X_CLANG_OBJC_METHOD_FAMILY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCMethodFamilyAttrSpelling) {
  return "ObjCMethodFamilyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCMethodFamilyAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCMethodFamilyAttrSpelling);

enum class ObjCNSObjectAttrSpelling : unsigned char {
  GNUNS_OBJECT,
  CXX11_CLANG_NS_OBJECT,
  C2X_CLANG_NS_OBJECT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCNSObjectAttrSpelling) {
  return "ObjCNSObjectAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCNSObjectAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCNSObjectAttrSpelling);

enum class ObjCNonLazyClassAttrSpelling : unsigned char {
  GNU_OBJC_NONLAZY_CLASS,
  CXX11_CLANG_OBJC_NONLAZY_CLASS,
  C2X_CLANG_OBJC_NONLAZY_CLASS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCNonLazyClassAttrSpelling) {
  return "ObjCNonLazyClassAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCNonLazyClassAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCNonLazyClassAttrSpelling);

enum class ObjCNonRuntimeProtocolAttrSpelling : unsigned char {
  GNU_OBJC_NON_RUNTIME_PROTOCOL,
  CXX11_CLANG_OBJC_NON_RUNTIME_PROTOCOL,
  C2X_CLANG_OBJC_NON_RUNTIME_PROTOCOL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCNonRuntimeProtocolAttrSpelling) {
  return "ObjCNonRuntimeProtocolAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCNonRuntimeProtocolAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCNonRuntimeProtocolAttrSpelling);

enum class ObjCOwnershipAttrSpelling : unsigned char {
  GNU_OBJC_OWNERSHIP,
  CXX11_CLANG_OBJC_OWNERSHIP,
  C2X_CLANG_OBJC_OWNERSHIP,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCOwnershipAttrSpelling) {
  return "ObjCOwnershipAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCOwnershipAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCOwnershipAttrSpelling);

enum class ObjCPreciseLifetimeAttrSpelling : unsigned char {
  GNU_OBJC_PRECISE_LIFETIME,
  CXX11_CLANG_OBJC_PRECISE_LIFETIME,
  C2X_CLANG_OBJC_PRECISE_LIFETIME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCPreciseLifetimeAttrSpelling) {
  return "ObjCPreciseLifetimeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCPreciseLifetimeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCPreciseLifetimeAttrSpelling);

enum class ObjCPropertyDeclPropertyControl : unsigned char {
  NONE,
  REQUIRED,
  OPTIONAL,
};

inline static const char *EnumerationName(ObjCPropertyDeclPropertyControl) {
  return "ObjCPropertyDeclPropertyControl";
}

inline static constexpr unsigned NumEnumerators(ObjCPropertyDeclPropertyControl) {
  return 3;
}

const char *EnumeratorName(ObjCPropertyDeclPropertyControl);

enum class ObjCPropertyDeclSetterKind : unsigned char {
  ASSIGN,
  RETAIN,
  COPY,
  WEAK,
};

inline static const char *EnumerationName(ObjCPropertyDeclSetterKind) {
  return "ObjCPropertyDeclSetterKind";
}

inline static constexpr unsigned NumEnumerators(ObjCPropertyDeclSetterKind) {
  return 4;
}

const char *EnumeratorName(ObjCPropertyDeclSetterKind);

enum class ObjCPropertyImplDeclKind : unsigned char {
  SYNTHESIZE,
  DYNAMIC,
};

inline static const char *EnumerationName(ObjCPropertyImplDeclKind) {
  return "ObjCPropertyImplDeclKind";
}

inline static constexpr unsigned NumEnumerators(ObjCPropertyImplDeclKind) {
  return 2;
}

const char *EnumeratorName(ObjCPropertyImplDeclKind);

enum class ObjCRequiresPropertyDefsAttrSpelling : unsigned char {
  GNU_OBJC_REQUIRES_PROPERTY_DEFINITIONS,
  CXX11_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS,
  C2X_CLANG_OBJC_REQUIRES_PROPERTY_DEFINITIONS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCRequiresPropertyDefsAttrSpelling) {
  return "ObjCRequiresPropertyDefsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCRequiresPropertyDefsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCRequiresPropertyDefsAttrSpelling);

enum class ObjCRequiresSuperAttrSpelling : unsigned char {
  GNU_OBJC_REQUIRES_SUPER,
  CXX11_CLANG_OBJC_REQUIRES_SUPER,
  C2X_CLANG_OBJC_REQUIRES_SUPER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCRequiresSuperAttrSpelling) {
  return "ObjCRequiresSuperAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCRequiresSuperAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCRequiresSuperAttrSpelling);

enum class ObjCReturnsInnerPointerAttrSpelling : unsigned char {
  GNU_OBJC_RETURNS_INNER_POINTER,
  CXX11_CLANG_OBJC_RETURNS_INNER_POINTER,
  C2X_CLANG_OBJC_RETURNS_INNER_POINTER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCReturnsInnerPointerAttrSpelling) {
  return "ObjCReturnsInnerPointerAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCReturnsInnerPointerAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCReturnsInnerPointerAttrSpelling);

enum class ObjCRootClassAttrSpelling : unsigned char {
  GNU_OBJC_ROOT_CLASS,
  CXX11_CLANG_OBJC_ROOT_CLASS,
  C2X_CLANG_OBJC_ROOT_CLASS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCRootClassAttrSpelling) {
  return "ObjCRootClassAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCRootClassAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCRootClassAttrSpelling);

enum class ObjCRuntimeNameAttrSpelling : unsigned char {
  GNU_OBJC_RUNTIME_NAME,
  CXX11_CLANG_OBJC_RUNTIME_NAME,
  C2X_CLANG_OBJC_RUNTIME_NAME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCRuntimeNameAttrSpelling) {
  return "ObjCRuntimeNameAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCRuntimeNameAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCRuntimeNameAttrSpelling);

enum class ObjCRuntimeVisibleAttrSpelling : unsigned char {
  GNU_OBJC_RUNTIME_VISIBLE,
  CXX11_CLANG_OBJC_RUNTIME_VISIBLE,
  C2X_CLANG_OBJC_RUNTIME_VISIBLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCRuntimeVisibleAttrSpelling) {
  return "ObjCRuntimeVisibleAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCRuntimeVisibleAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCRuntimeVisibleAttrSpelling);

enum class ObjCSubclassingRestrictedAttrSpelling : unsigned char {
  GNU_OBJC_SUBCLASSING_RESTRICTED,
  CXX11_CLANG_OBJC_SUBCLASSING_RESTRICTED,
  C2X_CLANG_OBJC_SUBCLASSING_RESTRICTED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ObjCSubclassingRestrictedAttrSpelling) {
  return "ObjCSubclassingRestrictedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ObjCSubclassingRestrictedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ObjCSubclassingRestrictedAttrSpelling);

enum class OpenCLAccessAttrSpelling : unsigned char {
  KEYWORD_READ_ONLY,
  KEYWORD_WRITE_ONLY,
  KEYWORD_READ_WRITE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLAccessAttrSpelling) {
  return "OpenCLAccessAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLAccessAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OpenCLAccessAttrSpelling);

enum class OpenCLConstantAddressSpaceAttrSpelling : unsigned char {
  KEYWORD_CONSTANT,
  GNU_OPENCL_CONSTANT,
  CXX11_CLANG_OPENCL_CONSTANT,
  C2X_CLANG_OPENCL_CONSTANT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLConstantAddressSpaceAttrSpelling) {
  return "OpenCLConstantAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLConstantAddressSpaceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(OpenCLConstantAddressSpaceAttrSpelling);

enum class OpenCLGenericAddressSpaceAttrSpelling : unsigned char {
  KEYWORD_GENERIC,
  GNU_OPENCL_GENERIC,
  CXX11_CLANG_OPENCL_GENERIC,
  C2X_CLANG_OPENCL_GENERIC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLGenericAddressSpaceAttrSpelling) {
  return "OpenCLGenericAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLGenericAddressSpaceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(OpenCLGenericAddressSpaceAttrSpelling);

enum class OpenCLGlobalAddressSpaceAttrSpelling : unsigned char {
  KEYWORD_GLOBAL,
  GNU_OPENCL_GLOBAL,
  CXX11_CLANG_OPENCL_GLOBAL,
  C2X_CLANG_OPENCL_GLOBAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLGlobalAddressSpaceAttrSpelling) {
  return "OpenCLGlobalAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLGlobalAddressSpaceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(OpenCLGlobalAddressSpaceAttrSpelling);

enum class OpenCLGlobalDeviceAddressSpaceAttrSpelling : unsigned char {
  GNU_OPENCL_GLOBAL_DEVICE,
  CXX11_CLANG_OPENCL_GLOBAL_DEVICE,
  C2X_CLANG_OPENCL_GLOBAL_DEVICE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLGlobalDeviceAddressSpaceAttrSpelling) {
  return "OpenCLGlobalDeviceAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLGlobalDeviceAddressSpaceAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OpenCLGlobalDeviceAddressSpaceAttrSpelling);

enum class OpenCLGlobalHostAddressSpaceAttrSpelling : unsigned char {
  GNU_OPENCL_GLOBAL_HOST,
  CXX11_CLANG_OPENCL_GLOBAL_HOST,
  C2X_CLANG_OPENCL_GLOBAL_HOST,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLGlobalHostAddressSpaceAttrSpelling) {
  return "OpenCLGlobalHostAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLGlobalHostAddressSpaceAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OpenCLGlobalHostAddressSpaceAttrSpelling);

enum class OpenCLKernelAttrSpelling : unsigned char {
  KEYWORD_KERNEL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLKernelAttrSpelling) {
  return "OpenCLKernelAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLKernelAttrSpelling) {
  return 2;
}

const char *EnumeratorName(OpenCLKernelAttrSpelling);

enum class OpenCLLocalAddressSpaceAttrSpelling : unsigned char {
  KEYWORD_LOCAL,
  GNU_OPENCL_LOCAL,
  CXX11_CLANG_OPENCL_LOCAL,
  C2X_CLANG_OPENCL_LOCAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLLocalAddressSpaceAttrSpelling) {
  return "OpenCLLocalAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLLocalAddressSpaceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(OpenCLLocalAddressSpaceAttrSpelling);

enum class OpenCLPrivateAddressSpaceAttrSpelling : unsigned char {
  KEYWORD_PRIVATE,
  GNU_OPENCL_PRIVATE,
  CXX11_CLANG_OPENCL_PRIVATE,
  C2X_CLANG_OPENCL_PRIVATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OpenCLPrivateAddressSpaceAttrSpelling) {
  return "OpenCLPrivateAddressSpaceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OpenCLPrivateAddressSpaceAttrSpelling) {
  return 5;
}

const char *EnumeratorName(OpenCLPrivateAddressSpaceAttrSpelling);

enum class OptimizeNoneAttrSpelling : unsigned char {
  GNU_OPTNONE,
  CXX11_CLANG_OPTNONE,
  C2X_CLANG_OPTNONE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OptimizeNoneAttrSpelling) {
  return "OptimizeNoneAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OptimizeNoneAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OptimizeNoneAttrSpelling);

enum class OverloadableAttrSpelling : unsigned char {
  GNU_OVERLOADABLE,
  CXX11_CLANG_OVERLOADABLE,
  C2X_CLANG_OVERLOADABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OverloadableAttrSpelling) {
  return "OverloadableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OverloadableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(OverloadableAttrSpelling);

enum class OwnershipAttrOwnershipKind : unsigned char {
  HOLDS,
  RETURNS,
  TAKES,
};

inline static const char *EnumerationName(OwnershipAttrOwnershipKind) {
  return "OwnershipAttrOwnershipKind";
}

inline static constexpr unsigned NumEnumerators(OwnershipAttrOwnershipKind) {
  return 3;
}

const char *EnumeratorName(OwnershipAttrOwnershipKind);

enum class OwnershipAttrSpelling : unsigned char {
  GNU_OWNERSHIP_HOLDS,
  CXX11_CLANG_OWNERSHIP_HOLDS,
  C2X_CLANG_OWNERSHIP_HOLDS,
  GNU_OWNERSHIP_RETURNS,
  CXX11_CLANG_OWNERSHIP_RETURNS,
  C2X_CLANG_OWNERSHIP_RETURNS,
  GNU_OWNERSHIP_TAKES,
  CXX11_CLANG_OWNERSHIP_TAKES,
  C2X_CLANG_OWNERSHIP_TAKES,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(OwnershipAttrSpelling) {
  return "OwnershipAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(OwnershipAttrSpelling) {
  return 10;
}

const char *EnumeratorName(OwnershipAttrSpelling);

enum class PackedAttrSpelling : unsigned char {
  GNU_PACKED,
  CXX11_GNU_PACKED,
  C2X_GNU_PACKED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PackedAttrSpelling) {
  return "PackedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PackedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PackedAttrSpelling);

enum class ParamTypestateAttrConsumedState : unsigned char {
  UNKNOWN,
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(ParamTypestateAttrConsumedState) {
  return "ParamTypestateAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(ParamTypestateAttrConsumedState) {
  return 3;
}

const char *EnumeratorName(ParamTypestateAttrConsumedState);

enum class ParamTypestateAttrSpelling : unsigned char {
  GNU_PARAMETER_TYPESTATE,
  CXX11_CLANG_PARAMETER_TYPESTATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ParamTypestateAttrSpelling) {
  return "ParamTypestateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ParamTypestateAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ParamTypestateAttrSpelling);

enum class PascalAttrSpelling : unsigned char {
  GNU_PASCAL,
  CXX11_CLANG_PASCAL,
  C2X_CLANG_PASCAL,
  KEYWORD_PASCAL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PascalAttrSpelling) {
  return "PascalAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PascalAttrSpelling) {
  return 5;
}

const char *EnumeratorName(PascalAttrSpelling);

enum class PassObjectSizeAttrSpelling : unsigned char {
  GNU_PASS_OBJECT_SIZE,
  CXX11_CLANG_PASS_OBJECT_SIZE,
  C2X_CLANG_PASS_OBJECT_SIZE,
  GNU_PASS_DYNAMIC_OBJECT_SIZE,
  CXX11_CLANG_PASS_DYNAMIC_OBJECT_SIZE,
  C2X_CLANG_PASS_DYNAMIC_OBJECT_SIZE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PassObjectSizeAttrSpelling) {
  return "PassObjectSizeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PassObjectSizeAttrSpelling) {
  return 7;
}

const char *EnumeratorName(PassObjectSizeAttrSpelling);

enum class PatchableFunctionEntryAttrSpelling : unsigned char {
  GNU_PATCHABLE_FUNCTION_ENTRY,
  CXX11_GNU_PATCHABLE_FUNCTION_ENTRY,
  C2X_GNU_PATCHABLE_FUNCTION_ENTRY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PatchableFunctionEntryAttrSpelling) {
  return "PatchableFunctionEntryAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PatchableFunctionEntryAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PatchableFunctionEntryAttrSpelling);

enum class PcsAttrPCSType : unsigned char {
  AAPCS,
  VFP,
};

inline static const char *EnumerationName(PcsAttrPCSType) {
  return "PcsAttrPCSType";
}

inline static constexpr unsigned NumEnumerators(PcsAttrPCSType) {
  return 2;
}

const char *EnumeratorName(PcsAttrPCSType);

enum class PcsAttrSpelling : unsigned char {
  GNU_PCS,
  CXX11_GNU_PCS,
  C2X_GNU_PCS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PcsAttrSpelling) {
  return "PcsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PcsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PcsAttrSpelling);

enum class PredefinedExprIdentKind : unsigned char {
  FUNC,
  FUNCTION,
  L_FUNCTION,
  FUNC_D_NAME,
  FUNC_SIG,
  L_FUNC_SIG,
  PRETTY_FUNCTION,
  PRETTY_FUNCTION_NO_VIRTUAL,
};

inline static const char *EnumerationName(PredefinedExprIdentKind) {
  return "PredefinedExprIdentKind";
}

inline static constexpr unsigned NumEnumerators(PredefinedExprIdentKind) {
  return 8;
}

const char *EnumeratorName(PredefinedExprIdentKind);

enum class PreferredNameAttrSpelling : unsigned char {
  GNU_PREFERRED_NAME,
  CXX11_CLANG_PREFERRED_NAME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PreferredNameAttrSpelling) {
  return "PreferredNameAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PreferredNameAttrSpelling) {
  return 3;
}

const char *EnumeratorName(PreferredNameAttrSpelling);

enum class PreserveAllAttrSpelling : unsigned char {
  GNU_PRESERVE_ALL,
  CXX11_CLANG_PRESERVE_ALL,
  C2X_CLANG_PRESERVE_ALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PreserveAllAttrSpelling) {
  return "PreserveAllAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PreserveAllAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PreserveAllAttrSpelling);

enum class PreserveMostAttrSpelling : unsigned char {
  GNU_PRESERVE_MOST,
  CXX11_CLANG_PRESERVE_MOST,
  C2X_CLANG_PRESERVE_MOST,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PreserveMostAttrSpelling) {
  return "PreserveMostAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PreserveMostAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PreserveMostAttrSpelling);

enum class PtGuardedVarAttrSpelling : unsigned char {
  GNU_PT_GUARDED_VARIABLE,
  CXX11_CLANG_PT_GUARDED_VARIABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PtGuardedVarAttrSpelling) {
  return "PtGuardedVarAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PtGuardedVarAttrSpelling) {
  return 3;
}

const char *EnumeratorName(PtGuardedVarAttrSpelling);

enum class PureAttrSpelling : unsigned char {
  GNU_PURE,
  CXX11_GNU_PURE,
  C2X_GNU_PURE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(PureAttrSpelling) {
  return "PureAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(PureAttrSpelling) {
  return 4;
}

const char *EnumeratorName(PureAttrSpelling);

enum class QualTypeDestructionKind : unsigned char {
  NONE,
  CXX_DESTRUCTOR,
  OBJC_STRONG_LIFETIME,
  OBJC_WEAK_LIFETIME,
  NONTRIVIAL_C_STRUCT,
};

inline static const char *EnumerationName(QualTypeDestructionKind) {
  return "QualTypeDestructionKind";
}

inline static constexpr unsigned NumEnumerators(QualTypeDestructionKind) {
  return 5;
}

const char *EnumeratorName(QualTypeDestructionKind);

enum class QualTypePrimitiveCopyKind : unsigned char {
  TRIVIAL,
  VOLATILE_TRIVIAL,
  ARC_STRONG,
  ARC_WEAK,
  STRUCT,
};

inline static const char *EnumerationName(QualTypePrimitiveCopyKind) {
  return "QualTypePrimitiveCopyKind";
}

inline static constexpr unsigned NumEnumerators(QualTypePrimitiveCopyKind) {
  return 5;
}

const char *EnumeratorName(QualTypePrimitiveCopyKind);

enum class QualTypePrimitiveDefaultInitializeKind : unsigned char {
  TRIVIAL,
  ARC_STRONG,
  ARC_WEAK,
  STRUCT,
};

inline static const char *EnumerationName(QualTypePrimitiveDefaultInitializeKind) {
  return "QualTypePrimitiveDefaultInitializeKind";
}

inline static constexpr unsigned NumEnumerators(QualTypePrimitiveDefaultInitializeKind) {
  return 4;
}

const char *EnumeratorName(QualTypePrimitiveDefaultInitializeKind);

enum class RISCVInterruptAttrInterruptType : unsigned char {
  USER,
  SUPERVISOR,
  MACHINE,
};

inline static const char *EnumerationName(RISCVInterruptAttrInterruptType) {
  return "RISCVInterruptAttrInterruptType";
}

inline static constexpr unsigned NumEnumerators(RISCVInterruptAttrInterruptType) {
  return 3;
}

const char *EnumeratorName(RISCVInterruptAttrInterruptType);

enum class RISCVInterruptAttrSpelling : unsigned char {
  GNU_INTERRUPT,
  CXX11_GNU_INTERRUPT,
  C2X_GNU_INTERRUPT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(RISCVInterruptAttrSpelling) {
  return "RISCVInterruptAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(RISCVInterruptAttrSpelling) {
  return 4;
}

const char *EnumeratorName(RISCVInterruptAttrSpelling);

enum class RecordDeclArgPassingKind : unsigned char {
  CAN_PASS_IN_REGS,
  CANNOT_PASS_IN_REGS,
  CAN_NEVER_PASS_IN_REGS,
};

inline static const char *EnumerationName(RecordDeclArgPassingKind) {
  return "RecordDeclArgPassingKind";
}

inline static constexpr unsigned NumEnumerators(RecordDeclArgPassingKind) {
  return 3;
}

const char *EnumeratorName(RecordDeclArgPassingKind);

enum class RegCallAttrSpelling : unsigned char {
  GNU_REGCALL,
  CXX11_GNU_REGCALL,
  C2X_GNU_REGCALL,
  KEYWORD_REGCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(RegCallAttrSpelling) {
  return "RegCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(RegCallAttrSpelling) {
  return 5;
}

const char *EnumeratorName(RegCallAttrSpelling);

enum class ReinitializesAttrSpelling : unsigned char {
  GNU_REINITIALIZES,
  CXX11_CLANG_REINITIALIZES,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReinitializesAttrSpelling) {
  return "ReinitializesAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReinitializesAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ReinitializesAttrSpelling);

enum class ReleaseCapabilityAttrSpelling : unsigned char {
  GNU_RELEASE_CAPABILITY,
  CXX11_CLANG_RELEASE_CAPABILITY,
  GNU_RELEASE_SHARED_CAPABILITY,
  CXX11_CLANG_RELEASE_SHARED_CAPABILITY,
  GNU_RELEASE_GENERIC_CAPABILITY,
  CXX11_CLANG_RELEASE_GENERIC_CAPABILITY,
  GNU_UNLOCK_FUNCTION,
  CXX11_CLANG_UNLOCK_FUNCTION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReleaseCapabilityAttrSpelling) {
  return "ReleaseCapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReleaseCapabilityAttrSpelling) {
  return 9;
}

const char *EnumeratorName(ReleaseCapabilityAttrSpelling);

enum class ReleaseHandleAttrSpelling : unsigned char {
  GNU_RELEASE_HANDLE,
  CXX11_CLANG_RELEASE_HANDLE,
  C2X_CLANG_RELEASE_HANDLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReleaseHandleAttrSpelling) {
  return "ReleaseHandleAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReleaseHandleAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ReleaseHandleAttrSpelling);

enum class RequiresCapabilityAttrSpelling : unsigned char {
  GNU_REQUIRES_CAPABILITY,
  CXX11_CLANG_REQUIRES_CAPABILITY,
  GNU_EXCLUSIVE_LOCKS_REQUIRED,
  CXX11_CLANG_EXCLUSIVE_LOCKS_REQUIRED,
  GNU_REQUIRES_SHARED_CAPABILITY,
  CXX11_CLANG_REQUIRES_SHARED_CAPABILITY,
  GNU_SHARED_LOCKS_REQUIRED,
  CXX11_CLANG_SHARED_LOCKS_REQUIRED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(RequiresCapabilityAttrSpelling) {
  return "RequiresCapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(RequiresCapabilityAttrSpelling) {
  return 9;
}

const char *EnumeratorName(RequiresCapabilityAttrSpelling);

enum class RestrictAttrSpelling : unsigned char {
  DECLSPEC_RESTRICT,
  GNU_MALLOC,
  CXX11_GNU_MALLOC,
  C2X_GNU_MALLOC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(RestrictAttrSpelling) {
  return "RestrictAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(RestrictAttrSpelling) {
  return 5;
}

const char *EnumeratorName(RestrictAttrSpelling);

enum class RetainAttrSpelling : unsigned char {
  GNU_RETAIN,
  CXX11_GNU_RETAIN,
  C2X_GNU_RETAIN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(RetainAttrSpelling) {
  return "RetainAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(RetainAttrSpelling) {
  return 4;
}

const char *EnumeratorName(RetainAttrSpelling);

enum class ReturnTypestateAttrConsumedState : unsigned char {
  UNKNOWN,
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(ReturnTypestateAttrConsumedState) {
  return "ReturnTypestateAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(ReturnTypestateAttrConsumedState) {
  return 3;
}

const char *EnumeratorName(ReturnTypestateAttrConsumedState);

enum class ReturnTypestateAttrSpelling : unsigned char {
  GNU_RETURN_TYPESTATE,
  CXX11_CLANG_RETURN_TYPESTATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReturnTypestateAttrSpelling) {
  return "ReturnTypestateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReturnTypestateAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ReturnTypestateAttrSpelling);

enum class ReturnsNonNullAttrSpelling : unsigned char {
  GNU_RETURNS_NONNULL,
  CXX11_GNU_RETURNS_NONNULL,
  C2X_GNU_RETURNS_NONNULL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReturnsNonNullAttrSpelling) {
  return "ReturnsNonNullAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReturnsNonNullAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ReturnsNonNullAttrSpelling);

enum class ReturnsTwiceAttrSpelling : unsigned char {
  GNU_RETURNS_TWICE,
  CXX11_GNU_RETURNS_TWICE,
  C2X_GNU_RETURNS_TWICE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ReturnsTwiceAttrSpelling) {
  return "ReturnsTwiceAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ReturnsTwiceAttrSpelling) {
  return 4;
}

const char *EnumeratorName(ReturnsTwiceAttrSpelling);

enum class SYCLKernelAttrSpelling : unsigned char {
  GNU_SYCL_KERNEL,
  CXX11_CLANG_SYCL_KERNEL,
  C2X_CLANG_SYCL_KERNEL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SYCLKernelAttrSpelling) {
  return "SYCLKernelAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SYCLKernelAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SYCLKernelAttrSpelling);

enum class SYCLSpecialClassAttrSpelling : unsigned char {
  GNU_SYCL_SPECIAL_CLASS,
  CXX11_CLANG_SYCL_SPECIAL_CLASS,
  C2X_CLANG_SYCL_SPECIAL_CLASS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SYCLSpecialClassAttrSpelling) {
  return "SYCLSpecialClassAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SYCLSpecialClassAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SYCLSpecialClassAttrSpelling);

enum class ScopedLockableAttrSpelling : unsigned char {
  GNU_SCOPED_LOCKABLE,
  CXX11_CLANG_SCOPED_LOCKABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ScopedLockableAttrSpelling) {
  return "ScopedLockableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ScopedLockableAttrSpelling) {
  return 3;
}

const char *EnumeratorName(ScopedLockableAttrSpelling);

enum class SectionAttrSpelling : unsigned char {
  GNU_SECTION,
  CXX11_GNU_SECTION,
  C2X_GNU_SECTION,
  DECLSPEC_ALLOCATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SectionAttrSpelling) {
  return "SectionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SectionAttrSpelling) {
  return 5;
}

const char *EnumeratorName(SectionAttrSpelling);

enum class SelectAnyAttrSpelling : unsigned char {
  DECLSPEC_SELECTANY,
  GNU_SELECTANY,
  CXX11_GNU_SELECTANY,
  C2X_GNU_SELECTANY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SelectAnyAttrSpelling) {
  return "SelectAnyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SelectAnyAttrSpelling) {
  return 5;
}

const char *EnumeratorName(SelectAnyAttrSpelling);

enum class SentinelAttrSpelling : unsigned char {
  GNU_SENTINEL,
  CXX11_GNU_SENTINEL,
  C2X_GNU_SENTINEL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SentinelAttrSpelling) {
  return "SentinelAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SentinelAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SentinelAttrSpelling);

enum class SetTypestateAttrConsumedState : unsigned char {
  UNKNOWN,
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(SetTypestateAttrConsumedState) {
  return "SetTypestateAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(SetTypestateAttrConsumedState) {
  return 3;
}

const char *EnumeratorName(SetTypestateAttrConsumedState);

enum class SetTypestateAttrSpelling : unsigned char {
  GNU_TYPESTATE,
  CXX11_CLANG_TYPESTATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SetTypestateAttrSpelling) {
  return "SetTypestateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SetTypestateAttrSpelling) {
  return 3;
}

const char *EnumeratorName(SetTypestateAttrSpelling);

enum class SourceLocExprIdentKind : unsigned char {
  FUNCTION,
  FILE,
  LINE,
  COLUMN,
};

inline static const char *EnumerationName(SourceLocExprIdentKind) {
  return "SourceLocExprIdentKind";
}

inline static constexpr unsigned NumEnumerators(SourceLocExprIdentKind) {
  return 4;
}

const char *EnumeratorName(SourceLocExprIdentKind);

enum class SpeculativeLoadHardeningAttrSpelling : unsigned char {
  GNU_SPECULATIVE_LOAD_HARDENING,
  CXX11_CLANG_SPECULATIVE_LOAD_HARDENING,
  C2X_CLANG_SPECULATIVE_LOAD_HARDENING,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SpeculativeLoadHardeningAttrSpelling) {
  return "SpeculativeLoadHardeningAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SpeculativeLoadHardeningAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SpeculativeLoadHardeningAttrSpelling);

enum class StandaloneDebugAttrSpelling : unsigned char {
  GNU_STANDALONE_DEBUG,
  CXX11_CLANG_STANDALONE_DEBUG,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(StandaloneDebugAttrSpelling) {
  return "StandaloneDebugAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(StandaloneDebugAttrSpelling) {
  return 3;
}

const char *EnumeratorName(StandaloneDebugAttrSpelling);

enum class StdCallAttrSpelling : unsigned char {
  GNU_STDCALL,
  CXX11_GNU_STDCALL,
  C2X_GNU_STDCALL,
  KEYWORD_STDCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(StdCallAttrSpelling) {
  return "StdCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(StdCallAttrSpelling) {
  return 5;
}

const char *EnumeratorName(StdCallAttrSpelling);

enum class StmtLikelihood : unsigned char {
  UNLIKELY,
  NONE,
  LIKELY,
};

inline static const char *EnumerationName(StmtLikelihood) {
  return "StmtLikelihood";
}

inline static constexpr unsigned NumEnumerators(StmtLikelihood) {
  return 3;
}

const char *EnumeratorName(StmtLikelihood);

enum class StmtKind : unsigned char {
  GCC_ASM_STMT,
  MS_ASM_STMT,
  BREAK_STMT,
  CXX_CATCH_STMT,
  CXX_FOR_RANGE_STMT,
  CXX_TRY_STMT,
  CAPTURED_STMT,
  COMPOUND_STMT,
  CONTINUE_STMT,
  CORETURN_STMT,
  COROUTINE_BODY_STMT,
  DECL_STMT,
  DO_STMT,
  FOR_STMT,
  GOTO_STMT,
  IF_STMT,
  INDIRECT_GOTO_STMT,
  MS_DEPENDENT_EXISTS_STMT,
  NULL_STMT,
  OMP_CANONICAL_LOOP,
  OMP_ATOMIC_DIRECTIVE,
  OMP_BARRIER_DIRECTIVE,
  OMP_CANCEL_DIRECTIVE,
  OMP_CANCELLATION_POINT_DIRECTIVE,
  OMP_CRITICAL_DIRECTIVE,
  OMP_DEPOBJ_DIRECTIVE,
  OMP_DISPATCH_DIRECTIVE,
  OMP_FLUSH_DIRECTIVE,
  OMP_INTEROP_DIRECTIVE,
  OMP_DISTRIBUTE_DIRECTIVE,
  OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
  OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
  OMP_DISTRIBUTE_SIMD_DIRECTIVE,
  OMP_FOR_DIRECTIVE,
  OMP_FOR_SIMD_DIRECTIVE,
  OMP_GENERIC_LOOP_DIRECTIVE,
  OMP_MASTER_TASK_LOOP_DIRECTIVE,
  OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE,
  OMP_PARALLEL_FOR_DIRECTIVE,
  OMP_PARALLEL_FOR_SIMD_DIRECTIVE,
  OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE,
  OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE,
  OMP_SIMD_DIRECTIVE,
  OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE,
  OMP_TARGET_SIMD_DIRECTIVE,
  OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE,
  OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
  OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
  OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,
  OMP_TASK_LOOP_DIRECTIVE,
  OMP_TASK_LOOP_SIMD_DIRECTIVE,
  OMP_TEAMS_DISTRIBUTE_DIRECTIVE,
  OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,
  OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,
  OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,
  OMP_TILE_DIRECTIVE,
  OMP_UNROLL_DIRECTIVE,
  OMP_MASKED_DIRECTIVE,
  OMP_MASTER_DIRECTIVE,
  OMP_META_DIRECTIVE,
  OMP_ORDERED_DIRECTIVE,
  OMP_PARALLEL_DIRECTIVE,
  OMP_PARALLEL_MASTER_DIRECTIVE,
  OMP_PARALLEL_SECTIONS_DIRECTIVE,
  OMP_SCAN_DIRECTIVE,
  OMP_SECTION_DIRECTIVE,
  OMP_SECTIONS_DIRECTIVE,
  OMP_SINGLE_DIRECTIVE,
  OMP_TARGET_DATA_DIRECTIVE,
  OMP_TARGET_DIRECTIVE,
  OMP_TARGET_ENTER_DATA_DIRECTIVE,
  OMP_TARGET_EXIT_DATA_DIRECTIVE,
  OMP_TARGET_PARALLEL_DIRECTIVE,
  OMP_TARGET_PARALLEL_FOR_DIRECTIVE,
  OMP_TARGET_TEAMS_DIRECTIVE,
  OMP_TARGET_UPDATE_DIRECTIVE,
  OMP_TASK_DIRECTIVE,
  OMP_TASKGROUP_DIRECTIVE,
  OMP_TASKWAIT_DIRECTIVE,
  OMP_TASKYIELD_DIRECTIVE,
  OMP_TEAMS_DIRECTIVE,
  OBJ_C_AT_CATCH_STMT,
  OBJ_C_AT_FINALLY_STMT,
  OBJ_C_AT_SYNCHRONIZED_STMT,
  OBJ_C_AT_THROW_STMT,
  OBJ_C_AT_TRY_STMT,
  OBJ_C_AUTORELEASE_POOL_STMT,
  OBJ_C_FOR_COLLECTION_STMT,
  RETURN_STMT,
  SEH_EXCEPT_STMT,
  SEH_FINALLY_STMT,
  SEH_LEAVE_STMT,
  SEH_TRY_STMT,
  CASE_STMT,
  DEFAULT_STMT,
  SWITCH_STMT,
  ATTRIBUTED_STMT,
  BINARY_CONDITIONAL_OPERATOR,
  CONDITIONAL_OPERATOR,
  ADDR_LABEL_EXPR,
  ARRAY_INIT_INDEX_EXPR,
  ARRAY_INIT_LOOP_EXPR,
  ARRAY_SUBSCRIPT_EXPR,
  ARRAY_TYPE_TRAIT_EXPR,
  AS_TYPE_EXPR,
  ATOMIC_EXPR,
  BINARY_OPERATOR,
  COMPOUND_ASSIGN_OPERATOR,
  BLOCK_EXPR,
  CXX_BIND_TEMPORARY_EXPR,
  CXX_BOOL_LITERAL_EXPR,
  CXX_CONSTRUCT_EXPR,
  CXX_TEMPORARY_OBJECT_EXPR,
  CXX_DEFAULT_ARG_EXPR,
  CXX_DEFAULT_INIT_EXPR,
  CXX_DELETE_EXPR,
  CXX_DEPENDENT_SCOPE_MEMBER_EXPR,
  CXX_FOLD_EXPR,
  CXX_INHERITED_CTOR_INIT_EXPR,
  CXX_NEW_EXPR,
  CXX_NOEXCEPT_EXPR,
  CXX_NULL_PTR_LITERAL_EXPR,
  CXX_PSEUDO_DESTRUCTOR_EXPR,
  CXX_REWRITTEN_BINARY_OPERATOR,
  CXX_SCALAR_VALUE_INIT_EXPR,
  CXX_STD_INITIALIZER_LIST_EXPR,
  CXX_THIS_EXPR,
  CXX_THROW_EXPR,
  CXX_TYPEID_EXPR,
  CXX_UNRESOLVED_CONSTRUCT_EXPR,
  CXX_UUIDOF_EXPR,
  CALL_EXPR,
  CUDA_KERNEL_CALL_EXPR,
  CXX_MEMBER_CALL_EXPR,
  CXX_OPERATOR_CALL_EXPR,
  USER_DEFINED_LITERAL,
  BUILTIN_BIT_CAST_EXPR,
  C_STYLE_CAST_EXPR,
  CXX_FUNCTIONAL_CAST_EXPR,
  CXX_ADDRSPACE_CAST_EXPR,
  CXX_CONST_CAST_EXPR,
  CXX_DYNAMIC_CAST_EXPR,
  CXX_REINTERPRET_CAST_EXPR,
  CXX_STATIC_CAST_EXPR,
  OBJ_C_BRIDGED_CAST_EXPR,
  IMPLICIT_CAST_EXPR,
  CHARACTER_LITERAL,
  CHOOSE_EXPR,
  COMPOUND_LITERAL_EXPR,
  CONCEPT_SPECIALIZATION_EXPR,
  CONVERT_VECTOR_EXPR,
  COAWAIT_EXPR,
  COYIELD_EXPR,
  DECL_REF_EXPR,
  DEPENDENT_COAWAIT_EXPR,
  DEPENDENT_SCOPE_DECL_REF_EXPR,
  DESIGNATED_INIT_EXPR,
  DESIGNATED_INIT_UPDATE_EXPR,
  EXPRESSION_TRAIT_EXPR,
  EXT_VECTOR_ELEMENT_EXPR,
  FIXED_POINT_LITERAL,
  FLOATING_LITERAL,
  CONSTANT_EXPR,
  EXPR_WITH_CLEANUPS,
  FUNCTION_PARM_PACK_EXPR,
  GNU_NULL_EXPR,
  GENERIC_SELECTION_EXPR,
  IMAGINARY_LITERAL,
  IMPLICIT_VALUE_INIT_EXPR,
  INIT_LIST_EXPR,
  INTEGER_LITERAL,
  LAMBDA_EXPR,
  MS_PROPERTY_REF_EXPR,
  MS_PROPERTY_SUBSCRIPT_EXPR,
  MATERIALIZE_TEMPORARY_EXPR,
  MATRIX_SUBSCRIPT_EXPR,
  MEMBER_EXPR,
  NO_INIT_EXPR,
  OMP_ARRAY_SECTION_EXPR,
  OMP_ARRAY_SHAPING_EXPR,
  OMP_ITERATOR_EXPR,
  OBJ_C_ARRAY_LITERAL,
  OBJ_C_AVAILABILITY_CHECK_EXPR,
  OBJ_C_BOOL_LITERAL_EXPR,
  OBJ_C_BOXED_EXPR,
  OBJ_C_DICTIONARY_LITERAL,
  OBJ_C_ENCODE_EXPR,
  OBJ_C_INDIRECT_COPY_RESTORE_EXPR,
  OBJ_C_ISA_EXPR,
  OBJ_C_IVAR_REF_EXPR,
  OBJ_C_MESSAGE_EXPR,
  OBJ_C_PROPERTY_REF_EXPR,
  OBJ_C_PROTOCOL_EXPR,
  OBJ_C_SELECTOR_EXPR,
  OBJ_C_STRING_LITERAL,
  OBJ_C_SUBSCRIPT_REF_EXPR,
  OFFSET_OF_EXPR,
  OPAQUE_VALUE_EXPR,
  UNRESOLVED_LOOKUP_EXPR,
  UNRESOLVED_MEMBER_EXPR,
  PACK_EXPANSION_EXPR,
  PAREN_EXPR,
  PAREN_LIST_EXPR,
  PREDEFINED_EXPR,
  PSEUDO_OBJECT_EXPR,
  RECOVERY_EXPR,
  REQUIRES_EXPR,
  SYCL_UNIQUE_STABLE_NAME_EXPR,
  SHUFFLE_VECTOR_EXPR,
  SIZE_OF_PACK_EXPR,
  SOURCE_LOC_EXPR,
  STMT_EXPR,
  STRING_LITERAL,
  SUBST_NON_TYPE_TEMPLATE_PARM_EXPR,
  SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR,
  TYPE_TRAIT_EXPR,
  TYPO_EXPR,
  UNARY_EXPR_OR_TYPE_TRAIT_EXPR,
  UNARY_OPERATOR,
  VA_ARG_EXPR,
  LABEL_STMT,
  WHILE_STMT,
};

inline static const char *EnumerationName(StmtKind) {
  return "StmtKind";
}

inline static constexpr unsigned NumEnumerators(StmtKind) {
  return 222;
}

const char *EnumeratorName(StmtKind);

enum class StringLiteralStringKind : unsigned char {
  ASCII,
  WIDE,
  UTF8,
  UTF16,
  UTF32,
};

inline static const char *EnumerationName(StringLiteralStringKind) {
  return "StringLiteralStringKind";
}

inline static constexpr unsigned NumEnumerators(StringLiteralStringKind) {
  return 5;
}

const char *EnumeratorName(StringLiteralStringKind);

enum class SwiftAsyncAttrKind : unsigned char {
  NONE,
  SWIFT_PRIVATE,
  NOT_SWIFT_PRIVATE,
};

inline static const char *EnumerationName(SwiftAsyncAttrKind) {
  return "SwiftAsyncAttrKind";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncAttrKind) {
  return 3;
}

const char *EnumeratorName(SwiftAsyncAttrKind);

enum class SwiftAsyncAttrSpelling : unsigned char {
  GNU_SWIFT_ASYNC,
  CXX11_CLANG_SWIFT_ASYNC,
  C2X_CLANG_SWIFT_ASYNC,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftAsyncAttrSpelling) {
  return "SwiftAsyncAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftAsyncAttrSpelling);

enum class SwiftAsyncCallAttrSpelling : unsigned char {
  GNU_SWIFTASYNCCALL,
  CXX11_CLANG_SWIFTASYNCCALL,
  C2X_CLANG_SWIFTASYNCCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftAsyncCallAttrSpelling) {
  return "SwiftAsyncCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncCallAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftAsyncCallAttrSpelling);

enum class SwiftAsyncContextAttrSpelling : unsigned char {
  GNU_SWIFT_ASYNC_CONTEXT,
  CXX11_CLANG_SWIFT_ASYNC_CONTEXT,
  C2X_CLANG_SWIFT_ASYNC_CONTEXT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftAsyncContextAttrSpelling) {
  return "SwiftAsyncContextAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncContextAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftAsyncContextAttrSpelling);

enum class SwiftAsyncErrorAttrConventionKind : unsigned char {
  NONE,
  NON_NULL_ERROR,
  ZERO_ARGUMENT,
  NON_ZERO_ARGUMENT,
};

inline static const char *EnumerationName(SwiftAsyncErrorAttrConventionKind) {
  return "SwiftAsyncErrorAttrConventionKind";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncErrorAttrConventionKind) {
  return 4;
}

const char *EnumeratorName(SwiftAsyncErrorAttrConventionKind);

enum class SwiftAsyncErrorAttrSpelling : unsigned char {
  GNU_SWIFT_ASYNC_ERROR,
  CXX11_CLANG_SWIFT_ASYNC_ERROR,
  C2X_CLANG_SWIFT_ASYNC_ERROR,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftAsyncErrorAttrSpelling) {
  return "SwiftAsyncErrorAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncErrorAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftAsyncErrorAttrSpelling);

enum class SwiftCallAttrSpelling : unsigned char {
  GNU_SWIFTCALL,
  CXX11_CLANG_SWIFTCALL,
  C2X_CLANG_SWIFTCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftCallAttrSpelling) {
  return "SwiftCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftCallAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftCallAttrSpelling);

enum class SwiftContextAttrSpelling : unsigned char {
  GNU_SWIFT_CONTEXT,
  CXX11_CLANG_SWIFT_CONTEXT,
  C2X_CLANG_SWIFT_CONTEXT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftContextAttrSpelling) {
  return "SwiftContextAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftContextAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftContextAttrSpelling);

enum class SwiftErrorAttrConventionKind : unsigned char {
  NONE,
  NON_NULL_ERROR,
  NULL_RESULT,
  ZERO_RESULT,
  NON_ZERO_RESULT,
};

inline static const char *EnumerationName(SwiftErrorAttrConventionKind) {
  return "SwiftErrorAttrConventionKind";
}

inline static constexpr unsigned NumEnumerators(SwiftErrorAttrConventionKind) {
  return 5;
}

const char *EnumeratorName(SwiftErrorAttrConventionKind);

enum class SwiftErrorResultAttrSpelling : unsigned char {
  GNU_SWIFT_ERROR_RESULT,
  CXX11_CLANG_SWIFT_ERROR_RESULT,
  C2X_CLANG_SWIFT_ERROR_RESULT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftErrorResultAttrSpelling) {
  return "SwiftErrorResultAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftErrorResultAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftErrorResultAttrSpelling);

enum class SwiftIndirectResultAttrSpelling : unsigned char {
  GNU_SWIFT_INDIRECT_RESULT,
  CXX11_CLANG_SWIFT_INDIRECT_RESULT,
  C2X_CLANG_SWIFT_INDIRECT_RESULT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftIndirectResultAttrSpelling) {
  return "SwiftIndirectResultAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftIndirectResultAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SwiftIndirectResultAttrSpelling);

enum class SwiftNewTypeAttrNewtypeKind : unsigned char {
  STRUCT,
  ENUM,
};

inline static const char *EnumerationName(SwiftNewTypeAttrNewtypeKind) {
  return "SwiftNewTypeAttrNewtypeKind";
}

inline static constexpr unsigned NumEnumerators(SwiftNewTypeAttrNewtypeKind) {
  return 2;
}

const char *EnumeratorName(SwiftNewTypeAttrNewtypeKind);

enum class SwiftNewTypeAttrSpelling : unsigned char {
  GNU_SWIFT_NEWTYPE,
  GNU_SWIFT_WRAPPER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SwiftNewTypeAttrSpelling) {
  return "SwiftNewTypeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SwiftNewTypeAttrSpelling) {
  return 3;
}

const char *EnumeratorName(SwiftNewTypeAttrSpelling);

enum class SysVABIAttrSpelling : unsigned char {
  GNU_SYSV_ABI,
  CXX11_GNU_SYSV_ABI,
  C2X_GNU_SYSV_ABI,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(SysVABIAttrSpelling) {
  return "SysVABIAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(SysVABIAttrSpelling) {
  return 4;
}

const char *EnumeratorName(SysVABIAttrSpelling);

enum class TLSModelAttrSpelling : unsigned char {
  GNU_TLS_MODEL,
  CXX11_GNU_TLS_MODEL,
  C2X_GNU_TLS_MODEL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TLSModelAttrSpelling) {
  return "TLSModelAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TLSModelAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TLSModelAttrSpelling);

enum class TargetAttrSpelling : unsigned char {
  GNU_TARGET,
  CXX11_GNU_TARGET,
  C2X_GNU_TARGET,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TargetAttrSpelling) {
  return "TargetAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TargetAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TargetAttrSpelling);

enum class TargetClonesAttrSpelling : unsigned char {
  GNU_TARGET_CLONES,
  CXX11_GNU_TARGET_CLONES,
  C2X_GNU_TARGET_CLONES,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TargetClonesAttrSpelling) {
  return "TargetClonesAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TargetClonesAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TargetClonesAttrSpelling);

enum class TemplateArgumentKind : unsigned char {
  EMPTY,
  TYPE,
  DECLARATION,
  NULL_POINTER,
  INTEGRAL,
  TEMPLATE,
  TEMPLATE_EXPANSION,
  EXPRESSION,
  PACK,
};

inline static const char *EnumerationName(TemplateArgumentKind) {
  return "TemplateArgumentKind";
}

inline static constexpr unsigned NumEnumerators(TemplateArgumentKind) {
  return 9;
}

const char *EnumeratorName(TemplateArgumentKind);

enum class TestTypestateAttrConsumedState : unsigned char {
  CONSUMED,
  UNCONSUMED,
};

inline static const char *EnumerationName(TestTypestateAttrConsumedState) {
  return "TestTypestateAttrConsumedState";
}

inline static constexpr unsigned NumEnumerators(TestTypestateAttrConsumedState) {
  return 2;
}

const char *EnumeratorName(TestTypestateAttrConsumedState);

enum class TestTypestateAttrSpelling : unsigned char {
  GNU_TEST_TYPESTATE,
  CXX11_CLANG_TEST_TYPESTATE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TestTypestateAttrSpelling) {
  return "TestTypestateAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TestTypestateAttrSpelling) {
  return 3;
}

const char *EnumeratorName(TestTypestateAttrSpelling);

enum class ThisCallAttrSpelling : unsigned char {
  GNU_THISCALL,
  CXX11_GNU_THISCALL,
  C2X_GNU_THISCALL,
  KEYWORD_THISCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(ThisCallAttrSpelling) {
  return "ThisCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(ThisCallAttrSpelling) {
  return 5;
}

const char *EnumeratorName(ThisCallAttrSpelling);

enum class TransparentUnionAttrSpelling : unsigned char {
  GNU_TRANSPARENT_UNION,
  CXX11_GNU_TRANSPARENT_UNION,
  C2X_GNU_TRANSPARENT_UNION,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TransparentUnionAttrSpelling) {
  return "TransparentUnionAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TransparentUnionAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TransparentUnionAttrSpelling);

enum class TrivialABIAttrSpelling : unsigned char {
  GNU_TRIVIAL_ABI,
  CXX11_CLANG_TRIVIAL_ABI,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TrivialABIAttrSpelling) {
  return "TrivialABIAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TrivialABIAttrSpelling) {
  return 3;
}

const char *EnumeratorName(TrivialABIAttrSpelling);

enum class TryAcquireCapabilityAttrSpelling : unsigned char {
  GNU_TRY_ACQUIRE_CAPABILITY,
  CXX11_CLANG_TRY_ACQUIRE_CAPABILITY,
  GNU_TRY_ACQUIRE_SHARED_CAPABILITY,
  CXX11_CLANG_TRY_ACQUIRE_SHARED_CAPABILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TryAcquireCapabilityAttrSpelling) {
  return "TryAcquireCapabilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TryAcquireCapabilityAttrSpelling) {
  return 5;
}

const char *EnumeratorName(TryAcquireCapabilityAttrSpelling);

enum class TypeScalarTypeKind : unsigned char {
  C_POINTER,
  BLOCK_POINTER,
  OBJ_C_OBJECT_POINTER,
  MEMBER_POINTER,
  BOOLEAN,
  INTEGRAL,
  FLOATING,
  INTEGRAL_COMPLEX,
  FLOATING_COMPLEX,
  FIXED_POINT,
};

inline static const char *EnumerationName(TypeScalarTypeKind) {
  return "TypeScalarTypeKind";
}

inline static constexpr unsigned NumEnumerators(TypeScalarTypeKind) {
  return 10;
}

const char *EnumeratorName(TypeScalarTypeKind);

enum class TypeKind : unsigned char {
  ADJUSTED,
  DECAYED,
  CONSTANT_ARRAY,
  DEPENDENT_SIZED_ARRAY,
  INCOMPLETE_ARRAY,
  VARIABLE_ARRAY,
  ATOMIC,
  ATTRIBUTED,
  BIT_INT,
  BLOCK_POINTER,
  BUILTIN,
  COMPLEX,
  DECLTYPE,
  AUTO,
  DEDUCED_TEMPLATE_SPECIALIZATION,
  DEPENDENT_ADDRESS_SPACE,
  DEPENDENT_BIT_INT,
  DEPENDENT_NAME,
  DEPENDENT_SIZED_EXT_VECTOR,
  DEPENDENT_TEMPLATE_SPECIALIZATION,
  DEPENDENT_VECTOR,
  ELABORATED,
  FUNCTION_NO_PROTO,
  FUNCTION_PROTO,
  INJECTED_CLASS_NAME,
  MACRO_QUALIFIED,
  CONSTANT_MATRIX,
  DEPENDENT_SIZED_MATRIX,
  MEMBER_POINTER,
  OBJ_C_OBJECT_POINTER,
  OBJ_C_OBJECT,
  OBJ_C_INTERFACE,
  OBJ_C_TYPE_PARAM,
  PACK_EXPANSION,
  PAREN,
  PIPE,
  POINTER,
  L_VALUE_REFERENCE,
  R_VALUE_REFERENCE,
  SUBST_TEMPLATE_TYPE_PARM_PACK,
  SUBST_TEMPLATE_TYPE_PARM,
  ENUM,
  RECORD,
  TEMPLATE_SPECIALIZATION,
  TEMPLATE_TYPE_PARM,
  TYPE_OF_EXPR,
  TYPE_OF,
  TYPEDEF,
  UNARY_TRANSFORM,
  UNRESOLVED_USING,
  USING,
  VECTOR,
  EXT_VECTOR,
};

inline static const char *EnumerationName(TypeKind) {
  return "TypeKind";
}

inline static constexpr unsigned NumEnumerators(TypeKind) {
  return 53;
}

const char *EnumeratorName(TypeKind);

enum class TypeTagForDatatypeAttrSpelling : unsigned char {
  GNU_TYPE_TAG_FOR_DATATYPE,
  CXX11_CLANG_TYPE_TAG_FOR_DATATYPE,
  C2X_CLANG_TYPE_TAG_FOR_DATATYPE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TypeTagForDatatypeAttrSpelling) {
  return "TypeTagForDatatypeAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TypeTagForDatatypeAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TypeTagForDatatypeAttrSpelling);

enum class TypeVisibilityAttrSpelling : unsigned char {
  GNU_TYPE_VISIBILITY,
  CXX11_CLANG_TYPE_VISIBILITY,
  C2X_CLANG_TYPE_VISIBILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(TypeVisibilityAttrSpelling) {
  return "TypeVisibilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(TypeVisibilityAttrSpelling) {
  return 4;
}

const char *EnumeratorName(TypeVisibilityAttrSpelling);

enum class TypeVisibilityAttrVisibilityType : unsigned char {
  DEFAULT,
  HIDDEN,
  PROTECTED,
};

inline static const char *EnumerationName(TypeVisibilityAttrVisibilityType) {
  return "TypeVisibilityAttrVisibilityType";
}

inline static constexpr unsigned NumEnumerators(TypeVisibilityAttrVisibilityType) {
  return 3;
}

const char *EnumeratorName(TypeVisibilityAttrVisibilityType);

enum class UnaryTransformTypeUTTKind : unsigned char {
  ENUM_UNDERLYING_TYPE,
};

inline static const char *EnumerationName(UnaryTransformTypeUTTKind) {
  return "UnaryTransformTypeUTTKind";
}

inline static constexpr unsigned NumEnumerators(UnaryTransformTypeUTTKind) {
  return 1;
}

const char *EnumeratorName(UnaryTransformTypeUTTKind);

enum class UnavailableAttrImplicitReason : unsigned char {
  NONE,
  ARC_FORBIDDEN_TYPE,
  FORBIDDEN_WEAK,
  ARC_FORBIDDEN_CONVERSION,
  ARC_INIT_RETURNS_UNRELATED,
  ARC_FIELD_WITH_OWNERSHIP,
};

inline static const char *EnumerationName(UnavailableAttrImplicitReason) {
  return "UnavailableAttrImplicitReason";
}

inline static constexpr unsigned NumEnumerators(UnavailableAttrImplicitReason) {
  return 6;
}

const char *EnumeratorName(UnavailableAttrImplicitReason);

enum class UnavailableAttrSpelling : unsigned char {
  GNU_UNAVAILABLE,
  CXX11_CLANG_UNAVAILABLE,
  C2X_CLANG_UNAVAILABLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UnavailableAttrSpelling) {
  return "UnavailableAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UnavailableAttrSpelling) {
  return 4;
}

const char *EnumeratorName(UnavailableAttrSpelling);

enum class UninitializedAttrSpelling : unsigned char {
  GNU_UNINITIALIZED,
  CXX11_CLANG_UNINITIALIZED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UninitializedAttrSpelling) {
  return "UninitializedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UninitializedAttrSpelling) {
  return 3;
}

const char *EnumeratorName(UninitializedAttrSpelling);

enum class UnlikelyAttrSpelling : unsigned char {
  CXX11_UNLIKELY,
  C2X_CLANG_UNLIKELY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UnlikelyAttrSpelling) {
  return "UnlikelyAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UnlikelyAttrSpelling) {
  return 3;
}

const char *EnumeratorName(UnlikelyAttrSpelling);

enum class UnusedAttrSpelling : unsigned char {
  CXX11_MAYBE_UNUSED,
  GNU_UNUSED,
  CXX11_GNU_UNUSED,
  C2X_GNU_UNUSED,
  C2X_MAYBE_UNUSED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UnusedAttrSpelling) {
  return "UnusedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UnusedAttrSpelling) {
  return 6;
}

const char *EnumeratorName(UnusedAttrSpelling);

enum class UseHandleAttrSpelling : unsigned char {
  GNU_USE_HANDLE,
  CXX11_CLANG_USE_HANDLE,
  C2X_CLANG_USE_HANDLE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UseHandleAttrSpelling) {
  return "UseHandleAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UseHandleAttrSpelling) {
  return 4;
}

const char *EnumeratorName(UseHandleAttrSpelling);

enum class UsedAttrSpelling : unsigned char {
  GNU_USED,
  CXX11_GNU_USED,
  C2X_GNU_USED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UsedAttrSpelling) {
  return "UsedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UsedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(UsedAttrSpelling);

enum class UserDefinedLiteralLiteralOperatorKind : unsigned char {
  RAW,
  TEMPLATE,
  INTEGER,
  FLOATING,
  STRING,
  CHARACTER,
};

inline static const char *EnumerationName(UserDefinedLiteralLiteralOperatorKind) {
  return "UserDefinedLiteralLiteralOperatorKind";
}

inline static constexpr unsigned NumEnumerators(UserDefinedLiteralLiteralOperatorKind) {
  return 6;
}

const char *EnumeratorName(UserDefinedLiteralLiteralOperatorKind);

enum class UsingIfExistsAttrSpelling : unsigned char {
  GNU_USING_IF_EXISTS,
  CXX11_CLANG_USING_IF_EXISTS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UsingIfExistsAttrSpelling) {
  return "UsingIfExistsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UsingIfExistsAttrSpelling) {
  return 3;
}

const char *EnumeratorName(UsingIfExistsAttrSpelling);

enum class UuidAttrSpelling : unsigned char {
  DECLSPEC_UUID,
  MICROSOFT_UUID,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(UuidAttrSpelling) {
  return "UuidAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(UuidAttrSpelling) {
  return 3;
}

const char *EnumeratorName(UuidAttrSpelling);

enum class VarDeclDefinitionKind : unsigned char {
  DECLARATION_ONLY,
  TENTATIVE_DEFINITION,
  DEFINITION,
};

inline static const char *EnumerationName(VarDeclDefinitionKind) {
  return "VarDeclDefinitionKind";
}

inline static constexpr unsigned NumEnumerators(VarDeclDefinitionKind) {
  return 3;
}

const char *EnumeratorName(VarDeclDefinitionKind);

enum class VarDeclInitializationStyle : unsigned char {
  C_INIT,
  CALL_INITIALIZER,
  LIST_INITIALIZER,
};

inline static const char *EnumerationName(VarDeclInitializationStyle) {
  return "VarDeclInitializationStyle";
}

inline static constexpr unsigned NumEnumerators(VarDeclInitializationStyle) {
  return 3;
}

const char *EnumeratorName(VarDeclInitializationStyle);

enum class VarDeclTLSKind : unsigned char {
  NONE,
  STATIC,
  DYNAMIC,
};

inline static const char *EnumerationName(VarDeclTLSKind) {
  return "VarDeclTLSKind";
}

inline static constexpr unsigned NumEnumerators(VarDeclTLSKind) {
  return 3;
}

const char *EnumeratorName(VarDeclTLSKind);

enum class VecReturnAttrSpelling : unsigned char {
  GNU_VECRETURN,
  CXX11_CLANG_VECRETURN,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(VecReturnAttrSpelling) {
  return "VecReturnAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(VecReturnAttrSpelling) {
  return 3;
}

const char *EnumeratorName(VecReturnAttrSpelling);

enum class VectorCallAttrSpelling : unsigned char {
  GNU_VECTORCALL,
  CXX11_CLANG_VECTORCALL,
  C2X_CLANG_VECTORCALL,
  KEYWORD_VECTORCALL,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(VectorCallAttrSpelling) {
  return "VectorCallAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(VectorCallAttrSpelling) {
  return 5;
}

const char *EnumeratorName(VectorCallAttrSpelling);

enum class VectorTypeVectorKind : unsigned char {
  GENERIC_VECTOR,
  ALTI_VEC_VECTOR,
  ALTI_VEC_PIXEL,
  ALTI_VEC_BOOLEAN,
  NEON_VECTOR,
  NEON_POLY_VECTOR,
  SVE_FIXED_LENGTH_DATA_VECTOR,
  SVE_FIXED_LENGTH_PREDICATE_VECTOR,
};

inline static const char *EnumerationName(VectorTypeVectorKind) {
  return "VectorTypeVectorKind";
}

inline static constexpr unsigned NumEnumerators(VectorTypeVectorKind) {
  return 8;
}

const char *EnumeratorName(VectorTypeVectorKind);

enum class VisibilityAttrSpelling : unsigned char {
  GNU_VISIBILITY,
  CXX11_GNU_VISIBILITY,
  C2X_GNU_VISIBILITY,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(VisibilityAttrSpelling) {
  return "VisibilityAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(VisibilityAttrSpelling) {
  return 4;
}

const char *EnumeratorName(VisibilityAttrSpelling);

enum class VisibilityAttrVisibilityType : unsigned char {
  DEFAULT,
  HIDDEN,
  PROTECTED,
};

inline static const char *EnumerationName(VisibilityAttrVisibilityType) {
  return "VisibilityAttrVisibilityType";
}

inline static constexpr unsigned NumEnumerators(VisibilityAttrVisibilityType) {
  return 3;
}

const char *EnumeratorName(VisibilityAttrVisibilityType);

enum class WarnUnusedAttrSpelling : unsigned char {
  GNU_WARN_UNUSED,
  CXX11_GNU_WARN_UNUSED,
  C2X_GNU_WARN_UNUSED,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WarnUnusedAttrSpelling) {
  return "WarnUnusedAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WarnUnusedAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WarnUnusedAttrSpelling);

enum class WarnUnusedResultAttrSpelling : unsigned char {
  CXX11_NODISCARD,
  C2X_NODISCARD,
  CXX11_CLANG_WARN_UNUSED_RESULT,
  GNU_WARN_UNUSED_RESULT,
  CXX11_GNU_WARN_UNUSED_RESULT,
  C2X_GNU_WARN_UNUSED_RESULT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WarnUnusedResultAttrSpelling) {
  return "WarnUnusedResultAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WarnUnusedResultAttrSpelling) {
  return 7;
}

const char *EnumeratorName(WarnUnusedResultAttrSpelling);

enum class WeakAttrSpelling : unsigned char {
  GNU_WEAK,
  CXX11_GNU_WEAK,
  C2X_GNU_WEAK,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WeakAttrSpelling) {
  return "WeakAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WeakAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WeakAttrSpelling);

enum class WeakImportAttrSpelling : unsigned char {
  GNU_WEAK_IMPORT,
  CXX11_CLANG_WEAK_IMPORT,
  C2X_CLANG_WEAK_IMPORT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WeakImportAttrSpelling) {
  return "WeakImportAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WeakImportAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WeakImportAttrSpelling);

enum class WeakRefAttrSpelling : unsigned char {
  GNU_WEAKREF,
  CXX11_GNU_WEAKREF,
  C2X_GNU_WEAKREF,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WeakRefAttrSpelling) {
  return "WeakRefAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WeakRefAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WeakRefAttrSpelling);

enum class WebAssemblyExportNameAttrSpelling : unsigned char {
  GNU_EXPORT_NAME,
  CXX11_CLANG_EXPORT_NAME,
  C2X_CLANG_EXPORT_NAME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WebAssemblyExportNameAttrSpelling) {
  return "WebAssemblyExportNameAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WebAssemblyExportNameAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WebAssemblyExportNameAttrSpelling);

enum class WebAssemblyImportModuleAttrSpelling : unsigned char {
  GNU_IMPORT_MODULE,
  CXX11_CLANG_IMPORT_MODULE,
  C2X_CLANG_IMPORT_MODULE,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WebAssemblyImportModuleAttrSpelling) {
  return "WebAssemblyImportModuleAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WebAssemblyImportModuleAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WebAssemblyImportModuleAttrSpelling);

enum class WebAssemblyImportNameAttrSpelling : unsigned char {
  GNU_IMPORT_NAME,
  CXX11_CLANG_IMPORT_NAME,
  C2X_CLANG_IMPORT_NAME,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(WebAssemblyImportNameAttrSpelling) {
  return "WebAssemblyImportNameAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(WebAssemblyImportNameAttrSpelling) {
  return 4;
}

const char *EnumeratorName(WebAssemblyImportNameAttrSpelling);

enum class X86ForceAlignArgPointerAttrSpelling : unsigned char {
  GNU_FORCE_ALIGN_ARGUMENT_POINTER,
  CXX11_GNU_FORCE_ALIGN_ARGUMENT_POINTER,
  C2X_GNU_FORCE_ALIGN_ARGUMENT_POINTER,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(X86ForceAlignArgPointerAttrSpelling) {
  return "X86ForceAlignArgPointerAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(X86ForceAlignArgPointerAttrSpelling) {
  return 4;
}

const char *EnumeratorName(X86ForceAlignArgPointerAttrSpelling);

enum class XRayInstrumentAttrSpelling : unsigned char {
  GNU_XRAY_ALWAYS_INSTRUMENT,
  CXX11_CLANG_XRAY_ALWAYS_INSTRUMENT,
  C2X_CLANG_XRAY_ALWAYS_INSTRUMENT,
  GNU_XRAY_NEVER_INSTRUMENT,
  CXX11_CLANG_XRAY_NEVER_INSTRUMENT,
  C2X_CLANG_XRAY_NEVER_INSTRUMENT,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(XRayInstrumentAttrSpelling) {
  return "XRayInstrumentAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(XRayInstrumentAttrSpelling) {
  return 7;
}

const char *EnumeratorName(XRayInstrumentAttrSpelling);

enum class XRayLogArgsAttrSpelling : unsigned char {
  GNU_XRAY_LOG_ARGUMENTS,
  CXX11_CLANG_XRAY_LOG_ARGUMENTS,
  C2X_CLANG_XRAY_LOG_ARGUMENTS,
  SPELLING_NOT_CALCULATED,
};

inline static const char *EnumerationName(XRayLogArgsAttrSpelling) {
  return "XRayLogArgsAttrSpelling";
}

inline static constexpr unsigned NumEnumerators(XRayLogArgsAttrSpelling) {
  return 4;
}

const char *EnumeratorName(XRayLogArgsAttrSpelling);

enum class ASTDumpOutputFormat : unsigned char {
  DEFAULT,
  JSON,
};

inline static const char *EnumerationName(ASTDumpOutputFormat) {
  return "ASTDumpOutputFormat";
}

inline static constexpr unsigned NumEnumerators(ASTDumpOutputFormat) {
  return 2;
}

const char *EnumeratorName(ASTDumpOutputFormat);

enum class AccessSpecifier : unsigned char {
  PUBLIC,
  PROTECTED,
  PRIVATE,
  NONE,
};

inline static const char *EnumerationName(AccessSpecifier) {
  return "AccessSpecifier";
}

inline static constexpr unsigned NumEnumerators(AccessSpecifier) {
  return 4;
}

const char *EnumeratorName(AccessSpecifier);

enum class AddrSpaceMapMangling : unsigned char {
  TARGET,
  ON,
  OFF,
};

inline static const char *EnumerationName(AddrSpaceMapMangling) {
  return "AddrSpaceMapMangling";
}

inline static constexpr unsigned NumEnumerators(AddrSpaceMapMangling) {
  return 3;
}

const char *EnumeratorName(AddrSpaceMapMangling);

enum class AlignRequirementKind : unsigned char {
  NONE,
  REQUIRED_BY_TYPEDEF,
  REQUIRED_BY_RECORD,
  REQUIRED_BY_ENUM,
};

inline static const char *EnumerationName(AlignRequirementKind) {
  return "AlignRequirementKind";
}

inline static constexpr unsigned NumEnumerators(AlignRequirementKind) {
  return 4;
}

const char *EnumeratorName(AlignRequirementKind);

enum class AltivecSrcCompatKind : unsigned char {
  MIXED,
  GCC,
  XL,
  // Skipped repeat pasta::kDefault
};

inline static const char *EnumerationName(AltivecSrcCompatKind) {
  return "AltivecSrcCompatKind";
}

inline static constexpr unsigned NumEnumerators(AltivecSrcCompatKind) {
  return 3;
}

const char *EnumeratorName(AltivecSrcCompatKind);

enum class ArgumentKind : unsigned char {
  STD_STRING,
  C_STRING,
  SINT,
  UINT,
  TOKENKIND,
  IDENTIFIERINFO,
  ADDRSPACE,
  QUALIFIED,
  QUALTYPE,
  DECLARATIONNAME,
  NAMEDDECL,
  NESTEDNAMESPEC,
  DECLCONTEXT,
  QUALTYPE_PAIR,
  ATTRIBUTE,
};

inline static const char *EnumerationName(ArgumentKind) {
  return "ArgumentKind";
}

inline static constexpr unsigned NumEnumerators(ArgumentKind) {
  return 15;
}

const char *EnumeratorName(ArgumentKind);

enum class ArrayTypeTrait : unsigned char {
  ARRAY_RANK,
  ARRAY_EXTENT,
};

inline static const char *EnumerationName(ArrayTypeTrait) {
  return "ArrayTypeTrait";
}

inline static constexpr unsigned NumEnumerators(ArrayTypeTrait) {
  return 2;
}

const char *EnumeratorName(ArrayTypeTrait);

enum class AtomicScopeModelKind : unsigned char {
  NONE,
  OPEN_CL,
  HIP,
};

inline static const char *EnumerationName(AtomicScopeModelKind) {
  return "AtomicScopeModelKind";
}

inline static constexpr unsigned NumEnumerators(AtomicScopeModelKind) {
  return 3;
}

const char *EnumeratorName(AtomicScopeModelKind);

enum class AutoTypeKeyword : unsigned char {
  AUTO,
  DECLTYPE_AUTO,
  GNU_AUTO_TYPE,
};

inline static const char *EnumerationName(AutoTypeKeyword) {
  return "AutoTypeKeyword";
}

inline static constexpr unsigned NumEnumerators(AutoTypeKeyword) {
  return 3;
}

const char *EnumeratorName(AutoTypeKeyword);

enum class AvailabilityResult : unsigned char {
  AVAILABLE,
  NOT_YET_INTRODUCED,
  DEPRECATED,
  UNAVAILABLE,
};

inline static const char *EnumerationName(AvailabilityResult) {
  return "AvailabilityResult";
}

inline static constexpr unsigned NumEnumerators(AvailabilityResult) {
  return 4;
}

const char *EnumeratorName(AvailabilityResult);

enum class BinaryOperatorKind : unsigned char {
  POINTER_MEMORY_D,
  POINTER_MEMORY_I,
  MUL,
  DIV,
  REM,
  ADD,
  SUB,
  SHL,
  SHR,
  CMP,
  LT,
  GT,
  LE,
  GE,
  EQ,
  NE,
  AND,
  XOR,
  OR,
  L_AND,
  L_OR,
  ASSIGN,
  MUL_ASSIGN,
  DIV_ASSIGN,
  REM_ASSIGN,
  ADD_ASSIGN,
  SUB_ASSIGN,
  SHL_ASSIGN,
  SHR_ASSIGN,
  AND_ASSIGN,
  XOR_ASSIGN,
  OR_ASSIGN,
  COMMA,
};

inline static const char *EnumerationName(BinaryOperatorKind) {
  return "BinaryOperatorKind";
}

inline static constexpr unsigned NumEnumerators(BinaryOperatorKind) {
  return 33;
}

const char *EnumeratorName(BinaryOperatorKind);

enum class Bits : unsigned char {
  NONE,
  UNEXPANDED_PACK,
  INSTANTIATION,
  TYPE,
  VALUE,
  DEPENDENT,
  ERROR,
  VARIABLY_MODIFIED,
  SYNTACTIC,
};

inline static const char *EnumerationName(Bits) {
  return "Bits";
}

inline static constexpr unsigned NumEnumerators(Bits) {
  return 9;
}

const char *EnumeratorName(Bits);

enum class CallingConv : unsigned char {
  C,
  X86_STD_CALL,
  X86_FAST_CALL,
  X86_THIS_CALL,
  X86_VECTOR_CALL,
  X86_PASCAL,
  WIN64,
  X8664_SYS_V,
  X86_REG_CALL,
  AAPCS,
  AAPCSVFP,
  INTEL_OCL_BICC,
  SPIR_FUNCTION,
  OPEN_CL_KERNEL,
  SWIFT,
  SWIFT_ASYNC,
  PRESERVE_MOST,
  PRESERVE_ALL,
  A_ARCH64_VECTOR_CALL,
};

inline static const char *EnumerationName(CallingConv) {
  return "CallingConv";
}

inline static constexpr unsigned NumEnumerators(CallingConv) {
  return 19;
}

const char *EnumeratorName(CallingConv);

enum class CanThrowResult : unsigned char {
  CANNOT,
  DEPENDENT,
  CAN,
};

inline static const char *EnumerationName(CanThrowResult) {
  return "CanThrowResult";
}

inline static constexpr unsigned NumEnumerators(CanThrowResult) {
  return 3;
}

const char *EnumeratorName(CanThrowResult);

enum class CapturedRegionKind : unsigned char {
  DEFAULT,
  OBJ_C_AT_FINALLY,
  OPEN_MP,
};

inline static const char *EnumerationName(CapturedRegionKind) {
  return "CapturedRegionKind";
}

inline static constexpr unsigned NumEnumerators(CapturedRegionKind) {
  return 3;
}

const char *EnumeratorName(CapturedRegionKind);

enum class CastKind : unsigned char {
  DEPENDENT,
  BIT_CAST,
  L_VALUE_BIT_CAST,
  L_VALUE_TO_R_VALUE_BIT_CAST,
  L_VALUE_TO_R_VALUE,
  NO_OPERATION,
  BASE_TO_DERIVED,
  DERIVED_TO_BASE,
  UNCHECKED_DERIVED_TO_BASE,
  DYNAMIC,
  TO_UNION,
  ARRAY_TO_POINTER_DECAY,
  FUNCTION_TO_POINTER_DECAY,
  NULL_TO_POINTER,
  NULL_TO_MEMBER_POINTER,
  BASE_TO_DERIVED_MEMBER_POINTER,
  DERIVED_TO_BASE_MEMBER_POINTER,
  MEMBER_POINTER_TO_BOOLEAN,
  REINTERPRET_MEMBER_POINTER,
  USER_DEFINED_CONVERSION,
  CONSTRUCTOR_CONVERSION,
  INTEGRAL_TO_POINTER,
  POINTER_TO_INTEGRAL,
  POINTER_TO_BOOLEAN,
  TO_VOID,
  MATRIX_CAST,
  VECTOR_SPLAT,
  INTEGRAL_CAST,
  INTEGRAL_TO_BOOLEAN,
  INTEGRAL_TO_FLOATING,
  FLOATING_TO_FIXED_POINT,
  FIXED_POINT_TO_FLOATING,
  FIXED_POINT_CAST,
  FIXED_POINT_TO_INTEGRAL,
  INTEGRAL_TO_FIXED_POINT,
  FIXED_POINT_TO_BOOLEAN,
  FLOATING_TO_INTEGRAL,
  FLOATING_TO_BOOLEAN,
  BOOLEAN_TO_SIGNED_INTEGRAL,
  FLOATING_CAST,
  C_POINTER_TO_OBJ_C_POINTER_CAST,
  BLOCK_POINTER_TO_OBJ_C_POINTER_CAST,
  ANY_POINTER_TO_BLOCK_POINTER_CAST,
  OBJ_C_OBJECT_L_VALUE_CAST,
  FLOATING_REAL_TO_COMPLEX,
  FLOATING_COMPLEX_TO_REAL,
  FLOATING_COMPLEX_TO_BOOLEAN,
  FLOATING_COMPLEX_CAST,
  FLOATING_COMPLEX_TO_INTEGRAL_COMPLEX,
  INTEGRAL_REAL_TO_COMPLEX,
  INTEGRAL_COMPLEX_TO_REAL,
  INTEGRAL_COMPLEX_TO_BOOLEAN,
  INTEGRAL_COMPLEX_CAST,
  INTEGRAL_COMPLEX_TO_FLOATING_COMPLEX,
  ARC_PRODUCE_OBJECT,
  ARC_CONSUME_OBJECT,
  ARC_RECLAIM_RETURNED_OBJECT,
  ARC_EXTEND_BLOCK_OBJECT,
  ATOMIC_TO_NON_ATOMIC,
  NON_ATOMIC_TO_ATOMIC,
  COPY_AND_AUTORELEASE_BLOCK_OBJECT,
  BUILTIN_FN_TO_FN_POINTER,
  ZERO_TO_OCL_OPAQUE_TYPE,
  ADDRESS_SPACE_CONVERSION,
  INT_TO_OCL_SAMPLER,
};

inline static const char *EnumerationName(CastKind) {
  return "CastKind";
}

inline static constexpr unsigned NumEnumerators(CastKind) {
  return 65;
}

const char *EnumeratorName(CastKind);

enum class ClangABI : unsigned char {
  VER38,
  VER4,
  VER6,
  VER7,
  VER9,
  VER11,
  VER12,
  LATEST,
};

inline static const char *EnumerationName(ClangABI) {
  return "ClangABI";
}

inline static constexpr unsigned NumEnumerators(ClangABI) {
  return 8;
}

const char *EnumeratorName(ClangABI);

enum class CommentKind : unsigned char {
  INVALID,
  ORDINARY_BCPL,
  ORDINARY_C,
  BCPL_SLASH,
  BCPL_EXCL,
  JAVA_DOC,
  QT,
  MERGED,
};

inline static const char *EnumerationName(CommentKind) {
  return "CommentKind";
}

inline static constexpr unsigned NumEnumerators(CommentKind) {
  return 8;
}

const char *EnumeratorName(CommentKind);

enum class ComparisonCategoryResult : unsigned char {
  EQUAL,
  EQUIVALENT,
  LESS,
  GREATER,
  UNORDERED,
};

inline static const char *EnumerationName(ComparisonCategoryResult) {
  return "ComparisonCategoryResult";
}

inline static constexpr unsigned NumEnumerators(ComparisonCategoryResult) {
  return 5;
}

const char *EnumeratorName(ComparisonCategoryResult);

enum class ComparisonCategoryType : unsigned char {
  PARTIAL_ORDERING,
  WEAK_ORDERING,
  STRONG_ORDERING,
};

inline static const char *EnumerationName(ComparisonCategoryType) {
  return "ComparisonCategoryType";
}

inline static constexpr unsigned NumEnumerators(ComparisonCategoryType) {
  return 3;
}

const char *EnumeratorName(ComparisonCategoryType);

enum class CompilingModuleKind : unsigned char {
  NONE,
  MODULE_MAP,
  HEADER_MODULE,
  MODULE_INTERFACE,
};

inline static const char *EnumerationName(CompilingModuleKind) {
  return "CompilingModuleKind";
}

inline static constexpr unsigned NumEnumerators(CompilingModuleKind) {
  return 4;
}

const char *EnumeratorName(CompilingModuleKind);

enum class ConstexprSpecKind : unsigned char {
  UNSPECIFIED,
  CONSTEXPR,
  CONSTEVAL,
  CONSTINIT,
};

inline static const char *EnumerationName(ConstexprSpecKind) {
  return "ConstexprSpecKind";
}

inline static constexpr unsigned NumEnumerators(ConstexprSpecKind) {
  return 4;
}

const char *EnumeratorName(ConstexprSpecKind);

enum class CoreFoundationABI : unsigned char {
  UNSPECIFIED,
  STANDALONE,
  OBJECTIVE_C,
  SWIFT,
  SWIFT50,
  SWIFT42,
  SWIFT41,
};

inline static const char *EnumerationName(CoreFoundationABI) {
  return "CoreFoundationABI";
}

inline static constexpr unsigned NumEnumerators(CoreFoundationABI) {
  return 7;
}

const char *EnumeratorName(CoreFoundationABI);

enum class DataPositionTy : unsigned char {
  POSX,
  POSV,
  POSE,
  POS_UPDATE_EXPRESSION,
};

inline static const char *EnumerationName(DataPositionTy) {
  return "DataPositionTy";
}

inline static constexpr unsigned NumEnumerators(DataPositionTy) {
  return 4;
}

const char *EnumeratorName(DataPositionTy);

enum class DefaultArgKind : unsigned char {
  NONE,
  UNPARSED,
  UNINSTANTIATED,
  NORMAL,
};

inline static const char *EnumerationName(DefaultArgKind) {
  return "DefaultArgKind";
}

inline static constexpr unsigned NumEnumerators(DefaultArgKind) {
  return 4;
}

const char *EnumeratorName(DefaultArgKind);

enum class DefaultCallingConvention : unsigned char {
  NONE,
  C_DECL,
  FAST_CALL,
  STD_CALL,
  VECTOR_CALL,
  REG_CALL,
};

inline static const char *EnumerationName(DefaultCallingConvention) {
  return "DefaultCallingConvention";
}

inline static constexpr unsigned NumEnumerators(DefaultCallingConvention) {
  return 6;
}

const char *EnumeratorName(DefaultCallingConvention);

enum class DiagnosticLevelMask : unsigned char {
  NONE,
  NOTE,
  REMARK,
  WARNING,
  ERROR,
  ALL,
};

inline static const char *EnumerationName(DiagnosticLevelMask) {
  return "DiagnosticLevelMask";
}

inline static constexpr unsigned NumEnumerators(DiagnosticLevelMask) {
  return 6;
}

const char *EnumeratorName(DiagnosticLevelMask);

enum class ElaboratedTypeKeyword : unsigned char {
  STRUCT,
  INTERFACE,
  UNION,
  CLASS,
  ENUM,
  TYPENAME,
  NONE,
};

inline static const char *EnumerationName(ElaboratedTypeKeyword) {
  return "ElaboratedTypeKeyword";
}

inline static constexpr unsigned NumEnumerators(ElaboratedTypeKeyword) {
  return 7;
}

const char *EnumeratorName(ElaboratedTypeKeyword);

enum class EmbedBitcodeKind : unsigned char {
  EMBED_OFF,
  EMBED_ALL,
  EMBED_BITCODE,
  EMBED_MARKER,
};

inline static const char *EnumerationName(EmbedBitcodeKind) {
  return "EmbedBitcodeKind";
}

inline static constexpr unsigned NumEnumerators(EmbedBitcodeKind) {
  return 4;
}

const char *EnumeratorName(EmbedBitcodeKind);

enum class ExceptionHandlingKind : unsigned char {
  NONE,
  SJ_LJ,
  WIN_EH,
  DWARF_CFI,
  WASM,
};

inline static const char *EnumerationName(ExceptionHandlingKind) {
  return "ExceptionHandlingKind";
}

inline static constexpr unsigned NumEnumerators(ExceptionHandlingKind) {
  return 5;
}

const char *EnumeratorName(ExceptionHandlingKind);

enum class ExceptionSpecificationType : unsigned char {
  NONE,
  DYNAMIC_NONE,
  DYNAMIC,
  MS_ANY,
  NO_THROW,
  BASIC_NOEXCEPT,
  DEPENDENT_NOEXCEPT,
  NOEXCEPT_FALSE,
  NOEXCEPT_TRUE,
  UNEVALUATED,
  UNINSTANTIATED,
  UNPARSED,
};

inline static const char *EnumerationName(ExceptionSpecificationType) {
  return "ExceptionSpecificationType";
}

inline static constexpr unsigned NumEnumerators(ExceptionSpecificationType) {
  return 12;
}

const char *EnumeratorName(ExceptionSpecificationType);

enum class ExplicitSpecKind : unsigned char {
  RESOLVED_FALSE,
  RESOLVED_TRUE,
  UNRESOLVED,
};

inline static const char *EnumerationName(ExplicitSpecKind) {
  return "ExplicitSpecKind";
}

inline static constexpr unsigned NumEnumerators(ExplicitSpecKind) {
  return 3;
}

const char *EnumeratorName(ExplicitSpecKind);

enum class ExprDependence : unsigned char {
  UNEXPANDED_PACK,
  INSTANTIATION,
  TYPE,
  VALUE,
  ERROR,
  NONE,
  ALL,
  TYPE_VALUE,
  TYPE_INSTANTIATION,
  VALUE_INSTANTIATION,
  TYPE_VALUE_INSTANTIATION,
  ERROR_DEPENDENT,
};

inline static const char *EnumerationName(ExprDependence) {
  return "ExprDependence";
}

inline static constexpr unsigned NumEnumerators(ExprDependence) {
  return 12;
}

const char *EnumeratorName(ExprDependence);

enum class ExprObjectKind : unsigned char {
  ORDINARY,
  BIT_FIELD,
  VECTOR_COMPONENT,
  OBJ_C_PROPERTY,
  OBJ_C_SUBSCRIPT,
  MATRIX_COMPONENT,
};

inline static const char *EnumerationName(ExprObjectKind) {
  return "ExprObjectKind";
}

inline static constexpr unsigned NumEnumerators(ExprObjectKind) {
  return 6;
}

const char *EnumeratorName(ExprObjectKind);

enum class ExprOffsets : unsigned char {
  ALLOCATOR,
  ALLOCATOR_TRAITS,
  TOTAL,
};

inline static const char *EnumerationName(ExprOffsets) {
  return "ExprOffsets";
}

inline static constexpr unsigned NumEnumerators(ExprOffsets) {
  return 3;
}

const char *EnumeratorName(ExprOffsets);

enum class ExprValueKind : unsigned char {
  PR_VALUE,
  L_VALUE,
  X_VALUE,
};

inline static const char *EnumerationName(ExprValueKind) {
  return "ExprValueKind";
}

inline static constexpr unsigned NumEnumerators(ExprValueKind) {
  return 3;
}

const char *EnumeratorName(ExprValueKind);

enum class ExpressionTrait : unsigned char {
  IS_L_VALUE_EXPRESSION,
  IS_R_VALUE_EXPRESSION,
};

inline static const char *EnumerationName(ExpressionTrait) {
  return "ExpressionTrait";
}

inline static constexpr unsigned NumEnumerators(ExpressionTrait) {
  return 2;
}

const char *EnumeratorName(ExpressionTrait);

enum class ExtKind : unsigned char {
  ALWAYS,
  NEVER,
  REPLY_HAZY,
};

inline static const char *EnumerationName(ExtKind) {
  return "ExtKind";
}

inline static constexpr unsigned NumEnumerators(ExtKind) {
  return 3;
}

const char *EnumeratorName(ExtKind);

enum class ExtendArgsKind : unsigned char {
  EXTEND_TO32,
  EXTEND_TO64,
};

inline static const char *EnumerationName(ExtendArgsKind) {
  return "ExtendArgsKind";
}

inline static constexpr unsigned NumEnumerators(ExtendArgsKind) {
  return 2;
}

const char *EnumeratorName(ExtendArgsKind);

enum class FPExceptionModeKind : unsigned char {
  IGNORE,
  MAY_TRAP,
  STRICT,
};

inline static const char *EnumerationName(FPExceptionModeKind) {
  return "FPExceptionModeKind";
}

inline static constexpr unsigned NumEnumerators(FPExceptionModeKind) {
  return 3;
}

const char *EnumeratorName(FPExceptionModeKind);

enum class FPModeKind : unsigned char {
  OFF,
  ON,
  FAST,
  FAST_HONOR_PRAGMAS,
};

inline static const char *EnumerationName(FPModeKind) {
  return "FPModeKind";
}

inline static constexpr unsigned NumEnumerators(FPModeKind) {
  return 4;
}

const char *EnumeratorName(FPModeKind);

enum class FiniteLoopsKind : unsigned char {
  LANGUAGE,
  ALWAYS,
  NEVER,
};

inline static const char *EnumerationName(FiniteLoopsKind) {
  return "FiniteLoopsKind";
}

inline static constexpr unsigned NumEnumerators(FiniteLoopsKind) {
  return 3;
}

const char *EnumeratorName(FiniteLoopsKind);

enum class FramePointerKind : unsigned char {
  NONE,
  NON_LEAF,
  ALL,
};

inline static const char *EnumerationName(FramePointerKind) {
  return "FramePointerKind";
}

inline static constexpr unsigned NumEnumerators(FramePointerKind) {
  return 3;
}

const char *EnumeratorName(FramePointerKind);

enum class GC : unsigned char {
  GC_NONE,
  WEAK,
  STRONG,
};

inline static const char *EnumerationName(GC) {
  return "GC";
}

inline static constexpr unsigned NumEnumerators(GC) {
  return 3;
}

const char *EnumeratorName(GC);

enum class GCMode : unsigned char {
  NON_GC,
  GC_ONLY,
  HYBRID_GC,
};

inline static const char *EnumerationName(GCMode) {
  return "GCMode";
}

inline static constexpr unsigned NumEnumerators(GCMode) {
  return 3;
}

const char *EnumeratorName(GCMode);

enum class GVALinkage : unsigned char {
  INTERNAL,
  AVAILABLE_EXTERNALLY,
  DISCARDABLE_ODR,
  STRONG_EXTERNAL,
  STRONG_ODR,
};

inline static const char *EnumerationName(GVALinkage) {
  return "GVALinkage";
}

inline static constexpr unsigned NumEnumerators(GVALinkage) {
  return 5;
}

const char *EnumeratorName(GVALinkage);

enum class GetBuiltinTypeError : unsigned char {
  NONE,
  MISSING_TYPE,
  MISSING_STDIO,
  MISSING,
  MISSING_UCONTEXT,
};

inline static const char *EnumerationName(GetBuiltinTypeError) {
  return "GetBuiltinTypeError";
}

inline static constexpr unsigned NumEnumerators(GetBuiltinTypeError) {
  return 5;
}

const char *EnumeratorName(GetBuiltinTypeError);

enum class ID : unsigned char {
  WORK_GROUP,
  DEVICE,
  ALL_SVM_DEVICES,
  SUB_GROUP,
};

inline static const char *EnumerationName(ID) {
  return "ID";
}

inline static constexpr unsigned NumEnumerators(ID) {
  return 4;
}

const char *EnumeratorName(ID);

enum class IdentifierInfoFlag : unsigned char {
  ZERO_ARGUMENT,
  ONE_ARGUMENT,
  MULTI_ARGUMENT,
  // Skipped repeat pasta::kArgumentFlags
};

inline static const char *EnumerationName(IdentifierInfoFlag) {
  return "IdentifierInfoFlag";
}

inline static constexpr unsigned NumEnumerators(IdentifierInfoFlag) {
  return 3;
}

const char *EnumeratorName(IdentifierInfoFlag);

enum class IfStatementKind : unsigned char {
  ORDINARY,
  CONSTEXPR,
  CONSTEVAL_NON_NEGATED,
  CONSTEVAL_NEGATED,
};

inline static const char *EnumerationName(IfStatementKind) {
  return "IfStatementKind";
}

inline static constexpr unsigned NumEnumerators(IfStatementKind) {
  return 4;
}

const char *EnumeratorName(IfStatementKind);

enum class ImbueAttribute : unsigned char {
  NONE,
  ALWAYS,
  NEVER,
  ALWAYSARG1,
};

inline static const char *EnumerationName(ImbueAttribute) {
  return "ImbueAttribute";
}

inline static constexpr unsigned NumEnumerators(ImbueAttribute) {
  return 4;
}

const char *EnumeratorName(ImbueAttribute);

enum class InClassInitStyle : unsigned char {
  NO_INITIALIZER,
  COPY_INITIALIZER,
  LIST_INITIALIZER,
};

inline static const char *EnumerationName(InClassInitStyle) {
  return "InClassInitStyle";
}

inline static constexpr unsigned NumEnumerators(InClassInitStyle) {
  return 3;
}

const char *EnumeratorName(InClassInitStyle);

enum class InheritedDesignatedInitializersState : unsigned char {
  UNKNOWN,
  INHERITED,
  NOT_INHERITED,
};

inline static const char *EnumerationName(InheritedDesignatedInitializersState) {
  return "InheritedDesignatedInitializersState";
}

inline static constexpr unsigned NumEnumerators(InheritedDesignatedInitializersState) {
  return 3;
}

const char *EnumeratorName(InheritedDesignatedInitializersState);

enum class InitStorageKind : unsigned char {
  NO_INITIALIZER,
  IN_CLASS_COPY_INITIALIZER,
  IN_CLASS_LIST_INITIALIZER,
  CAPTURED_VLA_TYPE,
};

inline static const char *EnumerationName(InitStorageKind) {
  return "InitStorageKind";
}

inline static constexpr unsigned NumEnumerators(InitStorageKind) {
  return 4;
}

const char *EnumeratorName(InitStorageKind);

enum class InlineAsmDialectKind : unsigned char {
  IADATT,
  IAD_INTEL,
};

inline static const char *EnumerationName(InlineAsmDialectKind) {
  return "InlineAsmDialectKind";
}

inline static constexpr unsigned NumEnumerators(InlineAsmDialectKind) {
  return 2;
}

const char *EnumeratorName(InlineAsmDialectKind);

enum class InlineVariableDefinitionKind : unsigned char {
  NONE,
  WEAK,
  WEAK_UNKNOWN,
  STRONG,
};

inline static const char *EnumerationName(InlineVariableDefinitionKind) {
  return "InlineVariableDefinitionKind";
}

inline static constexpr unsigned NumEnumerators(InlineVariableDefinitionKind) {
  return 4;
}

const char *EnumeratorName(InlineVariableDefinitionKind);

enum class InliningMethod : unsigned char {
  NORMAL_INLINING,
  ONLY_HINT_INLINING,
  ONLY_ALWAYS_INLINING,
};

inline static const char *EnumerationName(InliningMethod) {
  return "InliningMethod";
}

inline static constexpr unsigned NumEnumerators(InliningMethod) {
  return 3;
}

const char *EnumeratorName(InliningMethod);

enum class Kinds : unsigned char {
  L_VALUE,
  X_VALUE,
  FUNCTION,
  VOID,
  ADDRESSABLE_VOID,
  DUPLICATE_VECTOR_COMPONENTS,
  MEMBER_FUNCTION,
  SUB_OBJ_C_PROPERTY_SETTING,
  CLASS_TEMPORARY,
  ARRAY_TEMPORARY,
  OBJ_C_MESSAGE_R_VALUE,
  PR_VALUE,
};

inline static const char *EnumerationName(Kinds) {
  return "Kinds";
}

inline static constexpr unsigned NumEnumerators(Kinds) {
  return 12;
}

const char *EnumeratorName(Kinds);

enum class LambdaCaptureDefault : unsigned char {
  NONE,
  BY_COPY,
  BY_REFERENCE,
};

inline static const char *EnumerationName(LambdaCaptureDefault) {
  return "LambdaCaptureDefault";
}

inline static constexpr unsigned NumEnumerators(LambdaCaptureDefault) {
  return 3;
}

const char *EnumeratorName(LambdaCaptureDefault);

enum class LambdaCaptureKind : unsigned char {
  THIS,
  STAR_THIS,
  BY_COPY,
  BY_REFERENCE,
  VLA_TYPE,
};

inline static const char *EnumerationName(LambdaCaptureKind) {
  return "LambdaCaptureKind";
}

inline static constexpr unsigned NumEnumerators(LambdaCaptureKind) {
  return 5;
}

const char *EnumeratorName(LambdaCaptureKind);

enum class LangAS : unsigned char {
  DEFAULT,
  OPENCL_GLOBAL,
  OPENCL_LOCAL,
  OPENCL_CONSTANT,
  OPENCL_PRIVATE,
  OPENCL_GENERIC,
  OPENCL_GLOBAL_DEVICE,
  OPENCL_GLOBAL_HOST,
  CUDA_DEVICE,
  CUDA_CONSTANT,
  CUDA_SHARED,
  SYCL_GLOBAL,
  SYCL_GLOBAL_DEVICE,
  SYCL_GLOBAL_HOST,
  SYCL_LOCAL,
  SYCL_PRIVATE,
  PTR32_SPTR,
  PTR32_UPTR,
  PTR64,
};

inline static const char *EnumerationName(LangAS) {
  return "LangAS";
}

inline static constexpr unsigned NumEnumerators(LangAS) {
  return 19;
}

const char *EnumeratorName(LangAS);

enum class LangFeatures : unsigned char {
  LINE_COMMENT,
  C99,
  C11,
  C17,
  C2X,
  C_PLUS_PLUS,
  C_PLUS_PLUS11,
  C_PLUS_PLUS14,
  C_PLUS_PLUS17,
  C_PLUS_PLUS20,
  C_PLUS_PLUS2B,
  DIGRAPHS,
  GNU_MODE,
  HEX_FLOAT,
  IMPLICIT_INT,
  OPEN_CL,
};

inline static const char *EnumerationName(LangFeatures) {
  return "LangFeatures";
}

inline static constexpr unsigned NumEnumerators(LangFeatures) {
  return 16;
}

const char *EnumeratorName(LangFeatures);

enum class Language : unsigned char {
  UNKNOWN,
  ASSEMBLY,
  LLVMIR,
  C,
  CXX,
  OBJ_C,
  OBJ_CXX,
  OPEN_CL,
  OPEN_CLCXX,
  CUDA,
  RENDER_SCRIPT,
  HIP,
};

inline static const char *EnumerationName(Language) {
  return "Language";
}

inline static constexpr unsigned NumEnumerators(Language) {
  return 12;
}

const char *EnumeratorName(Language);

enum class LanguageLinkage : unsigned char {
  C_LANGUAGE_LINKAGE,
  CXX_LANGUAGE_LINKAGE,
  NO_LANGUAGE_LINKAGE,
};

inline static const char *EnumerationName(LanguageLinkage) {
  return "LanguageLinkage";
}

inline static constexpr unsigned NumEnumerators(LanguageLinkage) {
  return 3;
}

const char *EnumeratorName(LanguageLinkage);

enum class LaxVectorConversionKind : unsigned char {
  NONE,
  INTEGER,
  ALL,
};

inline static const char *EnumerationName(LaxVectorConversionKind) {
  return "LaxVectorConversionKind";
}

inline static constexpr unsigned NumEnumerators(LaxVectorConversionKind) {
  return 3;
}

const char *EnumeratorName(LaxVectorConversionKind);

enum class Level : unsigned char {
  IGNORED,
  NOTE,
  REMARK,
  WARNING,
  ERROR,
  FATAL,
};

inline static const char *EnumerationName(Level) {
  return "Level";
}

inline static constexpr unsigned NumEnumerators(Level) {
  return 6;
}

const char *EnumeratorName(Level);

enum class Linkage : unsigned char {
  NO_LINKAGE,
  INTERNAL_LINKAGE,
  UNIQUE_EXTERNAL_LINKAGE,
  VISIBLE_NO_LINKAGE,
  MODULE_INTERNAL_LINKAGE,
  MODULE_LINKAGE,
  EXTERNAL_LINKAGE,
};

inline static const char *EnumerationName(Linkage) {
  return "Linkage";
}

inline static constexpr unsigned NumEnumerators(Linkage) {
  return 7;
}

const char *EnumeratorName(Linkage);

enum class MSInheritanceModel : unsigned char {
  SINGLE,
  MULTIPLE,
  VIRTUAL,
  UNSPECIFIED,
};

inline static const char *EnumerationName(MSInheritanceModel) {
  return "MSInheritanceModel";
}

inline static constexpr unsigned NumEnumerators(MSInheritanceModel) {
  return 4;
}

const char *EnumeratorName(MSInheritanceModel);

enum class MSVCMajorVersion : unsigned char {
  MSVC2010,
  MSVC2012,
  MSVC2013,
  MSVC2015,
  MSVC2017,
  MSVC20175,
  MSVC20177,
  MSVC2019,
  MSVC20195,
  MSVC20198,
};

inline static const char *EnumerationName(MSVCMajorVersion) {
  return "MSVCMajorVersion";
}

inline static constexpr unsigned NumEnumerators(MSVCMajorVersion) {
  return 10;
}

const char *EnumeratorName(MSVCMajorVersion);

enum class MSVtorDispMode : unsigned char {
  NEVER,
  FOR_VIRTUAL_BASE_OVERRIDE,
  FOR_VF_TABLE,
};

inline static const char *EnumerationName(MSVtorDispMode) {
  return "MSVtorDispMode";
}

inline static constexpr unsigned NumEnumerators(MSVtorDispMode) {
  return 3;
}

const char *EnumeratorName(MSVtorDispMode);

enum class MethodRefFlags : unsigned char {
  METHOD_REFERENCE_NONE,
  METHOD_REFERENCE_GETTER,
  METHOD_REFERENCE_SETTER,
};

inline static const char *EnumerationName(MethodRefFlags) {
  return "MethodRefFlags";
}

inline static constexpr unsigned NumEnumerators(MethodRefFlags) {
  return 3;
}

const char *EnumeratorName(MethodRefFlags);

enum class ModifiableType : unsigned char {
  UNTESTED,
  MODIFIABLE,
  R_VALUE,
  FUNCTION,
  L_VALUE_CAST,
  NO_SETTER_PROPERTY,
  CONST_QUALIFIED,
  CONST_QUALIFIED_FIELD,
  CONST_ADDRESS_SPACE,
  ARRAY_TYPE,
  INCOMPLETE_TYPE,
};

inline static const char *EnumerationName(ModifiableType) {
  return "ModifiableType";
}

inline static constexpr unsigned NumEnumerators(ModifiableType) {
  return 11;
}

const char *EnumeratorName(ModifiableType);

enum class MultiVersionKind : unsigned char {
  NONE,
  TARGET,
  CPU_SPECIFIC,
  CPU_DISPATCH,
  TARGET_CLONES,
};

inline static const char *EnumerationName(MultiVersionKind) {
  return "MultiVersionKind";
}

inline static constexpr unsigned NumEnumerators(MultiVersionKind) {
  return 5;
}

const char *EnumeratorName(MultiVersionKind);

enum class NameKind : unsigned char {
  TEMPLATE,
  OVERLOADED_TEMPLATE,
  ASSUMED_TEMPLATE,
  QUALIFIED_TEMPLATE,
  DEPENDENT_TEMPLATE,
  SUBST_TEMPLATE_TEMPLATE_PARM,
  SUBST_TEMPLATE_TEMPLATE_PARM_PACK,
};

inline static const char *EnumerationName(NameKind) {
  return "NameKind";
}

inline static constexpr unsigned NumEnumerators(NameKind) {
  return 7;
}

const char *EnumeratorName(NameKind);

enum class NeedExtraManglingDecl : unsigned char {
  NEED_EXTRA_MANGLING_DECLARATION,
};

inline static const char *EnumerationName(NeedExtraManglingDecl) {
  return "NeedExtraManglingDecl";
}

inline static constexpr unsigned NumEnumerators(NeedExtraManglingDecl) {
  return 1;
}

const char *EnumeratorName(NeedExtraManglingDecl);

enum class NestedNameSpecifierDependence : unsigned char {
  UNEXPANDED_PACK,
  INSTANTIATION,
  DEPENDENT,
  ERROR,
  NONE,
  DEPENDENT_INSTANTIATION,
  ALL,
};

inline static const char *EnumerationName(NestedNameSpecifierDependence) {
  return "NestedNameSpecifierDependence";
}

inline static constexpr unsigned NumEnumerators(NestedNameSpecifierDependence) {
  return 7;
}

const char *EnumeratorName(NestedNameSpecifierDependence);

enum class NonOdrUseReason : unsigned char {
  NONE,
  UNEVALUATED,
  CONSTANT,
  DISCARDED,
};

inline static const char *EnumerationName(NonOdrUseReason) {
  return "NonOdrUseReason";
}

inline static constexpr unsigned NumEnumerators(NonOdrUseReason) {
  return 4;
}

const char *EnumeratorName(NonOdrUseReason);

enum class NonceObjCInterface : unsigned char {
  OBJ_C_INTERFACE,
};

inline static const char *EnumerationName(NonceObjCInterface) {
  return "NonceObjCInterface";
}

inline static constexpr unsigned NumEnumerators(NonceObjCInterface) {
  return 1;
}

const char *EnumeratorName(NonceObjCInterface);

enum class NullabilityKind : unsigned char {
  NON_NULL,
  NULLABLE,
  UNSPECIFIED,
  NULLABLE_RESULT,
};

inline static const char *EnumerationName(NullabilityKind) {
  return "NullabilityKind";
}

inline static constexpr unsigned NumEnumerators(NullabilityKind) {
  return 4;
}

const char *EnumeratorName(NullabilityKind);

enum class ObjCBridgeCastKind : unsigned char {
  BRIDGE,
  BRIDGE_TRANSFER,
  BRIDGE_RETAINED,
};

inline static const char *EnumerationName(ObjCBridgeCastKind) {
  return "ObjCBridgeCastKind";
}

inline static constexpr unsigned NumEnumerators(ObjCBridgeCastKind) {
  return 3;
}

const char *EnumeratorName(ObjCBridgeCastKind);

enum class ObjCDispatchMethodKind : unsigned char {
  LEGACY,
  NON_LEGACY,
  MIXED,
};

inline static const char *EnumerationName(ObjCDispatchMethodKind) {
  return "ObjCDispatchMethodKind";
}

inline static constexpr unsigned NumEnumerators(ObjCDispatchMethodKind) {
  return 3;
}

const char *EnumeratorName(ObjCDispatchMethodKind);

enum class ObjCInstanceTypeFamily : unsigned char {
  NONE,
  ARRAY,
  DICTIONARY,
  SINGLETON,
  INITIALIZER,
  RETURNS_SELF,
};

inline static const char *EnumerationName(ObjCInstanceTypeFamily) {
  return "ObjCInstanceTypeFamily";
}

inline static constexpr unsigned NumEnumerators(ObjCInstanceTypeFamily) {
  return 6;
}

const char *EnumeratorName(ObjCInstanceTypeFamily);

enum class ObjCLifetime : unsigned char {
  NONE,
  EXPLICIT_NONE,
  STRONG,
  WEAK,
  AUTORELEASING,
};

inline static const char *EnumerationName(ObjCLifetime) {
  return "ObjCLifetime";
}

inline static constexpr unsigned NumEnumerators(ObjCLifetime) {
  return 5;
}

const char *EnumeratorName(ObjCLifetime);

enum class ObjCMethodFamily : unsigned char {
  NONE,
  ALLOC,
  COPY,
  INITIALIZER,
  MUTABLE_COPY,
  NEW,
  AUTORELEASE,
  DEALLOC,
  FINALIZE,
  RELEASE,
  RETAIN,
  RETAIN_COUNT,
  SELF,
  INITIALIZE,
  PERFORM_SELECTOR,
};

inline static const char *EnumerationName(ObjCMethodFamily) {
  return "ObjCMethodFamily";
}

inline static constexpr unsigned NumEnumerators(ObjCMethodFamily) {
  return 15;
}

const char *EnumeratorName(ObjCMethodFamily);

enum class ObjCPropertyQueryKind : unsigned char {
  QUERY_UNKNOWN,
  QUERY_INSTANCE,
  QUERY_CLASS,
};

inline static const char *EnumerationName(ObjCPropertyQueryKind) {
  return "ObjCPropertyQueryKind";
}

inline static constexpr unsigned NumEnumerators(ObjCPropertyQueryKind) {
  return 3;
}

const char *EnumeratorName(ObjCPropertyQueryKind);

enum class ObjCStringFormatFamily : unsigned char {
  NONE,
  NS_STRING,
  CF_STRING,
};

inline static const char *EnumerationName(ObjCStringFormatFamily) {
  return "ObjCStringFormatFamily";
}

inline static constexpr unsigned NumEnumerators(ObjCStringFormatFamily) {
  return 3;
}

const char *EnumeratorName(ObjCStringFormatFamily);

enum class ObjCSubstitutionContext : unsigned char {
  ORDINARY,
  RESULT,
  PARAMETER,
  PROPERTY,
  SUPERCLASS,
};

inline static const char *EnumerationName(ObjCSubstitutionContext) {
  return "ObjCSubstitutionContext";
}

inline static constexpr unsigned NumEnumerators(ObjCSubstitutionContext) {
  return 5;
}

const char *EnumeratorName(ObjCSubstitutionContext);

enum class ObjCTypeParamVariance : unsigned char {
  INVARIANT,
  COVARIANT,
  CONTRAVARIANT,
};

inline static const char *EnumerationName(ObjCTypeParamVariance) {
  return "ObjCTypeParamVariance";
}

inline static constexpr unsigned NumEnumerators(ObjCTypeParamVariance) {
  return 3;
}

const char *EnumeratorName(ObjCTypeParamVariance);

enum class OnOffSwitch : unsigned char {
  ON,
  OFF,
  DEFAULT,
};

inline static const char *EnumerationName(OnOffSwitch) {
  return "OnOffSwitch";
}

inline static constexpr unsigned NumEnumerators(OnOffSwitch) {
  return 3;
}

const char *EnumeratorName(OnOffSwitch);

enum class OnStackType : unsigned char {
  ON_STACK,
};

inline static const char *EnumerationName(OnStackType) {
  return "OnStackType";
}

inline static constexpr unsigned NumEnumerators(OnStackType) {
  return 1;
}

const char *EnumeratorName(OnStackType);

enum class OpenMPAdjustArgsOpKind : unsigned char {
  ADJUSTARGS_NOTHING,
  ADJUSTARGS_NEED_DEVICE_POINTER,
  ADJUSTARGS_UNKNOWN,
};

inline static const char *EnumerationName(OpenMPAdjustArgsOpKind) {
  return "OpenMPAdjustArgsOpKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPAdjustArgsOpKind) {
  return 3;
}

const char *EnumeratorName(OpenMPAdjustArgsOpKind);

enum class OpenMPAtomicDefaultMemOrderClauseKind : unsigned char {
  SEQ_CST,
  ACQ_REL,
  RELAXED,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPAtomicDefaultMemOrderClauseKind) {
  return "OpenMPAtomicDefaultMemOrderClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPAtomicDefaultMemOrderClauseKind) {
  return 4;
}

const char *EnumeratorName(OpenMPAtomicDefaultMemOrderClauseKind);

enum class OpenMPBindClauseKind : unsigned char {
  BIND_TEAMS,
  BIND_PARALLEL,
  BIND_THREAD,
  BIND_UNKNOWN,
};

inline static const char *EnumerationName(OpenMPBindClauseKind) {
  return "OpenMPBindClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPBindClauseKind) {
  return 4;
}

const char *EnumeratorName(OpenMPBindClauseKind);

enum class OpenMPDefaultmapClauseKind : unsigned char {
  SCALAR,
  AGGREGATE,
  POINTER,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPDefaultmapClauseKind) {
  return "OpenMPDefaultmapClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPDefaultmapClauseKind) {
  return 4;
}

const char *EnumeratorName(OpenMPDefaultmapClauseKind);

enum class OpenMPDefaultmapClauseModifier : unsigned char {
  UNKNOWN,
  ALLOC,
  TO,
  FROM,
  TOFROM,
  NONE,
  DEFAULT,
  PRESENT,
};

inline static const char *EnumerationName(OpenMPDefaultmapClauseModifier) {
  return "OpenMPDefaultmapClauseModifier";
}

inline static constexpr unsigned NumEnumerators(OpenMPDefaultmapClauseModifier) {
  return 8;
}

const char *EnumeratorName(OpenMPDefaultmapClauseModifier);

enum class OpenMPDependClauseKind : unsigned char {
  IN,
  OUT,
  INOUT,
  MUTEXINOUTSET,
  DEPOBJ,
  SOURCE,
  SINK,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPDependClauseKind) {
  return "OpenMPDependClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPDependClauseKind) {
  return 8;
}

const char *EnumeratorName(OpenMPDependClauseKind);

enum class OpenMPDeviceClauseModifier : unsigned char {
  ANCESTOR,
  DEVICE_NUM,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPDeviceClauseModifier) {
  return "OpenMPDeviceClauseModifier";
}

inline static constexpr unsigned NumEnumerators(OpenMPDeviceClauseModifier) {
  return 3;
}

const char *EnumeratorName(OpenMPDeviceClauseModifier);

enum class OpenMPDeviceType : unsigned char {
  HOST,
  NOHOST,
  ANY,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPDeviceType) {
  return "OpenMPDeviceType";
}

inline static constexpr unsigned NumEnumerators(OpenMPDeviceType) {
  return 4;
}

const char *EnumeratorName(OpenMPDeviceType);

enum class OpenMPDistScheduleClauseKind : unsigned char {
  STATIC,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPDistScheduleClauseKind) {
  return "OpenMPDistScheduleClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPDistScheduleClauseKind) {
  return 2;
}

const char *EnumeratorName(OpenMPDistScheduleClauseKind);

enum class OpenMPLastprivateModifier : unsigned char {
  CONDITIONAL,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPLastprivateModifier) {
  return "OpenMPLastprivateModifier";
}

inline static constexpr unsigned NumEnumerators(OpenMPLastprivateModifier) {
  return 2;
}

const char *EnumeratorName(OpenMPLastprivateModifier);

enum class OpenMPLinearClauseKind : unsigned char {
  VALUE,
  REFERENCE,
  UVAL,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPLinearClauseKind) {
  return "OpenMPLinearClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPLinearClauseKind) {
  return 4;
}

const char *EnumeratorName(OpenMPLinearClauseKind);

enum class OpenMPMapClauseKind : unsigned char {
  ALLOC,
  TO,
  FROM,
  TOFROM,
  DELETE,
  RELEASE,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPMapClauseKind) {
  return "OpenMPMapClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPMapClauseKind) {
  return 7;
}

const char *EnumeratorName(OpenMPMapClauseKind);

enum class OpenMPMapModifierKind : unsigned char {
  UNKNOWN,
  ALWAYS,
  CLOSE,
  MAPPER,
  PRESENT,
  OMPX_HOLD,
};

inline static const char *EnumerationName(OpenMPMapModifierKind) {
  return "OpenMPMapModifierKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPMapModifierKind) {
  return 6;
}

const char *EnumeratorName(OpenMPMapModifierKind);

enum class OpenMPMotionModifierKind : unsigned char {
  MOTIONMODIFIER_MAPPER,
  MOTIONMODIFIER_PRESENT,
  MOTIONMODIFIER_UNKNOWN,
};

inline static const char *EnumerationName(OpenMPMotionModifierKind) {
  return "OpenMPMotionModifierKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPMotionModifierKind) {
  return 3;
}

const char *EnumeratorName(OpenMPMotionModifierKind);

enum class OpenMPOrderClauseKind : unsigned char {
  CONCURRENT,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPOrderClauseKind) {
  return "OpenMPOrderClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPOrderClauseKind) {
  return 2;
}

const char *EnumeratorName(OpenMPOrderClauseKind);

enum class OpenMPReductionClauseModifier : unsigned char {
  DEFAULT,
  INSCAN,
  TASK,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPReductionClauseModifier) {
  return "OpenMPReductionClauseModifier";
}

inline static constexpr unsigned NumEnumerators(OpenMPReductionClauseModifier) {
  return 4;
}

const char *EnumeratorName(OpenMPReductionClauseModifier);

enum class OpenMPScheduleClauseKind : unsigned char {
  STATIC,
  DYNAMIC,
  GUIDED,
  AUTO,
  RUNTIME,
  UNKNOWN,
};

inline static const char *EnumerationName(OpenMPScheduleClauseKind) {
  return "OpenMPScheduleClauseKind";
}

inline static constexpr unsigned NumEnumerators(OpenMPScheduleClauseKind) {
  return 6;
}

const char *EnumeratorName(OpenMPScheduleClauseKind);

enum class OpenMPScheduleClauseModifier : unsigned char {
  UNKNOWN,
  MONOTONIC,
  NONMONOTONIC,
  SIMD,
};

inline static const char *EnumerationName(OpenMPScheduleClauseModifier) {
  return "OpenMPScheduleClauseModifier";
}

inline static constexpr unsigned NumEnumerators(OpenMPScheduleClauseModifier) {
  return 4;
}

const char *EnumeratorName(OpenMPScheduleClauseModifier);

enum class OverloadedOperatorKind : unsigned char {
  NONE,
  NEW,
  DELETE,
  ARRAY_NEW,
  ARRAY_DELETE,
  PLUS,
  MINUS,
  STAR,
  SLASH,
  PERCENT,
  CARET,
  AMP,
  PIPE,
  TILDE,
  EXCLAIM,
  EQUAL,
  LESS,
  GREATER,
  PLUS_EQUAL,
  MINUS_EQUAL,
  STAR_EQUAL,
  SLASH_EQUAL,
  PERCENT_EQUAL,
  CARET_EQUAL,
  AMP_EQUAL,
  PIPE_EQUAL,
  LESS_LESS,
  GREATER_GREATER,
  LESS_LESS_EQUAL,
  GREATER_GREATER_EQUAL,
  EQUAL_EQUAL,
  EXCLAIM_EQUAL,
  LESS_EQUAL,
  GREATER_EQUAL,
  SPACESHIP,
  AMP_AMP,
  PIPE_PIPE,
  PLUS_PLUS,
  MINUS_MINUS,
  COMMA,
  ARROW_STAR,
  ARROW,
  CALL,
  SUBSCRIPT,
  CONDITIONAL,
  COAWAIT,
};

inline static const char *EnumerationName(OverloadedOperatorKind) {
  return "OverloadedOperatorKind";
}

inline static constexpr unsigned NumEnumerators(OverloadedOperatorKind) {
  return 46;
}

const char *EnumeratorName(OverloadedOperatorKind);

enum class OverloadsShown : unsigned char {
  ALL,
  BEST,
};

inline static const char *EnumerationName(OverloadsShown) {
  return "OverloadsShown";
}

inline static constexpr unsigned NumEnumerators(OverloadsShown) {
  return 2;
}

const char *EnumeratorName(OverloadsShown);

enum class ParameterABI : unsigned char {
  ORDINARY,
  SWIFT_INDIRECT_RESULT,
  SWIFT_ERROR_RESULT,
  SWIFT_CONTEXT,
  SWIFT_ASYNC_CONTEXT,
};

inline static const char *EnumerationName(ParameterABI) {
  return "ParameterABI";
}

inline static constexpr unsigned NumEnumerators(ParameterABI) {
  return 5;
}

const char *EnumeratorName(ParameterABI);

enum class ParenLocsOffsets : unsigned char {
  L_PAREN_TOKEN,
  R_PAREN_TOKEN,
  TOTAL,
};

inline static const char *EnumerationName(ParenLocsOffsets) {
  return "ParenLocsOffsets";
}

inline static constexpr unsigned NumEnumerators(ParenLocsOffsets) {
  return 3;
}

const char *EnumeratorName(ParenLocsOffsets);

enum class PragmaFloatControlKind : unsigned char {
  UNKNOWN,
  PRECISE,
  NO_PRECISE,
  EXCEPT,
  NO_EXCEPT,
  PUSH,
  POP,
};

inline static const char *EnumerationName(PragmaFloatControlKind) {
  return "PragmaFloatControlKind";
}

inline static constexpr unsigned NumEnumerators(PragmaFloatControlKind) {
  return 7;
}

const char *EnumeratorName(PragmaFloatControlKind);

enum class PragmaMSCommentKind : unsigned char {
  UNKNOWN,
  LINKER,
  LIB,
  COMPILER,
  EXE_STRING,
  USER,
};

inline static const char *EnumerationName(PragmaMSCommentKind) {
  return "PragmaMSCommentKind";
}

inline static constexpr unsigned NumEnumerators(PragmaMSCommentKind) {
  return 6;
}

const char *EnumeratorName(PragmaMSCommentKind);

enum class PragmaMSPointersToMembersKind : unsigned char {
  BEST_CASE,
  FULL_GENERALITY_SINGLE_INHERITANCE,
  FULL_GENERALITY_MULTIPLE_INHERITANCE,
  FULL_GENERALITY_VIRTUAL_INHERITANCE,
};

inline static const char *EnumerationName(PragmaMSPointersToMembersKind) {
  return "PragmaMSPointersToMembersKind";
}

inline static constexpr unsigned NumEnumerators(PragmaMSPointersToMembersKind) {
  return 4;
}

const char *EnumeratorName(PragmaMSPointersToMembersKind);

enum class PragmaMSStructKind : unsigned char {
  OFF,
  ON,
};

inline static const char *EnumerationName(PragmaMSStructKind) {
  return "PragmaMSStructKind";
}

inline static constexpr unsigned NumEnumerators(PragmaMSStructKind) {
  return 2;
}

const char *EnumeratorName(PragmaMSStructKind);

enum class PragmaSectionFlag : unsigned char {
  NONE,
  READ,
  WRITE,
  EXECUTE,
  IMPLICIT,
  ZERO_INITIALIZER,
  INVALID,
};

inline static const char *EnumerationName(PragmaSectionFlag) {
  return "PragmaSectionFlag";
}

inline static constexpr unsigned NumEnumerators(PragmaSectionFlag) {
  return 7;
}

const char *EnumeratorName(PragmaSectionFlag);

enum class ProfileInstrKind : unsigned char {
  PROFILE_NONE,
  PROFILE_CLANG_INSTR,
  PROFILE_IR_INSTR,
  PROFILE_CSIR_INSTR,
};

inline static const char *EnumerationName(ProfileInstrKind) {
  return "ProfileInstrKind";
}

inline static constexpr unsigned NumEnumerators(ProfileInstrKind) {
  return 4;
}

const char *EnumeratorName(ProfileInstrKind);

enum class Qualified : unsigned char {
  NONE,
  AS_WRITTEN,
  FULLY,
};

inline static const char *EnumerationName(Qualified) {
  return "Qualified";
}

inline static constexpr unsigned NumEnumerators(Qualified) {
  return 3;
}

const char *EnumeratorName(Qualified);

enum class RangeExprOffset : unsigned char {
  BEGIN,
  END,
  STEP,
  TOTAL,
};

inline static const char *EnumerationName(RangeExprOffset) {
  return "RangeExprOffset";
}

inline static constexpr unsigned NumEnumerators(RangeExprOffset) {
  return 4;
}

const char *EnumeratorName(RangeExprOffset);

enum class RangeLocOffset : unsigned char {
  ASSIGN_TOKEN,
  SECOND_COLON_TOKEN,
  TOTAL,
};

inline static const char *EnumerationName(RangeLocOffset) {
  return "RangeLocOffset";
}

inline static constexpr unsigned NumEnumerators(RangeLocOffset) {
  return 3;
}

const char *EnumeratorName(RangeLocOffset);

enum class RefQualifierKind : unsigned char {
  NONE,
  L_VALUE,
  R_VALUE,
};

inline static const char *EnumerationName(RefQualifierKind) {
  return "RefQualifierKind";
}

inline static constexpr unsigned NumEnumerators(RefQualifierKind) {
  return 3;
}

const char *EnumeratorName(RefQualifierKind);

enum class RemarkKind : unsigned char {
  MISSING,
  ENABLED,
  ENABLED_EVERYTHING,
  DISABLED,
  DISABLED_EVERYTHING,
  WITH_PATTERN,
};

inline static const char *EnumerationName(RemarkKind) {
  return "RemarkKind";
}

inline static constexpr unsigned NumEnumerators(RemarkKind) {
  return 6;
}

const char *EnumeratorName(RemarkKind);

enum class ReservedIdentifierStatus : unsigned char {
  NOT_RESERVED,
  STARTS_WITH_UNDERSCORE_AT_GLOBAL_SCOPE,
  STARTS_WITH_UNDERSCORE_AND_IS_EXTERN_C,
  STARTS_WITH_DOUBLE_UNDERSCORE,
  STARTS_WITH_UNDERSCORE_FOLLOWED_BY_CAPITAL_LETTER,
  CONTAINS_DOUBLE_UNDERSCORE,
};

inline static const char *EnumerationName(ReservedIdentifierStatus) {
  return "ReservedIdentifierStatus";
}

inline static constexpr unsigned NumEnumerators(ReservedIdentifierStatus) {
  return 6;
}

const char *EnumeratorName(ReservedIdentifierStatus);

enum class SFINAEResponse : unsigned char {
  SUBSTITUTION_FAILURE,
  SUPPRESS,
  REPORT,
  ACCESS_CONTROL,
};

inline static const char *EnumerationName(SFINAEResponse) {
  return "SFINAEResponse";
}

inline static constexpr unsigned NumEnumerators(SFINAEResponse) {
  return 4;
}

const char *EnumeratorName(SFINAEResponse);

enum class SYCLMajorVersion : unsigned char {
  VERSION_NONE,
  VERSION2017,
  VERSION2020,
  // Skipped repeat pasta::kDefault
};

inline static const char *EnumerationName(SYCLMajorVersion) {
  return "SYCLMajorVersion";
}

inline static constexpr unsigned NumEnumerators(SYCLMajorVersion) {
  return 3;
}

const char *EnumeratorName(SYCLMajorVersion);

enum class SanitizerOrdinal : unsigned char {
  ADDRESS,
  POINTER_COMPARE,
  POINTER_SUBTRACT,
  KERNEL_ADDRESS,
  HW_ADDRESS,
  KERNEL_HW_ADDRESS,
  MEMORY_TAG,
  MEMORY,
  KERNEL_MEMORY,
  FUZZER,
  FUZZER_NO_LINK,
  THREAD,
  LEAK,
  ALIGNMENT,
  ARRAY_BOUNDS,
  BOOLEAN,
  BUILTIN,
  ENUM,
  FLOAT_CAST_OVERFLOW,
  FLOAT_DIVIDE_BY_ZERO,
  FUNCTION,
  INTEGER_DIVIDE_BY_ZERO,
  NONNULL_ATTRIBUTE,
  NULL_,
  NULLABILITY_ARGUMENT,
  NULLABILITY_ASSIGN,
  NULLABILITY_RETURN,
  NULLABILITY_GROUP,
  OBJECT_SIZE,
  POINTER_OVERFLOW,
  RETURN,
  RETURNS_NONNULL_ATTRIBUTE,
  SHIFT_BASE,
  SHIFT_EXPONENT,
  SHIFT_GROUP,
  SIGNED_INTEGER_OVERFLOW,
  UNREACHABLE,
  VLA_BOUND,
  VPTR,
  UNSIGNED_INTEGER_OVERFLOW,
  UNSIGNED_SHIFT_BASE,
  DATA_FLOW,
  CFI_CAST_STRICT,
  CFI_DERIVED_CAST,
  CFII_CALL,
  CFIMF_CALL,
  CFI_UNRELATED_CAST,
  CFINV_CALL,
  CFIV_CALL,
  CFI_GROUP,
  SAFE_STACK,
  SHADOW_CALL_STACK,
  UNDEFINED_GROUP,
  UNDEFINED_TRAP_GROUP,
  IMPLICIT_UNSIGNED_INTEGER_TRUNCATION,
  IMPLICIT_SIGNED_INTEGER_TRUNCATION,
  IMPLICIT_INTEGER_TRUNCATION_GROUP,
  IMPLICIT_INTEGER_SIGN_CHANGE,
  IMPLICIT_INTEGER_ARITHMETIC_VALUE_CHANGE_GROUP,
  OBJ_C_CAST,
  IMPLICIT_CONVERSION_GROUP,
  INTEGER_GROUP,
  LOCAL_BOUNDS,
  BOUNDS_GROUP,
  SCUDO,
  ALL_GROUP,
  COUNT,
};

inline static const char *EnumerationName(SanitizerOrdinal) {
  return "SanitizerOrdinal";
}

inline static constexpr unsigned NumEnumerators(SanitizerOrdinal) {
  return 67;
}

const char *EnumeratorName(SanitizerOrdinal);

enum class SelectorLocationsKind : unsigned char {
  NON_STANDARD,
  STANDARD_NO_SPACE,
  STANDARD_WITH_SPACE,
};

inline static const char *EnumerationName(SelectorLocationsKind) {
  return "SelectorLocationsKind";
}

inline static constexpr unsigned NumEnumerators(SelectorLocationsKind) {
  return 3;
}

const char *EnumeratorName(SelectorLocationsKind);

enum class SignReturnAddressKeyKind : unsigned char {
  A_KEY,
  B_KEY,
};

inline static const char *EnumerationName(SignReturnAddressKeyKind) {
  return "SignReturnAddressKeyKind";
}

inline static constexpr unsigned NumEnumerators(SignReturnAddressKeyKind) {
  return 2;
}

const char *EnumeratorName(SignReturnAddressKeyKind);

enum class SignReturnAddressScopeKind : unsigned char {
  NONE,
  NON_LEAF,
  ALL,
};

inline static const char *EnumerationName(SignReturnAddressScopeKind) {
  return "SignReturnAddressScopeKind";
}

inline static constexpr unsigned NumEnumerators(SignReturnAddressScopeKind) {
  return 3;
}

const char *EnumeratorName(SignReturnAddressScopeKind);

enum class SignedOverflowBehaviorTy : unsigned char {
  UNDEFINED,
  DEFINED,
  TRAPPING,
};

inline static const char *EnumerationName(SignedOverflowBehaviorTy) {
  return "SignedOverflowBehaviorTy";
}

inline static constexpr unsigned NumEnumerators(SignedOverflowBehaviorTy) {
  return 3;
}

const char *EnumeratorName(SignedOverflowBehaviorTy);

enum class SpecialMemberFlags : unsigned char {
  DEFAULT_CONSTRUCTOR,
  COPY_CONSTRUCTOR,
  MOVE_CONSTRUCTOR,
  COPY_ASSIGNMENT,
  MOVE_ASSIGNMENT,
  DESTRUCTOR,
  ALL,
};

inline static const char *EnumerationName(SpecialMemberFlags) {
  return "SpecialMemberFlags";
}

inline static constexpr unsigned NumEnumerators(SpecialMemberFlags) {
  return 7;
}

const char *EnumeratorName(SpecialMemberFlags);

enum class SpecifierKind : unsigned char {
  IDENTIFIER,
  NAMESPACE,
  NAMESPACE_ALIAS,
  TYPE_SPEC,
  TYPE_SPEC_WITH_TEMPLATE,
  GLOBAL,
  SUPER,
};

inline static const char *EnumerationName(SpecifierKind) {
  return "SpecifierKind";
}

inline static constexpr unsigned NumEnumerators(SpecifierKind) {
  return 7;
}

const char *EnumeratorName(SpecifierKind);

enum class StackProtectorMode : unsigned char {
  OFF,
  ON,
  STRONG,
  REQ,
};

inline static const char *EnumerationName(StackProtectorMode) {
  return "StackProtectorMode";
}

inline static constexpr unsigned NumEnumerators(StackProtectorMode) {
  return 4;
}

const char *EnumeratorName(StackProtectorMode);

enum class StorageClass : unsigned char {
  NONE,
  EXTERN,
  STATIC,
  PRIVATE_EXTERN,
  AUTO,
  REGISTER,
};

inline static const char *EnumerationName(StorageClass) {
  return "StorageClass";
}

inline static constexpr unsigned NumEnumerators(StorageClass) {
  return 6;
}

const char *EnumeratorName(StorageClass);

enum class StorageDuration : unsigned char {
  FULL_EXPRESSION,
  AUTOMATIC,
  THREAD,
  STATIC,
  DYNAMIC,
};

inline static const char *EnumerationName(StorageDuration) {
  return "StorageDuration";
}

inline static constexpr unsigned NumEnumerators(StorageDuration) {
  return 5;
}

const char *EnumeratorName(StorageDuration);

enum class StoredNameKind : unsigned char {
  STORED_IDENTIFIER,
  STORED_OBJ_C_ZERO_ARGUMENT_SELECTOR,
  STORED_OBJ_C_ONE_ARGUMENT_SELECTOR,
  STORED_CXX_CONSTRUCTOR_NAME,
  STORED_CXX_DESTRUCTOR_NAME,
  STORED_CXX_CONVERSION_FUNCTION_NAME,
  STORED_CXX_OPERATOR_NAME,
  STORED_DECLARATION_NAME_EXTRA,
  // Skipped repeat pasta::kPointerMask
  UNCOMMON_NAME_KIND_OFFSET,
};

inline static const char *EnumerationName(StoredNameKind) {
  return "StoredNameKind";
}

inline static constexpr unsigned NumEnumerators(StoredNameKind) {
  return 9;
}

const char *EnumeratorName(StoredNameKind);

enum class StoredSpecifierKind : unsigned char {
  STORED_IDENTIFIER,
  STORED_DECLARATION,
  STORED_TYPE_SPEC,
  STORED_TYPE_SPEC_WITH_TEMPLATE,
};

inline static const char *EnumerationName(StoredSpecifierKind) {
  return "StoredSpecifierKind";
}

inline static constexpr unsigned NumEnumerators(StoredSpecifierKind) {
  return 4;
}

const char *EnumeratorName(StoredSpecifierKind);

enum class StructReturnConventionKind : unsigned char {
  DEFAULT,
  ON_STACK,
  IN_REGS,
};

inline static const char *EnumerationName(StructReturnConventionKind) {
  return "StructReturnConventionKind";
}

inline static constexpr unsigned NumEnumerators(StructReturnConventionKind) {
  return 3;
}

const char *EnumeratorName(StructReturnConventionKind);

enum class SubExpr : unsigned char {
  CALLEE,
  LHS,
  RHS,
  COUNT,
};

inline static const char *EnumerationName(SubExpr) {
  return "SubExpr";
}

inline static constexpr unsigned NumEnumerators(SubExpr) {
  return 4;
}

const char *EnumeratorName(SubExpr);

enum class SubStmt : unsigned char {
  BODY,
  PROMISE,
  INITIALIZER_SUSPEND,
  FINAL_SUSPEND,
  ON_EXCEPTION,
  ON_FALLTHROUGH,
  ALLOCATE,
  DEALLOCATE,
  RETURN_VALUE,
  RESULT_DECLARATION,
  RETURN_STATEMENT,
  RETURN_STATEMENT_ON_ALLOC_FAILURE,
};

inline static const char *EnumerationName(SubStmt) {
  return "SubStmt";
}

inline static constexpr unsigned NumEnumerators(SubStmt) {
  return 12;
}

const char *EnumeratorName(SubStmt);

enum class SwiftAsyncFramePointerKind : unsigned char {
  AUTO,
  ALWAYS,
  NEVER,
  // Skipped repeat pasta::kDefault
};

inline static const char *EnumerationName(SwiftAsyncFramePointerKind) {
  return "SwiftAsyncFramePointerKind";
}

inline static constexpr unsigned NumEnumerators(SwiftAsyncFramePointerKind) {
  return 3;
}

const char *EnumeratorName(SwiftAsyncFramePointerKind);

enum class SyncScope : unsigned char {
  HIP_SINGLE_THREAD,
  HIP_WAVEFRONT,
  HIP_WORKGROUP,
  HIP_AGENT,
  HIP_SYSTEM,
  OPEN_CL_WORK_GROUP,
  OPEN_CL_DEVICE,
  OPEN_CL_ALL_SVM_DEVICES,
  OPEN_CL_SUB_GROUP,
};

inline static const char *EnumerationName(SyncScope) {
  return "SyncScope";
}

inline static constexpr unsigned NumEnumerators(SyncScope) {
  return 9;
}

const char *EnumeratorName(SyncScope);

enum class Syntax : unsigned char {
  GNU,
  CXX11,
  C2X,
  DECLSPEC,
  MICROSOFT,
  KEYWORD,
  PRAGMA,
  CONTEXT_SENSITIVE_KEYWORD,
};

inline static const char *EnumerationName(Syntax) {
  return "Syntax";
}

inline static constexpr unsigned NumEnumerators(Syntax) {
  return 8;
}

const char *EnumeratorName(Syntax);

enum class TLSModel : unsigned char {
  GENERAL_DYNAMIC_TLS_MODEL,
  LOCAL_DYNAMIC_TLS_MODEL,
  INITIAL_EXEC_TLS_MODEL,
  LOCAL_EXEC_TLS_MODEL,
};

inline static const char *EnumerationName(TLSModel) {
  return "TLSModel";
}

inline static constexpr unsigned NumEnumerators(TLSModel) {
  return 4;
}

const char *EnumeratorName(TLSModel);

enum class TQ : unsigned char {
  CONST,
  RESTRICT,
  VOLATILE,
  CVR_MASK,
};

inline static const char *EnumerationName(TQ) {
  return "TQ";
}

inline static constexpr unsigned NumEnumerators(TQ) {
  return 4;
}

const char *EnumeratorName(TQ);

enum class TagTypeKind : unsigned char {
  STRUCT,
  INTERFACE,
  UNION,
  CLASS,
  ENUM,
};

inline static const char *EnumerationName(TagTypeKind) {
  return "TagTypeKind";
}

inline static constexpr unsigned NumEnumerators(TagTypeKind) {
  return 5;
}

const char *EnumeratorName(TagTypeKind);

enum class TailPaddingUseRules : unsigned char {
  ALWAYS_USE_TAIL_PADDING,
  USE_TAIL_PADDING_UNLESS_POD03,
  USE_TAIL_PADDING_UNLESS_POD11,
};

inline static const char *EnumerationName(TailPaddingUseRules) {
  return "TailPaddingUseRules";
}

inline static constexpr unsigned NumEnumerators(TailPaddingUseRules) {
  return 3;
}

const char *EnumeratorName(TailPaddingUseRules);

enum class TemplateArgumentDependence : unsigned char {
  UNEXPANDED_PACK,
  INSTANTIATION,
  DEPENDENT,
  ERROR,
  NONE,
  DEPENDENT_INSTANTIATION,
  ALL,
};

inline static const char *EnumerationName(TemplateArgumentDependence) {
  return "TemplateArgumentDependence";
}

inline static constexpr unsigned NumEnumerators(TemplateArgumentDependence) {
  return 7;
}

const char *EnumeratorName(TemplateArgumentDependence);

enum class TemplateNameDependence : unsigned char {
  UNEXPANDED_PACK,
  INSTANTIATION,
  DEPENDENT,
  ERROR,
  NONE,
  DEPENDENT_INSTANTIATION,
  ALL,
};

inline static const char *EnumerationName(TemplateNameDependence) {
  return "TemplateNameDependence";
}

inline static constexpr unsigned NumEnumerators(TemplateNameDependence) {
  return 7;
}

const char *EnumeratorName(TemplateNameDependence);

enum class TemplateSpecializationKind : unsigned char {
  UNDECLARED,
  IMPLICIT_INSTANTIATION,
  EXPLICIT_SPECIALIZATION,
  EXPLICIT_INSTANTIATION_DECLARATION,
  EXPLICIT_INSTANTIATION_DEFINITION,
};

inline static const char *EnumerationName(TemplateSpecializationKind) {
  return "TemplateSpecializationKind";
}

inline static constexpr unsigned NumEnumerators(TemplateSpecializationKind) {
  return 5;
}

const char *EnumeratorName(TemplateSpecializationKind);

enum class TextDiagnosticFormat : unsigned char {
  CLANG,
  MSVC,
  VI,
};

inline static const char *EnumerationName(TextDiagnosticFormat) {
  return "TextDiagnosticFormat";
}

inline static constexpr unsigned NumEnumerators(TextDiagnosticFormat) {
  return 3;
}

const char *EnumeratorName(TextDiagnosticFormat);

enum class ThreadModelKind : unsigned char {
  POSIX,
  SINGLE,
};

inline static const char *EnumerationName(ThreadModelKind) {
  return "ThreadModelKind";
}

inline static constexpr unsigned NumEnumerators(ThreadModelKind) {
  return 2;
}

const char *EnumeratorName(ThreadModelKind);

enum class ThreadStorageClassSpecifier : unsigned char {
  UNSPECIFIED,
  __THREAD,
  THREAD_LOCAL,
  _THREAD_LOCAL,
};

inline static const char *EnumerationName(ThreadStorageClassSpecifier) {
  return "ThreadStorageClassSpecifier";
}

inline static constexpr unsigned NumEnumerators(ThreadStorageClassSpecifier) {
  return 4;
}

const char *EnumeratorName(ThreadStorageClassSpecifier);

enum class TokenKind : unsigned short {
  UNKNOWN,
  END_OF_FILE,
  END_OF_DIRECTIVE,
  CODE_COMPLETION,
  COMMENT,
  IDENTIFIER,
  WHITESPACE,
  NUMERIC_CONSTANT,
  CHARACTER_CONSTANT,
  WIDE_CHARACTER_CONSTANT,
  UTF8_CHARACTER_CONSTANT,
  UTF16_CHARACTER_CONSTANT,
  UTF32_CHARACTER_CONSTANT,
  STRING_LITERAL,
  WIDE_STRING_LITERAL,
  HEADER_NAME,
  UTF8_STRING_LITERAL,
  UTF16_STRING_LITERAL,
  UTF32_STRING_LITERAL,
  L_SQUARE,
  R_SQUARE,
  L_PARENTHESIS,
  R_PARENTHESIS,
  L_BRACE_TOKEN,
  R_BRACE_TOKEN,
  PERIOD,
  ELLIPSIS,
  AMP,
  AMP_AMP,
  AMP_EQUAL,
  STAR,
  STAR_EQUAL,
  PLUS,
  PLUS_PLUS,
  PLUS_EQUAL,
  MINUS,
  ARROW,
  MINUS_MINUS,
  MINUS_EQUAL,
  TILDE,
  EXCLAIM,
  EXCLAIM_EQUAL,
  SLASH,
  SLASH_EQUAL,
  PERCENT,
  PERCENT_EQUAL,
  LESS,
  LESS_LESS,
  LESS_EQUAL,
  LESS_LESS_EQUAL,
  SPACESHIP,
  GREATER,
  GREATER_GREATER,
  GREATER_EQUAL,
  GREATER_GREATER_EQUAL,
  CARET,
  CARET_EQUAL,
  PIPE,
  PIPE_PIPE,
  PIPE_EQUAL,
  QUESTION,
  COLON,
  SEMI,
  EQUAL,
  EQUAL_EQUAL,
  COMMA,
  HASH,
  HASH_HASH,
  HASHAT,
  PERIOD_STAR,
  ARROW_STAR,
  COLON_COLON,
  AT,
  LESS_LESS_LESS,
  GREATER_GREATER_GREATER,
  CARETCARET,
  KEYWORD_AUTO,
  KEYWORD_BREAK,
  KEYWORD_CASE,
  KEYWORD_CHARACTER,
  KEYWORD_CONST,
  KEYWORD_CONTINUE,
  KEYWORD_DEFAULT,
  KEYWORD_DO,
  KEYWORD_DOUBLE,
  KEYWORD_ELSE,
  KEYWORD_ENUM,
  KEYWORD_EXTERN,
  KEYWORD_FLOAT,
  KEYWORD_FOR,
  KEYWORD_GOTO,
  KEYWORD_IF,
  KEYWORD_INLINE,
  KEYWORD_INT,
  KEYWORD__EXT_INT,
  KEYWORD__BIT_INT,
  KEYWORD_LONG,
  KEYWORD_REGISTER,
  KEYWORD_RESTRICT,
  KEYWORD_RETURN,
  KEYWORD_SHORT,
  KEYWORD_SIGNED,
  KEYWORD_SIZEOF,
  KEYWORD_STATIC,
  KEYWORD_STRUCT,
  KEYWORD_SWITCH,
  KEYWORD_TYPEDEF,
  KEYWORD_UNION,
  KEYWORD_UNSIGNED,
  KEYWORD_VOID,
  KEYWORD_VOLATILE,
  KEYWORD_WHILE,
  KEYWORD__ALIGNAS,
  KEYWORD__ALIGNOF,
  KEYWORD__ATOMIC,
  KEYWORD__BOOLEAN,
  KEYWORD__COMPLEX,
  KEYWORD__GENERIC,
  KEYWORD__IMAGINARY,
  KEYWORD__NORETURN,
  KEYWORD__STATIC_ASSERT,
  KEYWORD__THREAD_LOCAL,
  KEYWORD___FUNC__,
  KEYWORD___OBJC_YES,
  KEYWORD___OBJC_NO,
  KEYWORD_ASSEMBLY,
  KEYWORD_BOOLEAN,
  KEYWORD_CATCH,
  KEYWORD_CLASS,
  KEYWORD_CONST_CAST,
  KEYWORD_DELETE,
  KEYWORD_DYNAMIC_CAST,
  KEYWORD_EXPLICIT,
  KEYWORD_EXPORT,
  KEYWORD_FALSE,
  KEYWORD_FRIEND,
  KEYWORD_MUTABLE,
  KEYWORD_NAMESPACE,
  KEYWORD_NEW,
  KEYWORD_OPERATOR,
  KEYWORD_PRIVATE,
  KEYWORD_PROTECTED,
  KEYWORD_PUBLIC,
  KEYWORD_REINTERPRET_CAST,
  KEYWORD_STATIC_CAST,
  KEYWORD_TEMPLATE,
  KEYWORD_THIS,
  KEYWORD_THROW,
  KEYWORD_TRUE,
  KEYWORD_TRY,
  KEYWORD_TYPENAME,
  KEYWORD_TYPEID,
  KEYWORD_USING,
  KEYWORD_VIRTUAL,
  KEYWORD_WCHAR_T,
  KEYWORD_ALIGNAS,
  KEYWORD_ALIGNOF,
  KEYWORD_CHAR16_T,
  KEYWORD_CHAR32_T,
  KEYWORD_CONSTEXPR,
  KEYWORD_DECLTYPE,
  KEYWORD_NOEXCEPT,
  KEYWORD_NULLPTR,
  KEYWORD_STATIC_ASSERT,
  KEYWORD_THREAD_LOCAL,
  KEYWORD_CONCEPT,
  KEYWORD_REQUIRES,
  KEYWORD_CO_AWAIT,
  KEYWORD_CO_RETURN,
  KEYWORD_CO_YIELD,
  KEYWORD_MODULE,
  KEYWORD_IMPORT,
  KEYWORD_CONSTEVAL,
  KEYWORD_CONSTINIT,
  KEYWORD_CHAR8_T,
  KEYWORD__FLOAT16,
  KEYWORD__ACCUM,
  KEYWORD__FRACT,
  KEYWORD__SAT,
  KEYWORD__DECIMAL32,
  KEYWORD__DECIMAL64,
  KEYWORD__DECIMAL128,
  KEYWORD___NULL,
  KEYWORD___ALIGNOF,
  KEYWORD___ATTRIBUTE,
  KEYWORD___BUILTIN_CHOOSE_EXPRESSION,
  KEYWORD___BUILTIN_OFFSETOF,
  KEYWORD___BUILTIN_FILE,
  KEYWORD___BUILTIN_FUNCTION,
  KEYWORD___BUILTIN_LINE,
  KEYWORD___BUILTIN_COLUMN,
  KEYWORD___BUILTIN_TYPES_COMPATIBLE_P,
  KEYWORD___BUILTIN_VA_ARGUMENT,
  KEYWORD___EXTENSION__,
  KEYWORD___FLOAT128,
  KEYWORD___IBM128,
  KEYWORD___IMAG,
  KEYWORD___INT128,
  KEYWORD___LABEL__,
  KEYWORD___REAL,
  KEYWORD___THREAD,
  KEYWORD___FUNCTION__,
  KEYWORD___PRETTYFUNCTION__,
  KEYWORD___AUTO_TYPE,
  KEYWORD_TYPEOF,
  KEYWORD___FUNCDNAME__,
  KEYWORD___FUNCSIG__,
  KEYWORD_LFUNCTION__,
  KEYWORD_LFUNCSIG__,
  KEYWORD___IS_INTERFACE_CLASS,
  KEYWORD___IS_SEALED,
  KEYWORD___IS_DESTRUCTIBLE,
  KEYWORD___IS_TRIVIALLY_DESTRUCTIBLE,
  KEYWORD___IS_NOTHROW_DESTRUCTIBLE,
  KEYWORD___IS_NOTHROW_ASSIGNABLE,
  KEYWORD___IS_CONSTRUCTIBLE,
  KEYWORD___IS_NOTHROW_CONSTRUCTIBLE,
  KEYWORD___IS_ASSIGNABLE,
  KEYWORD___HAS_NOTHROW_MOVE_ASSIGN,
  KEYWORD___HAS_TRIVIAL_MOVE_ASSIGN,
  KEYWORD___HAS_TRIVIAL_MOVE_CONSTRUCTOR,
  KEYWORD___HAS_NOTHROW_ASSIGN,
  KEYWORD___HAS_NOTHROW_COPY,
  KEYWORD___HAS_NOTHROW_CONSTRUCTOR,
  KEYWORD___HAS_TRIVIAL_ASSIGN,
  KEYWORD___HAS_TRIVIAL_COPY,
  KEYWORD___HAS_TRIVIAL_CONSTRUCTOR,
  KEYWORD___HAS_TRIVIAL_DESTRUCTOR,
  KEYWORD___HAS_VIRTUAL_DESTRUCTOR,
  KEYWORD___IS_ABSTRACT,
  KEYWORD___IS_AGGREGATE,
  KEYWORD___IS_BASE_OF,
  KEYWORD___IS_CLASS,
  KEYWORD___IS_CONVERTIBLE_TO,
  KEYWORD___IS_EMPTY,
  KEYWORD___IS_ENUM,
  KEYWORD___IS_FINAL,
  KEYWORD___IS_LITERAL,
  KEYWORD___IS_POD,
  KEYWORD___IS_POLYMORPHIC,
  KEYWORD___IS_STANDARD_LAYOUT,
  KEYWORD___IS_TRIVIAL,
  KEYWORD___IS_TRIVIALLY_ASSIGNABLE,
  KEYWORD___IS_TRIVIALLY_CONSTRUCTIBLE,
  KEYWORD___IS_TRIVIALLY_COPYABLE,
  KEYWORD___IS_UNION,
  KEYWORD___HAS_UNIQUE_OBJECT_REPRESENTATIONS,
  KEYWORD___UNDERLYING_TYPE,
  KEYWORD___REFERENCE_BINDS_TO_TEMPORARY,
  KEYWORD___IS_LVALUE_EXPRESSION,
  KEYWORD___IS_RVALUE_EXPRESSION,
  KEYWORD___IS_ARITHMETIC,
  KEYWORD___IS_FLOATING_POINT,
  KEYWORD___IS_INTEGRAL,
  KEYWORD___IS_COMPLETE_TYPE,
  KEYWORD___IS_VOID,
  KEYWORD___IS_ARRAY,
  KEYWORD___IS_FUNCTION,
  KEYWORD___IS_REFERENCE,
  KEYWORD___IS_LVALUE_REFERENCE,
  KEYWORD___IS_RVALUE_REFERENCE,
  KEYWORD___IS_FUNDAMENTAL,
  KEYWORD___IS_OBJECT,
  KEYWORD___IS_SCALAR,
  KEYWORD___IS_COMPOUND,
  KEYWORD___IS_POINTER,
  KEYWORD___IS_MEMBER_OBJECT_POINTER,
  KEYWORD___IS_MEMBER_FUNCTION_POINTER,
  KEYWORD___IS_MEMBER_POINTER,
  KEYWORD___IS_CONST,
  KEYWORD___IS_VOLATILE,
  KEYWORD___IS_SIGNED,
  KEYWORD___IS_UNSIGNED,
  KEYWORD___IS_SAME,
  KEYWORD___IS_CONVERTIBLE,
  KEYWORD___ARRAY_RANK,
  KEYWORD___ARRAY_EXTENT,
  KEYWORD___PRIVATE_EXTERN__,
  KEYWORD___MODULE_PRIVATE__,
  KEYWORD___DECLSPEC,
  KEYWORD___CDECL,
  KEYWORD___STDCALL,
  KEYWORD___FASTCALL,
  KEYWORD___THISCALL,
  KEYWORD___REGCALL,
  KEYWORD___VECTORCALL,
  KEYWORD___FORCEINLINE,
  KEYWORD___UNALIGNED,
  KEYWORD___SUPER,
  KEYWORD___GLOBAL,
  KEYWORD___LOCAL,
  KEYWORD___CONSTANT,
  KEYWORD___PRIVATE,
  KEYWORD___GENERIC,
  KEYWORD___KERNEL,
  KEYWORD___READ_ONLY,
  KEYWORD___WRITE_ONLY,
  KEYWORD___READ_WRITE,
  KEYWORD___BUILTIN_ASTYPE,
  KEYWORD_VEC_STEP,
  KEYWORD_IMAGE_1D_T,
  KEYWORD_IMAGE_1D_ARRAY_T,
  KEYWORD_IMAGE_1D_BUFFER_T,
  KEYWORD_IMAGE_2D_T,
  KEYWORD_IMAGE_2D_ARRAY_T,
  KEYWORD_IMAGE_2D_DEPTH_T,
  KEYWORD_IMAGE_2D_ARRAY_DEPTH_T,
  KEYWORD_IMAGE_2D_MSAA_T,
  KEYWORD_IMAGE_2D_ARRAY_MSAA_T,
  KEYWORD_IMAGE_2D_MSAA_DEPTH_T,
  KEYWORD_IMAGE_2D_ARRAY_MSAA_DEPTH_T,
  KEYWORD_IMAGE_3D_T,
  KEYWORD_PIPE,
  KEYWORD_ADDRSPACE_CAST,
  KEYWORD___BUILTIN_OMP_REQUIRED_SIMD_ALIGN,
  KEYWORD___PASCAL,
  KEYWORD___VECTOR,
  KEYWORD___PIXEL,
  KEYWORD___BOOLEAN,
  KEYWORD___BF16,
  KEYWORD_HALF,
  KEYWORD___BRIDGE,
  KEYWORD___BRIDGE_TRANSFER,
  KEYWORD___BRIDGE_RETAINED,
  KEYWORD___BRIDGE_RETAIN,
  KEYWORD___COVARIANT,
  KEYWORD___CONTRAVARIANT,
  KEYWORD___KINDOF,
  KEYWORD__NONNULL,
  KEYWORD__NULLABLE,
  KEYWORD__NULLABLE_RESULT,
  KEYWORD__NULL_UNSPECIFIED,
  KEYWORD___PTR64,
  KEYWORD___PTR32,
  KEYWORD___SPTR,
  KEYWORD___UPTR,
  KEYWORD___W64,
  KEYWORD___UUIDOF,
  KEYWORD___TRY,
  KEYWORD___FINALLY,
  KEYWORD___LEAVE,
  KEYWORD___INT64,
  KEYWORD___IF_EXISTS,
  KEYWORD___IF_NOT_EXISTS,
  KEYWORD___SINGLE_INHERITANCE,
  KEYWORD___MULTIPLE_INHERITANCE,
  KEYWORD___VIRTUAL_INHERITANCE,
  KEYWORD___INTERFACE,
  KEYWORD___BUILTIN_CONVERTVECTOR,
  KEYWORD___BUILTIN_BIT_CAST,
  KEYWORD___BUILTIN_AVAILABLE,
  KEYWORD___BUILTIN_SYCL_UNIQUE_STABLE_NAME,
  KEYWORD___UNKNOWN_ANYTYPE,
  ANNOT_CXXSCOPE,
  ANNOT_TYPENAME,
  ANNOT_TEMPLATE_ID,
  ANNOT_NON_TYPE,
  ANNOT_NON_TYPE_UNDECLARED,
  ANNOT_NON_TYPE_DEPENDENT,
  ANNOT_OVERLOAD,
  ANNOT_PRIMARY_EXPRESSION,
  ANNOT_DECLTYPE,
  ANNOT_PRAGMA_UNUSED,
  ANNOT_PRAGMA_VIS,
  ANNOT_PRAGMA_PACK,
  ANNOT_PRAGMA_PARSER_CRASH,
  ANNOT_PRAGMA_CAPTURED,
  ANNOT_PRAGMA_DUMP,
  ANNOT_PRAGMA_MSSTRUCT,
  ANNOT_PRAGMA_ALIGN,
  ANNOT_PRAGMA_WEAK,
  ANNOT_PRAGMA_WEAKALIAS,
  ANNOT_PRAGMA_REDEFINE_EXTNAME,
  ANNOT_PRAGMA_FP_CONTRACT,
  ANNOT_PRAGMA_FENV_ACCESS,
  ANNOT_PRAGMA_FENV_ACCESS_MS,
  ANNOT_PRAGMA_FENV_ROUND,
  ANNOT_PRAGMA_FLOAT_CONTROL,
  ANNOT_PRAGMA_MS_POINTERS_TO_MEMBERS,
  ANNOT_PRAGMA_MS_VTORDISP,
  ANNOT_PRAGMA_MS_PRAGMA,
  ANNOT_PRAGMA_OPENCL_EXTENSION,
  ANNOT_ATTRIBUTE_OPENMP,
  ANNOT_PRAGMA_OPENMP,
  ANNOT_PRAGMA_OPENMP_END,
  ANNOT_PRAGMA_LOOP_HINT,
  ANNOT_PRAGMA_FP,
  ANNOT_PRAGMA_ATTRIBUTE,
  ANNOT_MODULE_INCLUDE,
  ANNOT_MODULE_BEGIN,
  ANNOT_MODULE_END,
  ANNOT_HEADER_UNIT,
  PP_IF,
  PP_IFDEF,
  PP_IFNDEF,
  PP_ELIF,
  PP_ELIFDEF,
  PP_ELIFNDEF,
  PP_ELSE,
  PP_ENDIF,
  PP_DEFINED,
  PP_INCLUDE,
  PP___INCLUDE_MACROS,
  PP_DEFINE,
  PP_UNDEF,
  PP_LINE,
  PP_ERROR,
  PP_PRAGMA,
  PP_IMPORT,
  PP_INCLUDE_NEXT,
  PP_WARNING,
  PP_IDENTIFIER,
  PP_SCCS,
  PP_ASSERT,
  PP_UNASSERT,
  PP___PUBLIC_MACRO,
  PP___PRIVATE_MACRO,
  OBJC_AT_CLASS,
  OBJC_AT_COMPATIBILITY_ALIAS,
  OBJC_AT_DEFINITIONS,
  OBJC_AT_ENCODE,
  OBJC_AT_OBJC_END,
  OBJC_AT_IMPLEMENTATION,
  OBJC_AT_INTERFACE,
  OBJC_AT_PRIVATE,
  OBJC_AT_PROTECTED,
  OBJC_AT_PROTOCOL,
  OBJC_AT_PUBLIC,
  OBJC_AT_SELECTOR,
  OBJC_AT_THROW,
  OBJC_AT_TRY,
  OBJC_AT_CATCH,
  OBJC_AT_FINALLY,
  OBJC_AT_SYNCHRONIZED,
  OBJC_AT_AUTORELEASEPOOL,
  OBJC_AT_PROPERTY,
  OBJC_AT_PACKAGE,
  OBJC_AT_REQUIRED,
  OBJC_AT_OPTIONAL,
  OBJC_AT_SYNTHESIZE,
  OBJC_AT_DYNAMIC,
  OBJC_AT_IMPORT,
  OBJC_AT_AVAILABLE,
  BEGIN_OF_FILE_MARKER,
  END_OF_FILE_MARKER,
  BEGIN_OF_MACRO_EXPANSION_MARKER,
  END_OF_MACRO_EXPANSION_MARKER,
};

inline static const char *EnumerationName(TokenKind) {
  return "TokenKind";
}

inline static constexpr unsigned NumEnumerators(TokenKind) {
  return 447;
}

const char *EnumeratorName(TokenKind);

enum class TrailingAllocKind : unsigned char {
  TAK_INHERITS_CONSTRUCTOR,
  TAK_HAS_TAIL_EXPLICIT,
};

inline static const char *EnumerationName(TrailingAllocKind) {
  return "TrailingAllocKind";
}

inline static constexpr unsigned NumEnumerators(TrailingAllocKind) {
  return 2;
}

const char *EnumeratorName(TrailingAllocKind);

enum class TranslationUnitKind : unsigned char {
  COMPLETE,
  PREFIX,
  MODULE,
  INCREMENTAL,
};

inline static const char *EnumerationName(TranslationUnitKind) {
  return "TranslationUnitKind";
}

inline static constexpr unsigned NumEnumerators(TranslationUnitKind) {
  return 4;
}

const char *EnumeratorName(TranslationUnitKind);

enum class TrivialAutoVarInitKind : unsigned char {
  UNINITIALIZED,
  ZERO,
  PATTERN,
};

inline static const char *EnumerationName(TrivialAutoVarInitKind) {
  return "TrivialAutoVarInitKind";
}

inline static constexpr unsigned NumEnumerators(TrivialAutoVarInitKind) {
  return 3;
}

const char *EnumeratorName(TrivialAutoVarInitKind);

enum class TypeDependence : unsigned char {
  UNEXPANDED_PACK,
  INSTANTIATION,
  DEPENDENT,
  VARIABLY_MODIFIED,
  ERROR,
  NONE,
  ALL,
  DEPENDENT_INSTANTIATION,
};

inline static const char *EnumerationName(TypeDependence) {
  return "TypeDependence";
}

inline static constexpr unsigned NumEnumerators(TypeDependence) {
  return 8;
}

const char *EnumeratorName(TypeDependence);

enum class TypeLocClass : unsigned char {
  ADJUSTED,
  DECAYED,
  CONSTANT_ARRAY,
  DEPENDENT_SIZED_ARRAY,
  INCOMPLETE_ARRAY,
  VARIABLE_ARRAY,
  ATOMIC,
  ATTRIBUTED,
  BIT_INT,
  BLOCK_POINTER,
  BUILTIN,
  COMPLEX,
  DECLTYPE,
  AUTO,
  DEDUCED_TEMPLATE_SPECIALIZATION,
  DEPENDENT_ADDRESS_SPACE,
  DEPENDENT_BIT_INT,
  DEPENDENT_NAME,
  DEPENDENT_SIZED_EXT_VECTOR,
  DEPENDENT_TEMPLATE_SPECIALIZATION,
  DEPENDENT_VECTOR,
  ELABORATED,
  FUNCTION_NO_PROTO,
  FUNCTION_PROTO,
  INJECTED_CLASS_NAME,
  MACRO_QUALIFIED,
  CONSTANT_MATRIX,
  DEPENDENT_SIZED_MATRIX,
  MEMBER_POINTER,
  OBJ_C_OBJECT_POINTER,
  OBJ_C_OBJECT,
  OBJ_C_INTERFACE,
  OBJ_C_TYPE_PARAMETER,
  PACK_EXPANSION,
  PARENTHESIS,
  PIPE,
  POINTER,
  L_VALUE_REFERENCE,
  R_VALUE_REFERENCE,
  SUBST_TEMPLATE_TYPE_PARM_PACK,
  SUBST_TEMPLATE_TYPE_PARM,
  ENUM,
  RECORD,
  TEMPLATE_SPECIALIZATION,
  TEMPLATE_TYPE_PARM,
  TYPE_OF_EXPRESSION,
  TYPE_OF,
  TYPEDEF,
  UNARY_TRANSFORM,
  UNRESOLVED_USING,
  USING,
  VECTOR,
  EXT_VECTOR,
  QUALIFIED,
};

inline static const char *EnumerationName(TypeLocClass) {
  return "TypeLocClass";
}

inline static constexpr unsigned NumEnumerators(TypeLocClass) {
  return 54;
}

const char *EnumeratorName(TypeLocClass);

enum class TypeSpecifierSign : unsigned char {
  UNSPECIFIED,
  SIGNED,
  UNSIGNED,
};

inline static const char *EnumerationName(TypeSpecifierSign) {
  return "TypeSpecifierSign";
}

inline static constexpr unsigned NumEnumerators(TypeSpecifierSign) {
  return 3;
}

const char *EnumeratorName(TypeSpecifierSign);

enum class TypeSpecifierType : unsigned char {
  UNSPECIFIED,
  VOID,
  CHARACTER,
  WCHAR,
  CHAR8,
  CHAR16,
  CHAR32,
  INT,
  INT128,
  BITINT,
  HALF,
  FLOAT16,
  ACCUM,
  FRACT,
  B_FLOAT16,
  FLOAT,
  DOUBLE,
  FLOAT128,
  IBM128,
  BOOLEAN,
  DECIMAL32,
  DECIMAL64,
  DECIMAL128,
  ENUM,
  UNION,
  STRUCT,
  CLASS,
  INTERFACE,
  TYPENAME,
  TYPEOF_TYPE,
  TYPEOF_EXPRESSION,
  DECLTYPE,
  UNDERLYING_TYPE,
  AUTO,
  DECLTYPE_AUTO,
  AUTO_TYPE,
  UNKNOWN_ANYTYPE,
  ATOMIC,
  IMAGE_1D_T,
  IMAGE_1D_ARRAY_T,
  IMAGE_1D_BUFFER_T,
  IMAGE_2D_T,
  IMAGE_2D_ARRAY_T,
  IMAGE_2D_DEPTH_T,
  IMAGE_2D_ARRAY_DEPTH_T,
  IMAGE_2D_MSAA_T,
  IMAGE_2D_ARRAY_MSAA_T,
  IMAGE_2D_MSAA_DEPTH_T,
  IMAGE_2D_ARRAY_MSAA_DEPTH_T,
  IMAGE_3D_T,
  ERROR,
};

inline static const char *EnumerationName(TypeSpecifierType) {
  return "TypeSpecifierType";
}

inline static constexpr unsigned NumEnumerators(TypeSpecifierType) {
  return 51;
}

const char *EnumeratorName(TypeSpecifierType);

enum class TypeSpecifierWidth : unsigned char {
  UNSPECIFIED,
  SHORT,
  LONG,
  LONG_LONG,
};

inline static const char *EnumerationName(TypeSpecifierWidth) {
  return "TypeSpecifierWidth";
}

inline static constexpr unsigned NumEnumerators(TypeSpecifierWidth) {
  return 4;
}

const char *EnumeratorName(TypeSpecifierWidth);

enum class TypeSpecifiersPipe : unsigned char {
  UNSPECIFIED,
  PIPE,
};

inline static const char *EnumerationName(TypeSpecifiersPipe) {
  return "TypeSpecifiersPipe";
}

inline static constexpr unsigned NumEnumerators(TypeSpecifiersPipe) {
  return 2;
}

const char *EnumeratorName(TypeSpecifiersPipe);

enum class TypeTrait : unsigned char {
  IS_INTERFACE_CLASS,
  IS_SEALED,
  IS_DESTRUCTIBLE,
  IS_TRIVIALLY_DESTRUCTIBLE,
  IS_NOTHROW_DESTRUCTIBLE,
  HAS_NOTHROW_MOVE_ASSIGN,
  HAS_TRIVIAL_MOVE_ASSIGN,
  HAS_TRIVIAL_MOVE_CONSTRUCTOR,
  HAS_NOTHROW_ASSIGN,
  HAS_NOTHROW_COPY,
  HAS_NOTHROW_CONSTRUCTOR,
  HAS_TRIVIAL_ASSIGN,
  HAS_TRIVIAL_COPY,
  HAS_TRIVIAL_DEFAULT_CONSTRUCTOR,
  HAS_TRIVIAL_DESTRUCTOR,
  HAS_VIRTUAL_DESTRUCTOR,
  IS_ABSTRACT,
  IS_AGGREGATE,
  IS_CLASS,
  IS_EMPTY,
  IS_ENUM,
  IS_FINAL,
  IS_LITERAL,
  IS_POD,
  IS_POLYMORPHIC,
  IS_STANDARD_LAYOUT,
  IS_TRIVIAL,
  IS_TRIVIALLY_COPYABLE,
  IS_UNION,
  HAS_UNIQUE_OBJECT_REPRESENTATIONS,
  IS_ARITHMETIC,
  IS_FLOATING_POINT,
  IS_INTEGRAL,
  IS_COMPLETE_TYPE,
  IS_VOID,
  IS_ARRAY,
  IS_FUNCTION,
  IS_REFERENCE,
  IS_LVALUE_REFERENCE,
  IS_RVALUE_REFERENCE,
  IS_FUNDAMENTAL,
  IS_OBJECT,
  IS_SCALAR,
  IS_COMPOUND,
  IS_POINTER,
  IS_MEMBER_OBJECT_POINTER,
  IS_MEMBER_FUNCTION_POINTER,
  IS_MEMBER_POINTER,
  IS_CONST,
  IS_VOLATILE,
  IS_SIGNED,
  IS_UNSIGNED,
  TYPE_COMPATIBLE,
  IS_NOTHROW_ASSIGNABLE,
  IS_ASSIGNABLE,
  IS_BASE_OF,
  IS_CONVERTIBLE_TO,
  IS_TRIVIALLY_ASSIGNABLE,
  REFERENCE_BINDS_TO_TEMPORARY,
  IS_SAME,
  IS_CONVERTIBLE,
  IS_CONSTRUCTIBLE,
  IS_NOTHROW_CONSTRUCTIBLE,
  IS_TRIVIALLY_CONSTRUCTIBLE,
};

inline static const char *EnumerationName(TypeTrait) {
  return "TypeTrait";
}

inline static constexpr unsigned NumEnumerators(TypeTrait) {
  return 64;
}

const char *EnumeratorName(TypeTrait);

enum class UnaryExprOrTypeTrait : unsigned char {
  SIZE_OF,
  ALIGN_OF,
  PREFERRED_ALIGN_OF,
  VEC_STEP,
  OPEN_MP_REQUIRED_SIMD_ALIGN,
};

inline static const char *EnumerationName(UnaryExprOrTypeTrait) {
  return "UnaryExprOrTypeTrait";
}

inline static constexpr unsigned NumEnumerators(UnaryExprOrTypeTrait) {
  return 5;
}

const char *EnumeratorName(UnaryExprOrTypeTrait);

enum class UnaryOperatorKind : unsigned char {
  POST_INCREMENT,
  POST_DEC,
  PRE_INCREMENT,
  PRE_DEC,
  ADDRESS_OF,
  DEREF,
  PLUS,
  MINUS,
  NOT,
  L_NOT,
  REAL,
  IMAG,
  EXTENSION,
  COAWAIT,
};

inline static const char *EnumerationName(UnaryOperatorKind) {
  return "UnaryOperatorKind";
}

inline static constexpr unsigned NumEnumerators(UnaryOperatorKind) {
  return 14;
}

const char *EnumeratorName(UnaryOperatorKind);

enum class APValueKind : unsigned char {
  NONE,
  INDETERMINATE,
  INT,
  FLOAT,
  FIXED_POINT,
  COMPLEX_INT,
  COMPLEX_FLOAT,
  L_VALUE,
  VECTOR,
  ARRAY,
  STRUCT,
  UNION,
  MEMBER_POINTER,
  ADDRESS_LABEL_DIFF,
};

inline static const char *EnumerationName(APValueKind) {
  return "APValueKind";
}

inline static constexpr unsigned NumEnumerators(APValueKind) {
  return 14;
}

const char *EnumeratorName(APValueKind);

enum class VectorLibrary : unsigned char {
  NO_LIBRARY,
  ACCELERATE,
  LIBMVEC,
  MASSV,
  SVML,
  DARWIN_LIBSYSTEM_M,
};

inline static const char *EnumerationName(VectorLibrary) {
  return "VectorLibrary";
}

inline static constexpr unsigned NumEnumerators(VectorLibrary) {
  return 6;
}

const char *EnumeratorName(VectorLibrary);

enum class Visibility : unsigned char {
  HIDDEN_VISIBILITY,
  PROTECTED_VISIBILITY,
  DEFAULT_VISIBILITY,
};

inline static const char *EnumerationName(Visibility) {
  return "Visibility";
}

inline static constexpr unsigned NumEnumerators(Visibility) {
  return 3;
}

const char *EnumeratorName(Visibility);

enum class AttributeSyntax : unsigned char {
  GNU,
  CXX11,
  C2X,
  DECLSPEC,
  MICROSOFT,
  KEYWORD,
  PRAGMA,
  CONTEXT_SENSITIVE_KEYWORD,
};

inline static const char *EnumerationName(AttributeSyntax) {
  return "AttributeSyntax";
}

inline static constexpr unsigned NumEnumerators(AttributeSyntax) {
  return 8;
}

const char *EnumeratorName(AttributeSyntax);

enum class DeclCategory : unsigned char {
  UNKNOWN,
  LOCAL_VARIABLE,
  GLOBAL_VARIABLE,
  PARAMETER_VARIABLE,
  FUNCTION,
  INSTANCE_METHOD,
  INSTANCE_MEMBER,
  CLASS_METHOD,
  CLASS_MEMBER,
  THIS,
  CLASS,
  STRUCTURE,
  UNION,
  INTERFACE,
  ENUMERATION,
  ENUMERATOR,
  NAMESPACE,
  TYPE_ALIAS,
  TEMPLATE_TYPE_PARAMETER,
  TEMPLATE_VALUE_PARAMETER,
  LABEL,
};

inline static const char *EnumerationName(DeclCategory) {
  return "DeclCategory";
}

inline static constexpr unsigned NumEnumerators(DeclCategory) {
  return 21;
}

const char *EnumeratorName(DeclCategory);

enum class PathKind : unsigned char {
  UNIX,
  WINDOWS,
};

inline static const char *EnumerationName(PathKind) {
  return "PathKind";
}

inline static constexpr unsigned NumEnumerators(PathKind) {
  return 2;
}

const char *EnumeratorName(PathKind);

enum class FileType : unsigned char {
  NONE,
  NOT_FOUND,
  REGULAR,
  DIRECTORY,
  SYMBOLIC_LINK,
  BLOCK,
  CHARACTER,
  FIRST_IN_FIRST_OUT,
  SOCKET,
  KNKNOWN,
};

inline static const char *EnumerationName(FileType) {
  return "FileType";
}

inline static constexpr unsigned NumEnumerators(FileType) {
  return 10;
}

const char *EnumeratorName(FileType);

enum class CompilerName : unsigned char {
  UNKNOWN,
  CLANG,
  APPLE_CLANG,
  CLANG_CL,
  CL,
  GNU,
};

inline static const char *EnumerationName(CompilerName) {
  return "CompilerName";
}

inline static constexpr unsigned NumEnumerators(CompilerName) {
  return 6;
}

const char *EnumeratorName(CompilerName);

enum class IncludePathLocation : unsigned char {
  ABSOLUTE,
  SYSROOT_RELATIVE,
};

inline static const char *EnumerationName(IncludePathLocation) {
  return "IncludePathLocation";
}

inline static constexpr unsigned NumEnumerators(IncludePathLocation) {
  return 2;
}

const char *EnumeratorName(IncludePathLocation);

enum class TargetLanguage : unsigned char {
  C,
  CXX,
};

inline static const char *EnumerationName(TargetLanguage) {
  return "TargetLanguage";
}

inline static constexpr unsigned NumEnumerators(TargetLanguage) {
  return 2;
}

const char *EnumeratorName(TargetLanguage);

enum class PseudoKind : unsigned char {
  TEMPLATE_ARGUMENT,
  TEMPLATE_PARAMETER_LIST,
  CXX_BASE_SPECIFIER,
  DESIGNATOR,
};

inline static const char *EnumerationName(PseudoKind) {
  return "PseudoKind";
}

inline static constexpr unsigned NumEnumerators(PseudoKind) {
  return 4;
}

const char *EnumeratorName(PseudoKind);

class Token;
class TokenRange;
class CXXBaseSpecifier;
class TemplateArgument;
class TemplateParameterList;
class Designator;
class FileToken;
class Decl;
class EmptyDecl;
class ExportDecl;
class ExternCContextDecl;
class FileScopeAsmDecl;
class FriendDecl;
class FriendTemplateDecl;
class ImportDecl;
class LifetimeExtendedTemporaryDecl;
class LinkageSpecDecl;
class NamedDecl;
class NamespaceAliasDecl;
class NamespaceDecl;
class ObjCCompatibleAliasDecl;
class ObjCContainerDecl;
class ObjCImplDecl;
class ObjCImplementationDecl;
class ObjCInterfaceDecl;
class ObjCMethodDecl;
class ObjCPropertyDecl;
class ObjCPropertyImplDecl;
class ObjCProtocolDecl;
class PragmaCommentDecl;
class PragmaDetectMismatchDecl;
class RequiresExprBodyDecl;
class StaticAssertDecl;
class TemplateDecl;
class TemplateTemplateParmDecl;
class TranslationUnitDecl;
class TypeDecl;
class TypedefNameDecl;
class UnresolvedUsingIfExistsDecl;
class UnresolvedUsingTypenameDecl;
class UsingDirectiveDecl;
class UsingPackDecl;
class UsingShadowDecl;
class ValueDecl;
class OMPDeclarativeDirectiveDecl;
class OMPDeclarativeDirectiveValueDecl;
class AccessSpecDecl;
class BaseUsingDecl;
class BindingDecl;
class BlockDecl;
class BuiltinTemplateDecl;
class CapturedDecl;
class ClassScopeFunctionSpecializationDecl;
class ConceptDecl;
class ConstructorUsingShadowDecl;
class DeclaratorDecl;
class EnumConstantDecl;
class FieldDecl;
class FunctionDecl;
class IndirectFieldDecl;
class LabelDecl;
class MSGuidDecl;
class MSPropertyDecl;
class NonTypeTemplateParmDecl;
class OMPAllocateDecl;
class OMPDeclareMapperDecl;
class OMPDeclareReductionDecl;
class OMPRequiresDecl;
class OMPThreadPrivateDecl;
class ObjCAtDefsFieldDecl;
class ObjCCategoryDecl;
class ObjCCategoryImplDecl;
class ObjCIvarDecl;
class ObjCTypeParamDecl;
class RedeclarableTemplateDecl;
class TagDecl;
class TemplateParamObjectDecl;
class TemplateTypeParmDecl;
class TypeAliasDecl;
class TypeAliasTemplateDecl;
class TypedefDecl;
class UnresolvedUsingValueDecl;
class UsingDecl;
class UsingEnumDecl;
class VarDecl;
class VarTemplateDecl;
class VarTemplateSpecializationDecl;
class CXXDeductionGuideDecl;
class CXXMethodDecl;
class ClassTemplateDecl;
class DecompositionDecl;
class EnumDecl;
class FunctionTemplateDecl;
class ImplicitParamDecl;
class OMPCapturedExprDecl;
class ParmVarDecl;
class RecordDecl;
class VarTemplatePartialSpecializationDecl;
class CXXConstructorDecl;
class CXXConversionDecl;
class CXXDestructorDecl;
class CXXRecordDecl;
class ClassTemplateSpecializationDecl;
class ClassTemplatePartialSpecializationDecl;
class Stmt;
class SwitchCase;
class SwitchStmt;
class ValueStmt;
class WhileStmt;
class AsmStmt;
class AttributedStmt;
class BreakStmt;
class CXXCatchStmt;
class CXXForRangeStmt;
class CXXTryStmt;
class CapturedStmt;
class CaseStmt;
class CompoundStmt;
class ContinueStmt;
class CoreturnStmt;
class CoroutineBodyStmt;
class DeclStmt;
class DefaultStmt;
class DoStmt;
class Expr;
class ExpressionTraitExpr;
class ExtVectorElementExpr;
class FixedPointLiteral;
class FloatingLiteral;
class ForStmt;
class FullExpr;
class FunctionParmPackExpr;
class GCCAsmStmt;
class GNUNullExpr;
class GenericSelectionExpr;
class GotoStmt;
class IfStmt;
class ImaginaryLiteral;
class ImplicitValueInitExpr;
class IndirectGotoStmt;
class InitListExpr;
class IntegerLiteral;
class LabelStmt;
class LambdaExpr;
class MSAsmStmt;
class MSDependentExistsStmt;
class MSPropertyRefExpr;
class MSPropertySubscriptExpr;
class MaterializeTemporaryExpr;
class MatrixSubscriptExpr;
class MemberExpr;
class NoInitExpr;
class NullStmt;
class OMPArraySectionExpr;
class OMPArrayShapingExpr;
class OMPCanonicalLoop;
class OMPExecutableDirective;
class OMPFlushDirective;
class OMPInteropDirective;
class OMPIteratorExpr;
class OMPLoopBasedDirective;
class OMPLoopDirective;
class OMPLoopTransformationDirective;
class OMPMaskedDirective;
class OMPMasterDirective;
class OMPMasterTaskLoopDirective;
class OMPMasterTaskLoopSimdDirective;
class OMPMetaDirective;
class OMPOrderedDirective;
class OMPParallelDirective;
class OMPParallelForDirective;
class OMPParallelForSimdDirective;
class OMPParallelMasterDirective;
class OMPParallelMasterTaskLoopDirective;
class OMPParallelMasterTaskLoopSimdDirective;
class OMPParallelSectionsDirective;
class OMPScanDirective;
class OMPSectionDirective;
class OMPSectionsDirective;
class OMPSimdDirective;
class OMPSingleDirective;
class OMPTargetDataDirective;
class OMPTargetDirective;
class OMPTargetEnterDataDirective;
class OMPTargetExitDataDirective;
class OMPTargetParallelDirective;
class OMPTargetParallelForDirective;
class OMPTargetParallelForSimdDirective;
class OMPTargetSimdDirective;
class OMPTargetTeamsDirective;
class OMPTargetTeamsDistributeDirective;
class OMPTargetTeamsDistributeParallelForDirective;
class OMPTargetTeamsDistributeParallelForSimdDirective;
class OMPTargetTeamsDistributeSimdDirective;
class OMPTargetUpdateDirective;
class OMPTaskDirective;
class OMPTaskLoopDirective;
class OMPTaskLoopSimdDirective;
class OMPTaskgroupDirective;
class OMPTaskwaitDirective;
class OMPTaskyieldDirective;
class OMPTeamsDirective;
class OMPTeamsDistributeDirective;
class OMPTeamsDistributeParallelForDirective;
class OMPTeamsDistributeParallelForSimdDirective;
class OMPTeamsDistributeSimdDirective;
class OMPTileDirective;
class OMPUnrollDirective;
class ObjCArrayLiteral;
class ObjCAtCatchStmt;
class ObjCAtFinallyStmt;
class ObjCAtSynchronizedStmt;
class ObjCAtThrowStmt;
class ObjCAtTryStmt;
class ObjCAutoreleasePoolStmt;
class ObjCAvailabilityCheckExpr;
class ObjCBoolLiteralExpr;
class ObjCBoxedExpr;
class ObjCDictionaryLiteral;
class ObjCEncodeExpr;
class ObjCForCollectionStmt;
class ObjCIndirectCopyRestoreExpr;
class ObjCIsaExpr;
class ObjCIvarRefExpr;
class ObjCMessageExpr;
class ObjCPropertyRefExpr;
class ObjCProtocolExpr;
class ObjCSelectorExpr;
class ObjCStringLiteral;
class ObjCSubscriptRefExpr;
class OffsetOfExpr;
class OpaqueValueExpr;
class OverloadExpr;
class PackExpansionExpr;
class ParenExpr;
class ParenListExpr;
class PredefinedExpr;
class PseudoObjectExpr;
class RecoveryExpr;
class RequiresExpr;
class ReturnStmt;
class SEHExceptStmt;
class SEHFinallyStmt;
class SEHLeaveStmt;
class SEHTryStmt;
class SYCLUniqueStableNameExpr;
class ShuffleVectorExpr;
class SizeOfPackExpr;
class SourceLocExpr;
class StmtExpr;
class StringLiteral;
class SubstNonTypeTemplateParmExpr;
class SubstNonTypeTemplateParmPackExpr;
class TypeTraitExpr;
class TypoExpr;
class UnaryExprOrTypeTraitExpr;
class UnaryOperator;
class UnresolvedLookupExpr;
class UnresolvedMemberExpr;
class VAArgExpr;
class AbstractConditionalOperator;
class AddrLabelExpr;
class ArrayInitIndexExpr;
class ArrayInitLoopExpr;
class ArraySubscriptExpr;
class ArrayTypeTraitExpr;
class AsTypeExpr;
class AtomicExpr;
class BinaryConditionalOperator;
class BinaryOperator;
class BlockExpr;
class CXXBindTemporaryExpr;
class CXXBoolLiteralExpr;
class CXXConstructExpr;
class CXXDefaultArgExpr;
class CXXDefaultInitExpr;
class CXXDeleteExpr;
class CXXDependentScopeMemberExpr;
class CXXFoldExpr;
class CXXInheritedCtorInitExpr;
class CXXNewExpr;
class CXXNoexceptExpr;
class CXXNullPtrLiteralExpr;
class CXXPseudoDestructorExpr;
class CXXRewrittenBinaryOperator;
class CXXScalarValueInitExpr;
class CXXStdInitializerListExpr;
class CXXTemporaryObjectExpr;
class CXXThisExpr;
class CXXThrowExpr;
class CXXTypeidExpr;
class CXXUnresolvedConstructExpr;
class CXXUuidofExpr;
class CallExpr;
class CastExpr;
class CharacterLiteral;
class ChooseExpr;
class CompoundAssignOperator;
class CompoundLiteralExpr;
class ConceptSpecializationExpr;
class ConditionalOperator;
class ConstantExpr;
class ConvertVectorExpr;
class CoroutineSuspendExpr;
class CoyieldExpr;
class DeclRefExpr;
class DependentCoawaitExpr;
class DependentScopeDeclRefExpr;
class DesignatedInitExpr;
class DesignatedInitUpdateExpr;
class ExplicitCastExpr;
class ExprWithCleanups;
class ImplicitCastExpr;
class OMPAtomicDirective;
class OMPBarrierDirective;
class OMPCancelDirective;
class OMPCancellationPointDirective;
class OMPCriticalDirective;
class OMPDepobjDirective;
class OMPDispatchDirective;
class OMPDistributeDirective;
class OMPDistributeParallelForDirective;
class OMPDistributeParallelForSimdDirective;
class OMPDistributeSimdDirective;
class OMPForDirective;
class OMPForSimdDirective;
class OMPGenericLoopDirective;
class ObjCBridgedCastExpr;
class UserDefinedLiteral;
class BuiltinBitCastExpr;
class CStyleCastExpr;
class CUDAKernelCallExpr;
class CXXFunctionalCastExpr;
class CXXMemberCallExpr;
class CXXNamedCastExpr;
class CXXOperatorCallExpr;
class CXXReinterpretCastExpr;
class CXXStaticCastExpr;
class CoawaitExpr;
class CXXAddrspaceCastExpr;
class CXXConstCastExpr;
class CXXDynamicCastExpr;
class Type;
class TypeOfExprType;
class TypeOfType;
class TypedefType;
class UnaryTransformType;
class UnresolvedUsingType;
class UsingType;
class VectorType;
class TypeWithKeyword;
class AdjustedType;
class ArrayType;
class AtomicType;
class AttributedType;
class BitIntType;
class BlockPointerType;
class BuiltinType;
class ComplexType;
class ConstantArrayType;
class DecayedType;
class DecltypeType;
class DeducedType;
class DependentAddressSpaceType;
class DependentBitIntType;
class DependentNameType;
class DependentSizedArrayType;
class DependentSizedExtVectorType;
class DependentTemplateSpecializationType;
class DependentVectorType;
class ElaboratedType;
class ExtVectorType;
class FunctionType;
class IncompleteArrayType;
class InjectedClassNameType;
class MacroQualifiedType;
class MatrixType;
class MemberPointerType;
class ObjCObjectPointerType;
class ObjCObjectType;
class ObjCTypeParamType;
class PackExpansionType;
class ParenType;
class PipeType;
class PointerType;
class ReferenceType;
class SubstTemplateTypeParmPackType;
class SubstTemplateTypeParmType;
class TagType;
class TemplateSpecializationType;
class TemplateTypeParmType;
class VariableArrayType;
class AutoType;
class ConstantMatrixType;
class DeducedTemplateSpecializationType;
class DependentSizedMatrixType;
class EnumType;
class FunctionNoProtoType;
class FunctionProtoType;
class LValueReferenceType;
class ObjCInterfaceType;
class RValueReferenceType;
class RecordType;
class Attr;
class BuiltinAliasAttr;
class CalledOnceAttr;
class IFuncAttr;
class InheritableAttr;
class InheritableParamAttr;
class InitPriorityAttr;
class InitSegAttr;
class IntelOclBiccAttr;
class InternalLinkageAttr;
class LTOVisibilityPublicAttr;
class LayoutVersionAttr;
class LeafAttr;
class LifetimeBoundAttr;
class LoaderUninitializedAttr;
class LockReturnedAttr;
class LocksExcludedAttr;
class LoopHintAttr;
class M68kInterruptAttr;
class MIGServerRoutineAttr;
class MSABIAttr;
class MSAllocatorAttr;
class MSInheritanceAttr;
class MSNoVTableAttr;
class MSP430InterruptAttr;
class MSStructAttr;
class MSVtorDispAttr;
class MaxFieldAlignmentAttr;
class MayAliasAttr;
class MicroMipsAttr;
class MinSizeAttr;
class MinVectorWidthAttr;
class Mips16Attr;
class MipsInterruptAttr;
class MipsLongCallAttr;
class MipsShortCallAttr;
class ModeAttr;
class NSConsumedAttr;
class NSConsumesSelfAttr;
class NSErrorDomainAttr;
class NSReturnsAutoreleasedAttr;
class NSReturnsNotRetainedAttr;
class NSReturnsRetainedAttr;
class NakedAttr;
class NoAliasAttr;
class NoBuiltinAttr;
class NoCommonAttr;
class NoDebugAttr;
class NoDestroyAttr;
class NoDuplicateAttr;
class NoEscapeAttr;
class NoInlineAttr;
class NoInstrumentFunctionAttr;
class NoMicroMipsAttr;
class NoMips16Attr;
class NoProfileFunctionAttr;
class NoReturnAttr;
class NoSanitizeAttr;
class NoSpeculativeLoadHardeningAttr;
class NoSplitStackAttr;
class NoStackProtectorAttr;
class NoThreadSafetyAnalysisAttr;
class NoThrowAttr;
class NoUniqueAddressAttr;
class NonNullAttr;
class NotTailCalledAttr;
class OMPAllocateDeclAttr;
class OMPCaptureKindAttr;
class OMPCaptureNoInitAttr;
class OMPDeclareSimdDeclAttr;
class OMPDeclareTargetDeclAttr;
class OMPDeclareVariantAttr;
class OMPReferencedVarAttr;
class OMPThreadPrivateDeclAttr;
class OSConsumedAttr;
class OSConsumesThisAttr;
class OSReturnsNotRetainedAttr;
class OSReturnsRetainedAttr;
class OSReturnsRetainedOnNonZeroAttr;
class OSReturnsRetainedOnZeroAttr;
class ObjCBoxableAttr;
class ObjCBridgeAttr;
class ObjCBridgeMutableAttr;
class ObjCBridgeRelatedAttr;
class ObjCClassStubAttr;
class ObjCDesignatedInitializerAttr;
class ObjCDirectAttr;
class ObjCDirectMembersAttr;
class ObjCExceptionAttr;
class ObjCExplicitProtocolImplAttr;
class ObjCExternallyRetainedAttr;
class ObjCIndependentClassAttr;
class ObjCMethodFamilyAttr;
class ObjCNSObjectAttr;
class ObjCNonLazyClassAttr;
class ObjCNonRuntimeProtocolAttr;
class ObjCOwnershipAttr;
class ObjCPreciseLifetimeAttr;
class ObjCRequiresPropertyDefsAttr;
class ObjCRequiresSuperAttr;
class ObjCReturnsInnerPointerAttr;
class ObjCRootClassAttr;
class ObjCRuntimeNameAttr;
class ObjCRuntimeVisibleAttr;
class ObjCSubclassingRestrictedAttr;
class OpenCLAccessAttr;
class OpenCLIntelReqdSubGroupSizeAttr;
class OpenCLKernelAttr;
class OptimizeNoneAttr;
class OverloadableAttr;
class OverrideAttr;
class OwnerAttr;
class OwnershipAttr;
class PackedAttr;
class ParamTypestateAttr;
class ParameterABIAttr;
class PascalAttr;
class PassObjectSizeAttr;
class PatchableFunctionEntryAttr;
class PcsAttr;
class PointerAttr;
class PragmaClangBSSSectionAttr;
class PragmaClangDataSectionAttr;
class PragmaClangRelroSectionAttr;
class PragmaClangRodataSectionAttr;
class PragmaClangTextSectionAttr;
class PreferredNameAttr;
class PreserveAllAttr;
class PreserveMostAttr;
class PtGuardedByAttr;
class PtGuardedVarAttr;
class PureAttr;
class RISCVInterruptAttr;
class RegCallAttr;
class ReinitializesAttr;
class ReleaseCapabilityAttr;
class ReleaseHandleAttr;
class RenderScriptKernelAttr;
class ReqdWorkGroupSizeAttr;
class RequiresCapabilityAttr;
class RestrictAttr;
class RetainAttr;
class ReturnTypestateAttr;
class ReturnsNonNullAttr;
class ReturnsTwiceAttr;
class SYCLKernelAttr;
class SYCLSpecialClassAttr;
class ScopedLockableAttr;
class SectionAttr;
class SelectAnyAttr;
class SentinelAttr;
class SetTypestateAttr;
class SharedTrylockFunctionAttr;
class SpeculativeLoadHardeningAttr;
class StandaloneDebugAttr;
class StdCallAttr;
class StmtAttr;
class StrictFPAttr;
class SuppressAttr;
class SwiftAsyncAttr;
class SwiftAsyncCallAttr;
class SwiftAsyncContextAttr;
class SwiftAsyncErrorAttr;
class SwiftAsyncNameAttr;
class SwiftAttrAttr;
class SwiftBridgeAttr;
class SwiftBridgedTypedefAttr;
class SwiftCallAttr;
class SwiftContextAttr;
class SwiftErrorAttr;
class SwiftErrorResultAttr;
class SwiftIndirectResultAttr;
class SwiftNameAttr;
class SwiftNewTypeAttr;
class SwiftObjCMembersAttr;
class SwiftPrivateAttr;
class SysVABIAttr;
class TLSModelAttr;
class TargetAttr;
class TargetClonesAttr;
class TestTypestateAttr;
class ThisCallAttr;
class ThreadAttr;
class TransparentUnionAttr;
class TrivialABIAttr;
class TryAcquireCapabilityAttr;
class TypeAttr;
class TypeNonNullAttr;
class TypeNullUnspecifiedAttr;
class TypeNullableAttr;
class TypeNullableResultAttr;
class TypeTagForDatatypeAttr;
class TypeVisibilityAttr;
class UPtrAttr;
class UnavailableAttr;
class UninitializedAttr;
class UnlikelyAttr;
class UnusedAttr;
class UseHandleAttr;
class UsedAttr;
class UsingIfExistsAttr;
class UuidAttr;
class VecReturnAttr;
class VecTypeHintAttr;
class VectorCallAttr;
class VisibilityAttr;
class WarnUnusedAttr;
class WarnUnusedResultAttr;
class WeakAttr;
class WeakImportAttr;
class WeakRefAttr;
class WebAssemblyExportNameAttr;
class WebAssemblyImportModuleAttr;
class WebAssemblyImportNameAttr;
class WorkGroupSizeHintAttr;
class X86ForceAlignArgPointerAttr;
class XRayInstrumentAttr;
class XRayLogArgsAttr;
class AArch64VectorPcsAttr;
class AMDGPUFlatWorkGroupSizeAttr;
class AMDGPUNumSGPRAttr;
class AMDGPUNumVGPRAttr;
class AMDGPUWavesPerEUAttr;
class ARMInterruptAttr;
class AVRInterruptAttr;
class AVRSignalAttr;
class AbiTagAttr;
class AcquireCapabilityAttr;
class AcquireHandleAttr;
class AcquiredAfterAttr;
class AcquiredBeforeAttr;
class AddressSpaceAttr;
class AliasAttr;
class AlignMac68kAttr;
class AlignNaturalAttr;
class AlignValueAttr;
class AlignedAttr;
class AllocAlignAttr;
class AllocSizeAttr;
class AlwaysDestroyAttr;
class AlwaysInlineAttr;
class AnalyzerNoReturnAttr;
class AnnotateAttr;
class AnyX86InterruptAttr;
class AnyX86NoCallerSavedRegistersAttr;
class AnyX86NoCfCheckAttr;
class ArcWeakrefUnavailableAttr;
class ArgumentWithTypeTagAttr;
class ArmBuiltinAliasAttr;
class ArmMveStrictPolymorphismAttr;
class ArtificialAttr;
class AsmLabelAttr;
class AssertCapabilityAttr;
class AssertExclusiveLockAttr;
class AssertSharedLockAttr;
class AssumeAlignedAttr;
class AssumptionAttr;
class AvailabilityAttr;
class BPFPreserveAccessIndexAttr;
class BTFDeclTagAttr;
class BTFTypeTagAttr;
class BlocksAttr;
class BuiltinAttr;
class C11NoReturnAttr;
class CDeclAttr;
class CFAuditedTransferAttr;
class CFConsumedAttr;
class CFGuardAttr;
class CFICanonicalJumpTableAttr;
class CFReturnsNotRetainedAttr;
class CFReturnsRetainedAttr;
class CFUnknownTransferAttr;
class CPUDispatchAttr;
class CPUSpecificAttr;
class CUDAConstantAttr;
class CUDADeviceAttr;
class CUDADeviceBuiltinSurfaceTypeAttr;
class CUDADeviceBuiltinTextureTypeAttr;
class CUDAGlobalAttr;
class CUDAHostAttr;
class CUDAInvalidTargetAttr;
class CUDALaunchBoundsAttr;
class CUDASharedAttr;
class CXX11NoReturnAttr;
class CallableWhenAttr;
class CallbackAttr;
class CapabilityAttr;
class CapturedRecordAttr;
class CarriesDependencyAttr;
class CleanupAttr;
class CmseNSCallAttr;
class CmseNSEntryAttr;
class CodeSegAttr;
class ColdAttr;
class CommonAttr;
class ConstAttr;
class ConstInitAttr;
class ConstructorAttr;
class ConsumableAttr;
class ConsumableAutoCastAttr;
class ConsumableSetOnReadAttr;
class ConvergentAttr;
class DLLExportAttr;
class DLLExportStaticLocalAttr;
class DLLImportAttr;
class DLLImportStaticLocalAttr;
class DeclOrStmtAttr;
class DeprecatedAttr;
class DestructorAttr;
class DiagnoseAsBuiltinAttr;
class DiagnoseIfAttr;
class DisableSanitizerInstrumentationAttr;
class DisableTailCallsAttr;
class EmptyBasesAttr;
class EnableIfAttr;
class EnforceTCBAttr;
class EnforceTCBLeafAttr;
class EnumExtensibilityAttr;
class ErrorAttr;
class ExcludeFromExplicitInstantiationAttr;
class ExclusiveTrylockFunctionAttr;
class ExternalSourceSymbolAttr;
class FallThroughAttr;
class FastCallAttr;
class FinalAttr;
class FlagEnumAttr;
class FlattenAttr;
class FormatArgAttr;
class FormatAttr;
class GNUInlineAttr;
class GuardedByAttr;
class GuardedVarAttr;
class HIPManagedAttr;
class HotAttr;
class IBActionAttr;
class IBOutletAttr;
class IBOutletCollectionAttr;
class LikelyAttr;
class MustTailAttr;
class NoDerefAttr;
class NoMergeAttr;
class ObjCGCAttr;
class ObjCInertUnsafeUnretainedAttr;
class ObjCKindOfAttr;
class OpenCLConstantAddressSpaceAttr;
class OpenCLGenericAddressSpaceAttr;
class OpenCLGlobalAddressSpaceAttr;
class OpenCLGlobalDeviceAddressSpaceAttr;
class OpenCLGlobalHostAddressSpaceAttr;
class OpenCLLocalAddressSpaceAttr;
class OpenCLPrivateAddressSpaceAttr;
class OpenCLUnrollHintAttr;
class Ptr32Attr;
class Ptr64Attr;
class SPtrAttr;
#if !defined(MX_DISABLE_API) || defined(MX_ENABLE_API)
class Designator {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  Designator(Designator &&) noexcept = default;
  Designator(const Designator &) = default;
  Designator &operator=(Designator &&) noexcept = default;
  Designator &operator=(const Designator &) = default;

  inline Designator(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  bool is_field_designator(void) const;
  bool is_array_designator(void) const;
  bool is_array_range_designator(void) const;
  std::optional<FieldDecl> field(void) const;
  TokenRange tokens(void) const;
  Token dot_token(void) const;
  Token field_token(void) const;
  Token left_bracket_token(void) const;
  Token right_bracket_token(void) const;
  Token ellipsis_token(void) const;
  std::optional<unsigned> first_expression_index(void) const;
};

class TemplateParameterList {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  TemplateParameterList(TemplateParameterList &&) noexcept = default;
  TemplateParameterList(const TemplateParameterList &) = default;
  TemplateParameterList &operator=(TemplateParameterList &&) noexcept = default;
  TemplateParameterList &operator=(const TemplateParameterList &) = default;

  inline TemplateParameterList(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  unsigned num_parameters(void) const;
  unsigned num_required_parameters(void) const;
  unsigned depth(void) const;
  bool has_unexpanded_parameter_pack(void) const;
  bool has_parameter_pack(void) const;
  std::optional<Expr> requires_clause(void) const;
  Token template_keyword_token(void) const;
  Token left_angle_token(void) const;
  Token right_angle_token(void) const;
  TokenRange tokens(void) const;
  std::vector<NamedDecl> parameters(void) const;
};

class TemplateArgument {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  TemplateArgument(TemplateArgument &&) noexcept = default;
  TemplateArgument(const TemplateArgument &) = default;
  TemplateArgument &operator=(TemplateArgument &&) noexcept = default;
  TemplateArgument &operator=(const TemplateArgument &) = default;

  inline TemplateArgument(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  TemplateArgumentKind kind(void) const;
  bool is_null(void) const;
  bool is_dependent(void) const;
  bool is_instantiation_dependent(void) const;
  bool contains_unexpanded_parameter_pack(void) const;
  bool is_pack_expansion(void) const;
  std::optional<ValueDecl> as_declaration(void) const;
  std::optional<Type> as_type(void) const;
  std::optional<Type> parameter_type_for_declaration(void) const;
  std::optional<Type> null_pointer_type(void) const;
};

class CXXBaseSpecifier {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  CXXBaseSpecifier(CXXBaseSpecifier &&) noexcept = default;
  CXXBaseSpecifier(const CXXBaseSpecifier &) = default;
  CXXBaseSpecifier &operator=(CXXBaseSpecifier &&) noexcept = default;
  CXXBaseSpecifier &operator=(const CXXBaseSpecifier &) = default;

  inline CXXBaseSpecifier(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  TokenRange tokens(void) const;
  Token base_type_token(void) const;
  bool is_virtual(void) const;
  TagTypeKind base_kind(void) const;
  bool is_pack_expansion(void) const;
  bool constructors_are_inherited(void) const;
  std::optional<Token> ellipsis_token(void) const;
  AccessSpecifier semantic_access_specifier(void) const;
  AccessSpecifier lexical_access_specifier(void) const;
  Type base_type(void) const;
};

using AttrRange = DerivedEntityRange<AttrIterator, Attr>;
using AttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, Attr>;
class Attr {
 protected:
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  Attr(Attr &&) noexcept = default;
  Attr(const Attr &) = default;
  Attr &operator=(Attr &&) noexcept = default;
  Attr &operator=(const Attr &) = default;

  inline Attr(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  inline static std::optional<Attr> from(const Attr &self) {
    return self;
  }

  inline static std::optional<Attr> from(const std::optional<Attr> &self) {
    return self;
  }

  inline static std::optional<Attr> from(const TokenContext &c) {
    return c.as_attribute();
  }

  EntityId id(void) const;
  UseRange<AttrUseSelector> uses(void) const;

 protected:
  static AttrIterator in_internal(const Fragment &fragment);

 public:
  inline static AttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Attr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  Token token(void) const;
  bool is_implicit(void) const;
  bool is_inherited(void) const;
  bool is_late_parsed(void) const;
  bool is_pack_expansion(void) const;
  AttrKind kind(void) const;
  TokenRange tokens(void) const;
};

using AlignValueAttrRange = DerivedEntityRange<AttrIterator, AlignValueAttr>;
using AlignValueAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlignValueAttr>;
class AlignValueAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static AlignValueAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlignValueAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlignValueAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALIGN_VALUE;
  }

  static std::optional<AlignValueAttr> from(const TokenContext &c);
  static std::optional<AlignValueAttr> from(const Attr &parent);

  inline static std::optional<AlignValueAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlignValueAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr alignment(void) const;
  std::string_view spelling(void) const;
};

using AliasAttrRange = DerivedEntityRange<AttrIterator, AliasAttr>;
using AliasAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AliasAttr>;
class AliasAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static AliasAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AliasAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AliasAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALIAS;
  }

  static std::optional<AliasAttr> from(const TokenContext &c);
  static std::optional<AliasAttr> from(const Attr &parent);

  inline static std::optional<AliasAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view aliasee(void) const;
  std::string_view spelling(void) const;
};

using AbiTagAttrRange = DerivedEntityRange<AttrIterator, AbiTagAttr>;
using AbiTagAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AbiTagAttr>;
class AbiTagAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static AbiTagAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AbiTagAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AbiTagAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ABI_TAG;
  }

  static std::optional<AbiTagAttr> from(const TokenContext &c);
  static std::optional<AbiTagAttr> from(const Attr &parent);

  inline static std::optional<AbiTagAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AbiTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TypeAttrRange = DerivedEntityRange<AttrIterator, TypeAttr>;
using TypeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeAttr>;
class TypeAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static TypeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<TypeAttr> from(const TokenContext &c);
  static std::optional<TypeAttr> from(const Attr &parent);

  inline static std::optional<TypeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using SPtrAttrRange = DerivedEntityRange<AttrIterator, SPtrAttr>;
using SPtrAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SPtrAttr>;
class SPtrAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static SPtrAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SPtrAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SPtrAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::S_PTR;
  }

  static std::optional<SPtrAttr> from(const TokenContext &c);
  static std::optional<SPtrAttr> from(const TypeAttr &parent);

  inline static std::optional<SPtrAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return SPtrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SPtrAttr> from(const Attr &parent);

  inline static std::optional<SPtrAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SPtrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using Ptr64AttrRange = DerivedEntityRange<AttrIterator, Ptr64Attr>;
using Ptr64AttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, Ptr64Attr>;
class Ptr64Attr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static Ptr64AttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static Ptr64AttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Ptr64Attr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PTR64;
  }

  static std::optional<Ptr64Attr> from(const TokenContext &c);
  static std::optional<Ptr64Attr> from(const TypeAttr &parent);

  inline static std::optional<Ptr64Attr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return Ptr64Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<Ptr64Attr> from(const Attr &parent);

  inline static std::optional<Ptr64Attr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return Ptr64Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using Ptr32AttrRange = DerivedEntityRange<AttrIterator, Ptr32Attr>;
using Ptr32AttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, Ptr32Attr>;
class Ptr32Attr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static Ptr32AttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static Ptr32AttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Ptr32Attr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PTR32;
  }

  static std::optional<Ptr32Attr> from(const TokenContext &c);
  static std::optional<Ptr32Attr> from(const TypeAttr &parent);

  inline static std::optional<Ptr32Attr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return Ptr32Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<Ptr32Attr> from(const Attr &parent);

  inline static std::optional<Ptr32Attr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return Ptr32Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLPrivateAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLPrivateAddressSpaceAttr>;
using OpenCLPrivateAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLPrivateAddressSpaceAttr>;
class OpenCLPrivateAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLPrivateAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLPrivateAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLPrivateAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_PRIVATE_ADDRESS_SPACE;
  }

  static std::optional<OpenCLPrivateAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLPrivateAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLPrivateAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLPrivateAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLPrivateAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLPrivateAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLPrivateAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLPrivateAddressSpaceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using OpenCLLocalAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLLocalAddressSpaceAttr>;
using OpenCLLocalAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLLocalAddressSpaceAttr>;
class OpenCLLocalAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLLocalAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLLocalAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLLocalAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_LOCAL_ADDRESS_SPACE;
  }

  static std::optional<OpenCLLocalAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLLocalAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLLocalAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLLocalAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLLocalAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLLocalAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLLocalAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLLocalAddressSpaceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using OpenCLGlobalHostAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLGlobalHostAddressSpaceAttr>;
using OpenCLGlobalHostAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLGlobalHostAddressSpaceAttr>;
class OpenCLGlobalHostAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLGlobalHostAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLGlobalHostAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLGlobalHostAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_GLOBAL_HOST_ADDRESS_SPACE;
  }

  static std::optional<OpenCLGlobalHostAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLGlobalHostAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLGlobalHostAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLGlobalHostAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLGlobalHostAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLGlobalHostAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLGlobalHostAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLGlobalDeviceAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLGlobalDeviceAddressSpaceAttr>;
using OpenCLGlobalDeviceAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLGlobalDeviceAddressSpaceAttr>;
class OpenCLGlobalDeviceAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLGlobalDeviceAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLGlobalDeviceAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLGlobalDeviceAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_GLOBAL_DEVICE_ADDRESS_SPACE;
  }

  static std::optional<OpenCLGlobalDeviceAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLGlobalDeviceAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLGlobalDeviceAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLGlobalDeviceAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLGlobalDeviceAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLGlobalDeviceAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLGlobalDeviceAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLGlobalAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLGlobalAddressSpaceAttr>;
using OpenCLGlobalAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLGlobalAddressSpaceAttr>;
class OpenCLGlobalAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLGlobalAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLGlobalAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLGlobalAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_GLOBAL_ADDRESS_SPACE;
  }

  static std::optional<OpenCLGlobalAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLGlobalAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLGlobalAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLGlobalAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLGlobalAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLGlobalAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLGlobalAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLGlobalAddressSpaceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using OpenCLGenericAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLGenericAddressSpaceAttr>;
using OpenCLGenericAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLGenericAddressSpaceAttr>;
class OpenCLGenericAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLGenericAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLGenericAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLGenericAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_GENERIC_ADDRESS_SPACE;
  }

  static std::optional<OpenCLGenericAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLGenericAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLGenericAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLGenericAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLGenericAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLGenericAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLGenericAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLGenericAddressSpaceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using OpenCLConstantAddressSpaceAttrRange = DerivedEntityRange<AttrIterator, OpenCLConstantAddressSpaceAttr>;
using OpenCLConstantAddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLConstantAddressSpaceAttr>;
class OpenCLConstantAddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static OpenCLConstantAddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLConstantAddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLConstantAddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_CONSTANT_ADDRESS_SPACE;
  }

  static std::optional<OpenCLConstantAddressSpaceAttr> from(const TokenContext &c);
  static std::optional<OpenCLConstantAddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<OpenCLConstantAddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return OpenCLConstantAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLConstantAddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<OpenCLConstantAddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLConstantAddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLConstantAddressSpaceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using ObjCKindOfAttrRange = DerivedEntityRange<AttrIterator, ObjCKindOfAttr>;
using ObjCKindOfAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCKindOfAttr>;
class ObjCKindOfAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static ObjCKindOfAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCKindOfAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCKindOfAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_KIND_OF;
  }

  static std::optional<ObjCKindOfAttr> from(const TokenContext &c);
  static std::optional<ObjCKindOfAttr> from(const TypeAttr &parent);

  inline static std::optional<ObjCKindOfAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return ObjCKindOfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCKindOfAttr> from(const Attr &parent);

  inline static std::optional<ObjCKindOfAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCKindOfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCInertUnsafeUnretainedAttrRange = DerivedEntityRange<AttrIterator, ObjCInertUnsafeUnretainedAttr>;
using ObjCInertUnsafeUnretainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCInertUnsafeUnretainedAttr>;
class ObjCInertUnsafeUnretainedAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static ObjCInertUnsafeUnretainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCInertUnsafeUnretainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCInertUnsafeUnretainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_INERT_UNSAFE_UNRETAINED;
  }

  static std::optional<ObjCInertUnsafeUnretainedAttr> from(const TokenContext &c);
  static std::optional<ObjCInertUnsafeUnretainedAttr> from(const TypeAttr &parent);

  inline static std::optional<ObjCInertUnsafeUnretainedAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return ObjCInertUnsafeUnretainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCInertUnsafeUnretainedAttr> from(const Attr &parent);

  inline static std::optional<ObjCInertUnsafeUnretainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCInertUnsafeUnretainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCGCAttrRange = DerivedEntityRange<AttrIterator, ObjCGCAttr>;
using ObjCGCAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCGCAttr>;
class ObjCGCAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static ObjCGCAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCGCAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCGCAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_CGC;
  }

  static std::optional<ObjCGCAttr> from(const TokenContext &c);
  static std::optional<ObjCGCAttr> from(const TypeAttr &parent);

  inline static std::optional<ObjCGCAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return ObjCGCAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCGCAttr> from(const Attr &parent);

  inline static std::optional<ObjCGCAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCGCAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoDerefAttrRange = DerivedEntityRange<AttrIterator, NoDerefAttr>;
using NoDerefAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoDerefAttr>;
class NoDerefAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static NoDerefAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoDerefAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoDerefAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_DEREF;
  }

  static std::optional<NoDerefAttr> from(const TokenContext &c);
  static std::optional<NoDerefAttr> from(const TypeAttr &parent);

  inline static std::optional<NoDerefAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return NoDerefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoDerefAttr> from(const Attr &parent);

  inline static std::optional<NoDerefAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoDerefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CmseNSCallAttrRange = DerivedEntityRange<AttrIterator, CmseNSCallAttr>;
using CmseNSCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CmseNSCallAttr>;
class CmseNSCallAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static CmseNSCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CmseNSCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CmseNSCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CMSE_NS_CALL;
  }

  static std::optional<CmseNSCallAttr> from(const TokenContext &c);
  static std::optional<CmseNSCallAttr> from(const TypeAttr &parent);

  inline static std::optional<CmseNSCallAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return CmseNSCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CmseNSCallAttr> from(const Attr &parent);

  inline static std::optional<CmseNSCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CmseNSCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using BTFTypeTagAttrRange = DerivedEntityRange<AttrIterator, BTFTypeTagAttr>;
using BTFTypeTagAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BTFTypeTagAttr>;
class BTFTypeTagAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static BTFTypeTagAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BTFTypeTagAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BTFTypeTagAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BTF_TYPE_TAG;
  }

  static std::optional<BTFTypeTagAttr> from(const TokenContext &c);
  static std::optional<BTFTypeTagAttr> from(const TypeAttr &parent);

  inline static std::optional<BTFTypeTagAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return BTFTypeTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BTFTypeTagAttr> from(const Attr &parent);

  inline static std::optional<BTFTypeTagAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BTFTypeTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view btf_type_tag(void) const;
  std::string_view spelling(void) const;
};

using ArmMveStrictPolymorphismAttrRange = DerivedEntityRange<AttrIterator, ArmMveStrictPolymorphismAttr>;
using ArmMveStrictPolymorphismAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArmMveStrictPolymorphismAttr>;
class ArmMveStrictPolymorphismAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static ArmMveStrictPolymorphismAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArmMveStrictPolymorphismAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArmMveStrictPolymorphismAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARM_MVE_STRICT_POLYMORPHISM;
  }

  static std::optional<ArmMveStrictPolymorphismAttr> from(const TokenContext &c);
  static std::optional<ArmMveStrictPolymorphismAttr> from(const TypeAttr &parent);

  inline static std::optional<ArmMveStrictPolymorphismAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return ArmMveStrictPolymorphismAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArmMveStrictPolymorphismAttr> from(const Attr &parent);

  inline static std::optional<ArmMveStrictPolymorphismAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ArmMveStrictPolymorphismAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AddressSpaceAttrRange = DerivedEntityRange<AttrIterator, AddressSpaceAttr>;
using AddressSpaceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AddressSpaceAttr>;
class AddressSpaceAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static AddressSpaceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AddressSpaceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AddressSpaceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ADDRESS_SPACE;
  }

  static std::optional<AddressSpaceAttr> from(const TokenContext &c);
  static std::optional<AddressSpaceAttr> from(const TypeAttr &parent);

  inline static std::optional<AddressSpaceAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return AddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AddressSpaceAttr> from(const Attr &parent);

  inline static std::optional<AddressSpaceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AddressSpaceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UPtrAttrRange = DerivedEntityRange<AttrIterator, UPtrAttr>;
using UPtrAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UPtrAttr>;
class UPtrAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static UPtrAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UPtrAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UPtrAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::U_PTR;
  }

  static std::optional<UPtrAttr> from(const TokenContext &c);
  static std::optional<UPtrAttr> from(const TypeAttr &parent);

  inline static std::optional<UPtrAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return UPtrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UPtrAttr> from(const Attr &parent);

  inline static std::optional<UPtrAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UPtrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TypeNullableResultAttrRange = DerivedEntityRange<AttrIterator, TypeNullableResultAttr>;
using TypeNullableResultAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeNullableResultAttr>;
class TypeNullableResultAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static TypeNullableResultAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeNullableResultAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeNullableResultAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_NULLABLE_RESULT;
  }

  static std::optional<TypeNullableResultAttr> from(const TokenContext &c);
  static std::optional<TypeNullableResultAttr> from(const TypeAttr &parent);

  inline static std::optional<TypeNullableResultAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return TypeNullableResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeNullableResultAttr> from(const Attr &parent);

  inline static std::optional<TypeNullableResultAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeNullableResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TypeNullableAttrRange = DerivedEntityRange<AttrIterator, TypeNullableAttr>;
using TypeNullableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeNullableAttr>;
class TypeNullableAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static TypeNullableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeNullableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeNullableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_NULLABLE;
  }

  static std::optional<TypeNullableAttr> from(const TokenContext &c);
  static std::optional<TypeNullableAttr> from(const TypeAttr &parent);

  inline static std::optional<TypeNullableAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return TypeNullableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeNullableAttr> from(const Attr &parent);

  inline static std::optional<TypeNullableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeNullableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TypeNullUnspecifiedAttrRange = DerivedEntityRange<AttrIterator, TypeNullUnspecifiedAttr>;
using TypeNullUnspecifiedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeNullUnspecifiedAttr>;
class TypeNullUnspecifiedAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static TypeNullUnspecifiedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeNullUnspecifiedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeNullUnspecifiedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_NULL_UNSPECIFIED;
  }

  static std::optional<TypeNullUnspecifiedAttr> from(const TokenContext &c);
  static std::optional<TypeNullUnspecifiedAttr> from(const TypeAttr &parent);

  inline static std::optional<TypeNullUnspecifiedAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return TypeNullUnspecifiedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeNullUnspecifiedAttr> from(const Attr &parent);

  inline static std::optional<TypeNullUnspecifiedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeNullUnspecifiedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TypeNonNullAttrRange = DerivedEntityRange<AttrIterator, TypeNonNullAttr>;
using TypeNonNullAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeNonNullAttr>;
class TypeNonNullAttr : public TypeAttr {
 private:
  friend class FragmentImpl;
  friend class TypeAttr;
  friend class Attr;
 public:
  inline static TypeNonNullAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeNonNullAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeNonNullAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_NON_NULL;
  }

  static std::optional<TypeNonNullAttr> from(const TokenContext &c);
  static std::optional<TypeNonNullAttr> from(const TypeAttr &parent);

  inline static std::optional<TypeNonNullAttr> from(const std::optional<TypeAttr> &parent) {
    if (parent) {
      return TypeNonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeNonNullAttr> from(const Attr &parent);

  inline static std::optional<TypeNonNullAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeNonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ThreadAttrRange = DerivedEntityRange<AttrIterator, ThreadAttr>;
using ThreadAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ThreadAttr>;
class ThreadAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ThreadAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ThreadAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ThreadAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::THREAD;
  }

  static std::optional<ThreadAttr> from(const TokenContext &c);
  static std::optional<ThreadAttr> from(const Attr &parent);

  inline static std::optional<ThreadAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ThreadAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftObjCMembersAttrRange = DerivedEntityRange<AttrIterator, SwiftObjCMembersAttr>;
using SwiftObjCMembersAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftObjCMembersAttr>;
class SwiftObjCMembersAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static SwiftObjCMembersAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftObjCMembersAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftObjCMembersAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_OBJ_C_MEMBERS;
  }

  static std::optional<SwiftObjCMembersAttr> from(const TokenContext &c);
  static std::optional<SwiftObjCMembersAttr> from(const Attr &parent);

  inline static std::optional<SwiftObjCMembersAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftObjCMembersAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using StmtAttrRange = DerivedEntityRange<AttrIterator, StmtAttr>;
using StmtAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, StmtAttr>;
class StmtAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static StmtAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StmtAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StmtAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<StmtAttr> from(const TokenContext &c);
  static std::optional<StmtAttr> from(const Attr &parent);

  inline static std::optional<StmtAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return StmtAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OpenCLUnrollHintAttrRange = DerivedEntityRange<AttrIterator, OpenCLUnrollHintAttr>;
using OpenCLUnrollHintAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLUnrollHintAttr>;
class OpenCLUnrollHintAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static OpenCLUnrollHintAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLUnrollHintAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLUnrollHintAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_UNROLL_HINT;
  }

  static std::optional<OpenCLUnrollHintAttr> from(const TokenContext &c);
  static std::optional<OpenCLUnrollHintAttr> from(const StmtAttr &parent);

  inline static std::optional<OpenCLUnrollHintAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return OpenCLUnrollHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLUnrollHintAttr> from(const Attr &parent);

  inline static std::optional<OpenCLUnrollHintAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLUnrollHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MustTailAttrRange = DerivedEntityRange<AttrIterator, MustTailAttr>;
using MustTailAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MustTailAttr>;
class MustTailAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static MustTailAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MustTailAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MustTailAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MUST_TAIL;
  }

  static std::optional<MustTailAttr> from(const TokenContext &c);
  static std::optional<MustTailAttr> from(const StmtAttr &parent);

  inline static std::optional<MustTailAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return MustTailAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MustTailAttr> from(const Attr &parent);

  inline static std::optional<MustTailAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MustTailAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LikelyAttrRange = DerivedEntityRange<AttrIterator, LikelyAttr>;
using LikelyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LikelyAttr>;
class LikelyAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static LikelyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LikelyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LikelyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LIKELY;
  }

  static std::optional<LikelyAttr> from(const TokenContext &c);
  static std::optional<LikelyAttr> from(const StmtAttr &parent);

  inline static std::optional<LikelyAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return LikelyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LikelyAttr> from(const Attr &parent);

  inline static std::optional<LikelyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LikelyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FallThroughAttrRange = DerivedEntityRange<AttrIterator, FallThroughAttr>;
using FallThroughAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FallThroughAttr>;
class FallThroughAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static FallThroughAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FallThroughAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FallThroughAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FALL_THROUGH;
  }

  static std::optional<FallThroughAttr> from(const TokenContext &c);
  static std::optional<FallThroughAttr> from(const StmtAttr &parent);

  inline static std::optional<FallThroughAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return FallThroughAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FallThroughAttr> from(const Attr &parent);

  inline static std::optional<FallThroughAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FallThroughAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UnlikelyAttrRange = DerivedEntityRange<AttrIterator, UnlikelyAttr>;
using UnlikelyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnlikelyAttr>;
class UnlikelyAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static UnlikelyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnlikelyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnlikelyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::UNLIKELY;
  }

  static std::optional<UnlikelyAttr> from(const TokenContext &c);
  static std::optional<UnlikelyAttr> from(const StmtAttr &parent);

  inline static std::optional<UnlikelyAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return UnlikelyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnlikelyAttr> from(const Attr &parent);

  inline static std::optional<UnlikelyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UnlikelyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SuppressAttrRange = DerivedEntityRange<AttrIterator, SuppressAttr>;
using SuppressAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SuppressAttr>;
class SuppressAttr : public StmtAttr {
 private:
  friend class FragmentImpl;
  friend class StmtAttr;
  friend class Attr;
 public:
  inline static SuppressAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SuppressAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SuppressAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SUPPRESS;
  }

  static std::optional<SuppressAttr> from(const TokenContext &c);
  static std::optional<SuppressAttr> from(const StmtAttr &parent);

  inline static std::optional<SuppressAttr> from(const std::optional<StmtAttr> &parent) {
    if (parent) {
      return SuppressAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SuppressAttr> from(const Attr &parent);

  inline static std::optional<SuppressAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SuppressAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using RenderScriptKernelAttrRange = DerivedEntityRange<AttrIterator, RenderScriptKernelAttr>;
using RenderScriptKernelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RenderScriptKernelAttr>;
class RenderScriptKernelAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static RenderScriptKernelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RenderScriptKernelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RenderScriptKernelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RENDER_SCRIPT_KERNEL;
  }

  static std::optional<RenderScriptKernelAttr> from(const TokenContext &c);
  static std::optional<RenderScriptKernelAttr> from(const Attr &parent);

  inline static std::optional<RenderScriptKernelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RenderScriptKernelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OverloadableAttrRange = DerivedEntityRange<AttrIterator, OverloadableAttr>;
using OverloadableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OverloadableAttr>;
class OverloadableAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static OverloadableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OverloadableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OverloadableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OVERLOADABLE;
  }

  static std::optional<OverloadableAttr> from(const TokenContext &c);
  static std::optional<OverloadableAttr> from(const Attr &parent);

  inline static std::optional<OverloadableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OverloadableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLAccessAttrRange = DerivedEntityRange<AttrIterator, OpenCLAccessAttr>;
using OpenCLAccessAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLAccessAttr>;
class OpenCLAccessAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static OpenCLAccessAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLAccessAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLAccessAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_ACCESS;
  }

  static std::optional<OpenCLAccessAttr> from(const TokenContext &c);
  static std::optional<OpenCLAccessAttr> from(const Attr &parent);

  inline static std::optional<OpenCLAccessAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLAccessAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpenCLAccessAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_read_only(void) const;
  bool is_read_write(void) const;
  bool is_write_only(void) const;
};

using ObjCRuntimeVisibleAttrRange = DerivedEntityRange<AttrIterator, ObjCRuntimeVisibleAttr>;
using ObjCRuntimeVisibleAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCRuntimeVisibleAttr>;
class ObjCRuntimeVisibleAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCRuntimeVisibleAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCRuntimeVisibleAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCRuntimeVisibleAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_RUNTIME_VISIBLE;
  }

  static std::optional<ObjCRuntimeVisibleAttr> from(const TokenContext &c);
  static std::optional<ObjCRuntimeVisibleAttr> from(const Attr &parent);

  inline static std::optional<ObjCRuntimeVisibleAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCRuntimeVisibleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCRuntimeNameAttrRange = DerivedEntityRange<AttrIterator, ObjCRuntimeNameAttr>;
using ObjCRuntimeNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCRuntimeNameAttr>;
class ObjCRuntimeNameAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCRuntimeNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCRuntimeNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCRuntimeNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_RUNTIME_NAME;
  }

  static std::optional<ObjCRuntimeNameAttr> from(const TokenContext &c);
  static std::optional<ObjCRuntimeNameAttr> from(const Attr &parent);

  inline static std::optional<ObjCRuntimeNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCRuntimeNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view metadata_name(void) const;
  std::string_view spelling(void) const;
};

using ObjCNonRuntimeProtocolAttrRange = DerivedEntityRange<AttrIterator, ObjCNonRuntimeProtocolAttr>;
using ObjCNonRuntimeProtocolAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCNonRuntimeProtocolAttr>;
class ObjCNonRuntimeProtocolAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCNonRuntimeProtocolAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCNonRuntimeProtocolAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCNonRuntimeProtocolAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_NON_RUNTIME_PROTOCOL;
  }

  static std::optional<ObjCNonRuntimeProtocolAttr> from(const TokenContext &c);
  static std::optional<ObjCNonRuntimeProtocolAttr> from(const Attr &parent);

  inline static std::optional<ObjCNonRuntimeProtocolAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCNonRuntimeProtocolAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCNonLazyClassAttrRange = DerivedEntityRange<AttrIterator, ObjCNonLazyClassAttr>;
using ObjCNonLazyClassAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCNonLazyClassAttr>;
class ObjCNonLazyClassAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCNonLazyClassAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCNonLazyClassAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCNonLazyClassAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_NON_LAZY_CLASS;
  }

  static std::optional<ObjCNonLazyClassAttr> from(const TokenContext &c);
  static std::optional<ObjCNonLazyClassAttr> from(const Attr &parent);

  inline static std::optional<ObjCNonLazyClassAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCNonLazyClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCDirectMembersAttrRange = DerivedEntityRange<AttrIterator, ObjCDirectMembersAttr>;
using ObjCDirectMembersAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCDirectMembersAttr>;
class ObjCDirectMembersAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCDirectMembersAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCDirectMembersAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCDirectMembersAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_DIRECT_MEMBERS;
  }

  static std::optional<ObjCDirectMembersAttr> from(const TokenContext &c);
  static std::optional<ObjCDirectMembersAttr> from(const Attr &parent);

  inline static std::optional<ObjCDirectMembersAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCDirectMembersAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCDirectAttrRange = DerivedEntityRange<AttrIterator, ObjCDirectAttr>;
using ObjCDirectAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCDirectAttr>;
class ObjCDirectAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCDirectAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCDirectAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCDirectAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_DIRECT;
  }

  static std::optional<ObjCDirectAttr> from(const TokenContext &c);
  static std::optional<ObjCDirectAttr> from(const Attr &parent);

  inline static std::optional<ObjCDirectAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCDirectAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCDesignatedInitializerAttrRange = DerivedEntityRange<AttrIterator, ObjCDesignatedInitializerAttr>;
using ObjCDesignatedInitializerAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCDesignatedInitializerAttr>;
class ObjCDesignatedInitializerAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCDesignatedInitializerAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCDesignatedInitializerAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCDesignatedInitializerAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_DESIGNATED_INITIALIZER;
  }

  static std::optional<ObjCDesignatedInitializerAttr> from(const TokenContext &c);
  static std::optional<ObjCDesignatedInitializerAttr> from(const Attr &parent);

  inline static std::optional<ObjCDesignatedInitializerAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCDesignatedInitializerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCClassStubAttrRange = DerivedEntityRange<AttrIterator, ObjCClassStubAttr>;
using ObjCClassStubAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCClassStubAttr>;
class ObjCClassStubAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCClassStubAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCClassStubAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCClassStubAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_CLASS_STUB;
  }

  static std::optional<ObjCClassStubAttr> from(const TokenContext &c);
  static std::optional<ObjCClassStubAttr> from(const Attr &parent);

  inline static std::optional<ObjCClassStubAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCClassStubAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCBoxableAttrRange = DerivedEntityRange<AttrIterator, ObjCBoxableAttr>;
using ObjCBoxableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBoxableAttr>;
class ObjCBoxableAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ObjCBoxableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBoxableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBoxableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_BOXABLE;
  }

  static std::optional<ObjCBoxableAttr> from(const TokenContext &c);
  static std::optional<ObjCBoxableAttr> from(const Attr &parent);

  inline static std::optional<ObjCBoxableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCBoxableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OMPReferencedVarAttrRange = DerivedEntityRange<AttrIterator, OMPReferencedVarAttr>;
using OMPReferencedVarAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPReferencedVarAttr>;
class OMPReferencedVarAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static OMPReferencedVarAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPReferencedVarAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPReferencedVarAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_REFERENCED_VAR;
  }

  static std::optional<OMPReferencedVarAttr> from(const TokenContext &c);
  static std::optional<OMPReferencedVarAttr> from(const Attr &parent);

  inline static std::optional<OMPReferencedVarAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPReferencedVarAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr reference(void) const;
  std::string_view spelling(void) const;
};

using OMPDeclareSimdDeclAttrRange = DerivedEntityRange<AttrIterator, OMPDeclareSimdDeclAttr>;
using OMPDeclareSimdDeclAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclareSimdDeclAttr>;
class OMPDeclareSimdDeclAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static OMPDeclareSimdDeclAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclareSimdDeclAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclareSimdDeclAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_DECLARE_SIMD_DECL;
  }

  static std::optional<OMPDeclareSimdDeclAttr> from(const TokenContext &c);
  static std::optional<OMPDeclareSimdDeclAttr> from(const Attr &parent);

  inline static std::optional<OMPDeclareSimdDeclAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPDeclareSimdDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OMPDeclareSimdDeclAttrBranchStateTy branch_state(void) const;
  Expr simdlen(void) const;
  std::string_view spelling(void) const;
};

using OMPCaptureKindAttrRange = DerivedEntityRange<AttrIterator, OMPCaptureKindAttr>;
using OMPCaptureKindAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCaptureKindAttr>;
class OMPCaptureKindAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static OMPCaptureKindAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCaptureKindAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCaptureKindAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_CAPTURE_KIND;
  }

  static std::optional<OMPCaptureKindAttr> from(const TokenContext &c);
  static std::optional<OMPCaptureKindAttr> from(const Attr &parent);

  inline static std::optional<OMPCaptureKindAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPCaptureKindAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoEscapeAttrRange = DerivedEntityRange<AttrIterator, NoEscapeAttr>;
using NoEscapeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoEscapeAttr>;
class NoEscapeAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static NoEscapeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoEscapeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoEscapeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_ESCAPE;
  }

  static std::optional<NoEscapeAttr> from(const TokenContext &c);
  static std::optional<NoEscapeAttr> from(const Attr &parent);

  inline static std::optional<NoEscapeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoEscapeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoBuiltinAttrRange = DerivedEntityRange<AttrIterator, NoBuiltinAttr>;
using NoBuiltinAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoBuiltinAttr>;
class NoBuiltinAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static NoBuiltinAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoBuiltinAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoBuiltinAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_BUILTIN;
  }

  static std::optional<NoBuiltinAttr> from(const TokenContext &c);
  static std::optional<NoBuiltinAttr> from(const Attr &parent);

  inline static std::optional<NoBuiltinAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoBuiltinAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ModeAttrRange = DerivedEntityRange<AttrIterator, ModeAttr>;
using ModeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ModeAttr>;
class ModeAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static ModeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ModeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ModeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MODE;
  }

  static std::optional<ModeAttr> from(const TokenContext &c);
  static std::optional<ModeAttr> from(const Attr &parent);

  inline static std::optional<ModeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ModeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LoopHintAttrRange = DerivedEntityRange<AttrIterator, LoopHintAttr>;
using LoopHintAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LoopHintAttr>;
class LoopHintAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static LoopHintAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LoopHintAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LoopHintAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LOOP_HINT;
  }

  static std::optional<LoopHintAttr> from(const TokenContext &c);
  static std::optional<LoopHintAttr> from(const Attr &parent);

  inline static std::optional<LoopHintAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LoopHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  LoopHintAttrOptionType option(void) const;
  LoopHintAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  LoopHintAttrLoopHintState state(void) const;
  Expr value(void) const;
};

using LoaderUninitializedAttrRange = DerivedEntityRange<AttrIterator, LoaderUninitializedAttr>;
using LoaderUninitializedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LoaderUninitializedAttr>;
class LoaderUninitializedAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static LoaderUninitializedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LoaderUninitializedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LoaderUninitializedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LOADER_UNINITIALIZED;
  }

  static std::optional<LoaderUninitializedAttr> from(const TokenContext &c);
  static std::optional<LoaderUninitializedAttr> from(const Attr &parent);

  inline static std::optional<LoaderUninitializedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LoaderUninitializedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using InitSegAttrRange = DerivedEntityRange<AttrIterator, InitSegAttr>;
using InitSegAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, InitSegAttr>;
class InitSegAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static InitSegAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InitSegAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InitSegAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::INIT_SEG;
  }

  static std::optional<InitSegAttr> from(const TokenContext &c);
  static std::optional<InitSegAttr> from(const Attr &parent);

  inline static std::optional<InitSegAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return InitSegAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view section(void) const;
  std::string_view spelling(void) const;
};

using InheritableAttrRange = DerivedEntityRange<AttrIterator, InheritableAttr>;
using InheritableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, InheritableAttr>;
class InheritableAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static InheritableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InheritableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InheritableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<InheritableAttr> from(const TokenContext &c);
  static std::optional<InheritableAttr> from(const Attr &parent);

  inline static std::optional<InheritableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return InheritableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool should_inherit_even_if_already_present(void) const;
};

using IBOutletCollectionAttrRange = DerivedEntityRange<AttrIterator, IBOutletCollectionAttr>;
using IBOutletCollectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, IBOutletCollectionAttr>;
class IBOutletCollectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static IBOutletCollectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IBOutletCollectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IBOutletCollectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::IB_OUTLET_COLLECTION;
  }

  static std::optional<IBOutletCollectionAttr> from(const TokenContext &c);
  static std::optional<IBOutletCollectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<IBOutletCollectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return IBOutletCollectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IBOutletCollectionAttr> from(const Attr &parent);

  inline static std::optional<IBOutletCollectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return IBOutletCollectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type interface(void) const;
  Type interface_token(void) const;
  std::string_view spelling(void) const;
};

using IBOutletAttrRange = DerivedEntityRange<AttrIterator, IBOutletAttr>;
using IBOutletAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, IBOutletAttr>;
class IBOutletAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static IBOutletAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IBOutletAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IBOutletAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::IB_OUTLET;
  }

  static std::optional<IBOutletAttr> from(const TokenContext &c);
  static std::optional<IBOutletAttr> from(const InheritableAttr &parent);

  inline static std::optional<IBOutletAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return IBOutletAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IBOutletAttr> from(const Attr &parent);

  inline static std::optional<IBOutletAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return IBOutletAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using IBActionAttrRange = DerivedEntityRange<AttrIterator, IBActionAttr>;
using IBActionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, IBActionAttr>;
class IBActionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static IBActionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IBActionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IBActionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::IB_ACTION;
  }

  static std::optional<IBActionAttr> from(const TokenContext &c);
  static std::optional<IBActionAttr> from(const InheritableAttr &parent);

  inline static std::optional<IBActionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return IBActionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IBActionAttr> from(const Attr &parent);

  inline static std::optional<IBActionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return IBActionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using HotAttrRange = DerivedEntityRange<AttrIterator, HotAttr>;
using HotAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, HotAttr>;
class HotAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static HotAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static HotAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : HotAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::HOT;
  }

  static std::optional<HotAttr> from(const TokenContext &c);
  static std::optional<HotAttr> from(const InheritableAttr &parent);

  inline static std::optional<HotAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return HotAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<HotAttr> from(const Attr &parent);

  inline static std::optional<HotAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return HotAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using HIPManagedAttrRange = DerivedEntityRange<AttrIterator, HIPManagedAttr>;
using HIPManagedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, HIPManagedAttr>;
class HIPManagedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static HIPManagedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static HIPManagedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : HIPManagedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::HIP_MANAGED;
  }

  static std::optional<HIPManagedAttr> from(const TokenContext &c);
  static std::optional<HIPManagedAttr> from(const InheritableAttr &parent);

  inline static std::optional<HIPManagedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return HIPManagedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<HIPManagedAttr> from(const Attr &parent);

  inline static std::optional<HIPManagedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return HIPManagedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using GuardedVarAttrRange = DerivedEntityRange<AttrIterator, GuardedVarAttr>;
using GuardedVarAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, GuardedVarAttr>;
class GuardedVarAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static GuardedVarAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GuardedVarAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GuardedVarAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::GUARDED_VAR;
  }

  static std::optional<GuardedVarAttr> from(const TokenContext &c);
  static std::optional<GuardedVarAttr> from(const InheritableAttr &parent);

  inline static std::optional<GuardedVarAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return GuardedVarAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GuardedVarAttr> from(const Attr &parent);

  inline static std::optional<GuardedVarAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return GuardedVarAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using GuardedByAttrRange = DerivedEntityRange<AttrIterator, GuardedByAttr>;
using GuardedByAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, GuardedByAttr>;
class GuardedByAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static GuardedByAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GuardedByAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GuardedByAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::GUARDED_BY;
  }

  static std::optional<GuardedByAttr> from(const TokenContext &c);
  static std::optional<GuardedByAttr> from(const InheritableAttr &parent);

  inline static std::optional<GuardedByAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return GuardedByAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GuardedByAttr> from(const Attr &parent);

  inline static std::optional<GuardedByAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return GuardedByAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr argument(void) const;
  std::string_view spelling(void) const;
};

using GNUInlineAttrRange = DerivedEntityRange<AttrIterator, GNUInlineAttr>;
using GNUInlineAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, GNUInlineAttr>;
class GNUInlineAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static GNUInlineAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GNUInlineAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GNUInlineAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::GNU_INLINE;
  }

  static std::optional<GNUInlineAttr> from(const TokenContext &c);
  static std::optional<GNUInlineAttr> from(const InheritableAttr &parent);

  inline static std::optional<GNUInlineAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return GNUInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GNUInlineAttr> from(const Attr &parent);

  inline static std::optional<GNUInlineAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return GNUInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FormatAttrRange = DerivedEntityRange<AttrIterator, FormatAttr>;
using FormatAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FormatAttr>;
class FormatAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FormatAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FormatAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FormatAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FORMAT;
  }

  static std::optional<FormatAttr> from(const TokenContext &c);
  static std::optional<FormatAttr> from(const InheritableAttr &parent);

  inline static std::optional<FormatAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FormatAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FormatAttr> from(const Attr &parent);

  inline static std::optional<FormatAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FormatAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FormatArgAttrRange = DerivedEntityRange<AttrIterator, FormatArgAttr>;
using FormatArgAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FormatArgAttr>;
class FormatArgAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FormatArgAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FormatArgAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FormatArgAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FORMAT_ARG;
  }

  static std::optional<FormatArgAttr> from(const TokenContext &c);
  static std::optional<FormatArgAttr> from(const InheritableAttr &parent);

  inline static std::optional<FormatArgAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FormatArgAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FormatArgAttr> from(const Attr &parent);

  inline static std::optional<FormatArgAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FormatArgAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FlattenAttrRange = DerivedEntityRange<AttrIterator, FlattenAttr>;
using FlattenAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FlattenAttr>;
class FlattenAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FlattenAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FlattenAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FlattenAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FLATTEN;
  }

  static std::optional<FlattenAttr> from(const TokenContext &c);
  static std::optional<FlattenAttr> from(const InheritableAttr &parent);

  inline static std::optional<FlattenAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FlattenAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FlattenAttr> from(const Attr &parent);

  inline static std::optional<FlattenAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FlattenAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FlagEnumAttrRange = DerivedEntityRange<AttrIterator, FlagEnumAttr>;
using FlagEnumAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FlagEnumAttr>;
class FlagEnumAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FlagEnumAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FlagEnumAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FlagEnumAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FLAG_ENUM;
  }

  static std::optional<FlagEnumAttr> from(const TokenContext &c);
  static std::optional<FlagEnumAttr> from(const InheritableAttr &parent);

  inline static std::optional<FlagEnumAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FlagEnumAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FlagEnumAttr> from(const Attr &parent);

  inline static std::optional<FlagEnumAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FlagEnumAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using FinalAttrRange = DerivedEntityRange<AttrIterator, FinalAttr>;
using FinalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FinalAttr>;
class FinalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FinalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FinalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FinalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FINAL;
  }

  static std::optional<FinalAttr> from(const TokenContext &c);
  static std::optional<FinalAttr> from(const InheritableAttr &parent);

  inline static std::optional<FinalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FinalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FinalAttr> from(const Attr &parent);

  inline static std::optional<FinalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FinalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  FinalAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_spelled_as_sealed(void) const;
};

using FastCallAttrRange = DerivedEntityRange<AttrIterator, FastCallAttr>;
using FastCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, FastCallAttr>;
class FastCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static FastCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FastCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FastCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::FAST_CALL;
  }

  static std::optional<FastCallAttr> from(const TokenContext &c);
  static std::optional<FastCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<FastCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return FastCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FastCallAttr> from(const Attr &parent);

  inline static std::optional<FastCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return FastCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ExternalSourceSymbolAttrRange = DerivedEntityRange<AttrIterator, ExternalSourceSymbolAttr>;
using ExternalSourceSymbolAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExternalSourceSymbolAttr>;
class ExternalSourceSymbolAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ExternalSourceSymbolAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExternalSourceSymbolAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExternalSourceSymbolAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::EXTERNAL_SOURCE_SYMBOL;
  }

  static std::optional<ExternalSourceSymbolAttr> from(const TokenContext &c);
  static std::optional<ExternalSourceSymbolAttr> from(const InheritableAttr &parent);

  inline static std::optional<ExternalSourceSymbolAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ExternalSourceSymbolAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExternalSourceSymbolAttr> from(const Attr &parent);

  inline static std::optional<ExternalSourceSymbolAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ExternalSourceSymbolAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view defined_in(void) const;
  bool generated_declaration(void) const;
  std::string_view language(void) const;
  std::string_view spelling(void) const;
};

using ExclusiveTrylockFunctionAttrRange = DerivedEntityRange<AttrIterator, ExclusiveTrylockFunctionAttr>;
using ExclusiveTrylockFunctionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExclusiveTrylockFunctionAttr>;
class ExclusiveTrylockFunctionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ExclusiveTrylockFunctionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExclusiveTrylockFunctionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExclusiveTrylockFunctionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::EXCLUSIVE_TRYLOCK_FUNCTION;
  }

  static std::optional<ExclusiveTrylockFunctionAttr> from(const TokenContext &c);
  static std::optional<ExclusiveTrylockFunctionAttr> from(const InheritableAttr &parent);

  inline static std::optional<ExclusiveTrylockFunctionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ExclusiveTrylockFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExclusiveTrylockFunctionAttr> from(const Attr &parent);

  inline static std::optional<ExclusiveTrylockFunctionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ExclusiveTrylockFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  Expr success_value(void) const;
};

using ExcludeFromExplicitInstantiationAttrRange = DerivedEntityRange<AttrIterator, ExcludeFromExplicitInstantiationAttr>;
using ExcludeFromExplicitInstantiationAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExcludeFromExplicitInstantiationAttr>;
class ExcludeFromExplicitInstantiationAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ExcludeFromExplicitInstantiationAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExcludeFromExplicitInstantiationAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExcludeFromExplicitInstantiationAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::EXCLUDE_FROM_EXPLICIT_INSTANTIATION;
  }

  static std::optional<ExcludeFromExplicitInstantiationAttr> from(const TokenContext &c);
  static std::optional<ExcludeFromExplicitInstantiationAttr> from(const InheritableAttr &parent);

  inline static std::optional<ExcludeFromExplicitInstantiationAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ExcludeFromExplicitInstantiationAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExcludeFromExplicitInstantiationAttr> from(const Attr &parent);

  inline static std::optional<ExcludeFromExplicitInstantiationAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ExcludeFromExplicitInstantiationAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ErrorAttrRange = DerivedEntityRange<AttrIterator, ErrorAttr>;
using ErrorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ErrorAttr>;
class ErrorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ErrorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ErrorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ErrorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ERROR;
  }

  static std::optional<ErrorAttr> from(const TokenContext &c);
  static std::optional<ErrorAttr> from(const InheritableAttr &parent);

  inline static std::optional<ErrorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ErrorAttr> from(const Attr &parent);

  inline static std::optional<ErrorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ErrorAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  std::string_view user_diagnostic(void) const;
  bool is_error(void) const;
  bool is_warning(void) const;
};

using EnumExtensibilityAttrRange = DerivedEntityRange<AttrIterator, EnumExtensibilityAttr>;
using EnumExtensibilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnumExtensibilityAttr>;
class EnumExtensibilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static EnumExtensibilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnumExtensibilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnumExtensibilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ENUM_EXTENSIBILITY;
  }

  static std::optional<EnumExtensibilityAttr> from(const TokenContext &c);
  static std::optional<EnumExtensibilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<EnumExtensibilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return EnumExtensibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumExtensibilityAttr> from(const Attr &parent);

  inline static std::optional<EnumExtensibilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return EnumExtensibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  EnumExtensibilityAttrKind extensibility(void) const;
  std::string_view spelling(void) const;
};

using EnforceTCBLeafAttrRange = DerivedEntityRange<AttrIterator, EnforceTCBLeafAttr>;
using EnforceTCBLeafAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnforceTCBLeafAttr>;
class EnforceTCBLeafAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static EnforceTCBLeafAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnforceTCBLeafAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnforceTCBLeafAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ENFORCE_TCB_LEAF;
  }

  static std::optional<EnforceTCBLeafAttr> from(const TokenContext &c);
  static std::optional<EnforceTCBLeafAttr> from(const InheritableAttr &parent);

  inline static std::optional<EnforceTCBLeafAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return EnforceTCBLeafAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnforceTCBLeafAttr> from(const Attr &parent);

  inline static std::optional<EnforceTCBLeafAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return EnforceTCBLeafAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  std::string_view tcb_name(void) const;
};

using EnforceTCBAttrRange = DerivedEntityRange<AttrIterator, EnforceTCBAttr>;
using EnforceTCBAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnforceTCBAttr>;
class EnforceTCBAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static EnforceTCBAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnforceTCBAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnforceTCBAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ENFORCE_TCB;
  }

  static std::optional<EnforceTCBAttr> from(const TokenContext &c);
  static std::optional<EnforceTCBAttr> from(const InheritableAttr &parent);

  inline static std::optional<EnforceTCBAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return EnforceTCBAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnforceTCBAttr> from(const Attr &parent);

  inline static std::optional<EnforceTCBAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return EnforceTCBAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  std::string_view tcb_name(void) const;
};

using EnableIfAttrRange = DerivedEntityRange<AttrIterator, EnableIfAttr>;
using EnableIfAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnableIfAttr>;
class EnableIfAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static EnableIfAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnableIfAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnableIfAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ENABLE_IF;
  }

  static std::optional<EnableIfAttr> from(const TokenContext &c);
  static std::optional<EnableIfAttr> from(const InheritableAttr &parent);

  inline static std::optional<EnableIfAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return EnableIfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnableIfAttr> from(const Attr &parent);

  inline static std::optional<EnableIfAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return EnableIfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr condition(void) const;
  std::string_view message(void) const;
  std::string_view spelling(void) const;
};

using EmptyBasesAttrRange = DerivedEntityRange<AttrIterator, EmptyBasesAttr>;
using EmptyBasesAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, EmptyBasesAttr>;
class EmptyBasesAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static EmptyBasesAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EmptyBasesAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EmptyBasesAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::EMPTY_BASES;
  }

  static std::optional<EmptyBasesAttr> from(const TokenContext &c);
  static std::optional<EmptyBasesAttr> from(const InheritableAttr &parent);

  inline static std::optional<EmptyBasesAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return EmptyBasesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EmptyBasesAttr> from(const Attr &parent);

  inline static std::optional<EmptyBasesAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return EmptyBasesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DisableTailCallsAttrRange = DerivedEntityRange<AttrIterator, DisableTailCallsAttr>;
using DisableTailCallsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DisableTailCallsAttr>;
class DisableTailCallsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DisableTailCallsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DisableTailCallsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DisableTailCallsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DISABLE_TAIL_CALLS;
  }

  static std::optional<DisableTailCallsAttr> from(const TokenContext &c);
  static std::optional<DisableTailCallsAttr> from(const InheritableAttr &parent);

  inline static std::optional<DisableTailCallsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DisableTailCallsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DisableTailCallsAttr> from(const Attr &parent);

  inline static std::optional<DisableTailCallsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DisableTailCallsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DisableSanitizerInstrumentationAttrRange = DerivedEntityRange<AttrIterator, DisableSanitizerInstrumentationAttr>;
using DisableSanitizerInstrumentationAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DisableSanitizerInstrumentationAttr>;
class DisableSanitizerInstrumentationAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DisableSanitizerInstrumentationAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DisableSanitizerInstrumentationAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DisableSanitizerInstrumentationAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DISABLE_SANITIZER_INSTRUMENTATION;
  }

  static std::optional<DisableSanitizerInstrumentationAttr> from(const TokenContext &c);
  static std::optional<DisableSanitizerInstrumentationAttr> from(const InheritableAttr &parent);

  inline static std::optional<DisableSanitizerInstrumentationAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DisableSanitizerInstrumentationAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DisableSanitizerInstrumentationAttr> from(const Attr &parent);

  inline static std::optional<DisableSanitizerInstrumentationAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DisableSanitizerInstrumentationAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DiagnoseIfAttrRange = DerivedEntityRange<AttrIterator, DiagnoseIfAttr>;
using DiagnoseIfAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DiagnoseIfAttr>;
class DiagnoseIfAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DiagnoseIfAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DiagnoseIfAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DiagnoseIfAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DIAGNOSE_IF;
  }

  static std::optional<DiagnoseIfAttr> from(const TokenContext &c);
  static std::optional<DiagnoseIfAttr> from(const InheritableAttr &parent);

  inline static std::optional<DiagnoseIfAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DiagnoseIfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DiagnoseIfAttr> from(const Attr &parent);

  inline static std::optional<DiagnoseIfAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DiagnoseIfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool argument_dependent(void) const;
  Expr condition(void) const;
  DiagnoseIfAttrDiagnosticType diagnostic_type(void) const;
  std::string_view message(void) const;
  NamedDecl parent(void) const;
  std::string_view spelling(void) const;
  bool is_error(void) const;
  bool is_warning(void) const;
};

using DiagnoseAsBuiltinAttrRange = DerivedEntityRange<AttrIterator, DiagnoseAsBuiltinAttr>;
using DiagnoseAsBuiltinAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DiagnoseAsBuiltinAttr>;
class DiagnoseAsBuiltinAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DiagnoseAsBuiltinAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DiagnoseAsBuiltinAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DiagnoseAsBuiltinAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DIAGNOSE_AS_BUILTIN;
  }

  static std::optional<DiagnoseAsBuiltinAttr> from(const TokenContext &c);
  static std::optional<DiagnoseAsBuiltinAttr> from(const InheritableAttr &parent);

  inline static std::optional<DiagnoseAsBuiltinAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DiagnoseAsBuiltinAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DiagnoseAsBuiltinAttr> from(const Attr &parent);

  inline static std::optional<DiagnoseAsBuiltinAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DiagnoseAsBuiltinAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  FunctionDecl function(void) const;
  std::string_view spelling(void) const;
};

using DestructorAttrRange = DerivedEntityRange<AttrIterator, DestructorAttr>;
using DestructorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DestructorAttr>;
class DestructorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DestructorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DestructorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DestructorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DESTRUCTOR;
  }

  static std::optional<DestructorAttr> from(const TokenContext &c);
  static std::optional<DestructorAttr> from(const InheritableAttr &parent);

  inline static std::optional<DestructorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DestructorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DestructorAttr> from(const Attr &parent);

  inline static std::optional<DestructorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DestructorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DeprecatedAttrRange = DerivedEntityRange<AttrIterator, DeprecatedAttr>;
using DeprecatedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeprecatedAttr>;
class DeprecatedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DeprecatedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeprecatedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeprecatedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DEPRECATED;
  }

  static std::optional<DeprecatedAttr> from(const TokenContext &c);
  static std::optional<DeprecatedAttr> from(const InheritableAttr &parent);

  inline static std::optional<DeprecatedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DeprecatedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeprecatedAttr> from(const Attr &parent);

  inline static std::optional<DeprecatedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DeprecatedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view message(void) const;
  std::string_view replacement(void) const;
  std::string_view spelling(void) const;
};

using DeclOrStmtAttrRange = DerivedEntityRange<AttrIterator, DeclOrStmtAttr>;
using DeclOrStmtAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeclOrStmtAttr>;
class DeclOrStmtAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DeclOrStmtAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeclOrStmtAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeclOrStmtAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<DeclOrStmtAttr> from(const TokenContext &c);
  static std::optional<DeclOrStmtAttr> from(const InheritableAttr &parent);

  inline static std::optional<DeclOrStmtAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DeclOrStmtAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeclOrStmtAttr> from(const Attr &parent);

  inline static std::optional<DeclOrStmtAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DeclOrStmtAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using NoMergeAttrRange = DerivedEntityRange<AttrIterator, NoMergeAttr>;
using NoMergeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoMergeAttr>;
class NoMergeAttr : public DeclOrStmtAttr {
 private:
  friend class FragmentImpl;
  friend class DeclOrStmtAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoMergeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoMergeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoMergeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_MERGE;
  }

  static std::optional<NoMergeAttr> from(const TokenContext &c);
  static std::optional<NoMergeAttr> from(const DeclOrStmtAttr &parent);

  inline static std::optional<NoMergeAttr> from(const std::optional<DeclOrStmtAttr> &parent) {
    if (parent) {
      return NoMergeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoMergeAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoMergeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoMergeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoMergeAttr> from(const Attr &parent);

  inline static std::optional<NoMergeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoMergeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DLLImportStaticLocalAttrRange = DerivedEntityRange<AttrIterator, DLLImportStaticLocalAttr>;
using DLLImportStaticLocalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DLLImportStaticLocalAttr>;
class DLLImportStaticLocalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DLLImportStaticLocalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DLLImportStaticLocalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DLLImportStaticLocalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DLL_IMPORT_STATIC_LOCAL;
  }

  static std::optional<DLLImportStaticLocalAttr> from(const TokenContext &c);
  static std::optional<DLLImportStaticLocalAttr> from(const InheritableAttr &parent);

  inline static std::optional<DLLImportStaticLocalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DLLImportStaticLocalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DLLImportStaticLocalAttr> from(const Attr &parent);

  inline static std::optional<DLLImportStaticLocalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DLLImportStaticLocalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DLLImportAttrRange = DerivedEntityRange<AttrIterator, DLLImportAttr>;
using DLLImportAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DLLImportAttr>;
class DLLImportAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DLLImportAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DLLImportAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DLLImportAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DLL_IMPORT;
  }

  static std::optional<DLLImportAttr> from(const TokenContext &c);
  static std::optional<DLLImportAttr> from(const InheritableAttr &parent);

  inline static std::optional<DLLImportAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DLLImportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DLLImportAttr> from(const Attr &parent);

  inline static std::optional<DLLImportAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DLLImportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DLLExportStaticLocalAttrRange = DerivedEntityRange<AttrIterator, DLLExportStaticLocalAttr>;
using DLLExportStaticLocalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DLLExportStaticLocalAttr>;
class DLLExportStaticLocalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DLLExportStaticLocalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DLLExportStaticLocalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DLLExportStaticLocalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DLL_EXPORT_STATIC_LOCAL;
  }

  static std::optional<DLLExportStaticLocalAttr> from(const TokenContext &c);
  static std::optional<DLLExportStaticLocalAttr> from(const InheritableAttr &parent);

  inline static std::optional<DLLExportStaticLocalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DLLExportStaticLocalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DLLExportStaticLocalAttr> from(const Attr &parent);

  inline static std::optional<DLLExportStaticLocalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DLLExportStaticLocalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using DLLExportAttrRange = DerivedEntityRange<AttrIterator, DLLExportAttr>;
using DLLExportAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, DLLExportAttr>;
class DLLExportAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static DLLExportAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DLLExportAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DLLExportAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::DLL_EXPORT;
  }

  static std::optional<DLLExportAttr> from(const TokenContext &c);
  static std::optional<DLLExportAttr> from(const InheritableAttr &parent);

  inline static std::optional<DLLExportAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return DLLExportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DLLExportAttr> from(const Attr &parent);

  inline static std::optional<DLLExportAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return DLLExportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ConvergentAttrRange = DerivedEntityRange<AttrIterator, ConvergentAttr>;
using ConvergentAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConvergentAttr>;
class ConvergentAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConvergentAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConvergentAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConvergentAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONVERGENT;
  }

  static std::optional<ConvergentAttr> from(const TokenContext &c);
  static std::optional<ConvergentAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConvergentAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConvergentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConvergentAttr> from(const Attr &parent);

  inline static std::optional<ConvergentAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConvergentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ConsumableSetOnReadAttrRange = DerivedEntityRange<AttrIterator, ConsumableSetOnReadAttr>;
using ConsumableSetOnReadAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConsumableSetOnReadAttr>;
class ConsumableSetOnReadAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConsumableSetOnReadAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConsumableSetOnReadAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConsumableSetOnReadAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONSUMABLE_SET_ON_READ;
  }

  static std::optional<ConsumableSetOnReadAttr> from(const TokenContext &c);
  static std::optional<ConsumableSetOnReadAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConsumableSetOnReadAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConsumableSetOnReadAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConsumableSetOnReadAttr> from(const Attr &parent);

  inline static std::optional<ConsumableSetOnReadAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConsumableSetOnReadAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ConsumableAutoCastAttrRange = DerivedEntityRange<AttrIterator, ConsumableAutoCastAttr>;
using ConsumableAutoCastAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConsumableAutoCastAttr>;
class ConsumableAutoCastAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConsumableAutoCastAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConsumableAutoCastAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConsumableAutoCastAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONSUMABLE_AUTO_CAST;
  }

  static std::optional<ConsumableAutoCastAttr> from(const TokenContext &c);
  static std::optional<ConsumableAutoCastAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConsumableAutoCastAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConsumableAutoCastAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConsumableAutoCastAttr> from(const Attr &parent);

  inline static std::optional<ConsumableAutoCastAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConsumableAutoCastAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ConsumableAttrRange = DerivedEntityRange<AttrIterator, ConsumableAttr>;
using ConsumableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConsumableAttr>;
class ConsumableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConsumableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConsumableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConsumableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONSUMABLE;
  }

  static std::optional<ConsumableAttr> from(const TokenContext &c);
  static std::optional<ConsumableAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConsumableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConsumableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConsumableAttr> from(const Attr &parent);

  inline static std::optional<ConsumableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConsumableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ConsumableAttrConsumedState default_state(void) const;
  std::string_view spelling(void) const;
};

using ConstructorAttrRange = DerivedEntityRange<AttrIterator, ConstructorAttr>;
using ConstructorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstructorAttr>;
class ConstructorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConstructorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstructorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstructorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONSTRUCTOR;
  }

  static std::optional<ConstructorAttr> from(const TokenContext &c);
  static std::optional<ConstructorAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConstructorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConstructorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstructorAttr> from(const Attr &parent);

  inline static std::optional<ConstructorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConstructorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ConstInitAttrRange = DerivedEntityRange<AttrIterator, ConstInitAttr>;
using ConstInitAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstInitAttr>;
class ConstInitAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConstInitAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstInitAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstInitAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONST_INIT;
  }

  static std::optional<ConstInitAttr> from(const TokenContext &c);
  static std::optional<ConstInitAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConstInitAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConstInitAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstInitAttr> from(const Attr &parent);

  inline static std::optional<ConstInitAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConstInitAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ConstInitAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_constinit(void) const;
};

using ConstAttrRange = DerivedEntityRange<AttrIterator, ConstAttr>;
using ConstAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstAttr>;
class ConstAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ConstAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CONST;
  }

  static std::optional<ConstAttr> from(const TokenContext &c);
  static std::optional<ConstAttr> from(const InheritableAttr &parent);

  inline static std::optional<ConstAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ConstAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstAttr> from(const Attr &parent);

  inline static std::optional<ConstAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ConstAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CommonAttrRange = DerivedEntityRange<AttrIterator, CommonAttr>;
using CommonAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CommonAttr>;
class CommonAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CommonAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CommonAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CommonAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::COMMON;
  }

  static std::optional<CommonAttr> from(const TokenContext &c);
  static std::optional<CommonAttr> from(const InheritableAttr &parent);

  inline static std::optional<CommonAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CommonAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CommonAttr> from(const Attr &parent);

  inline static std::optional<CommonAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CommonAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ColdAttrRange = DerivedEntityRange<AttrIterator, ColdAttr>;
using ColdAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ColdAttr>;
class ColdAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ColdAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ColdAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ColdAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::COLD;
  }

  static std::optional<ColdAttr> from(const TokenContext &c);
  static std::optional<ColdAttr> from(const InheritableAttr &parent);

  inline static std::optional<ColdAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ColdAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ColdAttr> from(const Attr &parent);

  inline static std::optional<ColdAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ColdAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CodeSegAttrRange = DerivedEntityRange<AttrIterator, CodeSegAttr>;
using CodeSegAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CodeSegAttr>;
class CodeSegAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CodeSegAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CodeSegAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CodeSegAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CODE_SEG;
  }

  static std::optional<CodeSegAttr> from(const TokenContext &c);
  static std::optional<CodeSegAttr> from(const InheritableAttr &parent);

  inline static std::optional<CodeSegAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CodeSegAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CodeSegAttr> from(const Attr &parent);

  inline static std::optional<CodeSegAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CodeSegAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using CmseNSEntryAttrRange = DerivedEntityRange<AttrIterator, CmseNSEntryAttr>;
using CmseNSEntryAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CmseNSEntryAttr>;
class CmseNSEntryAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CmseNSEntryAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CmseNSEntryAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CmseNSEntryAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CMSE_NS_ENTRY;
  }

  static std::optional<CmseNSEntryAttr> from(const TokenContext &c);
  static std::optional<CmseNSEntryAttr> from(const InheritableAttr &parent);

  inline static std::optional<CmseNSEntryAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CmseNSEntryAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CmseNSEntryAttr> from(const Attr &parent);

  inline static std::optional<CmseNSEntryAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CmseNSEntryAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CleanupAttrRange = DerivedEntityRange<AttrIterator, CleanupAttr>;
using CleanupAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CleanupAttr>;
class CleanupAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CleanupAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CleanupAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CleanupAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CLEANUP;
  }

  static std::optional<CleanupAttr> from(const TokenContext &c);
  static std::optional<CleanupAttr> from(const InheritableAttr &parent);

  inline static std::optional<CleanupAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CleanupAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CleanupAttr> from(const Attr &parent);

  inline static std::optional<CleanupAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CleanupAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  FunctionDecl function_declaration(void) const;
  std::string_view spelling(void) const;
};

using CapturedRecordAttrRange = DerivedEntityRange<AttrIterator, CapturedRecordAttr>;
using CapturedRecordAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CapturedRecordAttr>;
class CapturedRecordAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CapturedRecordAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CapturedRecordAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CapturedRecordAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CAPTURED_RECORD;
  }

  static std::optional<CapturedRecordAttr> from(const TokenContext &c);
  static std::optional<CapturedRecordAttr> from(const InheritableAttr &parent);

  inline static std::optional<CapturedRecordAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CapturedRecordAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CapturedRecordAttr> from(const Attr &parent);

  inline static std::optional<CapturedRecordAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CapturedRecordAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CapabilityAttrRange = DerivedEntityRange<AttrIterator, CapabilityAttr>;
using CapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CapabilityAttr>;
class CapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CAPABILITY;
  }

  static std::optional<CapabilityAttr> from(const TokenContext &c);
  static std::optional<CapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<CapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CapabilityAttr> from(const Attr &parent);

  inline static std::optional<CapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  CapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_shared(void) const;
};

using CallbackAttrRange = DerivedEntityRange<AttrIterator, CallbackAttr>;
using CallbackAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CallbackAttr>;
class CallbackAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CallbackAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CallbackAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CallbackAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CALLBACK;
  }

  static std::optional<CallbackAttr> from(const TokenContext &c);
  static std::optional<CallbackAttr> from(const InheritableAttr &parent);

  inline static std::optional<CallbackAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CallbackAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CallbackAttr> from(const Attr &parent);

  inline static std::optional<CallbackAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CallbackAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CallableWhenAttrRange = DerivedEntityRange<AttrIterator, CallableWhenAttr>;
using CallableWhenAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CallableWhenAttr>;
class CallableWhenAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CallableWhenAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CallableWhenAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CallableWhenAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CALLABLE_WHEN;
  }

  static std::optional<CallableWhenAttr> from(const TokenContext &c);
  static std::optional<CallableWhenAttr> from(const InheritableAttr &parent);

  inline static std::optional<CallableWhenAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CallableWhenAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CallableWhenAttr> from(const Attr &parent);

  inline static std::optional<CallableWhenAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CallableWhenAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CXX11NoReturnAttrRange = DerivedEntityRange<AttrIterator, CXX11NoReturnAttr>;
using CXX11NoReturnAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXX11NoReturnAttr>;
class CXX11NoReturnAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CXX11NoReturnAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXX11NoReturnAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXX11NoReturnAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CXX11_NO_RETURN;
  }

  static std::optional<CXX11NoReturnAttr> from(const TokenContext &c);
  static std::optional<CXX11NoReturnAttr> from(const InheritableAttr &parent);

  inline static std::optional<CXX11NoReturnAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CXX11NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXX11NoReturnAttr> from(const Attr &parent);

  inline static std::optional<CXX11NoReturnAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CXX11NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDASharedAttrRange = DerivedEntityRange<AttrIterator, CUDASharedAttr>;
using CUDASharedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDASharedAttr>;
class CUDASharedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDASharedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDASharedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDASharedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_SHARED;
  }

  static std::optional<CUDASharedAttr> from(const TokenContext &c);
  static std::optional<CUDASharedAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDASharedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDASharedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDASharedAttr> from(const Attr &parent);

  inline static std::optional<CUDASharedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDASharedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDALaunchBoundsAttrRange = DerivedEntityRange<AttrIterator, CUDALaunchBoundsAttr>;
using CUDALaunchBoundsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDALaunchBoundsAttr>;
class CUDALaunchBoundsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDALaunchBoundsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDALaunchBoundsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDALaunchBoundsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_LAUNCH_BOUNDS;
  }

  static std::optional<CUDALaunchBoundsAttr> from(const TokenContext &c);
  static std::optional<CUDALaunchBoundsAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDALaunchBoundsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDALaunchBoundsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDALaunchBoundsAttr> from(const Attr &parent);

  inline static std::optional<CUDALaunchBoundsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDALaunchBoundsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr max_threads(void) const;
  Expr min_blocks(void) const;
  std::string_view spelling(void) const;
};

using CUDAInvalidTargetAttrRange = DerivedEntityRange<AttrIterator, CUDAInvalidTargetAttr>;
using CUDAInvalidTargetAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDAInvalidTargetAttr>;
class CUDAInvalidTargetAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDAInvalidTargetAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDAInvalidTargetAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDAInvalidTargetAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_INVALID_TARGET;
  }

  static std::optional<CUDAInvalidTargetAttr> from(const TokenContext &c);
  static std::optional<CUDAInvalidTargetAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDAInvalidTargetAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDAInvalidTargetAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAInvalidTargetAttr> from(const Attr &parent);

  inline static std::optional<CUDAInvalidTargetAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDAInvalidTargetAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDAHostAttrRange = DerivedEntityRange<AttrIterator, CUDAHostAttr>;
using CUDAHostAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDAHostAttr>;
class CUDAHostAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDAHostAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDAHostAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDAHostAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_HOST;
  }

  static std::optional<CUDAHostAttr> from(const TokenContext &c);
  static std::optional<CUDAHostAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDAHostAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDAHostAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAHostAttr> from(const Attr &parent);

  inline static std::optional<CUDAHostAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDAHostAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDAGlobalAttrRange = DerivedEntityRange<AttrIterator, CUDAGlobalAttr>;
using CUDAGlobalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDAGlobalAttr>;
class CUDAGlobalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDAGlobalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDAGlobalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDAGlobalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_GLOBAL;
  }

  static std::optional<CUDAGlobalAttr> from(const TokenContext &c);
  static std::optional<CUDAGlobalAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDAGlobalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDAGlobalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAGlobalAttr> from(const Attr &parent);

  inline static std::optional<CUDAGlobalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDAGlobalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDADeviceBuiltinTextureTypeAttrRange = DerivedEntityRange<AttrIterator, CUDADeviceBuiltinTextureTypeAttr>;
using CUDADeviceBuiltinTextureTypeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDADeviceBuiltinTextureTypeAttr>;
class CUDADeviceBuiltinTextureTypeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDADeviceBuiltinTextureTypeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDADeviceBuiltinTextureTypeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDADeviceBuiltinTextureTypeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_DEVICE_BUILTIN_TEXTURE_TYPE;
  }

  static std::optional<CUDADeviceBuiltinTextureTypeAttr> from(const TokenContext &c);
  static std::optional<CUDADeviceBuiltinTextureTypeAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDADeviceBuiltinTextureTypeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDADeviceBuiltinTextureTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDADeviceBuiltinTextureTypeAttr> from(const Attr &parent);

  inline static std::optional<CUDADeviceBuiltinTextureTypeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDADeviceBuiltinTextureTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDADeviceBuiltinSurfaceTypeAttrRange = DerivedEntityRange<AttrIterator, CUDADeviceBuiltinSurfaceTypeAttr>;
using CUDADeviceBuiltinSurfaceTypeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDADeviceBuiltinSurfaceTypeAttr>;
class CUDADeviceBuiltinSurfaceTypeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDADeviceBuiltinSurfaceTypeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDADeviceBuiltinSurfaceTypeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDADeviceBuiltinSurfaceTypeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_DEVICE_BUILTIN_SURFACE_TYPE;
  }

  static std::optional<CUDADeviceBuiltinSurfaceTypeAttr> from(const TokenContext &c);
  static std::optional<CUDADeviceBuiltinSurfaceTypeAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDADeviceBuiltinSurfaceTypeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDADeviceBuiltinSurfaceTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDADeviceBuiltinSurfaceTypeAttr> from(const Attr &parent);

  inline static std::optional<CUDADeviceBuiltinSurfaceTypeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDADeviceBuiltinSurfaceTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDADeviceAttrRange = DerivedEntityRange<AttrIterator, CUDADeviceAttr>;
using CUDADeviceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDADeviceAttr>;
class CUDADeviceAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDADeviceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDADeviceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDADeviceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_DEVICE;
  }

  static std::optional<CUDADeviceAttr> from(const TokenContext &c);
  static std::optional<CUDADeviceAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDADeviceAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDADeviceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDADeviceAttr> from(const Attr &parent);

  inline static std::optional<CUDADeviceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDADeviceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CUDAConstantAttrRange = DerivedEntityRange<AttrIterator, CUDAConstantAttr>;
using CUDAConstantAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDAConstantAttr>;
class CUDAConstantAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CUDAConstantAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDAConstantAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDAConstantAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CUDA_CONSTANT;
  }

  static std::optional<CUDAConstantAttr> from(const TokenContext &c);
  static std::optional<CUDAConstantAttr> from(const InheritableAttr &parent);

  inline static std::optional<CUDAConstantAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CUDAConstantAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAConstantAttr> from(const Attr &parent);

  inline static std::optional<CUDAConstantAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CUDAConstantAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CPUSpecificAttrRange = DerivedEntityRange<AttrIterator, CPUSpecificAttr>;
using CPUSpecificAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CPUSpecificAttr>;
class CPUSpecificAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CPUSpecificAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CPUSpecificAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CPUSpecificAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CPU_SPECIFIC;
  }

  static std::optional<CPUSpecificAttr> from(const TokenContext &c);
  static std::optional<CPUSpecificAttr> from(const InheritableAttr &parent);

  inline static std::optional<CPUSpecificAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CPUSpecificAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CPUSpecificAttr> from(const Attr &parent);

  inline static std::optional<CPUSpecificAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CPUSpecificAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CPUDispatchAttrRange = DerivedEntityRange<AttrIterator, CPUDispatchAttr>;
using CPUDispatchAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CPUDispatchAttr>;
class CPUDispatchAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CPUDispatchAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CPUDispatchAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CPUDispatchAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CPU_DISPATCH;
  }

  static std::optional<CPUDispatchAttr> from(const TokenContext &c);
  static std::optional<CPUDispatchAttr> from(const InheritableAttr &parent);

  inline static std::optional<CPUDispatchAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CPUDispatchAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CPUDispatchAttr> from(const Attr &parent);

  inline static std::optional<CPUDispatchAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CPUDispatchAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFUnknownTransferAttrRange = DerivedEntityRange<AttrIterator, CFUnknownTransferAttr>;
using CFUnknownTransferAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFUnknownTransferAttr>;
class CFUnknownTransferAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFUnknownTransferAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFUnknownTransferAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFUnknownTransferAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_UNKNOWN_TRANSFER;
  }

  static std::optional<CFUnknownTransferAttr> from(const TokenContext &c);
  static std::optional<CFUnknownTransferAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFUnknownTransferAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFUnknownTransferAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFUnknownTransferAttr> from(const Attr &parent);

  inline static std::optional<CFUnknownTransferAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFUnknownTransferAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFReturnsRetainedAttrRange = DerivedEntityRange<AttrIterator, CFReturnsRetainedAttr>;
using CFReturnsRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFReturnsRetainedAttr>;
class CFReturnsRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFReturnsRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFReturnsRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFReturnsRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_RETURNS_RETAINED;
  }

  static std::optional<CFReturnsRetainedAttr> from(const TokenContext &c);
  static std::optional<CFReturnsRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFReturnsRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFReturnsRetainedAttr> from(const Attr &parent);

  inline static std::optional<CFReturnsRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFReturnsNotRetainedAttrRange = DerivedEntityRange<AttrIterator, CFReturnsNotRetainedAttr>;
using CFReturnsNotRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFReturnsNotRetainedAttr>;
class CFReturnsNotRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFReturnsNotRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFReturnsNotRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFReturnsNotRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_RETURNS_NOT_RETAINED;
  }

  static std::optional<CFReturnsNotRetainedAttr> from(const TokenContext &c);
  static std::optional<CFReturnsNotRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFReturnsNotRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFReturnsNotRetainedAttr> from(const Attr &parent);

  inline static std::optional<CFReturnsNotRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFICanonicalJumpTableAttrRange = DerivedEntityRange<AttrIterator, CFICanonicalJumpTableAttr>;
using CFICanonicalJumpTableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFICanonicalJumpTableAttr>;
class CFICanonicalJumpTableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFICanonicalJumpTableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFICanonicalJumpTableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFICanonicalJumpTableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CFI_CANONICAL_JUMP_TABLE;
  }

  static std::optional<CFICanonicalJumpTableAttr> from(const TokenContext &c);
  static std::optional<CFICanonicalJumpTableAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFICanonicalJumpTableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFICanonicalJumpTableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFICanonicalJumpTableAttr> from(const Attr &parent);

  inline static std::optional<CFICanonicalJumpTableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFICanonicalJumpTableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFGuardAttrRange = DerivedEntityRange<AttrIterator, CFGuardAttr>;
using CFGuardAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFGuardAttr>;
class CFGuardAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFGuardAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFGuardAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFGuardAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_GUARD;
  }

  static std::optional<CFGuardAttr> from(const TokenContext &c);
  static std::optional<CFGuardAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFGuardAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFGuardAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFGuardAttr> from(const Attr &parent);

  inline static std::optional<CFGuardAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFGuardAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CFGuardAttrGuardArg guard(void) const;
  std::string_view spelling(void) const;
};

using CFAuditedTransferAttrRange = DerivedEntityRange<AttrIterator, CFAuditedTransferAttr>;
using CFAuditedTransferAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFAuditedTransferAttr>;
class CFAuditedTransferAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFAuditedTransferAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFAuditedTransferAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFAuditedTransferAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_AUDITED_TRANSFER;
  }

  static std::optional<CFAuditedTransferAttr> from(const TokenContext &c);
  static std::optional<CFAuditedTransferAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFAuditedTransferAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFAuditedTransferAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFAuditedTransferAttr> from(const Attr &parent);

  inline static std::optional<CFAuditedTransferAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFAuditedTransferAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CDeclAttrRange = DerivedEntityRange<AttrIterator, CDeclAttr>;
using CDeclAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CDeclAttr>;
class CDeclAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CDeclAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CDeclAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CDeclAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::C_DECL;
  }

  static std::optional<CDeclAttr> from(const TokenContext &c);
  static std::optional<CDeclAttr> from(const InheritableAttr &parent);

  inline static std::optional<CDeclAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CDeclAttr> from(const Attr &parent);

  inline static std::optional<CDeclAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using C11NoReturnAttrRange = DerivedEntityRange<AttrIterator, C11NoReturnAttr>;
using C11NoReturnAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, C11NoReturnAttr>;
class C11NoReturnAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static C11NoReturnAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static C11NoReturnAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : C11NoReturnAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::C11_NO_RETURN;
  }

  static std::optional<C11NoReturnAttr> from(const TokenContext &c);
  static std::optional<C11NoReturnAttr> from(const InheritableAttr &parent);

  inline static std::optional<C11NoReturnAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return C11NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<C11NoReturnAttr> from(const Attr &parent);

  inline static std::optional<C11NoReturnAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return C11NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using BuiltinAttrRange = DerivedEntityRange<AttrIterator, BuiltinAttr>;
using BuiltinAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BuiltinAttr>;
class BuiltinAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static BuiltinAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BuiltinAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BuiltinAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BUILTIN;
  }

  static std::optional<BuiltinAttr> from(const TokenContext &c);
  static std::optional<BuiltinAttr> from(const InheritableAttr &parent);

  inline static std::optional<BuiltinAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return BuiltinAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinAttr> from(const Attr &parent);

  inline static std::optional<BuiltinAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BuiltinAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using BlocksAttrRange = DerivedEntityRange<AttrIterator, BlocksAttr>;
using BlocksAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BlocksAttr>;
class BlocksAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static BlocksAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BlocksAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BlocksAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BLOCKS;
  }

  static std::optional<BlocksAttr> from(const TokenContext &c);
  static std::optional<BlocksAttr> from(const InheritableAttr &parent);

  inline static std::optional<BlocksAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return BlocksAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BlocksAttr> from(const Attr &parent);

  inline static std::optional<BlocksAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BlocksAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  BlocksAttrBlockType type(void) const;
};

using BTFDeclTagAttrRange = DerivedEntityRange<AttrIterator, BTFDeclTagAttr>;
using BTFDeclTagAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BTFDeclTagAttr>;
class BTFDeclTagAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static BTFDeclTagAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BTFDeclTagAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BTFDeclTagAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BTF_DECL_TAG;
  }

  static std::optional<BTFDeclTagAttr> from(const TokenContext &c);
  static std::optional<BTFDeclTagAttr> from(const InheritableAttr &parent);

  inline static std::optional<BTFDeclTagAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return BTFDeclTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BTFDeclTagAttr> from(const Attr &parent);

  inline static std::optional<BTFDeclTagAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BTFDeclTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view btf_decl_tag(void) const;
  std::string_view spelling(void) const;
};

using BPFPreserveAccessIndexAttrRange = DerivedEntityRange<AttrIterator, BPFPreserveAccessIndexAttr>;
using BPFPreserveAccessIndexAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BPFPreserveAccessIndexAttr>;
class BPFPreserveAccessIndexAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static BPFPreserveAccessIndexAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BPFPreserveAccessIndexAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BPFPreserveAccessIndexAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BPF_PRESERVE_ACCESS_INDEX;
  }

  static std::optional<BPFPreserveAccessIndexAttr> from(const TokenContext &c);
  static std::optional<BPFPreserveAccessIndexAttr> from(const InheritableAttr &parent);

  inline static std::optional<BPFPreserveAccessIndexAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return BPFPreserveAccessIndexAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BPFPreserveAccessIndexAttr> from(const Attr &parent);

  inline static std::optional<BPFPreserveAccessIndexAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BPFPreserveAccessIndexAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AvailabilityAttrRange = DerivedEntityRange<AttrIterator, AvailabilityAttr>;
using AvailabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AvailabilityAttr>;
class AvailabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AvailabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AvailabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AvailabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AVAILABILITY;
  }

  static std::optional<AvailabilityAttr> from(const TokenContext &c);
  static std::optional<AvailabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<AvailabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AvailabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AvailabilityAttr> from(const Attr &parent);

  inline static std::optional<AvailabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AvailabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view message(void) const;
  std::string_view replacement(void) const;
  std::string_view spelling(void) const;
  bool strict(void) const;
  bool unavailable(void) const;
};

using AssumptionAttrRange = DerivedEntityRange<AttrIterator, AssumptionAttr>;
using AssumptionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AssumptionAttr>;
class AssumptionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AssumptionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AssumptionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AssumptionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASSUMPTION;
  }

  static std::optional<AssumptionAttr> from(const TokenContext &c);
  static std::optional<AssumptionAttr> from(const InheritableAttr &parent);

  inline static std::optional<AssumptionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AssumptionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AssumptionAttr> from(const Attr &parent);

  inline static std::optional<AssumptionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AssumptionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view assumption(void) const;
  std::string_view spelling(void) const;
};

using AssumeAlignedAttrRange = DerivedEntityRange<AttrIterator, AssumeAlignedAttr>;
using AssumeAlignedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AssumeAlignedAttr>;
class AssumeAlignedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AssumeAlignedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AssumeAlignedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AssumeAlignedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASSUME_ALIGNED;
  }

  static std::optional<AssumeAlignedAttr> from(const TokenContext &c);
  static std::optional<AssumeAlignedAttr> from(const InheritableAttr &parent);

  inline static std::optional<AssumeAlignedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AssumeAlignedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AssumeAlignedAttr> from(const Attr &parent);

  inline static std::optional<AssumeAlignedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AssumeAlignedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr alignment(void) const;
  std::optional<Expr> offset(void) const;
  std::string_view spelling(void) const;
};

using AssertSharedLockAttrRange = DerivedEntityRange<AttrIterator, AssertSharedLockAttr>;
using AssertSharedLockAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AssertSharedLockAttr>;
class AssertSharedLockAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AssertSharedLockAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AssertSharedLockAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AssertSharedLockAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASSERT_SHARED_LOCK;
  }

  static std::optional<AssertSharedLockAttr> from(const TokenContext &c);
  static std::optional<AssertSharedLockAttr> from(const InheritableAttr &parent);

  inline static std::optional<AssertSharedLockAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AssertSharedLockAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AssertSharedLockAttr> from(const Attr &parent);

  inline static std::optional<AssertSharedLockAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AssertSharedLockAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AssertExclusiveLockAttrRange = DerivedEntityRange<AttrIterator, AssertExclusiveLockAttr>;
using AssertExclusiveLockAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AssertExclusiveLockAttr>;
class AssertExclusiveLockAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AssertExclusiveLockAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AssertExclusiveLockAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AssertExclusiveLockAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASSERT_EXCLUSIVE_LOCK;
  }

  static std::optional<AssertExclusiveLockAttr> from(const TokenContext &c);
  static std::optional<AssertExclusiveLockAttr> from(const InheritableAttr &parent);

  inline static std::optional<AssertExclusiveLockAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AssertExclusiveLockAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AssertExclusiveLockAttr> from(const Attr &parent);

  inline static std::optional<AssertExclusiveLockAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AssertExclusiveLockAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AssertCapabilityAttrRange = DerivedEntityRange<AttrIterator, AssertCapabilityAttr>;
using AssertCapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AssertCapabilityAttr>;
class AssertCapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AssertCapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AssertCapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AssertCapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASSERT_CAPABILITY;
  }

  static std::optional<AssertCapabilityAttr> from(const TokenContext &c);
  static std::optional<AssertCapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<AssertCapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AssertCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AssertCapabilityAttr> from(const Attr &parent);

  inline static std::optional<AssertCapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AssertCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  AssertCapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_shared(void) const;
};

using AsmLabelAttrRange = DerivedEntityRange<AttrIterator, AsmLabelAttr>;
using AsmLabelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AsmLabelAttr>;
class AsmLabelAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AsmLabelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AsmLabelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AsmLabelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ASM_LABEL;
  }

  static std::optional<AsmLabelAttr> from(const TokenContext &c);
  static std::optional<AsmLabelAttr> from(const InheritableAttr &parent);

  inline static std::optional<AsmLabelAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AsmLabelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AsmLabelAttr> from(const Attr &parent);

  inline static std::optional<AsmLabelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AsmLabelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_literal_label(void) const;
  std::string_view label(void) const;
  std::string_view spelling(void) const;
};

using ArtificialAttrRange = DerivedEntityRange<AttrIterator, ArtificialAttr>;
using ArtificialAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArtificialAttr>;
class ArtificialAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ArtificialAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArtificialAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArtificialAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARTIFICIAL;
  }

  static std::optional<ArtificialAttr> from(const TokenContext &c);
  static std::optional<ArtificialAttr> from(const InheritableAttr &parent);

  inline static std::optional<ArtificialAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ArtificialAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArtificialAttr> from(const Attr &parent);

  inline static std::optional<ArtificialAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ArtificialAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ArmBuiltinAliasAttrRange = DerivedEntityRange<AttrIterator, ArmBuiltinAliasAttr>;
using ArmBuiltinAliasAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArmBuiltinAliasAttr>;
class ArmBuiltinAliasAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ArmBuiltinAliasAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArmBuiltinAliasAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArmBuiltinAliasAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARM_BUILTIN_ALIAS;
  }

  static std::optional<ArmBuiltinAliasAttr> from(const TokenContext &c);
  static std::optional<ArmBuiltinAliasAttr> from(const InheritableAttr &parent);

  inline static std::optional<ArmBuiltinAliasAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ArmBuiltinAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArmBuiltinAliasAttr> from(const Attr &parent);

  inline static std::optional<ArmBuiltinAliasAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ArmBuiltinAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ArgumentWithTypeTagAttrRange = DerivedEntityRange<AttrIterator, ArgumentWithTypeTagAttr>;
using ArgumentWithTypeTagAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArgumentWithTypeTagAttr>;
class ArgumentWithTypeTagAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ArgumentWithTypeTagAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArgumentWithTypeTagAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArgumentWithTypeTagAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARGUMENT_WITH_TYPE_TAG;
  }

  static std::optional<ArgumentWithTypeTagAttr> from(const TokenContext &c);
  static std::optional<ArgumentWithTypeTagAttr> from(const InheritableAttr &parent);

  inline static std::optional<ArgumentWithTypeTagAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ArgumentWithTypeTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArgumentWithTypeTagAttr> from(const Attr &parent);

  inline static std::optional<ArgumentWithTypeTagAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ArgumentWithTypeTagAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_pointer(void) const;
  ArgumentWithTypeTagAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using ArcWeakrefUnavailableAttrRange = DerivedEntityRange<AttrIterator, ArcWeakrefUnavailableAttr>;
using ArcWeakrefUnavailableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArcWeakrefUnavailableAttr>;
class ArcWeakrefUnavailableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ArcWeakrefUnavailableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArcWeakrefUnavailableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArcWeakrefUnavailableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARC_WEAKREF_UNAVAILABLE;
  }

  static std::optional<ArcWeakrefUnavailableAttr> from(const TokenContext &c);
  static std::optional<ArcWeakrefUnavailableAttr> from(const InheritableAttr &parent);

  inline static std::optional<ArcWeakrefUnavailableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ArcWeakrefUnavailableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArcWeakrefUnavailableAttr> from(const Attr &parent);

  inline static std::optional<ArcWeakrefUnavailableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ArcWeakrefUnavailableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AnyX86NoCfCheckAttrRange = DerivedEntityRange<AttrIterator, AnyX86NoCfCheckAttr>;
using AnyX86NoCfCheckAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AnyX86NoCfCheckAttr>;
class AnyX86NoCfCheckAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AnyX86NoCfCheckAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AnyX86NoCfCheckAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AnyX86NoCfCheckAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ANY_X86_NO_CF_CHECK;
  }

  static std::optional<AnyX86NoCfCheckAttr> from(const TokenContext &c);
  static std::optional<AnyX86NoCfCheckAttr> from(const InheritableAttr &parent);

  inline static std::optional<AnyX86NoCfCheckAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AnyX86NoCfCheckAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnyX86NoCfCheckAttr> from(const Attr &parent);

  inline static std::optional<AnyX86NoCfCheckAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AnyX86NoCfCheckAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AnyX86NoCallerSavedRegistersAttrRange = DerivedEntityRange<AttrIterator, AnyX86NoCallerSavedRegistersAttr>;
using AnyX86NoCallerSavedRegistersAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AnyX86NoCallerSavedRegistersAttr>;
class AnyX86NoCallerSavedRegistersAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AnyX86NoCallerSavedRegistersAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AnyX86NoCallerSavedRegistersAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AnyX86NoCallerSavedRegistersAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ANY_X86_NO_CALLER_SAVED_REGISTERS;
  }

  static std::optional<AnyX86NoCallerSavedRegistersAttr> from(const TokenContext &c);
  static std::optional<AnyX86NoCallerSavedRegistersAttr> from(const InheritableAttr &parent);

  inline static std::optional<AnyX86NoCallerSavedRegistersAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AnyX86NoCallerSavedRegistersAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnyX86NoCallerSavedRegistersAttr> from(const Attr &parent);

  inline static std::optional<AnyX86NoCallerSavedRegistersAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AnyX86NoCallerSavedRegistersAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AnyX86InterruptAttrRange = DerivedEntityRange<AttrIterator, AnyX86InterruptAttr>;
using AnyX86InterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AnyX86InterruptAttr>;
class AnyX86InterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AnyX86InterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AnyX86InterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AnyX86InterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ANY_X86_INTERRUPT;
  }

  static std::optional<AnyX86InterruptAttr> from(const TokenContext &c);
  static std::optional<AnyX86InterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<AnyX86InterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AnyX86InterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnyX86InterruptAttr> from(const Attr &parent);

  inline static std::optional<AnyX86InterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AnyX86InterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AnalyzerNoReturnAttrRange = DerivedEntityRange<AttrIterator, AnalyzerNoReturnAttr>;
using AnalyzerNoReturnAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AnalyzerNoReturnAttr>;
class AnalyzerNoReturnAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AnalyzerNoReturnAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AnalyzerNoReturnAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AnalyzerNoReturnAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ANALYZER_NO_RETURN;
  }

  static std::optional<AnalyzerNoReturnAttr> from(const TokenContext &c);
  static std::optional<AnalyzerNoReturnAttr> from(const InheritableAttr &parent);

  inline static std::optional<AnalyzerNoReturnAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AnalyzerNoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnalyzerNoReturnAttr> from(const Attr &parent);

  inline static std::optional<AnalyzerNoReturnAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AnalyzerNoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AlwaysInlineAttrRange = DerivedEntityRange<AttrIterator, AlwaysInlineAttr>;
using AlwaysInlineAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlwaysInlineAttr>;
class AlwaysInlineAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AlwaysInlineAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlwaysInlineAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlwaysInlineAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALWAYS_INLINE;
  }

  static std::optional<AlwaysInlineAttr> from(const TokenContext &c);
  static std::optional<AlwaysInlineAttr> from(const InheritableAttr &parent);

  inline static std::optional<AlwaysInlineAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AlwaysInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AlwaysInlineAttr> from(const Attr &parent);

  inline static std::optional<AlwaysInlineAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlwaysInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  AlwaysInlineAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using AlwaysDestroyAttrRange = DerivedEntityRange<AttrIterator, AlwaysDestroyAttr>;
using AlwaysDestroyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlwaysDestroyAttr>;
class AlwaysDestroyAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AlwaysDestroyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlwaysDestroyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlwaysDestroyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALWAYS_DESTROY;
  }

  static std::optional<AlwaysDestroyAttr> from(const TokenContext &c);
  static std::optional<AlwaysDestroyAttr> from(const InheritableAttr &parent);

  inline static std::optional<AlwaysDestroyAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AlwaysDestroyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AlwaysDestroyAttr> from(const Attr &parent);

  inline static std::optional<AlwaysDestroyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlwaysDestroyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AllocSizeAttrRange = DerivedEntityRange<AttrIterator, AllocSizeAttr>;
using AllocSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AllocSizeAttr>;
class AllocSizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AllocSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AllocSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AllocSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALLOC_SIZE;
  }

  static std::optional<AllocSizeAttr> from(const TokenContext &c);
  static std::optional<AllocSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<AllocSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AllocSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AllocSizeAttr> from(const Attr &parent);

  inline static std::optional<AllocSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AllocSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AllocAlignAttrRange = DerivedEntityRange<AttrIterator, AllocAlignAttr>;
using AllocAlignAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AllocAlignAttr>;
class AllocAlignAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AllocAlignAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AllocAlignAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AllocAlignAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALLOC_ALIGN;
  }

  static std::optional<AllocAlignAttr> from(const TokenContext &c);
  static std::optional<AllocAlignAttr> from(const InheritableAttr &parent);

  inline static std::optional<AllocAlignAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AllocAlignAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AllocAlignAttr> from(const Attr &parent);

  inline static std::optional<AllocAlignAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AllocAlignAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AlignedAttrRange = DerivedEntityRange<AttrIterator, AlignedAttr>;
using AlignedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlignedAttr>;
class AlignedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AlignedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlignedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlignedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALIGNED;
  }

  static std::optional<AlignedAttr> from(const TokenContext &c);
  static std::optional<AlignedAttr> from(const InheritableAttr &parent);

  inline static std::optional<AlignedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AlignedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AlignedAttr> from(const Attr &parent);

  inline static std::optional<AlignedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlignedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> alignment_expression(void) const;
  std::optional<Type> alignment_type(void) const;
  AlignedAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_alignas(void) const;
  bool is_alignment_dependent(void) const;
  bool is_alignment_error_dependent(void) const;
  bool is_alignment_expression(void) const;
  bool is_c11(void) const;
  bool is_declspec(void) const;
  bool is_gnu(void) const;
};

using AlignNaturalAttrRange = DerivedEntityRange<AttrIterator, AlignNaturalAttr>;
using AlignNaturalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlignNaturalAttr>;
class AlignNaturalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AlignNaturalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlignNaturalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlignNaturalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALIGN_NATURAL;
  }

  static std::optional<AlignNaturalAttr> from(const TokenContext &c);
  static std::optional<AlignNaturalAttr> from(const InheritableAttr &parent);

  inline static std::optional<AlignNaturalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AlignNaturalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AlignNaturalAttr> from(const Attr &parent);

  inline static std::optional<AlignNaturalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlignNaturalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AlignMac68kAttrRange = DerivedEntityRange<AttrIterator, AlignMac68kAttr>;
using AlignMac68kAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AlignMac68kAttr>;
class AlignMac68kAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AlignMac68kAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AlignMac68kAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AlignMac68kAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ALIGN_MAC68K;
  }

  static std::optional<AlignMac68kAttr> from(const TokenContext &c);
  static std::optional<AlignMac68kAttr> from(const InheritableAttr &parent);

  inline static std::optional<AlignMac68kAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AlignMac68kAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AlignMac68kAttr> from(const Attr &parent);

  inline static std::optional<AlignMac68kAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AlignMac68kAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AcquiredBeforeAttrRange = DerivedEntityRange<AttrIterator, AcquiredBeforeAttr>;
using AcquiredBeforeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AcquiredBeforeAttr>;
class AcquiredBeforeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AcquiredBeforeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AcquiredBeforeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AcquiredBeforeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ACQUIRED_BEFORE;
  }

  static std::optional<AcquiredBeforeAttr> from(const TokenContext &c);
  static std::optional<AcquiredBeforeAttr> from(const InheritableAttr &parent);

  inline static std::optional<AcquiredBeforeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AcquiredBeforeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AcquiredBeforeAttr> from(const Attr &parent);

  inline static std::optional<AcquiredBeforeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AcquiredBeforeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AcquiredAfterAttrRange = DerivedEntityRange<AttrIterator, AcquiredAfterAttr>;
using AcquiredAfterAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AcquiredAfterAttr>;
class AcquiredAfterAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AcquiredAfterAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AcquiredAfterAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AcquiredAfterAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ACQUIRED_AFTER;
  }

  static std::optional<AcquiredAfterAttr> from(const TokenContext &c);
  static std::optional<AcquiredAfterAttr> from(const InheritableAttr &parent);

  inline static std::optional<AcquiredAfterAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AcquiredAfterAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AcquiredAfterAttr> from(const Attr &parent);

  inline static std::optional<AcquiredAfterAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AcquiredAfterAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AcquireHandleAttrRange = DerivedEntityRange<AttrIterator, AcquireHandleAttr>;
using AcquireHandleAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AcquireHandleAttr>;
class AcquireHandleAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AcquireHandleAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AcquireHandleAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AcquireHandleAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ACQUIRE_HANDLE;
  }

  static std::optional<AcquireHandleAttr> from(const TokenContext &c);
  static std::optional<AcquireHandleAttr> from(const InheritableAttr &parent);

  inline static std::optional<AcquireHandleAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AcquireHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AcquireHandleAttr> from(const Attr &parent);

  inline static std::optional<AcquireHandleAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AcquireHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view handle_type(void) const;
  std::string_view spelling(void) const;
};

using AcquireCapabilityAttrRange = DerivedEntityRange<AttrIterator, AcquireCapabilityAttr>;
using AcquireCapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AcquireCapabilityAttr>;
class AcquireCapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AcquireCapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AcquireCapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AcquireCapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ACQUIRE_CAPABILITY;
  }

  static std::optional<AcquireCapabilityAttr> from(const TokenContext &c);
  static std::optional<AcquireCapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<AcquireCapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AcquireCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AcquireCapabilityAttr> from(const Attr &parent);

  inline static std::optional<AcquireCapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AcquireCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  AcquireCapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_shared(void) const;
};

using AVRSignalAttrRange = DerivedEntityRange<AttrIterator, AVRSignalAttr>;
using AVRSignalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AVRSignalAttr>;
class AVRSignalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AVRSignalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AVRSignalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AVRSignalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AVR_SIGNAL;
  }

  static std::optional<AVRSignalAttr> from(const TokenContext &c);
  static std::optional<AVRSignalAttr> from(const InheritableAttr &parent);

  inline static std::optional<AVRSignalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AVRSignalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AVRSignalAttr> from(const Attr &parent);

  inline static std::optional<AVRSignalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AVRSignalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AVRInterruptAttrRange = DerivedEntityRange<AttrIterator, AVRInterruptAttr>;
using AVRInterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AVRInterruptAttr>;
class AVRInterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AVRInterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AVRInterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AVRInterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AVR_INTERRUPT;
  }

  static std::optional<AVRInterruptAttr> from(const TokenContext &c);
  static std::optional<AVRInterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<AVRInterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AVRInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AVRInterruptAttr> from(const Attr &parent);

  inline static std::optional<AVRInterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AVRInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ARMInterruptAttrRange = DerivedEntityRange<AttrIterator, ARMInterruptAttr>;
using ARMInterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ARMInterruptAttr>;
class ARMInterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ARMInterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ARMInterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ARMInterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ARM_INTERRUPT;
  }

  static std::optional<ARMInterruptAttr> from(const TokenContext &c);
  static std::optional<ARMInterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<ARMInterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ARMInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ARMInterruptAttr> from(const Attr &parent);

  inline static std::optional<ARMInterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ARMInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ARMInterruptAttrInterruptType interrupt(void) const;
  std::string_view spelling(void) const;
};

using AMDGPUWavesPerEUAttrRange = DerivedEntityRange<AttrIterator, AMDGPUWavesPerEUAttr>;
using AMDGPUWavesPerEUAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AMDGPUWavesPerEUAttr>;
class AMDGPUWavesPerEUAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AMDGPUWavesPerEUAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AMDGPUWavesPerEUAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AMDGPUWavesPerEUAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AMDGPU_WAVES_PER_EU;
  }

  static std::optional<AMDGPUWavesPerEUAttr> from(const TokenContext &c);
  static std::optional<AMDGPUWavesPerEUAttr> from(const InheritableAttr &parent);

  inline static std::optional<AMDGPUWavesPerEUAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AMDGPUWavesPerEUAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AMDGPUWavesPerEUAttr> from(const Attr &parent);

  inline static std::optional<AMDGPUWavesPerEUAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AMDGPUWavesPerEUAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr max(void) const;
  Expr min(void) const;
  std::string_view spelling(void) const;
};

using AMDGPUNumVGPRAttrRange = DerivedEntityRange<AttrIterator, AMDGPUNumVGPRAttr>;
using AMDGPUNumVGPRAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AMDGPUNumVGPRAttr>;
class AMDGPUNumVGPRAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AMDGPUNumVGPRAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AMDGPUNumVGPRAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AMDGPUNumVGPRAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AMDGPU_NUM_VGPR;
  }

  static std::optional<AMDGPUNumVGPRAttr> from(const TokenContext &c);
  static std::optional<AMDGPUNumVGPRAttr> from(const InheritableAttr &parent);

  inline static std::optional<AMDGPUNumVGPRAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AMDGPUNumVGPRAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AMDGPUNumVGPRAttr> from(const Attr &parent);

  inline static std::optional<AMDGPUNumVGPRAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AMDGPUNumVGPRAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AMDGPUNumSGPRAttrRange = DerivedEntityRange<AttrIterator, AMDGPUNumSGPRAttr>;
using AMDGPUNumSGPRAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AMDGPUNumSGPRAttr>;
class AMDGPUNumSGPRAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AMDGPUNumSGPRAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AMDGPUNumSGPRAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AMDGPUNumSGPRAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AMDGPU_NUM_SGPR;
  }

  static std::optional<AMDGPUNumSGPRAttr> from(const TokenContext &c);
  static std::optional<AMDGPUNumSGPRAttr> from(const InheritableAttr &parent);

  inline static std::optional<AMDGPUNumSGPRAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AMDGPUNumSGPRAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AMDGPUNumSGPRAttr> from(const Attr &parent);

  inline static std::optional<AMDGPUNumSGPRAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AMDGPUNumSGPRAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AMDGPUFlatWorkGroupSizeAttrRange = DerivedEntityRange<AttrIterator, AMDGPUFlatWorkGroupSizeAttr>;
using AMDGPUFlatWorkGroupSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AMDGPUFlatWorkGroupSizeAttr>;
class AMDGPUFlatWorkGroupSizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AMDGPUFlatWorkGroupSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AMDGPUFlatWorkGroupSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AMDGPUFlatWorkGroupSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::AMDGPU_FLAT_WORK_GROUP_SIZE;
  }

  static std::optional<AMDGPUFlatWorkGroupSizeAttr> from(const TokenContext &c);
  static std::optional<AMDGPUFlatWorkGroupSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<AMDGPUFlatWorkGroupSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AMDGPUFlatWorkGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AMDGPUFlatWorkGroupSizeAttr> from(const Attr &parent);

  inline static std::optional<AMDGPUFlatWorkGroupSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AMDGPUFlatWorkGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr max(void) const;
  Expr min(void) const;
  std::string_view spelling(void) const;
};

using AArch64VectorPcsAttrRange = DerivedEntityRange<AttrIterator, AArch64VectorPcsAttr>;
using AArch64VectorPcsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AArch64VectorPcsAttr>;
class AArch64VectorPcsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AArch64VectorPcsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AArch64VectorPcsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AArch64VectorPcsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::A_ARCH64_VECTOR_PCS;
  }

  static std::optional<AArch64VectorPcsAttr> from(const TokenContext &c);
  static std::optional<AArch64VectorPcsAttr> from(const InheritableAttr &parent);

  inline static std::optional<AArch64VectorPcsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AArch64VectorPcsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AArch64VectorPcsAttr> from(const Attr &parent);

  inline static std::optional<AArch64VectorPcsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AArch64VectorPcsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using XRayLogArgsAttrRange = DerivedEntityRange<AttrIterator, XRayLogArgsAttr>;
using XRayLogArgsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, XRayLogArgsAttr>;
class XRayLogArgsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static XRayLogArgsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static XRayLogArgsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : XRayLogArgsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::X_RAY_LOG_ARGS;
  }

  static std::optional<XRayLogArgsAttr> from(const TokenContext &c);
  static std::optional<XRayLogArgsAttr> from(const InheritableAttr &parent);

  inline static std::optional<XRayLogArgsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return XRayLogArgsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<XRayLogArgsAttr> from(const Attr &parent);

  inline static std::optional<XRayLogArgsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return XRayLogArgsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using XRayInstrumentAttrRange = DerivedEntityRange<AttrIterator, XRayInstrumentAttr>;
using XRayInstrumentAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, XRayInstrumentAttr>;
class XRayInstrumentAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static XRayInstrumentAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static XRayInstrumentAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : XRayInstrumentAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::X_RAY_INSTRUMENT;
  }

  static std::optional<XRayInstrumentAttr> from(const TokenContext &c);
  static std::optional<XRayInstrumentAttr> from(const InheritableAttr &parent);

  inline static std::optional<XRayInstrumentAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return XRayInstrumentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<XRayInstrumentAttr> from(const Attr &parent);

  inline static std::optional<XRayInstrumentAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return XRayInstrumentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool always_x_ray_instrument(void) const;
  XRayInstrumentAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool never_x_ray_instrument(void) const;
};

using X86ForceAlignArgPointerAttrRange = DerivedEntityRange<AttrIterator, X86ForceAlignArgPointerAttr>;
using X86ForceAlignArgPointerAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, X86ForceAlignArgPointerAttr>;
class X86ForceAlignArgPointerAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static X86ForceAlignArgPointerAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static X86ForceAlignArgPointerAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : X86ForceAlignArgPointerAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::X86_FORCE_ALIGN_ARG_POINTER;
  }

  static std::optional<X86ForceAlignArgPointerAttr> from(const TokenContext &c);
  static std::optional<X86ForceAlignArgPointerAttr> from(const InheritableAttr &parent);

  inline static std::optional<X86ForceAlignArgPointerAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return X86ForceAlignArgPointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<X86ForceAlignArgPointerAttr> from(const Attr &parent);

  inline static std::optional<X86ForceAlignArgPointerAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return X86ForceAlignArgPointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using WorkGroupSizeHintAttrRange = DerivedEntityRange<AttrIterator, WorkGroupSizeHintAttr>;
using WorkGroupSizeHintAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WorkGroupSizeHintAttr>;
class WorkGroupSizeHintAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WorkGroupSizeHintAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WorkGroupSizeHintAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WorkGroupSizeHintAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WORK_GROUP_SIZE_HINT;
  }

  static std::optional<WorkGroupSizeHintAttr> from(const TokenContext &c);
  static std::optional<WorkGroupSizeHintAttr> from(const InheritableAttr &parent);

  inline static std::optional<WorkGroupSizeHintAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WorkGroupSizeHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WorkGroupSizeHintAttr> from(const Attr &parent);

  inline static std::optional<WorkGroupSizeHintAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WorkGroupSizeHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using WebAssemblyImportNameAttrRange = DerivedEntityRange<AttrIterator, WebAssemblyImportNameAttr>;
using WebAssemblyImportNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WebAssemblyImportNameAttr>;
class WebAssemblyImportNameAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WebAssemblyImportNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WebAssemblyImportNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WebAssemblyImportNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEB_ASSEMBLY_IMPORT_NAME;
  }

  static std::optional<WebAssemblyImportNameAttr> from(const TokenContext &c);
  static std::optional<WebAssemblyImportNameAttr> from(const InheritableAttr &parent);

  inline static std::optional<WebAssemblyImportNameAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WebAssemblyImportNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WebAssemblyImportNameAttr> from(const Attr &parent);

  inline static std::optional<WebAssemblyImportNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WebAssemblyImportNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view import_name(void) const;
  std::string_view spelling(void) const;
};

using WebAssemblyImportModuleAttrRange = DerivedEntityRange<AttrIterator, WebAssemblyImportModuleAttr>;
using WebAssemblyImportModuleAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WebAssemblyImportModuleAttr>;
class WebAssemblyImportModuleAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WebAssemblyImportModuleAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WebAssemblyImportModuleAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WebAssemblyImportModuleAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEB_ASSEMBLY_IMPORT_MODULE;
  }

  static std::optional<WebAssemblyImportModuleAttr> from(const TokenContext &c);
  static std::optional<WebAssemblyImportModuleAttr> from(const InheritableAttr &parent);

  inline static std::optional<WebAssemblyImportModuleAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WebAssemblyImportModuleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WebAssemblyImportModuleAttr> from(const Attr &parent);

  inline static std::optional<WebAssemblyImportModuleAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WebAssemblyImportModuleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view import_module(void) const;
  std::string_view spelling(void) const;
};

using WebAssemblyExportNameAttrRange = DerivedEntityRange<AttrIterator, WebAssemblyExportNameAttr>;
using WebAssemblyExportNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WebAssemblyExportNameAttr>;
class WebAssemblyExportNameAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WebAssemblyExportNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WebAssemblyExportNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WebAssemblyExportNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEB_ASSEMBLY_EXPORT_NAME;
  }

  static std::optional<WebAssemblyExportNameAttr> from(const TokenContext &c);
  static std::optional<WebAssemblyExportNameAttr> from(const InheritableAttr &parent);

  inline static std::optional<WebAssemblyExportNameAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WebAssemblyExportNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WebAssemblyExportNameAttr> from(const Attr &parent);

  inline static std::optional<WebAssemblyExportNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WebAssemblyExportNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view export_name(void) const;
  std::string_view spelling(void) const;
};

using WeakRefAttrRange = DerivedEntityRange<AttrIterator, WeakRefAttr>;
using WeakRefAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WeakRefAttr>;
class WeakRefAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WeakRefAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WeakRefAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WeakRefAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEAK_REF;
  }

  static std::optional<WeakRefAttr> from(const TokenContext &c);
  static std::optional<WeakRefAttr> from(const InheritableAttr &parent);

  inline static std::optional<WeakRefAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WeakRefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WeakRefAttr> from(const Attr &parent);

  inline static std::optional<WeakRefAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WeakRefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view aliasee(void) const;
  std::string_view spelling(void) const;
};

using WeakImportAttrRange = DerivedEntityRange<AttrIterator, WeakImportAttr>;
using WeakImportAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WeakImportAttr>;
class WeakImportAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WeakImportAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WeakImportAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WeakImportAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEAK_IMPORT;
  }

  static std::optional<WeakImportAttr> from(const TokenContext &c);
  static std::optional<WeakImportAttr> from(const InheritableAttr &parent);

  inline static std::optional<WeakImportAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WeakImportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WeakImportAttr> from(const Attr &parent);

  inline static std::optional<WeakImportAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WeakImportAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using WeakAttrRange = DerivedEntityRange<AttrIterator, WeakAttr>;
using WeakAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WeakAttr>;
class WeakAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WeakAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WeakAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WeakAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WEAK;
  }

  static std::optional<WeakAttr> from(const TokenContext &c);
  static std::optional<WeakAttr> from(const InheritableAttr &parent);

  inline static std::optional<WeakAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WeakAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WeakAttr> from(const Attr &parent);

  inline static std::optional<WeakAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WeakAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using WarnUnusedResultAttrRange = DerivedEntityRange<AttrIterator, WarnUnusedResultAttr>;
using WarnUnusedResultAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WarnUnusedResultAttr>;
class WarnUnusedResultAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WarnUnusedResultAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WarnUnusedResultAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WarnUnusedResultAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WARN_UNUSED_RESULT;
  }

  static std::optional<WarnUnusedResultAttr> from(const TokenContext &c);
  static std::optional<WarnUnusedResultAttr> from(const InheritableAttr &parent);

  inline static std::optional<WarnUnusedResultAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WarnUnusedResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WarnUnusedResultAttr> from(const Attr &parent);

  inline static std::optional<WarnUnusedResultAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WarnUnusedResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_cxx11_no_discard(void) const;
  std::string_view message(void) const;
  WarnUnusedResultAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using WarnUnusedAttrRange = DerivedEntityRange<AttrIterator, WarnUnusedAttr>;
using WarnUnusedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, WarnUnusedAttr>;
class WarnUnusedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static WarnUnusedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WarnUnusedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WarnUnusedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::WARN_UNUSED;
  }

  static std::optional<WarnUnusedAttr> from(const TokenContext &c);
  static std::optional<WarnUnusedAttr> from(const InheritableAttr &parent);

  inline static std::optional<WarnUnusedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return WarnUnusedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<WarnUnusedAttr> from(const Attr &parent);

  inline static std::optional<WarnUnusedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return WarnUnusedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using VisibilityAttrRange = DerivedEntityRange<AttrIterator, VisibilityAttr>;
using VisibilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, VisibilityAttr>;
class VisibilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static VisibilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VisibilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VisibilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::VISIBILITY;
  }

  static std::optional<VisibilityAttr> from(const TokenContext &c);
  static std::optional<VisibilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<VisibilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return VisibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VisibilityAttr> from(const Attr &parent);

  inline static std::optional<VisibilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return VisibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  VisibilityAttrVisibilityType visibility(void) const;
};

using VectorCallAttrRange = DerivedEntityRange<AttrIterator, VectorCallAttr>;
using VectorCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, VectorCallAttr>;
class VectorCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static VectorCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VectorCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VectorCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::VECTOR_CALL;
  }

  static std::optional<VectorCallAttr> from(const TokenContext &c);
  static std::optional<VectorCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<VectorCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return VectorCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VectorCallAttr> from(const Attr &parent);

  inline static std::optional<VectorCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return VectorCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using VecTypeHintAttrRange = DerivedEntityRange<AttrIterator, VecTypeHintAttr>;
using VecTypeHintAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, VecTypeHintAttr>;
class VecTypeHintAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static VecTypeHintAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VecTypeHintAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VecTypeHintAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::VEC_TYPE_HINT;
  }

  static std::optional<VecTypeHintAttr> from(const TokenContext &c);
  static std::optional<VecTypeHintAttr> from(const InheritableAttr &parent);

  inline static std::optional<VecTypeHintAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return VecTypeHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VecTypeHintAttr> from(const Attr &parent);

  inline static std::optional<VecTypeHintAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return VecTypeHintAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  Type type_hint(void) const;
  Type type_hint_token(void) const;
};

using VecReturnAttrRange = DerivedEntityRange<AttrIterator, VecReturnAttr>;
using VecReturnAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, VecReturnAttr>;
class VecReturnAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static VecReturnAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VecReturnAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VecReturnAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::VEC_RETURN;
  }

  static std::optional<VecReturnAttr> from(const TokenContext &c);
  static std::optional<VecReturnAttr> from(const InheritableAttr &parent);

  inline static std::optional<VecReturnAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return VecReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VecReturnAttr> from(const Attr &parent);

  inline static std::optional<VecReturnAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return VecReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UuidAttrRange = DerivedEntityRange<AttrIterator, UuidAttr>;
using UuidAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UuidAttr>;
class UuidAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UuidAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UuidAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UuidAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::UUID;
  }

  static std::optional<UuidAttr> from(const TokenContext &c);
  static std::optional<UuidAttr> from(const InheritableAttr &parent);

  inline static std::optional<UuidAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UuidAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UuidAttr> from(const Attr &parent);

  inline static std::optional<UuidAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UuidAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view guid(void) const;
  MSGuidDecl guid_declaration(void) const;
  std::string_view spelling(void) const;
};

using UsingIfExistsAttrRange = DerivedEntityRange<AttrIterator, UsingIfExistsAttr>;
using UsingIfExistsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingIfExistsAttr>;
class UsingIfExistsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UsingIfExistsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingIfExistsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingIfExistsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::USING_IF_EXISTS;
  }

  static std::optional<UsingIfExistsAttr> from(const TokenContext &c);
  static std::optional<UsingIfExistsAttr> from(const InheritableAttr &parent);

  inline static std::optional<UsingIfExistsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UsingIfExistsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingIfExistsAttr> from(const Attr &parent);

  inline static std::optional<UsingIfExistsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UsingIfExistsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UsedAttrRange = DerivedEntityRange<AttrIterator, UsedAttr>;
using UsedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsedAttr>;
class UsedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UsedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::USED;
  }

  static std::optional<UsedAttr> from(const TokenContext &c);
  static std::optional<UsedAttr> from(const InheritableAttr &parent);

  inline static std::optional<UsedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UsedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsedAttr> from(const Attr &parent);

  inline static std::optional<UsedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UsedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UnusedAttrRange = DerivedEntityRange<AttrIterator, UnusedAttr>;
using UnusedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnusedAttr>;
class UnusedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UnusedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnusedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnusedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::UNUSED;
  }

  static std::optional<UnusedAttr> from(const TokenContext &c);
  static std::optional<UnusedAttr> from(const InheritableAttr &parent);

  inline static std::optional<UnusedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UnusedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnusedAttr> from(const Attr &parent);

  inline static std::optional<UnusedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UnusedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  UnusedAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using UninitializedAttrRange = DerivedEntityRange<AttrIterator, UninitializedAttr>;
using UninitializedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UninitializedAttr>;
class UninitializedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UninitializedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UninitializedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UninitializedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::UNINITIALIZED;
  }

  static std::optional<UninitializedAttr> from(const TokenContext &c);
  static std::optional<UninitializedAttr> from(const InheritableAttr &parent);

  inline static std::optional<UninitializedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UninitializedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UninitializedAttr> from(const Attr &parent);

  inline static std::optional<UninitializedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UninitializedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using UnavailableAttrRange = DerivedEntityRange<AttrIterator, UnavailableAttr>;
using UnavailableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnavailableAttr>;
class UnavailableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UnavailableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnavailableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnavailableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::UNAVAILABLE;
  }

  static std::optional<UnavailableAttr> from(const TokenContext &c);
  static std::optional<UnavailableAttr> from(const InheritableAttr &parent);

  inline static std::optional<UnavailableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UnavailableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnavailableAttr> from(const Attr &parent);

  inline static std::optional<UnavailableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UnavailableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  UnavailableAttrImplicitReason implicit_reason(void) const;
  std::string_view message(void) const;
  std::string_view spelling(void) const;
};

using TypeVisibilityAttrRange = DerivedEntityRange<AttrIterator, TypeVisibilityAttr>;
using TypeVisibilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeVisibilityAttr>;
class TypeVisibilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TypeVisibilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeVisibilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeVisibilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_VISIBILITY;
  }

  static std::optional<TypeVisibilityAttr> from(const TokenContext &c);
  static std::optional<TypeVisibilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<TypeVisibilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TypeVisibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeVisibilityAttr> from(const Attr &parent);

  inline static std::optional<TypeVisibilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeVisibilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  TypeVisibilityAttrVisibilityType visibility(void) const;
};

using TypeTagForDatatypeAttrRange = DerivedEntityRange<AttrIterator, TypeTagForDatatypeAttr>;
using TypeTagForDatatypeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeTagForDatatypeAttr>;
class TypeTagForDatatypeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TypeTagForDatatypeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeTagForDatatypeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeTagForDatatypeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TYPE_TAG_FOR_DATATYPE;
  }

  static std::optional<TypeTagForDatatypeAttr> from(const TokenContext &c);
  static std::optional<TypeTagForDatatypeAttr> from(const InheritableAttr &parent);

  inline static std::optional<TypeTagForDatatypeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TypeTagForDatatypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeTagForDatatypeAttr> from(const Attr &parent);

  inline static std::optional<TypeTagForDatatypeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TypeTagForDatatypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool layout_compatible(void) const;
  Type matching_c_type(void) const;
  Type matching_c_type_token(void) const;
  bool must_be_null(void) const;
  std::string_view spelling(void) const;
};

using TryAcquireCapabilityAttrRange = DerivedEntityRange<AttrIterator, TryAcquireCapabilityAttr>;
using TryAcquireCapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TryAcquireCapabilityAttr>;
class TryAcquireCapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TryAcquireCapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TryAcquireCapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TryAcquireCapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TRY_ACQUIRE_CAPABILITY;
  }

  static std::optional<TryAcquireCapabilityAttr> from(const TokenContext &c);
  static std::optional<TryAcquireCapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<TryAcquireCapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TryAcquireCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TryAcquireCapabilityAttr> from(const Attr &parent);

  inline static std::optional<TryAcquireCapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TryAcquireCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  TryAcquireCapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  Expr success_value(void) const;
  bool is_shared(void) const;
};

using TrivialABIAttrRange = DerivedEntityRange<AttrIterator, TrivialABIAttr>;
using TrivialABIAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TrivialABIAttr>;
class TrivialABIAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TrivialABIAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TrivialABIAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TrivialABIAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TRIVIAL_ABI;
  }

  static std::optional<TrivialABIAttr> from(const TokenContext &c);
  static std::optional<TrivialABIAttr> from(const InheritableAttr &parent);

  inline static std::optional<TrivialABIAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TrivialABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TrivialABIAttr> from(const Attr &parent);

  inline static std::optional<TrivialABIAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TrivialABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TransparentUnionAttrRange = DerivedEntityRange<AttrIterator, TransparentUnionAttr>;
using TransparentUnionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TransparentUnionAttr>;
class TransparentUnionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TransparentUnionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TransparentUnionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TransparentUnionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TRANSPARENT_UNION;
  }

  static std::optional<TransparentUnionAttr> from(const TokenContext &c);
  static std::optional<TransparentUnionAttr> from(const InheritableAttr &parent);

  inline static std::optional<TransparentUnionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TransparentUnionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TransparentUnionAttr> from(const Attr &parent);

  inline static std::optional<TransparentUnionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TransparentUnionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ThisCallAttrRange = DerivedEntityRange<AttrIterator, ThisCallAttr>;
using ThisCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ThisCallAttr>;
class ThisCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ThisCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ThisCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ThisCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::THIS_CALL;
  }

  static std::optional<ThisCallAttr> from(const TokenContext &c);
  static std::optional<ThisCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<ThisCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ThisCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ThisCallAttr> from(const Attr &parent);

  inline static std::optional<ThisCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ThisCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TestTypestateAttrRange = DerivedEntityRange<AttrIterator, TestTypestateAttr>;
using TestTypestateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TestTypestateAttr>;
class TestTypestateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TestTypestateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TestTypestateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TestTypestateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TEST_TYPESTATE;
  }

  static std::optional<TestTypestateAttr> from(const TokenContext &c);
  static std::optional<TestTypestateAttr> from(const InheritableAttr &parent);

  inline static std::optional<TestTypestateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TestTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TestTypestateAttr> from(const Attr &parent);

  inline static std::optional<TestTypestateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TestTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  TestTypestateAttrConsumedState test_state(void) const;
};

using TargetClonesAttrRange = DerivedEntityRange<AttrIterator, TargetClonesAttr>;
using TargetClonesAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TargetClonesAttr>;
class TargetClonesAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TargetClonesAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TargetClonesAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TargetClonesAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TARGET_CLONES;
  }

  static std::optional<TargetClonesAttr> from(const TokenContext &c);
  static std::optional<TargetClonesAttr> from(const InheritableAttr &parent);

  inline static std::optional<TargetClonesAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TargetClonesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TargetClonesAttr> from(const Attr &parent);

  inline static std::optional<TargetClonesAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TargetClonesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using TargetAttrRange = DerivedEntityRange<AttrIterator, TargetAttr>;
using TargetAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TargetAttr>;
class TargetAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TargetAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TargetAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TargetAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TARGET;
  }

  static std::optional<TargetAttr> from(const TokenContext &c);
  static std::optional<TargetAttr> from(const InheritableAttr &parent);

  inline static std::optional<TargetAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TargetAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TargetAttr> from(const Attr &parent);

  inline static std::optional<TargetAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TargetAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view architecture(void) const;
  std::string_view features_string(void) const;
  std::string_view spelling(void) const;
  bool is_default_version(void) const;
};

using TLSModelAttrRange = DerivedEntityRange<AttrIterator, TLSModelAttr>;
using TLSModelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, TLSModelAttr>;
class TLSModelAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static TLSModelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TLSModelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TLSModelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::TLS_MODEL;
  }

  static std::optional<TLSModelAttr> from(const TokenContext &c);
  static std::optional<TLSModelAttr> from(const InheritableAttr &parent);

  inline static std::optional<TLSModelAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return TLSModelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TLSModelAttr> from(const Attr &parent);

  inline static std::optional<TLSModelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return TLSModelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view model(void) const;
  std::string_view spelling(void) const;
};

using SysVABIAttrRange = DerivedEntityRange<AttrIterator, SysVABIAttr>;
using SysVABIAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SysVABIAttr>;
class SysVABIAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SysVABIAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SysVABIAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SysVABIAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SYS_VABI;
  }

  static std::optional<SysVABIAttr> from(const TokenContext &c);
  static std::optional<SysVABIAttr> from(const InheritableAttr &parent);

  inline static std::optional<SysVABIAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SysVABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SysVABIAttr> from(const Attr &parent);

  inline static std::optional<SysVABIAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SysVABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftPrivateAttrRange = DerivedEntityRange<AttrIterator, SwiftPrivateAttr>;
using SwiftPrivateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftPrivateAttr>;
class SwiftPrivateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftPrivateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftPrivateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftPrivateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_PRIVATE;
  }

  static std::optional<SwiftPrivateAttr> from(const TokenContext &c);
  static std::optional<SwiftPrivateAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftPrivateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftPrivateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftPrivateAttr> from(const Attr &parent);

  inline static std::optional<SwiftPrivateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftPrivateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftNewTypeAttrRange = DerivedEntityRange<AttrIterator, SwiftNewTypeAttr>;
using SwiftNewTypeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftNewTypeAttr>;
class SwiftNewTypeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftNewTypeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftNewTypeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftNewTypeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_NEW_TYPE;
  }

  static std::optional<SwiftNewTypeAttr> from(const TokenContext &c);
  static std::optional<SwiftNewTypeAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftNewTypeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftNewTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftNewTypeAttr> from(const Attr &parent);

  inline static std::optional<SwiftNewTypeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftNewTypeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  SwiftNewTypeAttrNewtypeKind newtype_kind(void) const;
  SwiftNewTypeAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using SwiftNameAttrRange = DerivedEntityRange<AttrIterator, SwiftNameAttr>;
using SwiftNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftNameAttr>;
class SwiftNameAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_NAME;
  }

  static std::optional<SwiftNameAttr> from(const TokenContext &c);
  static std::optional<SwiftNameAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftNameAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftNameAttr> from(const Attr &parent);

  inline static std::optional<SwiftNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using SwiftErrorAttrRange = DerivedEntityRange<AttrIterator, SwiftErrorAttr>;
using SwiftErrorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftErrorAttr>;
class SwiftErrorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftErrorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftErrorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftErrorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ERROR;
  }

  static std::optional<SwiftErrorAttr> from(const TokenContext &c);
  static std::optional<SwiftErrorAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftErrorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftErrorAttr> from(const Attr &parent);

  inline static std::optional<SwiftErrorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  SwiftErrorAttrConventionKind convention(void) const;
  std::string_view spelling(void) const;
};

using SwiftCallAttrRange = DerivedEntityRange<AttrIterator, SwiftCallAttr>;
using SwiftCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftCallAttr>;
class SwiftCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_CALL;
  }

  static std::optional<SwiftCallAttr> from(const TokenContext &c);
  static std::optional<SwiftCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftCallAttr> from(const Attr &parent);

  inline static std::optional<SwiftCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftBridgedTypedefAttrRange = DerivedEntityRange<AttrIterator, SwiftBridgedTypedefAttr>;
using SwiftBridgedTypedefAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftBridgedTypedefAttr>;
class SwiftBridgedTypedefAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftBridgedTypedefAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftBridgedTypedefAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftBridgedTypedefAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_BRIDGED_TYPEDEF;
  }

  static std::optional<SwiftBridgedTypedefAttr> from(const TokenContext &c);
  static std::optional<SwiftBridgedTypedefAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftBridgedTypedefAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftBridgedTypedefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftBridgedTypedefAttr> from(const Attr &parent);

  inline static std::optional<SwiftBridgedTypedefAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftBridgedTypedefAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftBridgeAttrRange = DerivedEntityRange<AttrIterator, SwiftBridgeAttr>;
using SwiftBridgeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftBridgeAttr>;
class SwiftBridgeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftBridgeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftBridgeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftBridgeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_BRIDGE;
  }

  static std::optional<SwiftBridgeAttr> from(const TokenContext &c);
  static std::optional<SwiftBridgeAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftBridgeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftBridgeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftBridgeAttr> from(const Attr &parent);

  inline static std::optional<SwiftBridgeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftBridgeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  std::string_view swift_type(void) const;
};

using SwiftAttrAttrRange = DerivedEntityRange<AttrIterator, SwiftAttrAttr>;
using SwiftAttrAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAttrAttr>;
class SwiftAttrAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAttrAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAttrAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAttrAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ATTR;
  }

  static std::optional<SwiftAttrAttr> from(const TokenContext &c);
  static std::optional<SwiftAttrAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAttrAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAttrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAttrAttr> from(const Attr &parent);

  inline static std::optional<SwiftAttrAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAttrAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view attribute(void) const;
  std::string_view spelling(void) const;
};

using SwiftAsyncNameAttrRange = DerivedEntityRange<AttrIterator, SwiftAsyncNameAttr>;
using SwiftAsyncNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAsyncNameAttr>;
class SwiftAsyncNameAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAsyncNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAsyncNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAsyncNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ASYNC_NAME;
  }

  static std::optional<SwiftAsyncNameAttr> from(const TokenContext &c);
  static std::optional<SwiftAsyncNameAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAsyncNameAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAsyncNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncNameAttr> from(const Attr &parent);

  inline static std::optional<SwiftAsyncNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAsyncNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using SwiftAsyncErrorAttrRange = DerivedEntityRange<AttrIterator, SwiftAsyncErrorAttr>;
using SwiftAsyncErrorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAsyncErrorAttr>;
class SwiftAsyncErrorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAsyncErrorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAsyncErrorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAsyncErrorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ASYNC_ERROR;
  }

  static std::optional<SwiftAsyncErrorAttr> from(const TokenContext &c);
  static std::optional<SwiftAsyncErrorAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAsyncErrorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAsyncErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncErrorAttr> from(const Attr &parent);

  inline static std::optional<SwiftAsyncErrorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAsyncErrorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  SwiftAsyncErrorAttrConventionKind convention(void) const;
  std::string_view spelling(void) const;
};

using SwiftAsyncCallAttrRange = DerivedEntityRange<AttrIterator, SwiftAsyncCallAttr>;
using SwiftAsyncCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAsyncCallAttr>;
class SwiftAsyncCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAsyncCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAsyncCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAsyncCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ASYNC_CALL;
  }

  static std::optional<SwiftAsyncCallAttr> from(const TokenContext &c);
  static std::optional<SwiftAsyncCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAsyncCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAsyncCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncCallAttr> from(const Attr &parent);

  inline static std::optional<SwiftAsyncCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAsyncCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftAsyncAttrRange = DerivedEntityRange<AttrIterator, SwiftAsyncAttr>;
using SwiftAsyncAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAsyncAttr>;
class SwiftAsyncAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAsyncAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAsyncAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAsyncAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ASYNC;
  }

  static std::optional<SwiftAsyncAttr> from(const TokenContext &c);
  static std::optional<SwiftAsyncAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAsyncAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAsyncAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncAttr> from(const Attr &parent);

  inline static std::optional<SwiftAsyncAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAsyncAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using StrictFPAttrRange = DerivedEntityRange<AttrIterator, StrictFPAttr>;
using StrictFPAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, StrictFPAttr>;
class StrictFPAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static StrictFPAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StrictFPAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StrictFPAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::STRICT_FP;
  }

  static std::optional<StrictFPAttr> from(const TokenContext &c);
  static std::optional<StrictFPAttr> from(const InheritableAttr &parent);

  inline static std::optional<StrictFPAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return StrictFPAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StrictFPAttr> from(const Attr &parent);

  inline static std::optional<StrictFPAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return StrictFPAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using StdCallAttrRange = DerivedEntityRange<AttrIterator, StdCallAttr>;
using StdCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, StdCallAttr>;
class StdCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static StdCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StdCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StdCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::STD_CALL;
  }

  static std::optional<StdCallAttr> from(const TokenContext &c);
  static std::optional<StdCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<StdCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return StdCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StdCallAttr> from(const Attr &parent);

  inline static std::optional<StdCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return StdCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using StandaloneDebugAttrRange = DerivedEntityRange<AttrIterator, StandaloneDebugAttr>;
using StandaloneDebugAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, StandaloneDebugAttr>;
class StandaloneDebugAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static StandaloneDebugAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StandaloneDebugAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StandaloneDebugAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::STANDALONE_DEBUG;
  }

  static std::optional<StandaloneDebugAttr> from(const TokenContext &c);
  static std::optional<StandaloneDebugAttr> from(const InheritableAttr &parent);

  inline static std::optional<StandaloneDebugAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return StandaloneDebugAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StandaloneDebugAttr> from(const Attr &parent);

  inline static std::optional<StandaloneDebugAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return StandaloneDebugAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SpeculativeLoadHardeningAttrRange = DerivedEntityRange<AttrIterator, SpeculativeLoadHardeningAttr>;
using SpeculativeLoadHardeningAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SpeculativeLoadHardeningAttr>;
class SpeculativeLoadHardeningAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SpeculativeLoadHardeningAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SpeculativeLoadHardeningAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SpeculativeLoadHardeningAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SPECULATIVE_LOAD_HARDENING;
  }

  static std::optional<SpeculativeLoadHardeningAttr> from(const TokenContext &c);
  static std::optional<SpeculativeLoadHardeningAttr> from(const InheritableAttr &parent);

  inline static std::optional<SpeculativeLoadHardeningAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SpeculativeLoadHardeningAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SpeculativeLoadHardeningAttr> from(const Attr &parent);

  inline static std::optional<SpeculativeLoadHardeningAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SpeculativeLoadHardeningAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SharedTrylockFunctionAttrRange = DerivedEntityRange<AttrIterator, SharedTrylockFunctionAttr>;
using SharedTrylockFunctionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SharedTrylockFunctionAttr>;
class SharedTrylockFunctionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SharedTrylockFunctionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SharedTrylockFunctionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SharedTrylockFunctionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SHARED_TRYLOCK_FUNCTION;
  }

  static std::optional<SharedTrylockFunctionAttr> from(const TokenContext &c);
  static std::optional<SharedTrylockFunctionAttr> from(const InheritableAttr &parent);

  inline static std::optional<SharedTrylockFunctionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SharedTrylockFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SharedTrylockFunctionAttr> from(const Attr &parent);

  inline static std::optional<SharedTrylockFunctionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SharedTrylockFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  Expr success_value(void) const;
};

using SetTypestateAttrRange = DerivedEntityRange<AttrIterator, SetTypestateAttr>;
using SetTypestateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SetTypestateAttr>;
class SetTypestateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SetTypestateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SetTypestateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SetTypestateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SET_TYPESTATE;
  }

  static std::optional<SetTypestateAttr> from(const TokenContext &c);
  static std::optional<SetTypestateAttr> from(const InheritableAttr &parent);

  inline static std::optional<SetTypestateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SetTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SetTypestateAttr> from(const Attr &parent);

  inline static std::optional<SetTypestateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SetTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  SetTypestateAttrConsumedState new_state(void) const;
  std::string_view spelling(void) const;
};

using SentinelAttrRange = DerivedEntityRange<AttrIterator, SentinelAttr>;
using SentinelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SentinelAttr>;
class SentinelAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SentinelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SentinelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SentinelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SENTINEL;
  }

  static std::optional<SentinelAttr> from(const TokenContext &c);
  static std::optional<SentinelAttr> from(const InheritableAttr &parent);

  inline static std::optional<SentinelAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SentinelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SentinelAttr> from(const Attr &parent);

  inline static std::optional<SentinelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SentinelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SelectAnyAttrRange = DerivedEntityRange<AttrIterator, SelectAnyAttr>;
using SelectAnyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SelectAnyAttr>;
class SelectAnyAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SelectAnyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SelectAnyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SelectAnyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SELECT_ANY;
  }

  static std::optional<SelectAnyAttr> from(const TokenContext &c);
  static std::optional<SelectAnyAttr> from(const InheritableAttr &parent);

  inline static std::optional<SelectAnyAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SelectAnyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SelectAnyAttr> from(const Attr &parent);

  inline static std::optional<SelectAnyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SelectAnyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SectionAttrRange = DerivedEntityRange<AttrIterator, SectionAttr>;
using SectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SectionAttr>;
class SectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SECTION;
  }

  static std::optional<SectionAttr> from(const TokenContext &c);
  static std::optional<SectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<SectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SectionAttr> from(const Attr &parent);

  inline static std::optional<SectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  SectionAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using ScopedLockableAttrRange = DerivedEntityRange<AttrIterator, ScopedLockableAttr>;
using ScopedLockableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ScopedLockableAttr>;
class ScopedLockableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ScopedLockableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ScopedLockableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ScopedLockableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SCOPED_LOCKABLE;
  }

  static std::optional<ScopedLockableAttr> from(const TokenContext &c);
  static std::optional<ScopedLockableAttr> from(const InheritableAttr &parent);

  inline static std::optional<ScopedLockableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ScopedLockableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ScopedLockableAttr> from(const Attr &parent);

  inline static std::optional<ScopedLockableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ScopedLockableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SYCLSpecialClassAttrRange = DerivedEntityRange<AttrIterator, SYCLSpecialClassAttr>;
using SYCLSpecialClassAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SYCLSpecialClassAttr>;
class SYCLSpecialClassAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SYCLSpecialClassAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SYCLSpecialClassAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SYCLSpecialClassAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SYCL_SPECIAL_CLASS;
  }

  static std::optional<SYCLSpecialClassAttr> from(const TokenContext &c);
  static std::optional<SYCLSpecialClassAttr> from(const InheritableAttr &parent);

  inline static std::optional<SYCLSpecialClassAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SYCLSpecialClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SYCLSpecialClassAttr> from(const Attr &parent);

  inline static std::optional<SYCLSpecialClassAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SYCLSpecialClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SYCLKernelAttrRange = DerivedEntityRange<AttrIterator, SYCLKernelAttr>;
using SYCLKernelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SYCLKernelAttr>;
class SYCLKernelAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SYCLKernelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SYCLKernelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SYCLKernelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SYCL_KERNEL;
  }

  static std::optional<SYCLKernelAttr> from(const TokenContext &c);
  static std::optional<SYCLKernelAttr> from(const InheritableAttr &parent);

  inline static std::optional<SYCLKernelAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SYCLKernelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SYCLKernelAttr> from(const Attr &parent);

  inline static std::optional<SYCLKernelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SYCLKernelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ReturnsTwiceAttrRange = DerivedEntityRange<AttrIterator, ReturnsTwiceAttr>;
using ReturnsTwiceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReturnsTwiceAttr>;
class ReturnsTwiceAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReturnsTwiceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReturnsTwiceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReturnsTwiceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RETURNS_TWICE;
  }

  static std::optional<ReturnsTwiceAttr> from(const TokenContext &c);
  static std::optional<ReturnsTwiceAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReturnsTwiceAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReturnsTwiceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReturnsTwiceAttr> from(const Attr &parent);

  inline static std::optional<ReturnsTwiceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReturnsTwiceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ReturnsNonNullAttrRange = DerivedEntityRange<AttrIterator, ReturnsNonNullAttr>;
using ReturnsNonNullAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReturnsNonNullAttr>;
class ReturnsNonNullAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReturnsNonNullAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReturnsNonNullAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReturnsNonNullAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RETURNS_NON_NULL;
  }

  static std::optional<ReturnsNonNullAttr> from(const TokenContext &c);
  static std::optional<ReturnsNonNullAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReturnsNonNullAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReturnsNonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReturnsNonNullAttr> from(const Attr &parent);

  inline static std::optional<ReturnsNonNullAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReturnsNonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ReturnTypestateAttrRange = DerivedEntityRange<AttrIterator, ReturnTypestateAttr>;
using ReturnTypestateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReturnTypestateAttr>;
class ReturnTypestateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReturnTypestateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReturnTypestateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReturnTypestateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RETURN_TYPESTATE;
  }

  static std::optional<ReturnTypestateAttr> from(const TokenContext &c);
  static std::optional<ReturnTypestateAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReturnTypestateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReturnTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReturnTypestateAttr> from(const Attr &parent);

  inline static std::optional<ReturnTypestateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReturnTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  ReturnTypestateAttrConsumedState state(void) const;
};

using RetainAttrRange = DerivedEntityRange<AttrIterator, RetainAttr>;
using RetainAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RetainAttr>;
class RetainAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static RetainAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RetainAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RetainAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RETAIN;
  }

  static std::optional<RetainAttr> from(const TokenContext &c);
  static std::optional<RetainAttr> from(const InheritableAttr &parent);

  inline static std::optional<RetainAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return RetainAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RetainAttr> from(const Attr &parent);

  inline static std::optional<RetainAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RetainAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using RestrictAttrRange = DerivedEntityRange<AttrIterator, RestrictAttr>;
using RestrictAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RestrictAttr>;
class RestrictAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static RestrictAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RestrictAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RestrictAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RESTRICT;
  }

  static std::optional<RestrictAttr> from(const TokenContext &c);
  static std::optional<RestrictAttr> from(const InheritableAttr &parent);

  inline static std::optional<RestrictAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return RestrictAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RestrictAttr> from(const Attr &parent);

  inline static std::optional<RestrictAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RestrictAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  RestrictAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using RequiresCapabilityAttrRange = DerivedEntityRange<AttrIterator, RequiresCapabilityAttr>;
using RequiresCapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RequiresCapabilityAttr>;
class RequiresCapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static RequiresCapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RequiresCapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RequiresCapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::REQUIRES_CAPABILITY;
  }

  static std::optional<RequiresCapabilityAttr> from(const TokenContext &c);
  static std::optional<RequiresCapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<RequiresCapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return RequiresCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RequiresCapabilityAttr> from(const Attr &parent);

  inline static std::optional<RequiresCapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RequiresCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  RequiresCapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_shared(void) const;
};

using ReqdWorkGroupSizeAttrRange = DerivedEntityRange<AttrIterator, ReqdWorkGroupSizeAttr>;
using ReqdWorkGroupSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReqdWorkGroupSizeAttr>;
class ReqdWorkGroupSizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReqdWorkGroupSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReqdWorkGroupSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReqdWorkGroupSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::REQD_WORK_GROUP_SIZE;
  }

  static std::optional<ReqdWorkGroupSizeAttr> from(const TokenContext &c);
  static std::optional<ReqdWorkGroupSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReqdWorkGroupSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReqdWorkGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReqdWorkGroupSizeAttr> from(const Attr &parent);

  inline static std::optional<ReqdWorkGroupSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReqdWorkGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ReleaseCapabilityAttrRange = DerivedEntityRange<AttrIterator, ReleaseCapabilityAttr>;
using ReleaseCapabilityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReleaseCapabilityAttr>;
class ReleaseCapabilityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReleaseCapabilityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReleaseCapabilityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReleaseCapabilityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RELEASE_CAPABILITY;
  }

  static std::optional<ReleaseCapabilityAttr> from(const TokenContext &c);
  static std::optional<ReleaseCapabilityAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReleaseCapabilityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReleaseCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReleaseCapabilityAttr> from(const Attr &parent);

  inline static std::optional<ReleaseCapabilityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReleaseCapabilityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ReleaseCapabilityAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_generic(void) const;
  bool is_shared(void) const;
};

using ReinitializesAttrRange = DerivedEntityRange<AttrIterator, ReinitializesAttr>;
using ReinitializesAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReinitializesAttr>;
class ReinitializesAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReinitializesAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReinitializesAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReinitializesAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::REINITIALIZES;
  }

  static std::optional<ReinitializesAttr> from(const TokenContext &c);
  static std::optional<ReinitializesAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReinitializesAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReinitializesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReinitializesAttr> from(const Attr &parent);

  inline static std::optional<ReinitializesAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReinitializesAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using RegCallAttrRange = DerivedEntityRange<AttrIterator, RegCallAttr>;
using RegCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RegCallAttr>;
class RegCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static RegCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RegCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RegCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::REG_CALL;
  }

  static std::optional<RegCallAttr> from(const TokenContext &c);
  static std::optional<RegCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<RegCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return RegCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RegCallAttr> from(const Attr &parent);

  inline static std::optional<RegCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RegCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using RISCVInterruptAttrRange = DerivedEntityRange<AttrIterator, RISCVInterruptAttr>;
using RISCVInterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, RISCVInterruptAttr>;
class RISCVInterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static RISCVInterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RISCVInterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RISCVInterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RISCV_INTERRUPT;
  }

  static std::optional<RISCVInterruptAttr> from(const TokenContext &c);
  static std::optional<RISCVInterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<RISCVInterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return RISCVInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RISCVInterruptAttr> from(const Attr &parent);

  inline static std::optional<RISCVInterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return RISCVInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  RISCVInterruptAttrInterruptType interrupt(void) const;
  std::string_view spelling(void) const;
};

using PureAttrRange = DerivedEntityRange<AttrIterator, PureAttr>;
using PureAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PureAttr>;
class PureAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PureAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PureAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PureAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PURE;
  }

  static std::optional<PureAttr> from(const TokenContext &c);
  static std::optional<PureAttr> from(const InheritableAttr &parent);

  inline static std::optional<PureAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PureAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PureAttr> from(const Attr &parent);

  inline static std::optional<PureAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PureAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using PtGuardedVarAttrRange = DerivedEntityRange<AttrIterator, PtGuardedVarAttr>;
using PtGuardedVarAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PtGuardedVarAttr>;
class PtGuardedVarAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PtGuardedVarAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PtGuardedVarAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PtGuardedVarAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PT_GUARDED_VAR;
  }

  static std::optional<PtGuardedVarAttr> from(const TokenContext &c);
  static std::optional<PtGuardedVarAttr> from(const InheritableAttr &parent);

  inline static std::optional<PtGuardedVarAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PtGuardedVarAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PtGuardedVarAttr> from(const Attr &parent);

  inline static std::optional<PtGuardedVarAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PtGuardedVarAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using PtGuardedByAttrRange = DerivedEntityRange<AttrIterator, PtGuardedByAttr>;
using PtGuardedByAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PtGuardedByAttr>;
class PtGuardedByAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PtGuardedByAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PtGuardedByAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PtGuardedByAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PT_GUARDED_BY;
  }

  static std::optional<PtGuardedByAttr> from(const TokenContext &c);
  static std::optional<PtGuardedByAttr> from(const InheritableAttr &parent);

  inline static std::optional<PtGuardedByAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PtGuardedByAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PtGuardedByAttr> from(const Attr &parent);

  inline static std::optional<PtGuardedByAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PtGuardedByAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr argument(void) const;
  std::string_view spelling(void) const;
};

using PreserveMostAttrRange = DerivedEntityRange<AttrIterator, PreserveMostAttr>;
using PreserveMostAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PreserveMostAttr>;
class PreserveMostAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PreserveMostAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PreserveMostAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PreserveMostAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRESERVE_MOST;
  }

  static std::optional<PreserveMostAttr> from(const TokenContext &c);
  static std::optional<PreserveMostAttr> from(const InheritableAttr &parent);

  inline static std::optional<PreserveMostAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PreserveMostAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PreserveMostAttr> from(const Attr &parent);

  inline static std::optional<PreserveMostAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PreserveMostAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using PreserveAllAttrRange = DerivedEntityRange<AttrIterator, PreserveAllAttr>;
using PreserveAllAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PreserveAllAttr>;
class PreserveAllAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PreserveAllAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PreserveAllAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PreserveAllAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRESERVE_ALL;
  }

  static std::optional<PreserveAllAttr> from(const TokenContext &c);
  static std::optional<PreserveAllAttr> from(const InheritableAttr &parent);

  inline static std::optional<PreserveAllAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PreserveAllAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PreserveAllAttr> from(const Attr &parent);

  inline static std::optional<PreserveAllAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PreserveAllAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using PreferredNameAttrRange = DerivedEntityRange<AttrIterator, PreferredNameAttr>;
using PreferredNameAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PreferredNameAttr>;
class PreferredNameAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PreferredNameAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PreferredNameAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PreferredNameAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PREFERRED_NAME;
  }

  static std::optional<PreferredNameAttr> from(const TokenContext &c);
  static std::optional<PreferredNameAttr> from(const InheritableAttr &parent);

  inline static std::optional<PreferredNameAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PreferredNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PreferredNameAttr> from(const Attr &parent);

  inline static std::optional<PreferredNameAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PreferredNameAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  Type typedef_type(void) const;
  Type typedef_type_token(void) const;
};

using PragmaClangTextSectionAttrRange = DerivedEntityRange<AttrIterator, PragmaClangTextSectionAttr>;
using PragmaClangTextSectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaClangTextSectionAttr>;
class PragmaClangTextSectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PragmaClangTextSectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaClangTextSectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaClangTextSectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRAGMA_CLANG_TEXT_SECTION;
  }

  static std::optional<PragmaClangTextSectionAttr> from(const TokenContext &c);
  static std::optional<PragmaClangTextSectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<PragmaClangTextSectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PragmaClangTextSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PragmaClangTextSectionAttr> from(const Attr &parent);

  inline static std::optional<PragmaClangTextSectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PragmaClangTextSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using PragmaClangRodataSectionAttrRange = DerivedEntityRange<AttrIterator, PragmaClangRodataSectionAttr>;
using PragmaClangRodataSectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaClangRodataSectionAttr>;
class PragmaClangRodataSectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PragmaClangRodataSectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaClangRodataSectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaClangRodataSectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRAGMA_CLANG_RODATA_SECTION;
  }

  static std::optional<PragmaClangRodataSectionAttr> from(const TokenContext &c);
  static std::optional<PragmaClangRodataSectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<PragmaClangRodataSectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PragmaClangRodataSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PragmaClangRodataSectionAttr> from(const Attr &parent);

  inline static std::optional<PragmaClangRodataSectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PragmaClangRodataSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using PragmaClangRelroSectionAttrRange = DerivedEntityRange<AttrIterator, PragmaClangRelroSectionAttr>;
using PragmaClangRelroSectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaClangRelroSectionAttr>;
class PragmaClangRelroSectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PragmaClangRelroSectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaClangRelroSectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaClangRelroSectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRAGMA_CLANG_RELRO_SECTION;
  }

  static std::optional<PragmaClangRelroSectionAttr> from(const TokenContext &c);
  static std::optional<PragmaClangRelroSectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<PragmaClangRelroSectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PragmaClangRelroSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PragmaClangRelroSectionAttr> from(const Attr &parent);

  inline static std::optional<PragmaClangRelroSectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PragmaClangRelroSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using PragmaClangDataSectionAttrRange = DerivedEntityRange<AttrIterator, PragmaClangDataSectionAttr>;
using PragmaClangDataSectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaClangDataSectionAttr>;
class PragmaClangDataSectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PragmaClangDataSectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaClangDataSectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaClangDataSectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRAGMA_CLANG_DATA_SECTION;
  }

  static std::optional<PragmaClangDataSectionAttr> from(const TokenContext &c);
  static std::optional<PragmaClangDataSectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<PragmaClangDataSectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PragmaClangDataSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PragmaClangDataSectionAttr> from(const Attr &parent);

  inline static std::optional<PragmaClangDataSectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PragmaClangDataSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using PragmaClangBSSSectionAttrRange = DerivedEntityRange<AttrIterator, PragmaClangBSSSectionAttr>;
using PragmaClangBSSSectionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaClangBSSSectionAttr>;
class PragmaClangBSSSectionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PragmaClangBSSSectionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaClangBSSSectionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaClangBSSSectionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PRAGMA_CLANG_BSS_SECTION;
  }

  static std::optional<PragmaClangBSSSectionAttr> from(const TokenContext &c);
  static std::optional<PragmaClangBSSSectionAttr> from(const InheritableAttr &parent);

  inline static std::optional<PragmaClangBSSSectionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PragmaClangBSSSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PragmaClangBSSSectionAttr> from(const Attr &parent);

  inline static std::optional<PragmaClangBSSSectionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PragmaClangBSSSectionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view spelling(void) const;
};

using PointerAttrRange = DerivedEntityRange<AttrIterator, PointerAttr>;
using PointerAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PointerAttr>;
class PointerAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PointerAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PointerAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PointerAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::POINTER;
  }

  static std::optional<PointerAttr> from(const TokenContext &c);
  static std::optional<PointerAttr> from(const InheritableAttr &parent);

  inline static std::optional<PointerAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PointerAttr> from(const Attr &parent);

  inline static std::optional<PointerAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type deref_type(void) const;
  Type deref_type_token(void) const;
  std::string_view spelling(void) const;
};

using PcsAttrRange = DerivedEntityRange<AttrIterator, PcsAttr>;
using PcsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PcsAttr>;
class PcsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PcsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PcsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PcsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PCS;
  }

  static std::optional<PcsAttr> from(const TokenContext &c);
  static std::optional<PcsAttr> from(const InheritableAttr &parent);

  inline static std::optional<PcsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PcsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PcsAttr> from(const Attr &parent);

  inline static std::optional<PcsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PcsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  PcsAttrPCSType pcs(void) const;
  std::string_view spelling(void) const;
};

using PatchableFunctionEntryAttrRange = DerivedEntityRange<AttrIterator, PatchableFunctionEntryAttr>;
using PatchableFunctionEntryAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PatchableFunctionEntryAttr>;
class PatchableFunctionEntryAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PatchableFunctionEntryAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PatchableFunctionEntryAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PatchableFunctionEntryAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PATCHABLE_FUNCTION_ENTRY;
  }

  static std::optional<PatchableFunctionEntryAttr> from(const TokenContext &c);
  static std::optional<PatchableFunctionEntryAttr> from(const InheritableAttr &parent);

  inline static std::optional<PatchableFunctionEntryAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PatchableFunctionEntryAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PatchableFunctionEntryAttr> from(const Attr &parent);

  inline static std::optional<PatchableFunctionEntryAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PatchableFunctionEntryAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using PascalAttrRange = DerivedEntityRange<AttrIterator, PascalAttr>;
using PascalAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PascalAttr>;
class PascalAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PascalAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PascalAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PascalAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PASCAL;
  }

  static std::optional<PascalAttr> from(const TokenContext &c);
  static std::optional<PascalAttr> from(const InheritableAttr &parent);

  inline static std::optional<PascalAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PascalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PascalAttr> from(const Attr &parent);

  inline static std::optional<PascalAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PascalAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ParamTypestateAttrRange = DerivedEntityRange<AttrIterator, ParamTypestateAttr>;
using ParamTypestateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParamTypestateAttr>;
class ParamTypestateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ParamTypestateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParamTypestateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParamTypestateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PARAM_TYPESTATE;
  }

  static std::optional<ParamTypestateAttr> from(const TokenContext &c);
  static std::optional<ParamTypestateAttr> from(const InheritableAttr &parent);

  inline static std::optional<ParamTypestateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ParamTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParamTypestateAttr> from(const Attr &parent);

  inline static std::optional<ParamTypestateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ParamTypestateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ParamTypestateAttrConsumedState parameter_state(void) const;
  std::string_view spelling(void) const;
};

using PackedAttrRange = DerivedEntityRange<AttrIterator, PackedAttr>;
using PackedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PackedAttr>;
class PackedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PackedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PackedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PackedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PACKED;
  }

  static std::optional<PackedAttr> from(const TokenContext &c);
  static std::optional<PackedAttr> from(const InheritableAttr &parent);

  inline static std::optional<PackedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PackedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PackedAttr> from(const Attr &parent);

  inline static std::optional<PackedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PackedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OwnershipAttrRange = DerivedEntityRange<AttrIterator, OwnershipAttr>;
using OwnershipAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OwnershipAttr>;
class OwnershipAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OwnershipAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OwnershipAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OwnershipAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OWNERSHIP;
  }

  static std::optional<OwnershipAttr> from(const TokenContext &c);
  static std::optional<OwnershipAttr> from(const InheritableAttr &parent);

  inline static std::optional<OwnershipAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OwnershipAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OwnershipAttr> from(const Attr &parent);

  inline static std::optional<OwnershipAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OwnershipAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OwnershipAttrOwnershipKind own_kind(void) const;
  OwnershipAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_holds(void) const;
  bool is_returns(void) const;
  bool is_takes(void) const;
};

using OwnerAttrRange = DerivedEntityRange<AttrIterator, OwnerAttr>;
using OwnerAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OwnerAttr>;
class OwnerAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OwnerAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OwnerAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OwnerAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OWNER;
  }

  static std::optional<OwnerAttr> from(const TokenContext &c);
  static std::optional<OwnerAttr> from(const InheritableAttr &parent);

  inline static std::optional<OwnerAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OwnerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OwnerAttr> from(const Attr &parent);

  inline static std::optional<OwnerAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OwnerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type deref_type(void) const;
  Type deref_type_token(void) const;
  std::string_view spelling(void) const;
};

using OverrideAttrRange = DerivedEntityRange<AttrIterator, OverrideAttr>;
using OverrideAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OverrideAttr>;
class OverrideAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OverrideAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OverrideAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OverrideAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OVERRIDE;
  }

  static std::optional<OverrideAttr> from(const TokenContext &c);
  static std::optional<OverrideAttr> from(const InheritableAttr &parent);

  inline static std::optional<OverrideAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OverrideAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OverrideAttr> from(const Attr &parent);

  inline static std::optional<OverrideAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OverrideAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OptimizeNoneAttrRange = DerivedEntityRange<AttrIterator, OptimizeNoneAttr>;
using OptimizeNoneAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OptimizeNoneAttr>;
class OptimizeNoneAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OptimizeNoneAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OptimizeNoneAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OptimizeNoneAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPTIMIZE_NONE;
  }

  static std::optional<OptimizeNoneAttr> from(const TokenContext &c);
  static std::optional<OptimizeNoneAttr> from(const InheritableAttr &parent);

  inline static std::optional<OptimizeNoneAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OptimizeNoneAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OptimizeNoneAttr> from(const Attr &parent);

  inline static std::optional<OptimizeNoneAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OptimizeNoneAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLKernelAttrRange = DerivedEntityRange<AttrIterator, OpenCLKernelAttr>;
using OpenCLKernelAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLKernelAttr>;
class OpenCLKernelAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OpenCLKernelAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLKernelAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLKernelAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_KERNEL;
  }

  static std::optional<OpenCLKernelAttr> from(const TokenContext &c);
  static std::optional<OpenCLKernelAttr> from(const InheritableAttr &parent);

  inline static std::optional<OpenCLKernelAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OpenCLKernelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLKernelAttr> from(const Attr &parent);

  inline static std::optional<OpenCLKernelAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLKernelAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OpenCLIntelReqdSubGroupSizeAttrRange = DerivedEntityRange<AttrIterator, OpenCLIntelReqdSubGroupSizeAttr>;
using OpenCLIntelReqdSubGroupSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpenCLIntelReqdSubGroupSizeAttr>;
class OpenCLIntelReqdSubGroupSizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OpenCLIntelReqdSubGroupSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpenCLIntelReqdSubGroupSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpenCLIntelReqdSubGroupSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OPEN_CL_INTEL_REQD_SUB_GROUP_SIZE;
  }

  static std::optional<OpenCLIntelReqdSubGroupSizeAttr> from(const TokenContext &c);
  static std::optional<OpenCLIntelReqdSubGroupSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<OpenCLIntelReqdSubGroupSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OpenCLIntelReqdSubGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpenCLIntelReqdSubGroupSizeAttr> from(const Attr &parent);

  inline static std::optional<OpenCLIntelReqdSubGroupSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OpenCLIntelReqdSubGroupSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCSubclassingRestrictedAttrRange = DerivedEntityRange<AttrIterator, ObjCSubclassingRestrictedAttr>;
using ObjCSubclassingRestrictedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCSubclassingRestrictedAttr>;
class ObjCSubclassingRestrictedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCSubclassingRestrictedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCSubclassingRestrictedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCSubclassingRestrictedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_SUBCLASSING_RESTRICTED;
  }

  static std::optional<ObjCSubclassingRestrictedAttr> from(const TokenContext &c);
  static std::optional<ObjCSubclassingRestrictedAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCSubclassingRestrictedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCSubclassingRestrictedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCSubclassingRestrictedAttr> from(const Attr &parent);

  inline static std::optional<ObjCSubclassingRestrictedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCSubclassingRestrictedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCRootClassAttrRange = DerivedEntityRange<AttrIterator, ObjCRootClassAttr>;
using ObjCRootClassAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCRootClassAttr>;
class ObjCRootClassAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCRootClassAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCRootClassAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCRootClassAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_ROOT_CLASS;
  }

  static std::optional<ObjCRootClassAttr> from(const TokenContext &c);
  static std::optional<ObjCRootClassAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCRootClassAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCRootClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCRootClassAttr> from(const Attr &parent);

  inline static std::optional<ObjCRootClassAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCRootClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCReturnsInnerPointerAttrRange = DerivedEntityRange<AttrIterator, ObjCReturnsInnerPointerAttr>;
using ObjCReturnsInnerPointerAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCReturnsInnerPointerAttr>;
class ObjCReturnsInnerPointerAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCReturnsInnerPointerAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCReturnsInnerPointerAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCReturnsInnerPointerAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_RETURNS_INNER_POINTER;
  }

  static std::optional<ObjCReturnsInnerPointerAttr> from(const TokenContext &c);
  static std::optional<ObjCReturnsInnerPointerAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCReturnsInnerPointerAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCReturnsInnerPointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCReturnsInnerPointerAttr> from(const Attr &parent);

  inline static std::optional<ObjCReturnsInnerPointerAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCReturnsInnerPointerAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCRequiresSuperAttrRange = DerivedEntityRange<AttrIterator, ObjCRequiresSuperAttr>;
using ObjCRequiresSuperAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCRequiresSuperAttr>;
class ObjCRequiresSuperAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCRequiresSuperAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCRequiresSuperAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCRequiresSuperAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_REQUIRES_SUPER;
  }

  static std::optional<ObjCRequiresSuperAttr> from(const TokenContext &c);
  static std::optional<ObjCRequiresSuperAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCRequiresSuperAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCRequiresSuperAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCRequiresSuperAttr> from(const Attr &parent);

  inline static std::optional<ObjCRequiresSuperAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCRequiresSuperAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCRequiresPropertyDefsAttrRange = DerivedEntityRange<AttrIterator, ObjCRequiresPropertyDefsAttr>;
using ObjCRequiresPropertyDefsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCRequiresPropertyDefsAttr>;
class ObjCRequiresPropertyDefsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCRequiresPropertyDefsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCRequiresPropertyDefsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCRequiresPropertyDefsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_REQUIRES_PROPERTY_DEFS;
  }

  static std::optional<ObjCRequiresPropertyDefsAttr> from(const TokenContext &c);
  static std::optional<ObjCRequiresPropertyDefsAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCRequiresPropertyDefsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCRequiresPropertyDefsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCRequiresPropertyDefsAttr> from(const Attr &parent);

  inline static std::optional<ObjCRequiresPropertyDefsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCRequiresPropertyDefsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCPreciseLifetimeAttrRange = DerivedEntityRange<AttrIterator, ObjCPreciseLifetimeAttr>;
using ObjCPreciseLifetimeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCPreciseLifetimeAttr>;
class ObjCPreciseLifetimeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCPreciseLifetimeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCPreciseLifetimeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCPreciseLifetimeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_PRECISE_LIFETIME;
  }

  static std::optional<ObjCPreciseLifetimeAttr> from(const TokenContext &c);
  static std::optional<ObjCPreciseLifetimeAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCPreciseLifetimeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCPreciseLifetimeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCPreciseLifetimeAttr> from(const Attr &parent);

  inline static std::optional<ObjCPreciseLifetimeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCPreciseLifetimeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCOwnershipAttrRange = DerivedEntityRange<AttrIterator, ObjCOwnershipAttr>;
using ObjCOwnershipAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCOwnershipAttr>;
class ObjCOwnershipAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCOwnershipAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCOwnershipAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCOwnershipAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_OWNERSHIP;
  }

  static std::optional<ObjCOwnershipAttr> from(const TokenContext &c);
  static std::optional<ObjCOwnershipAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCOwnershipAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCOwnershipAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCOwnershipAttr> from(const Attr &parent);

  inline static std::optional<ObjCOwnershipAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCOwnershipAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCNSObjectAttrRange = DerivedEntityRange<AttrIterator, ObjCNSObjectAttr>;
using ObjCNSObjectAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCNSObjectAttr>;
class ObjCNSObjectAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCNSObjectAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCNSObjectAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCNSObjectAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_CNS_OBJECT;
  }

  static std::optional<ObjCNSObjectAttr> from(const TokenContext &c);
  static std::optional<ObjCNSObjectAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCNSObjectAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCNSObjectAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCNSObjectAttr> from(const Attr &parent);

  inline static std::optional<ObjCNSObjectAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCNSObjectAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCMethodFamilyAttrRange = DerivedEntityRange<AttrIterator, ObjCMethodFamilyAttr>;
using ObjCMethodFamilyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCMethodFamilyAttr>;
class ObjCMethodFamilyAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCMethodFamilyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCMethodFamilyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCMethodFamilyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_METHOD_FAMILY;
  }

  static std::optional<ObjCMethodFamilyAttr> from(const TokenContext &c);
  static std::optional<ObjCMethodFamilyAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCMethodFamilyAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCMethodFamilyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCMethodFamilyAttr> from(const Attr &parent);

  inline static std::optional<ObjCMethodFamilyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCMethodFamilyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCMethodFamilyAttrFamilyKind family(void) const;
  std::string_view spelling(void) const;
};

using ObjCIndependentClassAttrRange = DerivedEntityRange<AttrIterator, ObjCIndependentClassAttr>;
using ObjCIndependentClassAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCIndependentClassAttr>;
class ObjCIndependentClassAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCIndependentClassAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCIndependentClassAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCIndependentClassAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_INDEPENDENT_CLASS;
  }

  static std::optional<ObjCIndependentClassAttr> from(const TokenContext &c);
  static std::optional<ObjCIndependentClassAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCIndependentClassAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCIndependentClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIndependentClassAttr> from(const Attr &parent);

  inline static std::optional<ObjCIndependentClassAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCIndependentClassAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCExternallyRetainedAttrRange = DerivedEntityRange<AttrIterator, ObjCExternallyRetainedAttr>;
using ObjCExternallyRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCExternallyRetainedAttr>;
class ObjCExternallyRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCExternallyRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCExternallyRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCExternallyRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_EXTERNALLY_RETAINED;
  }

  static std::optional<ObjCExternallyRetainedAttr> from(const TokenContext &c);
  static std::optional<ObjCExternallyRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCExternallyRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCExternallyRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCExternallyRetainedAttr> from(const Attr &parent);

  inline static std::optional<ObjCExternallyRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCExternallyRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCExplicitProtocolImplAttrRange = DerivedEntityRange<AttrIterator, ObjCExplicitProtocolImplAttr>;
using ObjCExplicitProtocolImplAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCExplicitProtocolImplAttr>;
class ObjCExplicitProtocolImplAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCExplicitProtocolImplAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCExplicitProtocolImplAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCExplicitProtocolImplAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_EXPLICIT_PROTOCOL_IMPL;
  }

  static std::optional<ObjCExplicitProtocolImplAttr> from(const TokenContext &c);
  static std::optional<ObjCExplicitProtocolImplAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCExplicitProtocolImplAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCExplicitProtocolImplAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCExplicitProtocolImplAttr> from(const Attr &parent);

  inline static std::optional<ObjCExplicitProtocolImplAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCExplicitProtocolImplAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCExceptionAttrRange = DerivedEntityRange<AttrIterator, ObjCExceptionAttr>;
using ObjCExceptionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCExceptionAttr>;
class ObjCExceptionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCExceptionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCExceptionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCExceptionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_EXCEPTION;
  }

  static std::optional<ObjCExceptionAttr> from(const TokenContext &c);
  static std::optional<ObjCExceptionAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCExceptionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCExceptionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCExceptionAttr> from(const Attr &parent);

  inline static std::optional<ObjCExceptionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCExceptionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCBridgeRelatedAttrRange = DerivedEntityRange<AttrIterator, ObjCBridgeRelatedAttr>;
using ObjCBridgeRelatedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBridgeRelatedAttr>;
class ObjCBridgeRelatedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCBridgeRelatedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBridgeRelatedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBridgeRelatedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_BRIDGE_RELATED;
  }

  static std::optional<ObjCBridgeRelatedAttr> from(const TokenContext &c);
  static std::optional<ObjCBridgeRelatedAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCBridgeRelatedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCBridgeRelatedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgeRelatedAttr> from(const Attr &parent);

  inline static std::optional<ObjCBridgeRelatedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCBridgeRelatedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCBridgeMutableAttrRange = DerivedEntityRange<AttrIterator, ObjCBridgeMutableAttr>;
using ObjCBridgeMutableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBridgeMutableAttr>;
class ObjCBridgeMutableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCBridgeMutableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBridgeMutableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBridgeMutableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_BRIDGE_MUTABLE;
  }

  static std::optional<ObjCBridgeMutableAttr> from(const TokenContext &c);
  static std::optional<ObjCBridgeMutableAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCBridgeMutableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCBridgeMutableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgeMutableAttr> from(const Attr &parent);

  inline static std::optional<ObjCBridgeMutableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCBridgeMutableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using ObjCBridgeAttrRange = DerivedEntityRange<AttrIterator, ObjCBridgeAttr>;
using ObjCBridgeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBridgeAttr>;
class ObjCBridgeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ObjCBridgeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBridgeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBridgeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OBJ_C_BRIDGE;
  }

  static std::optional<ObjCBridgeAttr> from(const TokenContext &c);
  static std::optional<ObjCBridgeAttr> from(const InheritableAttr &parent);

  inline static std::optional<ObjCBridgeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ObjCBridgeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgeAttr> from(const Attr &parent);

  inline static std::optional<ObjCBridgeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ObjCBridgeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSReturnsRetainedOnZeroAttrRange = DerivedEntityRange<AttrIterator, OSReturnsRetainedOnZeroAttr>;
using OSReturnsRetainedOnZeroAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSReturnsRetainedOnZeroAttr>;
class OSReturnsRetainedOnZeroAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSReturnsRetainedOnZeroAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSReturnsRetainedOnZeroAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSReturnsRetainedOnZeroAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_RETURNS_RETAINED_ON_ZERO;
  }

  static std::optional<OSReturnsRetainedOnZeroAttr> from(const TokenContext &c);
  static std::optional<OSReturnsRetainedOnZeroAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSReturnsRetainedOnZeroAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSReturnsRetainedOnZeroAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSReturnsRetainedOnZeroAttr> from(const Attr &parent);

  inline static std::optional<OSReturnsRetainedOnZeroAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSReturnsRetainedOnZeroAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSReturnsRetainedOnNonZeroAttrRange = DerivedEntityRange<AttrIterator, OSReturnsRetainedOnNonZeroAttr>;
using OSReturnsRetainedOnNonZeroAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSReturnsRetainedOnNonZeroAttr>;
class OSReturnsRetainedOnNonZeroAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSReturnsRetainedOnNonZeroAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSReturnsRetainedOnNonZeroAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSReturnsRetainedOnNonZeroAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_RETURNS_RETAINED_ON_NON_ZERO;
  }

  static std::optional<OSReturnsRetainedOnNonZeroAttr> from(const TokenContext &c);
  static std::optional<OSReturnsRetainedOnNonZeroAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSReturnsRetainedOnNonZeroAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSReturnsRetainedOnNonZeroAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSReturnsRetainedOnNonZeroAttr> from(const Attr &parent);

  inline static std::optional<OSReturnsRetainedOnNonZeroAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSReturnsRetainedOnNonZeroAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSReturnsRetainedAttrRange = DerivedEntityRange<AttrIterator, OSReturnsRetainedAttr>;
using OSReturnsRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSReturnsRetainedAttr>;
class OSReturnsRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSReturnsRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSReturnsRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSReturnsRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_RETURNS_RETAINED;
  }

  static std::optional<OSReturnsRetainedAttr> from(const TokenContext &c);
  static std::optional<OSReturnsRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSReturnsRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSReturnsRetainedAttr> from(const Attr &parent);

  inline static std::optional<OSReturnsRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSReturnsNotRetainedAttrRange = DerivedEntityRange<AttrIterator, OSReturnsNotRetainedAttr>;
using OSReturnsNotRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSReturnsNotRetainedAttr>;
class OSReturnsNotRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSReturnsNotRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSReturnsNotRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSReturnsNotRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_RETURNS_NOT_RETAINED;
  }

  static std::optional<OSReturnsNotRetainedAttr> from(const TokenContext &c);
  static std::optional<OSReturnsNotRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSReturnsNotRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSReturnsNotRetainedAttr> from(const Attr &parent);

  inline static std::optional<OSReturnsNotRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSConsumesThisAttrRange = DerivedEntityRange<AttrIterator, OSConsumesThisAttr>;
using OSConsumesThisAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSConsumesThisAttr>;
class OSConsumesThisAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSConsumesThisAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSConsumesThisAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSConsumesThisAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_CONSUMES_THIS;
  }

  static std::optional<OSConsumesThisAttr> from(const TokenContext &c);
  static std::optional<OSConsumesThisAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSConsumesThisAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSConsumesThisAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSConsumesThisAttr> from(const Attr &parent);

  inline static std::optional<OSConsumesThisAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSConsumesThisAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OMPThreadPrivateDeclAttrRange = DerivedEntityRange<AttrIterator, OMPThreadPrivateDeclAttr>;
using OMPThreadPrivateDeclAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPThreadPrivateDeclAttr>;
class OMPThreadPrivateDeclAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OMPThreadPrivateDeclAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPThreadPrivateDeclAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPThreadPrivateDeclAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_THREAD_PRIVATE_DECL;
  }

  static std::optional<OMPThreadPrivateDeclAttr> from(const TokenContext &c);
  static std::optional<OMPThreadPrivateDeclAttr> from(const InheritableAttr &parent);

  inline static std::optional<OMPThreadPrivateDeclAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OMPThreadPrivateDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPThreadPrivateDeclAttr> from(const Attr &parent);

  inline static std::optional<OMPThreadPrivateDeclAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPThreadPrivateDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OMPDeclareVariantAttrRange = DerivedEntityRange<AttrIterator, OMPDeclareVariantAttr>;
using OMPDeclareVariantAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclareVariantAttr>;
class OMPDeclareVariantAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OMPDeclareVariantAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclareVariantAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclareVariantAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_DECLARE_VARIANT;
  }

  static std::optional<OMPDeclareVariantAttr> from(const TokenContext &c);
  static std::optional<OMPDeclareVariantAttr> from(const InheritableAttr &parent);

  inline static std::optional<OMPDeclareVariantAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OMPDeclareVariantAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareVariantAttr> from(const Attr &parent);

  inline static std::optional<OMPDeclareVariantAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPDeclareVariantAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  Expr variant_func_reference(void) const;
};

using OMPDeclareTargetDeclAttrRange = DerivedEntityRange<AttrIterator, OMPDeclareTargetDeclAttr>;
using OMPDeclareTargetDeclAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclareTargetDeclAttr>;
class OMPDeclareTargetDeclAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OMPDeclareTargetDeclAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclareTargetDeclAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclareTargetDeclAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_DECLARE_TARGET_DECL;
  }

  static std::optional<OMPDeclareTargetDeclAttr> from(const TokenContext &c);
  static std::optional<OMPDeclareTargetDeclAttr> from(const InheritableAttr &parent);

  inline static std::optional<OMPDeclareTargetDeclAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OMPDeclareTargetDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareTargetDeclAttr> from(const Attr &parent);

  inline static std::optional<OMPDeclareTargetDeclAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPDeclareTargetDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OMPDeclareTargetDeclAttrDevTypeTy dev_type(void) const;
  bool indirect(void) const;
  Expr indirect_expression(void) const;
  OMPDeclareTargetDeclAttrMapTypeTy map_type(void) const;
  std::string_view spelling(void) const;
};

using OMPCaptureNoInitAttrRange = DerivedEntityRange<AttrIterator, OMPCaptureNoInitAttr>;
using OMPCaptureNoInitAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCaptureNoInitAttr>;
class OMPCaptureNoInitAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OMPCaptureNoInitAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCaptureNoInitAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCaptureNoInitAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_CAPTURE_NO_INIT;
  }

  static std::optional<OMPCaptureNoInitAttr> from(const TokenContext &c);
  static std::optional<OMPCaptureNoInitAttr> from(const InheritableAttr &parent);

  inline static std::optional<OMPCaptureNoInitAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OMPCaptureNoInitAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCaptureNoInitAttr> from(const Attr &parent);

  inline static std::optional<OMPCaptureNoInitAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPCaptureNoInitAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OMPAllocateDeclAttrRange = DerivedEntityRange<AttrIterator, OMPAllocateDeclAttr>;
using OMPAllocateDeclAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPAllocateDeclAttr>;
class OMPAllocateDeclAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OMPAllocateDeclAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPAllocateDeclAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPAllocateDeclAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OMP_ALLOCATE_DECL;
  }

  static std::optional<OMPAllocateDeclAttr> from(const TokenContext &c);
  static std::optional<OMPAllocateDeclAttr> from(const InheritableAttr &parent);

  inline static std::optional<OMPAllocateDeclAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OMPAllocateDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPAllocateDeclAttr> from(const Attr &parent);

  inline static std::optional<OMPAllocateDeclAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OMPAllocateDeclAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr alignment(void) const;
  Expr allocator(void) const;
  OMPAllocateDeclAttrAllocatorTypeTy allocator_type(void) const;
  std::string_view spelling(void) const;
};

using NotTailCalledAttrRange = DerivedEntityRange<AttrIterator, NotTailCalledAttr>;
using NotTailCalledAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NotTailCalledAttr>;
class NotTailCalledAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NotTailCalledAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NotTailCalledAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NotTailCalledAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NOT_TAIL_CALLED;
  }

  static std::optional<NotTailCalledAttr> from(const TokenContext &c);
  static std::optional<NotTailCalledAttr> from(const InheritableAttr &parent);

  inline static std::optional<NotTailCalledAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NotTailCalledAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NotTailCalledAttr> from(const Attr &parent);

  inline static std::optional<NotTailCalledAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NotTailCalledAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoUniqueAddressAttrRange = DerivedEntityRange<AttrIterator, NoUniqueAddressAttr>;
using NoUniqueAddressAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoUniqueAddressAttr>;
class NoUniqueAddressAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoUniqueAddressAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoUniqueAddressAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoUniqueAddressAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_UNIQUE_ADDRESS;
  }

  static std::optional<NoUniqueAddressAttr> from(const TokenContext &c);
  static std::optional<NoUniqueAddressAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoUniqueAddressAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoUniqueAddressAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoUniqueAddressAttr> from(const Attr &parent);

  inline static std::optional<NoUniqueAddressAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoUniqueAddressAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoThrowAttrRange = DerivedEntityRange<AttrIterator, NoThrowAttr>;
using NoThrowAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoThrowAttr>;
class NoThrowAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoThrowAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoThrowAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoThrowAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_THROW;
  }

  static std::optional<NoThrowAttr> from(const TokenContext &c);
  static std::optional<NoThrowAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoThrowAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoThrowAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoThrowAttr> from(const Attr &parent);

  inline static std::optional<NoThrowAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoThrowAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoThreadSafetyAnalysisAttrRange = DerivedEntityRange<AttrIterator, NoThreadSafetyAnalysisAttr>;
using NoThreadSafetyAnalysisAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoThreadSafetyAnalysisAttr>;
class NoThreadSafetyAnalysisAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoThreadSafetyAnalysisAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoThreadSafetyAnalysisAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoThreadSafetyAnalysisAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_THREAD_SAFETY_ANALYSIS;
  }

  static std::optional<NoThreadSafetyAnalysisAttr> from(const TokenContext &c);
  static std::optional<NoThreadSafetyAnalysisAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoThreadSafetyAnalysisAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoThreadSafetyAnalysisAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoThreadSafetyAnalysisAttr> from(const Attr &parent);

  inline static std::optional<NoThreadSafetyAnalysisAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoThreadSafetyAnalysisAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoStackProtectorAttrRange = DerivedEntityRange<AttrIterator, NoStackProtectorAttr>;
using NoStackProtectorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoStackProtectorAttr>;
class NoStackProtectorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoStackProtectorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoStackProtectorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoStackProtectorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_STACK_PROTECTOR;
  }

  static std::optional<NoStackProtectorAttr> from(const TokenContext &c);
  static std::optional<NoStackProtectorAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoStackProtectorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoStackProtectorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoStackProtectorAttr> from(const Attr &parent);

  inline static std::optional<NoStackProtectorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoStackProtectorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoSplitStackAttrRange = DerivedEntityRange<AttrIterator, NoSplitStackAttr>;
using NoSplitStackAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoSplitStackAttr>;
class NoSplitStackAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoSplitStackAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoSplitStackAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoSplitStackAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_SPLIT_STACK;
  }

  static std::optional<NoSplitStackAttr> from(const TokenContext &c);
  static std::optional<NoSplitStackAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoSplitStackAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoSplitStackAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoSplitStackAttr> from(const Attr &parent);

  inline static std::optional<NoSplitStackAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoSplitStackAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoSpeculativeLoadHardeningAttrRange = DerivedEntityRange<AttrIterator, NoSpeculativeLoadHardeningAttr>;
using NoSpeculativeLoadHardeningAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoSpeculativeLoadHardeningAttr>;
class NoSpeculativeLoadHardeningAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoSpeculativeLoadHardeningAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoSpeculativeLoadHardeningAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoSpeculativeLoadHardeningAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_SPECULATIVE_LOAD_HARDENING;
  }

  static std::optional<NoSpeculativeLoadHardeningAttr> from(const TokenContext &c);
  static std::optional<NoSpeculativeLoadHardeningAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoSpeculativeLoadHardeningAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoSpeculativeLoadHardeningAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoSpeculativeLoadHardeningAttr> from(const Attr &parent);

  inline static std::optional<NoSpeculativeLoadHardeningAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoSpeculativeLoadHardeningAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoSanitizeAttrRange = DerivedEntityRange<AttrIterator, NoSanitizeAttr>;
using NoSanitizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoSanitizeAttr>;
class NoSanitizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoSanitizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoSanitizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoSanitizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_SANITIZE;
  }

  static std::optional<NoSanitizeAttr> from(const TokenContext &c);
  static std::optional<NoSanitizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoSanitizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoSanitizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoSanitizeAttr> from(const Attr &parent);

  inline static std::optional<NoSanitizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoSanitizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  bool has_coverage(void) const;
};

using NoReturnAttrRange = DerivedEntityRange<AttrIterator, NoReturnAttr>;
using NoReturnAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoReturnAttr>;
class NoReturnAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoReturnAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoReturnAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoReturnAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_RETURN;
  }

  static std::optional<NoReturnAttr> from(const TokenContext &c);
  static std::optional<NoReturnAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoReturnAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoReturnAttr> from(const Attr &parent);

  inline static std::optional<NoReturnAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoReturnAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoProfileFunctionAttrRange = DerivedEntityRange<AttrIterator, NoProfileFunctionAttr>;
using NoProfileFunctionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoProfileFunctionAttr>;
class NoProfileFunctionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoProfileFunctionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoProfileFunctionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoProfileFunctionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_PROFILE_FUNCTION;
  }

  static std::optional<NoProfileFunctionAttr> from(const TokenContext &c);
  static std::optional<NoProfileFunctionAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoProfileFunctionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoProfileFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoProfileFunctionAttr> from(const Attr &parent);

  inline static std::optional<NoProfileFunctionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoProfileFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoMips16AttrRange = DerivedEntityRange<AttrIterator, NoMips16Attr>;
using NoMips16AttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoMips16Attr>;
class NoMips16Attr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoMips16AttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoMips16AttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoMips16Attr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_MIPS16;
  }

  static std::optional<NoMips16Attr> from(const TokenContext &c);
  static std::optional<NoMips16Attr> from(const InheritableAttr &parent);

  inline static std::optional<NoMips16Attr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoMips16Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoMips16Attr> from(const Attr &parent);

  inline static std::optional<NoMips16Attr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoMips16Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoMicroMipsAttrRange = DerivedEntityRange<AttrIterator, NoMicroMipsAttr>;
using NoMicroMipsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoMicroMipsAttr>;
class NoMicroMipsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoMicroMipsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoMicroMipsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoMicroMipsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_MICRO_MIPS;
  }

  static std::optional<NoMicroMipsAttr> from(const TokenContext &c);
  static std::optional<NoMicroMipsAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoMicroMipsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoMicroMipsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoMicroMipsAttr> from(const Attr &parent);

  inline static std::optional<NoMicroMipsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoMicroMipsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoInstrumentFunctionAttrRange = DerivedEntityRange<AttrIterator, NoInstrumentFunctionAttr>;
using NoInstrumentFunctionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoInstrumentFunctionAttr>;
class NoInstrumentFunctionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoInstrumentFunctionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoInstrumentFunctionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoInstrumentFunctionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_INSTRUMENT_FUNCTION;
  }

  static std::optional<NoInstrumentFunctionAttr> from(const TokenContext &c);
  static std::optional<NoInstrumentFunctionAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoInstrumentFunctionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoInstrumentFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoInstrumentFunctionAttr> from(const Attr &parent);

  inline static std::optional<NoInstrumentFunctionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoInstrumentFunctionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoInlineAttrRange = DerivedEntityRange<AttrIterator, NoInlineAttr>;
using NoInlineAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoInlineAttr>;
class NoInlineAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoInlineAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoInlineAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoInlineAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_INLINE;
  }

  static std::optional<NoInlineAttr> from(const TokenContext &c);
  static std::optional<NoInlineAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoInlineAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoInlineAttr> from(const Attr &parent);

  inline static std::optional<NoInlineAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoInlineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoDuplicateAttrRange = DerivedEntityRange<AttrIterator, NoDuplicateAttr>;
using NoDuplicateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoDuplicateAttr>;
class NoDuplicateAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoDuplicateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoDuplicateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoDuplicateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_DUPLICATE;
  }

  static std::optional<NoDuplicateAttr> from(const TokenContext &c);
  static std::optional<NoDuplicateAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoDuplicateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoDuplicateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoDuplicateAttr> from(const Attr &parent);

  inline static std::optional<NoDuplicateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoDuplicateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoDestroyAttrRange = DerivedEntityRange<AttrIterator, NoDestroyAttr>;
using NoDestroyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoDestroyAttr>;
class NoDestroyAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoDestroyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoDestroyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoDestroyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_DESTROY;
  }

  static std::optional<NoDestroyAttr> from(const TokenContext &c);
  static std::optional<NoDestroyAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoDestroyAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoDestroyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoDestroyAttr> from(const Attr &parent);

  inline static std::optional<NoDestroyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoDestroyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoDebugAttrRange = DerivedEntityRange<AttrIterator, NoDebugAttr>;
using NoDebugAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoDebugAttr>;
class NoDebugAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoDebugAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoDebugAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoDebugAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_DEBUG;
  }

  static std::optional<NoDebugAttr> from(const TokenContext &c);
  static std::optional<NoDebugAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoDebugAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoDebugAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoDebugAttr> from(const Attr &parent);

  inline static std::optional<NoDebugAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoDebugAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoCommonAttrRange = DerivedEntityRange<AttrIterator, NoCommonAttr>;
using NoCommonAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoCommonAttr>;
class NoCommonAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoCommonAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoCommonAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoCommonAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_COMMON;
  }

  static std::optional<NoCommonAttr> from(const TokenContext &c);
  static std::optional<NoCommonAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoCommonAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoCommonAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoCommonAttr> from(const Attr &parent);

  inline static std::optional<NoCommonAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoCommonAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NoAliasAttrRange = DerivedEntityRange<AttrIterator, NoAliasAttr>;
using NoAliasAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoAliasAttr>;
class NoAliasAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NoAliasAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoAliasAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoAliasAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NO_ALIAS;
  }

  static std::optional<NoAliasAttr> from(const TokenContext &c);
  static std::optional<NoAliasAttr> from(const InheritableAttr &parent);

  inline static std::optional<NoAliasAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NoAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoAliasAttr> from(const Attr &parent);

  inline static std::optional<NoAliasAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NoAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NakedAttrRange = DerivedEntityRange<AttrIterator, NakedAttr>;
using NakedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NakedAttr>;
class NakedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NakedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NakedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NakedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NAKED;
  }

  static std::optional<NakedAttr> from(const TokenContext &c);
  static std::optional<NakedAttr> from(const InheritableAttr &parent);

  inline static std::optional<NakedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NakedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NakedAttr> from(const Attr &parent);

  inline static std::optional<NakedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NakedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NSReturnsRetainedAttrRange = DerivedEntityRange<AttrIterator, NSReturnsRetainedAttr>;
using NSReturnsRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSReturnsRetainedAttr>;
class NSReturnsRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSReturnsRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSReturnsRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSReturnsRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_RETURNS_RETAINED;
  }

  static std::optional<NSReturnsRetainedAttr> from(const TokenContext &c);
  static std::optional<NSReturnsRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSReturnsRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSReturnsRetainedAttr> from(const Attr &parent);

  inline static std::optional<NSReturnsRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSReturnsRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NSReturnsNotRetainedAttrRange = DerivedEntityRange<AttrIterator, NSReturnsNotRetainedAttr>;
using NSReturnsNotRetainedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSReturnsNotRetainedAttr>;
class NSReturnsNotRetainedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSReturnsNotRetainedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSReturnsNotRetainedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSReturnsNotRetainedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_RETURNS_NOT_RETAINED;
  }

  static std::optional<NSReturnsNotRetainedAttr> from(const TokenContext &c);
  static std::optional<NSReturnsNotRetainedAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSReturnsNotRetainedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSReturnsNotRetainedAttr> from(const Attr &parent);

  inline static std::optional<NSReturnsNotRetainedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSReturnsNotRetainedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NSReturnsAutoreleasedAttrRange = DerivedEntityRange<AttrIterator, NSReturnsAutoreleasedAttr>;
using NSReturnsAutoreleasedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSReturnsAutoreleasedAttr>;
class NSReturnsAutoreleasedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSReturnsAutoreleasedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSReturnsAutoreleasedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSReturnsAutoreleasedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_RETURNS_AUTORELEASED;
  }

  static std::optional<NSReturnsAutoreleasedAttr> from(const TokenContext &c);
  static std::optional<NSReturnsAutoreleasedAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSReturnsAutoreleasedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSReturnsAutoreleasedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSReturnsAutoreleasedAttr> from(const Attr &parent);

  inline static std::optional<NSReturnsAutoreleasedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSReturnsAutoreleasedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NSErrorDomainAttrRange = DerivedEntityRange<AttrIterator, NSErrorDomainAttr>;
using NSErrorDomainAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSErrorDomainAttr>;
class NSErrorDomainAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSErrorDomainAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSErrorDomainAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSErrorDomainAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_ERROR_DOMAIN;
  }

  static std::optional<NSErrorDomainAttr> from(const TokenContext &c);
  static std::optional<NSErrorDomainAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSErrorDomainAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSErrorDomainAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSErrorDomainAttr> from(const Attr &parent);

  inline static std::optional<NSErrorDomainAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSErrorDomainAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  VarDecl error_domain(void) const;
  std::string_view spelling(void) const;
};

using NSConsumesSelfAttrRange = DerivedEntityRange<AttrIterator, NSConsumesSelfAttr>;
using NSConsumesSelfAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSConsumesSelfAttr>;
class NSConsumesSelfAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSConsumesSelfAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSConsumesSelfAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSConsumesSelfAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_CONSUMES_SELF;
  }

  static std::optional<NSConsumesSelfAttr> from(const TokenContext &c);
  static std::optional<NSConsumesSelfAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSConsumesSelfAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSConsumesSelfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSConsumesSelfAttr> from(const Attr &parent);

  inline static std::optional<NSConsumesSelfAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSConsumesSelfAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MipsShortCallAttrRange = DerivedEntityRange<AttrIterator, MipsShortCallAttr>;
using MipsShortCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MipsShortCallAttr>;
class MipsShortCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MipsShortCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MipsShortCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MipsShortCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIPS_SHORT_CALL;
  }

  static std::optional<MipsShortCallAttr> from(const TokenContext &c);
  static std::optional<MipsShortCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<MipsShortCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MipsShortCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MipsShortCallAttr> from(const Attr &parent);

  inline static std::optional<MipsShortCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MipsShortCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  MipsShortCallAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using MipsLongCallAttrRange = DerivedEntityRange<AttrIterator, MipsLongCallAttr>;
using MipsLongCallAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MipsLongCallAttr>;
class MipsLongCallAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MipsLongCallAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MipsLongCallAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MipsLongCallAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIPS_LONG_CALL;
  }

  static std::optional<MipsLongCallAttr> from(const TokenContext &c);
  static std::optional<MipsLongCallAttr> from(const InheritableAttr &parent);

  inline static std::optional<MipsLongCallAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MipsLongCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MipsLongCallAttr> from(const Attr &parent);

  inline static std::optional<MipsLongCallAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MipsLongCallAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  MipsLongCallAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using MipsInterruptAttrRange = DerivedEntityRange<AttrIterator, MipsInterruptAttr>;
using MipsInterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MipsInterruptAttr>;
class MipsInterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MipsInterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MipsInterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MipsInterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIPS_INTERRUPT;
  }

  static std::optional<MipsInterruptAttr> from(const TokenContext &c);
  static std::optional<MipsInterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<MipsInterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MipsInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MipsInterruptAttr> from(const Attr &parent);

  inline static std::optional<MipsInterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MipsInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  MipsInterruptAttrInterruptType interrupt(void) const;
  std::string_view spelling(void) const;
};

using Mips16AttrRange = DerivedEntityRange<AttrIterator, Mips16Attr>;
using Mips16AttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, Mips16Attr>;
class Mips16Attr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static Mips16AttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static Mips16AttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Mips16Attr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIPS16;
  }

  static std::optional<Mips16Attr> from(const TokenContext &c);
  static std::optional<Mips16Attr> from(const InheritableAttr &parent);

  inline static std::optional<Mips16Attr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return Mips16Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<Mips16Attr> from(const Attr &parent);

  inline static std::optional<Mips16Attr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return Mips16Attr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MinVectorWidthAttrRange = DerivedEntityRange<AttrIterator, MinVectorWidthAttr>;
using MinVectorWidthAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MinVectorWidthAttr>;
class MinVectorWidthAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MinVectorWidthAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MinVectorWidthAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MinVectorWidthAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIN_VECTOR_WIDTH;
  }

  static std::optional<MinVectorWidthAttr> from(const TokenContext &c);
  static std::optional<MinVectorWidthAttr> from(const InheritableAttr &parent);

  inline static std::optional<MinVectorWidthAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MinVectorWidthAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MinVectorWidthAttr> from(const Attr &parent);

  inline static std::optional<MinVectorWidthAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MinVectorWidthAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MinSizeAttrRange = DerivedEntityRange<AttrIterator, MinSizeAttr>;
using MinSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MinSizeAttr>;
class MinSizeAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MinSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MinSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MinSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIN_SIZE;
  }

  static std::optional<MinSizeAttr> from(const TokenContext &c);
  static std::optional<MinSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<MinSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MinSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MinSizeAttr> from(const Attr &parent);

  inline static std::optional<MinSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MinSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MicroMipsAttrRange = DerivedEntityRange<AttrIterator, MicroMipsAttr>;
using MicroMipsAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MicroMipsAttr>;
class MicroMipsAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MicroMipsAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MicroMipsAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MicroMipsAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MICRO_MIPS;
  }

  static std::optional<MicroMipsAttr> from(const TokenContext &c);
  static std::optional<MicroMipsAttr> from(const InheritableAttr &parent);

  inline static std::optional<MicroMipsAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MicroMipsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MicroMipsAttr> from(const Attr &parent);

  inline static std::optional<MicroMipsAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MicroMipsAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MayAliasAttrRange = DerivedEntityRange<AttrIterator, MayAliasAttr>;
using MayAliasAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MayAliasAttr>;
class MayAliasAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MayAliasAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MayAliasAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MayAliasAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MAY_ALIAS;
  }

  static std::optional<MayAliasAttr> from(const TokenContext &c);
  static std::optional<MayAliasAttr> from(const InheritableAttr &parent);

  inline static std::optional<MayAliasAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MayAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MayAliasAttr> from(const Attr &parent);

  inline static std::optional<MayAliasAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MayAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MaxFieldAlignmentAttrRange = DerivedEntityRange<AttrIterator, MaxFieldAlignmentAttr>;
using MaxFieldAlignmentAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MaxFieldAlignmentAttr>;
class MaxFieldAlignmentAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MaxFieldAlignmentAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MaxFieldAlignmentAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MaxFieldAlignmentAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MAX_FIELD_ALIGNMENT;
  }

  static std::optional<MaxFieldAlignmentAttr> from(const TokenContext &c);
  static std::optional<MaxFieldAlignmentAttr> from(const InheritableAttr &parent);

  inline static std::optional<MaxFieldAlignmentAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MaxFieldAlignmentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MaxFieldAlignmentAttr> from(const Attr &parent);

  inline static std::optional<MaxFieldAlignmentAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MaxFieldAlignmentAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MSVtorDispAttrRange = DerivedEntityRange<AttrIterator, MSVtorDispAttr>;
using MSVtorDispAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSVtorDispAttr>;
class MSVtorDispAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSVtorDispAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSVtorDispAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSVtorDispAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MS_VTOR_DISP;
  }

  static std::optional<MSVtorDispAttr> from(const TokenContext &c);
  static std::optional<MSVtorDispAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSVtorDispAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSVtorDispAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSVtorDispAttr> from(const Attr &parent);

  inline static std::optional<MSVtorDispAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSVtorDispAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
  MSVtorDispMode vtor_disp_mode(void) const;
};

using MSStructAttrRange = DerivedEntityRange<AttrIterator, MSStructAttr>;
using MSStructAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSStructAttr>;
class MSStructAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSStructAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSStructAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSStructAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MS_STRUCT;
  }

  static std::optional<MSStructAttr> from(const TokenContext &c);
  static std::optional<MSStructAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSStructAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSStructAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSStructAttr> from(const Attr &parent);

  inline static std::optional<MSStructAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSStructAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MSP430InterruptAttrRange = DerivedEntityRange<AttrIterator, MSP430InterruptAttr>;
using MSP430InterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSP430InterruptAttr>;
class MSP430InterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSP430InterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSP430InterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSP430InterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MSP430_INTERRUPT;
  }

  static std::optional<MSP430InterruptAttr> from(const TokenContext &c);
  static std::optional<MSP430InterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSP430InterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSP430InterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSP430InterruptAttr> from(const Attr &parent);

  inline static std::optional<MSP430InterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSP430InterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MSNoVTableAttrRange = DerivedEntityRange<AttrIterator, MSNoVTableAttr>;
using MSNoVTableAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSNoVTableAttr>;
class MSNoVTableAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSNoVTableAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSNoVTableAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSNoVTableAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MS_NO_V_TABLE;
  }

  static std::optional<MSNoVTableAttr> from(const TokenContext &c);
  static std::optional<MSNoVTableAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSNoVTableAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSNoVTableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSNoVTableAttr> from(const Attr &parent);

  inline static std::optional<MSNoVTableAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSNoVTableAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MSInheritanceAttrRange = DerivedEntityRange<AttrIterator, MSInheritanceAttr>;
using MSInheritanceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSInheritanceAttr>;
class MSInheritanceAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSInheritanceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSInheritanceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSInheritanceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MS_INHERITANCE;
  }

  static std::optional<MSInheritanceAttr> from(const TokenContext &c);
  static std::optional<MSInheritanceAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSInheritanceAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSInheritanceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSInheritanceAttr> from(const Attr &parent);

  inline static std::optional<MSInheritanceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSInheritanceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool best_case(void) const;
  MSInheritanceModel inheritance_model(void) const;
  MSInheritanceAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using MSAllocatorAttrRange = DerivedEntityRange<AttrIterator, MSAllocatorAttr>;
using MSAllocatorAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSAllocatorAttr>;
class MSAllocatorAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSAllocatorAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSAllocatorAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSAllocatorAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MS_ALLOCATOR;
  }

  static std::optional<MSAllocatorAttr> from(const TokenContext &c);
  static std::optional<MSAllocatorAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSAllocatorAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSAllocatorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSAllocatorAttr> from(const Attr &parent);

  inline static std::optional<MSAllocatorAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSAllocatorAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MSABIAttrRange = DerivedEntityRange<AttrIterator, MSABIAttr>;
using MSABIAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSABIAttr>;
class MSABIAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MSABIAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSABIAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSABIAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MSABI;
  }

  static std::optional<MSABIAttr> from(const TokenContext &c);
  static std::optional<MSABIAttr> from(const InheritableAttr &parent);

  inline static std::optional<MSABIAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MSABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSABIAttr> from(const Attr &parent);

  inline static std::optional<MSABIAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MSABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using MIGServerRoutineAttrRange = DerivedEntityRange<AttrIterator, MIGServerRoutineAttr>;
using MIGServerRoutineAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, MIGServerRoutineAttr>;
class MIGServerRoutineAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static MIGServerRoutineAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MIGServerRoutineAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MIGServerRoutineAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::MIG_SERVER_ROUTINE_;
  }

  static std::optional<MIGServerRoutineAttr> from(const TokenContext &c);
  static std::optional<MIGServerRoutineAttr> from(const InheritableAttr &parent);

  inline static std::optional<MIGServerRoutineAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return MIGServerRoutineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MIGServerRoutineAttr> from(const Attr &parent);

  inline static std::optional<MIGServerRoutineAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return MIGServerRoutineAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using M68kInterruptAttrRange = DerivedEntityRange<AttrIterator, M68kInterruptAttr>;
using M68kInterruptAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, M68kInterruptAttr>;
class M68kInterruptAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static M68kInterruptAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static M68kInterruptAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : M68kInterruptAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::M68K_INTERRUPT;
  }

  static std::optional<M68kInterruptAttr> from(const TokenContext &c);
  static std::optional<M68kInterruptAttr> from(const InheritableAttr &parent);

  inline static std::optional<M68kInterruptAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return M68kInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<M68kInterruptAttr> from(const Attr &parent);

  inline static std::optional<M68kInterruptAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return M68kInterruptAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LocksExcludedAttrRange = DerivedEntityRange<AttrIterator, LocksExcludedAttr>;
using LocksExcludedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LocksExcludedAttr>;
class LocksExcludedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LocksExcludedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LocksExcludedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LocksExcludedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LOCKS_EXCLUDED;
  }

  static std::optional<LocksExcludedAttr> from(const TokenContext &c);
  static std::optional<LocksExcludedAttr> from(const InheritableAttr &parent);

  inline static std::optional<LocksExcludedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LocksExcludedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LocksExcludedAttr> from(const Attr &parent);

  inline static std::optional<LocksExcludedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LocksExcludedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LockReturnedAttrRange = DerivedEntityRange<AttrIterator, LockReturnedAttr>;
using LockReturnedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LockReturnedAttr>;
class LockReturnedAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LockReturnedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LockReturnedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LockReturnedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LOCK_RETURNED;
  }

  static std::optional<LockReturnedAttr> from(const TokenContext &c);
  static std::optional<LockReturnedAttr> from(const InheritableAttr &parent);

  inline static std::optional<LockReturnedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LockReturnedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LockReturnedAttr> from(const Attr &parent);

  inline static std::optional<LockReturnedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LockReturnedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr argument(void) const;
  std::string_view spelling(void) const;
};

using LifetimeBoundAttrRange = DerivedEntityRange<AttrIterator, LifetimeBoundAttr>;
using LifetimeBoundAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LifetimeBoundAttr>;
class LifetimeBoundAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LifetimeBoundAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LifetimeBoundAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LifetimeBoundAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LIFETIME_BOUND;
  }

  static std::optional<LifetimeBoundAttr> from(const TokenContext &c);
  static std::optional<LifetimeBoundAttr> from(const InheritableAttr &parent);

  inline static std::optional<LifetimeBoundAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LifetimeBoundAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LifetimeBoundAttr> from(const Attr &parent);

  inline static std::optional<LifetimeBoundAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LifetimeBoundAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LeafAttrRange = DerivedEntityRange<AttrIterator, LeafAttr>;
using LeafAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LeafAttr>;
class LeafAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LeafAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LeafAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LeafAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LEAF;
  }

  static std::optional<LeafAttr> from(const TokenContext &c);
  static std::optional<LeafAttr> from(const InheritableAttr &parent);

  inline static std::optional<LeafAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LeafAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LeafAttr> from(const Attr &parent);

  inline static std::optional<LeafAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LeafAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LayoutVersionAttrRange = DerivedEntityRange<AttrIterator, LayoutVersionAttr>;
using LayoutVersionAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LayoutVersionAttr>;
class LayoutVersionAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LayoutVersionAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LayoutVersionAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LayoutVersionAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LAYOUT_VERSION;
  }

  static std::optional<LayoutVersionAttr> from(const TokenContext &c);
  static std::optional<LayoutVersionAttr> from(const InheritableAttr &parent);

  inline static std::optional<LayoutVersionAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LayoutVersionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LayoutVersionAttr> from(const Attr &parent);

  inline static std::optional<LayoutVersionAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LayoutVersionAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using LTOVisibilityPublicAttrRange = DerivedEntityRange<AttrIterator, LTOVisibilityPublicAttr>;
using LTOVisibilityPublicAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, LTOVisibilityPublicAttr>;
class LTOVisibilityPublicAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static LTOVisibilityPublicAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LTOVisibilityPublicAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LTOVisibilityPublicAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::LTO_VISIBILITY_PUBLIC;
  }

  static std::optional<LTOVisibilityPublicAttr> from(const TokenContext &c);
  static std::optional<LTOVisibilityPublicAttr> from(const InheritableAttr &parent);

  inline static std::optional<LTOVisibilityPublicAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return LTOVisibilityPublicAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LTOVisibilityPublicAttr> from(const Attr &parent);

  inline static std::optional<LTOVisibilityPublicAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return LTOVisibilityPublicAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using InternalLinkageAttrRange = DerivedEntityRange<AttrIterator, InternalLinkageAttr>;
using InternalLinkageAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, InternalLinkageAttr>;
class InternalLinkageAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static InternalLinkageAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InternalLinkageAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InternalLinkageAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::INTERNAL_LINKAGE;
  }

  static std::optional<InternalLinkageAttr> from(const TokenContext &c);
  static std::optional<InternalLinkageAttr> from(const InheritableAttr &parent);

  inline static std::optional<InternalLinkageAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return InternalLinkageAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<InternalLinkageAttr> from(const Attr &parent);

  inline static std::optional<InternalLinkageAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return InternalLinkageAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using IntelOclBiccAttrRange = DerivedEntityRange<AttrIterator, IntelOclBiccAttr>;
using IntelOclBiccAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, IntelOclBiccAttr>;
class IntelOclBiccAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static IntelOclBiccAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IntelOclBiccAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IntelOclBiccAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::INTEL_OCL_BICC;
  }

  static std::optional<IntelOclBiccAttr> from(const TokenContext &c);
  static std::optional<IntelOclBiccAttr> from(const InheritableAttr &parent);

  inline static std::optional<IntelOclBiccAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return IntelOclBiccAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IntelOclBiccAttr> from(const Attr &parent);

  inline static std::optional<IntelOclBiccAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return IntelOclBiccAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using InitPriorityAttrRange = DerivedEntityRange<AttrIterator, InitPriorityAttr>;
using InitPriorityAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, InitPriorityAttr>;
class InitPriorityAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static InitPriorityAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InitPriorityAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InitPriorityAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::INIT_PRIORITY;
  }

  static std::optional<InitPriorityAttr> from(const TokenContext &c);
  static std::optional<InitPriorityAttr> from(const InheritableAttr &parent);

  inline static std::optional<InitPriorityAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return InitPriorityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<InitPriorityAttr> from(const Attr &parent);

  inline static std::optional<InitPriorityAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return InitPriorityAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using InheritableParamAttrRange = DerivedEntityRange<AttrIterator, InheritableParamAttr>;
using InheritableParamAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, InheritableParamAttr>;
class InheritableParamAttr : public InheritableAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static InheritableParamAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InheritableParamAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InheritableParamAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<InheritableParamAttr> from(const TokenContext &c);
  static std::optional<InheritableParamAttr> from(const InheritableAttr &parent);

  inline static std::optional<InheritableParamAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return InheritableParamAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<InheritableParamAttr> from(const Attr &parent);

  inline static std::optional<InheritableParamAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return InheritableParamAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CarriesDependencyAttrRange = DerivedEntityRange<AttrIterator, CarriesDependencyAttr>;
using CarriesDependencyAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CarriesDependencyAttr>;
class CarriesDependencyAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CarriesDependencyAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CarriesDependencyAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CarriesDependencyAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CARRIES_DEPENDENCY;
  }

  static std::optional<CarriesDependencyAttr> from(const TokenContext &c);
  static std::optional<CarriesDependencyAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<CarriesDependencyAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return CarriesDependencyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CarriesDependencyAttr> from(const InheritableAttr &parent);

  inline static std::optional<CarriesDependencyAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CarriesDependencyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CarriesDependencyAttr> from(const Attr &parent);

  inline static std::optional<CarriesDependencyAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CarriesDependencyAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using CFConsumedAttrRange = DerivedEntityRange<AttrIterator, CFConsumedAttr>;
using CFConsumedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CFConsumedAttr>;
class CFConsumedAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static CFConsumedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CFConsumedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CFConsumedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CF_CONSUMED;
  }

  static std::optional<CFConsumedAttr> from(const TokenContext &c);
  static std::optional<CFConsumedAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<CFConsumedAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return CFConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFConsumedAttr> from(const InheritableAttr &parent);

  inline static std::optional<CFConsumedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return CFConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CFConsumedAttr> from(const Attr &parent);

  inline static std::optional<CFConsumedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CFConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using AnnotateAttrRange = DerivedEntityRange<AttrIterator, AnnotateAttr>;
using AnnotateAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, AnnotateAttr>;
class AnnotateAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static AnnotateAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AnnotateAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AnnotateAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::ANNOTATE;
  }

  static std::optional<AnnotateAttr> from(const TokenContext &c);
  static std::optional<AnnotateAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<AnnotateAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return AnnotateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnnotateAttr> from(const InheritableAttr &parent);

  inline static std::optional<AnnotateAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return AnnotateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AnnotateAttr> from(const Attr &parent);

  inline static std::optional<AnnotateAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return AnnotateAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view annotation(void) const;
  std::string_view spelling(void) const;
};

using UseHandleAttrRange = DerivedEntityRange<AttrIterator, UseHandleAttr>;
using UseHandleAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, UseHandleAttr>;
class UseHandleAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static UseHandleAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UseHandleAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UseHandleAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::USE_HANDLE;
  }

  static std::optional<UseHandleAttr> from(const TokenContext &c);
  static std::optional<UseHandleAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<UseHandleAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return UseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UseHandleAttr> from(const InheritableAttr &parent);

  inline static std::optional<UseHandleAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return UseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UseHandleAttr> from(const Attr &parent);

  inline static std::optional<UseHandleAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return UseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view handle_type(void) const;
  std::string_view spelling(void) const;
};

using ReleaseHandleAttrRange = DerivedEntityRange<AttrIterator, ReleaseHandleAttr>;
using ReleaseHandleAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReleaseHandleAttr>;
class ReleaseHandleAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ReleaseHandleAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReleaseHandleAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReleaseHandleAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::RELEASE_HANDLE;
  }

  static std::optional<ReleaseHandleAttr> from(const TokenContext &c);
  static std::optional<ReleaseHandleAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<ReleaseHandleAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return ReleaseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReleaseHandleAttr> from(const InheritableAttr &parent);

  inline static std::optional<ReleaseHandleAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ReleaseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ReleaseHandleAttr> from(const Attr &parent);

  inline static std::optional<ReleaseHandleAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ReleaseHandleAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view handle_type(void) const;
  std::string_view spelling(void) const;
};

using PassObjectSizeAttrRange = DerivedEntityRange<AttrIterator, PassObjectSizeAttr>;
using PassObjectSizeAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, PassObjectSizeAttr>;
class PassObjectSizeAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static PassObjectSizeAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PassObjectSizeAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PassObjectSizeAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::PASS_OBJECT_SIZE;
  }

  static std::optional<PassObjectSizeAttr> from(const TokenContext &c);
  static std::optional<PassObjectSizeAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<PassObjectSizeAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return PassObjectSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PassObjectSizeAttr> from(const InheritableAttr &parent);

  inline static std::optional<PassObjectSizeAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return PassObjectSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PassObjectSizeAttr> from(const Attr &parent);

  inline static std::optional<PassObjectSizeAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return PassObjectSizeAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  PassObjectSizeAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
  bool is_dynamic(void) const;
};

using ParameterABIAttrRange = DerivedEntityRange<AttrIterator, ParameterABIAttr>;
using ParameterABIAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParameterABIAttr>;
class ParameterABIAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static ParameterABIAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParameterABIAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParameterABIAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<ParameterABIAttr> from(const TokenContext &c);
  static std::optional<ParameterABIAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<ParameterABIAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return ParameterABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParameterABIAttr> from(const InheritableAttr &parent);

  inline static std::optional<ParameterABIAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return ParameterABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParameterABIAttr> from(const Attr &parent);

  inline static std::optional<ParameterABIAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return ParameterABIAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ParameterABI abi(void) const;
};

using SwiftIndirectResultAttrRange = DerivedEntityRange<AttrIterator, SwiftIndirectResultAttr>;
using SwiftIndirectResultAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftIndirectResultAttr>;
class SwiftIndirectResultAttr : public ParameterABIAttr {
 private:
  friend class FragmentImpl;
  friend class ParameterABIAttr;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftIndirectResultAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftIndirectResultAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftIndirectResultAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_INDIRECT_RESULT;
  }

  static std::optional<SwiftIndirectResultAttr> from(const TokenContext &c);
  static std::optional<SwiftIndirectResultAttr> from(const ParameterABIAttr &parent);

  inline static std::optional<SwiftIndirectResultAttr> from(const std::optional<ParameterABIAttr> &parent) {
    if (parent) {
      return SwiftIndirectResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftIndirectResultAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<SwiftIndirectResultAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return SwiftIndirectResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftIndirectResultAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftIndirectResultAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftIndirectResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftIndirectResultAttr> from(const Attr &parent);

  inline static std::optional<SwiftIndirectResultAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftIndirectResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftErrorResultAttrRange = DerivedEntityRange<AttrIterator, SwiftErrorResultAttr>;
using SwiftErrorResultAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftErrorResultAttr>;
class SwiftErrorResultAttr : public ParameterABIAttr {
 private:
  friend class FragmentImpl;
  friend class ParameterABIAttr;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftErrorResultAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftErrorResultAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftErrorResultAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ERROR_RESULT;
  }

  static std::optional<SwiftErrorResultAttr> from(const TokenContext &c);
  static std::optional<SwiftErrorResultAttr> from(const ParameterABIAttr &parent);

  inline static std::optional<SwiftErrorResultAttr> from(const std::optional<ParameterABIAttr> &parent) {
    if (parent) {
      return SwiftErrorResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftErrorResultAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<SwiftErrorResultAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return SwiftErrorResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftErrorResultAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftErrorResultAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftErrorResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftErrorResultAttr> from(const Attr &parent);

  inline static std::optional<SwiftErrorResultAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftErrorResultAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftContextAttrRange = DerivedEntityRange<AttrIterator, SwiftContextAttr>;
using SwiftContextAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftContextAttr>;
class SwiftContextAttr : public ParameterABIAttr {
 private:
  friend class FragmentImpl;
  friend class ParameterABIAttr;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftContextAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftContextAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftContextAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_CONTEXT;
  }

  static std::optional<SwiftContextAttr> from(const TokenContext &c);
  static std::optional<SwiftContextAttr> from(const ParameterABIAttr &parent);

  inline static std::optional<SwiftContextAttr> from(const std::optional<ParameterABIAttr> &parent) {
    if (parent) {
      return SwiftContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftContextAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<SwiftContextAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return SwiftContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftContextAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftContextAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftContextAttr> from(const Attr &parent);

  inline static std::optional<SwiftContextAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using SwiftAsyncContextAttrRange = DerivedEntityRange<AttrIterator, SwiftAsyncContextAttr>;
using SwiftAsyncContextAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwiftAsyncContextAttr>;
class SwiftAsyncContextAttr : public ParameterABIAttr {
 private:
  friend class FragmentImpl;
  friend class ParameterABIAttr;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static SwiftAsyncContextAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwiftAsyncContextAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwiftAsyncContextAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::SWIFT_ASYNC_CONTEXT;
  }

  static std::optional<SwiftAsyncContextAttr> from(const TokenContext &c);
  static std::optional<SwiftAsyncContextAttr> from(const ParameterABIAttr &parent);

  inline static std::optional<SwiftAsyncContextAttr> from(const std::optional<ParameterABIAttr> &parent) {
    if (parent) {
      return SwiftAsyncContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncContextAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<SwiftAsyncContextAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return SwiftAsyncContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncContextAttr> from(const InheritableAttr &parent);

  inline static std::optional<SwiftAsyncContextAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return SwiftAsyncContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SwiftAsyncContextAttr> from(const Attr &parent);

  inline static std::optional<SwiftAsyncContextAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return SwiftAsyncContextAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using OSConsumedAttrRange = DerivedEntityRange<AttrIterator, OSConsumedAttr>;
using OSConsumedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, OSConsumedAttr>;
class OSConsumedAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static OSConsumedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OSConsumedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OSConsumedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::OS_CONSUMED;
  }

  static std::optional<OSConsumedAttr> from(const TokenContext &c);
  static std::optional<OSConsumedAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<OSConsumedAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return OSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSConsumedAttr> from(const InheritableAttr &parent);

  inline static std::optional<OSConsumedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return OSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OSConsumedAttr> from(const Attr &parent);

  inline static std::optional<OSConsumedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return OSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NonNullAttrRange = DerivedEntityRange<AttrIterator, NonNullAttr>;
using NonNullAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NonNullAttr>;
class NonNullAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NonNullAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NonNullAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NonNullAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NON_NULL;
  }

  static std::optional<NonNullAttr> from(const TokenContext &c);
  static std::optional<NonNullAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<NonNullAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return NonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NonNullAttr> from(const InheritableAttr &parent);

  inline static std::optional<NonNullAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NonNullAttr> from(const Attr &parent);

  inline static std::optional<NonNullAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NonNullAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using NSConsumedAttrRange = DerivedEntityRange<AttrIterator, NSConsumedAttr>;
using NSConsumedAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, NSConsumedAttr>;
class NSConsumedAttr : public InheritableParamAttr {
 private:
  friend class FragmentImpl;
  friend class InheritableParamAttr;
  friend class InheritableAttr;
  friend class Attr;
 public:
  inline static NSConsumedAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NSConsumedAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NSConsumedAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::NS_CONSUMED;
  }

  static std::optional<NSConsumedAttr> from(const TokenContext &c);
  static std::optional<NSConsumedAttr> from(const InheritableParamAttr &parent);

  inline static std::optional<NSConsumedAttr> from(const std::optional<InheritableParamAttr> &parent) {
    if (parent) {
      return NSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSConsumedAttr> from(const InheritableAttr &parent);

  inline static std::optional<NSConsumedAttr> from(const std::optional<InheritableAttr> &parent) {
    if (parent) {
      return NSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NSConsumedAttr> from(const Attr &parent);

  inline static std::optional<NSConsumedAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return NSConsumedAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using IFuncAttrRange = DerivedEntityRange<AttrIterator, IFuncAttr>;
using IFuncAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, IFuncAttr>;
class IFuncAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static IFuncAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IFuncAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IFuncAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::I_FUNC;
  }

  static std::optional<IFuncAttr> from(const TokenContext &c);
  static std::optional<IFuncAttr> from(const Attr &parent);

  inline static std::optional<IFuncAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return IFuncAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view resolver(void) const;
  std::string_view spelling(void) const;
};

using CalledOnceAttrRange = DerivedEntityRange<AttrIterator, CalledOnceAttr>;
using CalledOnceAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, CalledOnceAttr>;
class CalledOnceAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static CalledOnceAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CalledOnceAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CalledOnceAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::CALLED_ONCE;
  }

  static std::optional<CalledOnceAttr> from(const TokenContext &c);
  static std::optional<CalledOnceAttr> from(const Attr &parent);

  inline static std::optional<CalledOnceAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return CalledOnceAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view spelling(void) const;
};

using BuiltinAliasAttrRange = DerivedEntityRange<AttrIterator, BuiltinAliasAttr>;
using BuiltinAliasAttrContainingTokenRange = DerivedEntityRange<TokenContextIterator, BuiltinAliasAttr>;
class BuiltinAliasAttr : public Attr {
 private:
  friend class FragmentImpl;
  friend class Attr;
 public:
  inline static BuiltinAliasAttrRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BuiltinAliasAttrContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BuiltinAliasAttr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr AttrKind static_kind(void) {
    return AttrKind::BUILTIN_ALIAS;
  }

  static std::optional<BuiltinAliasAttr> from(const TokenContext &c);
  static std::optional<BuiltinAliasAttr> from(const Attr &parent);

  inline static std::optional<BuiltinAliasAttr> from(const std::optional<Attr> &parent) {
    if (parent) {
      return BuiltinAliasAttr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  BuiltinAliasAttrSpelling semantic_spelling(void) const;
  std::string_view spelling(void) const;
};

using TypeRange = DerivedEntityRange<TypeIterator, Type>;
using TypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, Type>;
class Type {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  Type(Type &&) noexcept = default;
  Type(const Type &) = default;
  Type &operator=(Type &&) noexcept = default;
  Type &operator=(const Type &) = default;

  inline Type(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  inline static std::optional<Type> from(const Type &self) {
    return self;
  }

  inline static std::optional<Type> from(const std::optional<Type> &self) {
    return self;
  }

  inline static std::optional<Type> from(const TokenContext &c) {
    return c.as_type();
  }

  EntityId id(void) const;
  UseRange<TypeUseSelector> uses(void) const;

 protected:
  static TypeIterator in_internal(const Fragment &fragment);

 public:
  inline static TypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Type::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  bool is_qualified(void) const;
  Type unqualified_type(void) const;
  bool accepts_obj_c_type_parameters(void) const;
  bool can_decay_to_pointer_type(void) const;
  bool can_have_nullability(void) const;
  bool contains_errors(void) const;
  bool contains_unexpanded_parameter_pack(void) const;
  std::optional<Type> array_element_type_no_type_qualified(void) const;
  std::optional<CXXRecordDecl> as_cxx_record_declaration(void) const;
  std::optional<ComplexType> as_complex_integer_type(void) const;
  std::optional<ObjCObjectPointerType> as_obj_c_interface_pointer_type(void) const;
  std::optional<ObjCObjectType> as_obj_c_interface_type(void) const;
  std::optional<ObjCObjectPointerType> as_obj_c_qualified_class_type(void) const;
  std::optional<ObjCObjectPointerType> as_obj_c_qualified_id_type(void) const;
  std::optional<ObjCObjectType> as_obj_c_qualified_interface_type(void) const;
  std::optional<BuiltinType> as_placeholder_type(void) const;
  std::optional<RecordDecl> as_record_declaration(void) const;
  std::optional<RecordType> as_structure_type(void) const;
  std::optional<TagDecl> as_tag_declaration(void) const;
  std::optional<RecordType> as_union_type(void) const;
  std::optional<AutoType> contained_auto_type(void) const;
  std::optional<DeducedType> contained_deduced_type(void) const;
  Linkage linkage(void) const;
  Type locally_unqualified_single_step_desugared_type(void) const;
  std::optional<NullabilityKind> nullability(void) const;
  std::optional<CXXRecordDecl> pointee_cxx_record_declaration(void) const;
  std::optional<Type> pointee_or_array_element_type(void) const;
  std::optional<Type> pointee_type(void) const;
  std::optional<TypeScalarTypeKind> scalar_type_kind(void) const;
  std::optional<Type> sve_element_type(void) const;
  TypeKind kind(void) const;
  Type unqualified_desugared_type(void) const;
  Visibility visibility(void) const;
  bool has_auto_for_trailing_return_type(void) const;
  bool has_floating_representation(void) const;
  bool has_integer_representation(void) const;
  bool has_obj_c_pointer_representation(void) const;
  bool has_pointer_representation(void) const;
  bool has_signed_integer_representation(void) const;
  bool has_sized_vla_type(void) const;
  bool has_unnamed_or_local_type(void) const;
  bool has_unsigned_integer_representation(void) const;
  std::optional<bool> is_aggregate_type(void) const;
  bool is_align_value_t(void) const;
  bool is_any_character_type(void) const;
  bool is_any_complex_type(void) const;
  bool is_any_pointer_type(void) const;
  bool is_arithmetic_type(void) const;
  bool is_array_type(void) const;
  bool is_atomic_type(void) const;
  bool is_b_float16_type(void) const;
  bool is_bit_int_type(void) const;
  bool is_block_compatible_obj_c_pointer_type(void) const;
  bool is_block_pointer_type(void) const;
  bool is_boolean_type(void) const;
  bool is_builtin_type(void) const;
  bool is_carc_bridgable_type(void) const;
  bool is_cuda_device_builtin_surface_type(void) const;
  bool is_cuda_device_builtin_texture_type(void) const;
  bool is_canonical_unqualified(void) const;
  bool is_char16_type(void) const;
  bool is_char32_type(void) const;
  bool is_char8_type(void) const;
  bool is_character_type(void) const;
  bool is_class_type(void) const;
  bool is_clk_event_t(void) const;
  bool is_complex_integer_type(void) const;
  bool is_complex_type(void) const;
  bool is_compound_type(void) const;
  bool is_constant_array_type(void) const;
  bool is_constant_matrix_type(void) const;
  std::optional<bool> is_constant_size_type(void) const;
  bool is_decltype_type(void) const;
  bool is_dependent_address_space_type(void) const;
  bool is_dependent_sized_array_type(void) const;
  bool is_dependent_type(void) const;
  bool is_elaborated_type_specifier(void) const;
  bool is_enumeral_type(void) const;
  bool is_event_t(void) const;
  bool is_ext_vector_type(void) const;
  bool is_fixed_point_or_integer_type(void) const;
  bool is_fixed_point_type(void) const;
  bool is_float128_type(void) const;
  bool is_float16_type(void) const;
  bool is_floating_type(void) const;
  bool is_from_ast(void) const;
  bool is_function_no_proto_type(void) const;
  bool is_function_pointer_type(void) const;
  bool is_function_proto_type(void) const;
  bool is_function_reference_type(void) const;
  bool is_function_type(void) const;
  bool is_fundamental_type(void) const;
  bool is_half_type(void) const;
  bool is_ibm128_type(void) const;
  bool is_image_type(void) const;
  bool is_incomplete_array_type(void) const;
  bool is_incomplete_or_object_type(void) const;
  bool is_incomplete_type(void) const;
  bool is_instantiation_dependent_type(void) const;
  bool is_integer_type(void) const;
  bool is_integral_or_enumeration_type(void) const;
  bool is_integral_or_unscoped_enumeration_type(void) const;
  bool is_integral_type(void) const;
  bool is_interface_type(void) const;
  bool is_l_value_reference_type(void) const;
  bool is_linkage_valid(void) const;
  std::optional<bool> is_literal_type(void) const;
  bool is_matrix_type(void) const;
  bool is_member_data_pointer_type(void) const;
  bool is_member_function_pointer_type(void) const;
  bool is_member_pointer_type(void) const;
  bool is_non_overload_placeholder_type(void) const;
  bool is_nothrow_t(void) const;
  bool is_null_pointer_type(void) const;
  bool is_ocl_ext_opaque_type(void) const;
  bool is_ocl_image_1d_array_ro_type(void) const;
  bool is_ocl_image_1d_array_rw_type(void) const;
  bool is_ocl_image_1d_array_wo_type(void) const;
  bool is_ocl_image_1d_buffer_ro_type(void) const;
  bool is_ocl_image_1d_buffer_rw_type(void) const;
  bool is_ocl_image_1d_buffer_wo_type(void) const;
  bool is_ocl_image_1d_ro_type(void) const;
  bool is_ocl_image_1d_rw_type(void) const;
  bool is_ocl_image_1d_wo_type(void) const;
  bool is_ocl_image_2d_array_depth_ro_type(void) const;
  bool is_ocl_image_2d_array_depth_rw_type(void) const;
  bool is_ocl_image_2d_array_depth_wo_type(void) const;
  bool is_ocl_image_2d_array_msaa_depth_ro_type(void) const;
  bool is_ocl_image_2d_array_msaa_depth_rw_type(void) const;
  bool is_ocl_image_2d_array_msaa_depth_wo_type(void) const;
  bool is_ocl_image_2d_array_msaaro_type(void) const;
  bool is_ocl_image_2d_array_msaarw_type(void) const;
  bool is_ocl_image_2d_array_msaawo_type(void) const;
  bool is_ocl_image_2d_array_ro_type(void) const;
  bool is_ocl_image_2d_array_rw_type(void) const;
  bool is_ocl_image_2d_array_wo_type(void) const;
  bool is_ocl_image_2d_depth_ro_type(void) const;
  bool is_ocl_image_2d_depth_rw_type(void) const;
  bool is_ocl_image_2d_depth_wo_type(void) const;
  bool is_ocl_image_2d_msaa_depth_ro_type(void) const;
  bool is_ocl_image_2d_msaa_depth_rw_type(void) const;
  bool is_ocl_image_2d_msaa_depth_wo_type(void) const;
  bool is_ocl_image_2d_msaaro_type(void) const;
  bool is_ocl_image_2d_msaarw_type(void) const;
  bool is_ocl_image_2d_msaawo_type(void) const;
  bool is_ocl_image_2d_ro_type(void) const;
  bool is_ocl_image_2d_rw_type(void) const;
  bool is_ocl_image_2d_wo_type(void) const;
  bool is_ocl_image_3d_ro_type(void) const;
  bool is_ocl_image_3d_rw_type(void) const;
  bool is_ocl_image_3d_wo_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_dual_reference_streamin_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_payload_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_result_dual_reference_streamout_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_result_single_reference_streamout_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_result_type(void) const;
  bool is_ocl_intel_subgroup_avc_ime_single_reference_streamin_type(void) const;
  bool is_ocl_intel_subgroup_avc_mce_payload_type(void) const;
  bool is_ocl_intel_subgroup_avc_mce_result_type(void) const;
  bool is_ocl_intel_subgroup_avc_ref_payload_type(void) const;
  bool is_ocl_intel_subgroup_avc_ref_result_type(void) const;
  bool is_ocl_intel_subgroup_avc_sic_payload_type(void) const;
  bool is_ocl_intel_subgroup_avc_sic_result_type(void) const;
  bool is_ocl_intel_subgroup_avc_type(void) const;
  bool is_obj_carc_bridgable_type(void) const;
  std::optional<bool> is_obj_carc_implicitly_unretained_type(void) const;
  bool is_obj_c_boxable_record_type(void) const;
  bool is_obj_c_builtin_type(void) const;
  bool is_obj_c_class_or_class_kind_of_type(void) const;
  bool is_obj_c_class_type(void) const;
  bool is_obj_c_id_type(void) const;
  bool is_obj_c_independent_class_type(void) const;
  bool is_obj_c_indirect_lifetime_type(void) const;
  bool is_obj_c_inert_unsafe_unretained_type(void) const;
  bool is_obj_c_lifetime_type(void) const;
  bool is_obj_cns_object_type(void) const;
  bool is_obj_c_object_or_interface_type(void) const;
  bool is_obj_c_object_pointer_type(void) const;
  bool is_obj_c_object_type(void) const;
  bool is_obj_c_qualified_class_type(void) const;
  bool is_obj_c_qualified_id_type(void) const;
  bool is_obj_c_qualified_interface_type(void) const;
  bool is_obj_c_retainable_type(void) const;
  bool is_obj_c_sel_type(void) const;
  bool is_object_pointer_type(void) const;
  bool is_object_type(void) const;
  bool is_open_cl_specific_type(void) const;
  bool is_overloadable_type(void) const;
  bool is_pipe_type(void) const;
  bool is_placeholder_type(void) const;
  bool is_pointer_type(void) const;
  bool is_promotable_integer_type(void) const;
  bool is_queue_t(void) const;
  bool is_r_value_reference_type(void) const;
  bool is_real_floating_type(void) const;
  bool is_real_type(void) const;
  bool is_record_type(void) const;
  bool is_reference_type(void) const;
  bool is_reserve_idt(void) const;
  bool is_sampler_t(void) const;
  bool is_saturated_fixed_point_type(void) const;
  bool is_scalar_type(void) const;
  bool is_scoped_enumeral_type(void) const;
  bool is_signed_fixed_point_type(void) const;
  bool is_signed_integer_or_enumeration_type(void) const;
  bool is_signed_integer_type(void) const;
  bool is_sizeless_builtin_type(void) const;
  bool is_sizeless_type(void) const;
  bool is_specifier_type(void) const;
  std::optional<bool> is_standard_layout_type(void) const;
  bool is_std_byte_type(void) const;
  std::optional<bool> is_structural_type(void) const;
  bool is_structure_or_class_type(void) const;
  bool is_structure_type(void) const;
  bool is_template_type_parm_type(void) const;
  bool is_typedef_name_type(void) const;
  bool is_undeduced_auto_type(void) const;
  bool is_undeduced_type(void) const;
  bool is_union_type(void) const;
  bool is_unsaturated_fixed_point_type(void) const;
  bool is_unscoped_enumeration_type(void) const;
  bool is_unsigned_fixed_point_type(void) const;
  bool is_unsigned_integer_or_enumeration_type(void) const;
  bool is_unsigned_integer_type(void) const;
  bool is_vlst_builtin_type(void) const;
  bool is_variable_array_type(void) const;
  bool is_variably_modified_type(void) const;
  bool is_vector_type(void) const;
  bool is_visibility_explicit(void) const;
  bool is_void_pointer_type(void) const;
  bool is_void_type(void) const;
  bool is_wide_character_type(void) const;
  Type ignore_parentheses(void) const;
  LangAS address_space(void) const;
  Type atomic_unqualified_type(void) const;
  Type canonical_type(void) const;
  Type desugared_type(void) const;
  Type local_unqualified_type(void) const;
  Type non_l_value_expression_type(void) const;
  Type non_pack_expansion_type(void) const;
  Type non_reference_type(void) const;
  Type single_step_desugared_type(void) const;
  bool has_address_space(void) const;
  bool has_local_non_fast_qualifiers(void) const;
  bool has_local_qualifiers(void) const;
  bool has_non_trivial_obj_c_lifetime(void) const;
  bool has_non_trivial_to_primitive_copy_c_union(void) const;
  bool has_non_trivial_to_primitive_default_initialize_c_union(void) const;
  bool has_non_trivial_to_primitive_destruct_c_union(void) const;
  bool has_qualifiers(void) const;
  bool has_strong_or_weak_obj_c_lifetime(void) const;
  bool is_c_forbidden_l_value_type(void) const;
  bool is_cxx11_pod_type(void) const;
  bool is_cxx98_pod_type(void) const;
  bool is_canonical(void) const;
  bool is_canonical_as_parameter(void) const;
  bool is_const_qualified(void) const;
  bool is_constant(void) const;
  QualTypeDestructionKind is_destructed_type(void) const;
  bool is_local_const_qualified(void) const;
  bool is_local_restrict_qualified(void) const;
  bool is_local_volatile_qualified(void) const;
  QualTypePrimitiveCopyKind is_non_trivial_to_primitive_copy(void) const;
  QualTypePrimitiveDefaultInitializeKind is_non_trivial_to_primitive_default_initialize(void) const;
  QualTypePrimitiveCopyKind is_non_trivial_to_primitive_destructive_move(void) const;
  bool is_non_weak_in_mrr_with_obj_c_weak(void) const;
  bool is_null(void) const;
  bool is_obj_cgc_strong(void) const;
  bool is_obj_cgc_weak(void) const;
  bool is_pod_type(void) const;
  bool is_restrict_qualified(void) const;
  bool is_trivial_type(void) const;
  bool is_trivially_copyable_type(void) const;
  bool is_volatile_qualified(void) const;
  bool may_be_dynamic_class(void) const;
  bool may_be_not_dynamic_class(void) const;
  Type strip_obj_c_kind_of_type(void) const;
  Type with_const(void) const;
  Type with_restrict(void) const;
  Type with_volatile(void) const;
  Type without_local_fast_qualifiers(void) const;
};

using TemplateTypeParmTypeRange = DerivedEntityRange<TypeIterator, TemplateTypeParmType>;
using TemplateTypeParmTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateTypeParmType>;
class TemplateTypeParmType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TemplateTypeParmTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateTypeParmTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateTypeParmType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::TEMPLATE_TYPE_PARM;
  }

  static std::optional<TemplateTypeParmType> from(const TokenContext &c);
  static std::optional<TemplateTypeParmType> from(const Type &parent);

  inline static std::optional<TemplateTypeParmType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TemplateTypeParmType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  std::optional<TemplateTypeParmDecl> declaration(void) const;
  bool is_parameter_pack(void) const;
  bool is_sugared(void) const;
};

using TemplateSpecializationTypeRange = DerivedEntityRange<TypeIterator, TemplateSpecializationType>;
using TemplateSpecializationTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateSpecializationType>;
class TemplateSpecializationType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TemplateSpecializationTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateSpecializationTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateSpecializationType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::TEMPLATE_SPECIALIZATION;
  }

  static std::optional<TemplateSpecializationType> from(const TokenContext &c);
  static std::optional<TemplateSpecializationType> from(const Type &parent);

  inline static std::optional<TemplateSpecializationType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TemplateSpecializationType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  std::optional<Type> aliased_type(void) const;
  bool is_current_instantiation(void) const;
  bool is_sugared(void) const;
  bool is_type_alias(void) const;
  std::vector<TemplateArgument> template_arguments(void) const;
};

using TagTypeRange = DerivedEntityRange<TypeIterator, TagType>;
using TagTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TagType>;
class TagType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TagTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TagTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TagType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<TagType> from(const TokenContext &c);
  static std::optional<TagType> from(const Type &parent);

  inline static std::optional<TagType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TagType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  TagDecl declaration(void) const;
  bool is_being_defined(void) const;
};

using RecordTypeRange = DerivedEntityRange<TypeIterator, RecordType>;
using RecordTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, RecordType>;
class RecordType : public TagType {
 private:
  friend class FragmentImpl;
  friend class TagType;
  friend class Type;
 public:
  inline static RecordTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RecordTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RecordType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::RECORD;
  }

  static std::optional<RecordType> from(const TokenContext &c);
  static std::optional<RecordType> from(const TagType &parent);

  inline static std::optional<RecordType> from(const std::optional<TagType> &parent) {
    if (parent) {
      return RecordType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecordType> from(const Type &parent);

  inline static std::optional<RecordType> from(const std::optional<Type> &parent) {
    if (parent) {
      return RecordType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool has_const_fields(void) const;
  bool is_sugared(void) const;
};

using EnumTypeRange = DerivedEntityRange<TypeIterator, EnumType>;
using EnumTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnumType>;
class EnumType : public TagType {
 private:
  friend class FragmentImpl;
  friend class TagType;
  friend class Type;
 public:
  inline static EnumTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnumTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnumType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::ENUM;
  }

  static std::optional<EnumType> from(const TokenContext &c);
  static std::optional<EnumType> from(const TagType &parent);

  inline static std::optional<EnumType> from(const std::optional<TagType> &parent) {
    if (parent) {
      return EnumType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumType> from(const Type &parent);

  inline static std::optional<EnumType> from(const std::optional<Type> &parent) {
    if (parent) {
      return EnumType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using SubstTemplateTypeParmTypeRange = DerivedEntityRange<TypeIterator, SubstTemplateTypeParmType>;
using SubstTemplateTypeParmTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, SubstTemplateTypeParmType>;
class SubstTemplateTypeParmType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static SubstTemplateTypeParmTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SubstTemplateTypeParmTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SubstTemplateTypeParmType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::SUBST_TEMPLATE_TYPE_PARM;
  }

  static std::optional<SubstTemplateTypeParmType> from(const TokenContext &c);
  static std::optional<SubstTemplateTypeParmType> from(const Type &parent);

  inline static std::optional<SubstTemplateTypeParmType> from(const std::optional<Type> &parent) {
    if (parent) {
      return SubstTemplateTypeParmType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  TemplateTypeParmType replaced_parameter(void) const;
  Type replacement_type(void) const;
  bool is_sugared(void) const;
};

using SubstTemplateTypeParmPackTypeRange = DerivedEntityRange<TypeIterator, SubstTemplateTypeParmPackType>;
using SubstTemplateTypeParmPackTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, SubstTemplateTypeParmPackType>;
class SubstTemplateTypeParmPackType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static SubstTemplateTypeParmPackTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SubstTemplateTypeParmPackTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SubstTemplateTypeParmPackType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::SUBST_TEMPLATE_TYPE_PARM_PACK;
  }

  static std::optional<SubstTemplateTypeParmPackType> from(const TokenContext &c);
  static std::optional<SubstTemplateTypeParmPackType> from(const Type &parent);

  inline static std::optional<SubstTemplateTypeParmPackType> from(const std::optional<Type> &parent) {
    if (parent) {
      return SubstTemplateTypeParmPackType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  TemplateTypeParmType replaced_parameter(void) const;
  bool is_sugared(void) const;
};

using ReferenceTypeRange = DerivedEntityRange<TypeIterator, ReferenceType>;
using ReferenceTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReferenceType>;
class ReferenceType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ReferenceTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReferenceTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReferenceType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<ReferenceType> from(const TokenContext &c);
  static std::optional<ReferenceType> from(const Type &parent);

  inline static std::optional<ReferenceType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ReferenceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type pointee_type_as_written(void) const;
  bool is_inner_reference(void) const;
  bool is_spelled_as_l_value(void) const;
};

using RValueReferenceTypeRange = DerivedEntityRange<TypeIterator, RValueReferenceType>;
using RValueReferenceTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, RValueReferenceType>;
class RValueReferenceType : public ReferenceType {
 private:
  friend class FragmentImpl;
  friend class ReferenceType;
  friend class Type;
 public:
  inline static RValueReferenceTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RValueReferenceTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RValueReferenceType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::R_VALUE_REFERENCE;
  }

  static std::optional<RValueReferenceType> from(const TokenContext &c);
  static std::optional<RValueReferenceType> from(const ReferenceType &parent);

  inline static std::optional<RValueReferenceType> from(const std::optional<ReferenceType> &parent) {
    if (parent) {
      return RValueReferenceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RValueReferenceType> from(const Type &parent);

  inline static std::optional<RValueReferenceType> from(const std::optional<Type> &parent) {
    if (parent) {
      return RValueReferenceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using LValueReferenceTypeRange = DerivedEntityRange<TypeIterator, LValueReferenceType>;
using LValueReferenceTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, LValueReferenceType>;
class LValueReferenceType : public ReferenceType {
 private:
  friend class FragmentImpl;
  friend class ReferenceType;
  friend class Type;
 public:
  inline static LValueReferenceTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LValueReferenceTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LValueReferenceType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::L_VALUE_REFERENCE;
  }

  static std::optional<LValueReferenceType> from(const TokenContext &c);
  static std::optional<LValueReferenceType> from(const ReferenceType &parent);

  inline static std::optional<LValueReferenceType> from(const std::optional<ReferenceType> &parent) {
    if (parent) {
      return LValueReferenceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LValueReferenceType> from(const Type &parent);

  inline static std::optional<LValueReferenceType> from(const std::optional<Type> &parent) {
    if (parent) {
      return LValueReferenceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using PointerTypeRange = DerivedEntityRange<TypeIterator, PointerType>;
using PointerTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, PointerType>;
class PointerType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static PointerTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PointerTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PointerType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::POINTER;
  }

  static std::optional<PointerType> from(const TokenContext &c);
  static std::optional<PointerType> from(const Type &parent);

  inline static std::optional<PointerType> from(const std::optional<Type> &parent) {
    if (parent) {
      return PointerType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using PipeTypeRange = DerivedEntityRange<TypeIterator, PipeType>;
using PipeTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, PipeType>;
class PipeType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static PipeTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PipeTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PipeType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::PIPE;
  }

  static std::optional<PipeType> from(const TokenContext &c);
  static std::optional<PipeType> from(const Type &parent);

  inline static std::optional<PipeType> from(const std::optional<Type> &parent) {
    if (parent) {
      return PipeType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type element_type(void) const;
  bool is_read_only(void) const;
  bool is_sugared(void) const;
};

using ParenTypeRange = DerivedEntityRange<TypeIterator, ParenType>;
using ParenTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParenType>;
class ParenType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ParenTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParenTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParenType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::PAREN;
  }

  static std::optional<ParenType> from(const TokenContext &c);
  static std::optional<ParenType> from(const Type &parent);

  inline static std::optional<ParenType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ParenType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type inner_type(void) const;
  bool is_sugared(void) const;
};

using PackExpansionTypeRange = DerivedEntityRange<TypeIterator, PackExpansionType>;
using PackExpansionTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, PackExpansionType>;
class PackExpansionType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static PackExpansionTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PackExpansionTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PackExpansionType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::PACK_EXPANSION;
  }

  static std::optional<PackExpansionType> from(const TokenContext &c);
  static std::optional<PackExpansionType> from(const Type &parent);

  inline static std::optional<PackExpansionType> from(const std::optional<Type> &parent) {
    if (parent) {
      return PackExpansionType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  std::optional<unsigned> num_expansions(void) const;
  Type pattern(void) const;
  bool is_sugared(void) const;
};

using ObjCTypeParamTypeRange = DerivedEntityRange<TypeIterator, ObjCTypeParamType>;
using ObjCTypeParamTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCTypeParamType>;
class ObjCTypeParamType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ObjCTypeParamTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCTypeParamTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCTypeParamType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::OBJ_C_TYPE_PARAM;
  }

  static std::optional<ObjCTypeParamType> from(const TokenContext &c);
  static std::optional<ObjCTypeParamType> from(const Type &parent);

  inline static std::optional<ObjCTypeParamType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ObjCTypeParamType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  ObjCTypeParamDecl declaration(void) const;
  bool is_sugared(void) const;
};

using ObjCObjectTypeRange = DerivedEntityRange<TypeIterator, ObjCObjectType>;
using ObjCObjectTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCObjectType>;
class ObjCObjectType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ObjCObjectTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCObjectTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCObjectType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::OBJ_C_OBJECT;
  }

  static std::optional<ObjCObjectType> from(const TokenContext &c);
  static std::optional<ObjCObjectType> from(const Type &parent);

  inline static std::optional<ObjCObjectType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ObjCObjectType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type base_type(void) const;
  ObjCInterfaceDecl interface(void) const;
  std::optional<Type> super_class_type(void) const;
  std::vector<Type> type_arguments(void) const;
  std::vector<Type> type_arguments_as_written(void) const;
  bool is_kind_of_type(void) const;
  bool is_kind_of_type_as_written(void) const;
  bool is_obj_c_class(void) const;
  bool is_obj_c_id(void) const;
  bool is_obj_c_qualified_class(void) const;
  bool is_obj_c_qualified_id(void) const;
  bool is_obj_c_unqualified_class(void) const;
  bool is_obj_c_unqualified_id(void) const;
  bool is_obj_c_unqualified_id_or_class(void) const;
  bool is_specialized(void) const;
  bool is_specialized_as_written(void) const;
  bool is_sugared(void) const;
  bool is_unspecialized(void) const;
  bool is_unspecialized_as_written(void) const;
  Type strip_obj_c_kind_of_type_and_qualifiers(void) const;
};

using ObjCInterfaceTypeRange = DerivedEntityRange<TypeIterator, ObjCInterfaceType>;
using ObjCInterfaceTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCInterfaceType>;
class ObjCInterfaceType : public ObjCObjectType {
 private:
  friend class FragmentImpl;
  friend class ObjCObjectType;
  friend class Type;
 public:
  inline static ObjCInterfaceTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCInterfaceTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCInterfaceType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::OBJ_C_INTERFACE;
  }

  static std::optional<ObjCInterfaceType> from(const TokenContext &c);
  static std::optional<ObjCInterfaceType> from(const ObjCObjectType &parent);

  inline static std::optional<ObjCInterfaceType> from(const std::optional<ObjCObjectType> &parent) {
    if (parent) {
      return ObjCInterfaceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCInterfaceType> from(const Type &parent);

  inline static std::optional<ObjCInterfaceType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ObjCInterfaceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCInterfaceDecl declaration(void) const;
};

using ObjCObjectPointerTypeRange = DerivedEntityRange<TypeIterator, ObjCObjectPointerType>;
using ObjCObjectPointerTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCObjectPointerType>;
class ObjCObjectPointerType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ObjCObjectPointerTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCObjectPointerTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCObjectPointerType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::OBJ_C_OBJECT_POINTER;
  }

  static std::optional<ObjCObjectPointerType> from(const TokenContext &c);
  static std::optional<ObjCObjectPointerType> from(const Type &parent);

  inline static std::optional<ObjCObjectPointerType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ObjCObjectPointerType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  ObjCInterfaceDecl interface_declaration(void) const;
  ObjCInterfaceType interface_type(void) const;
  ObjCObjectType object_type(void) const;
  Type super_class_type(void) const;
  std::vector<Type> type_arguments(void) const;
  std::vector<Type> type_arguments_as_written(void) const;
  bool is_kind_of_type(void) const;
  bool is_obj_c_id_or_class_type(void) const;
  bool is_specialized(void) const;
  bool is_specialized_as_written(void) const;
  bool is_sugared(void) const;
  bool is_unspecialized(void) const;
  bool is_unspecialized_as_written(void) const;
  std::vector<ObjCProtocolDecl> qualifiers(void) const;
  ObjCObjectPointerType strip_obj_c_kind_of_type_and_qualifiers(void) const;
  std::vector<ObjCProtocolDecl> protocols(void) const;
};

using MemberPointerTypeRange = DerivedEntityRange<TypeIterator, MemberPointerType>;
using MemberPointerTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, MemberPointerType>;
class MemberPointerType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static MemberPointerTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MemberPointerTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MemberPointerType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::MEMBER_POINTER;
  }

  static std::optional<MemberPointerType> from(const TokenContext &c);
  static std::optional<MemberPointerType> from(const Type &parent);

  inline static std::optional<MemberPointerType> from(const std::optional<Type> &parent) {
    if (parent) {
      return MemberPointerType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type class_(void) const;
  CXXRecordDecl most_recent_cxx_record_declaration(void) const;
  bool is_member_data_pointer(void) const;
  bool is_member_function_pointer(void) const;
  bool is_sugared(void) const;
};

using MatrixTypeRange = DerivedEntityRange<TypeIterator, MatrixType>;
using MatrixTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, MatrixType>;
class MatrixType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static MatrixTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MatrixTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MatrixType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<MatrixType> from(const TokenContext &c);
  static std::optional<MatrixType> from(const Type &parent);

  inline static std::optional<MatrixType> from(const std::optional<Type> &parent) {
    if (parent) {
      return MatrixType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type element_type(void) const;
  bool is_sugared(void) const;
};

using DependentSizedMatrixTypeRange = DerivedEntityRange<TypeIterator, DependentSizedMatrixType>;
using DependentSizedMatrixTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentSizedMatrixType>;
class DependentSizedMatrixType : public MatrixType {
 private:
  friend class FragmentImpl;
  friend class MatrixType;
  friend class Type;
 public:
  inline static DependentSizedMatrixTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentSizedMatrixTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentSizedMatrixType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_SIZED_MATRIX;
  }

  static std::optional<DependentSizedMatrixType> from(const TokenContext &c);
  static std::optional<DependentSizedMatrixType> from(const MatrixType &parent);

  inline static std::optional<DependentSizedMatrixType> from(const std::optional<MatrixType> &parent) {
    if (parent) {
      return DependentSizedMatrixType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentSizedMatrixType> from(const Type &parent);

  inline static std::optional<DependentSizedMatrixType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentSizedMatrixType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token attribute_token(void) const;
  Expr column_expression(void) const;
  Expr row_expression(void) const;
};

using ConstantMatrixTypeRange = DerivedEntityRange<TypeIterator, ConstantMatrixType>;
using ConstantMatrixTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstantMatrixType>;
class ConstantMatrixType : public MatrixType {
 private:
  friend class FragmentImpl;
  friend class MatrixType;
  friend class Type;
 public:
  inline static ConstantMatrixTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstantMatrixTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstantMatrixType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::CONSTANT_MATRIX;
  }

  static std::optional<ConstantMatrixType> from(const TokenContext &c);
  static std::optional<ConstantMatrixType> from(const MatrixType &parent);

  inline static std::optional<ConstantMatrixType> from(const std::optional<MatrixType> &parent) {
    if (parent) {
      return ConstantMatrixType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstantMatrixType> from(const Type &parent);

  inline static std::optional<ConstantMatrixType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ConstantMatrixType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using MacroQualifiedTypeRange = DerivedEntityRange<TypeIterator, MacroQualifiedType>;
using MacroQualifiedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, MacroQualifiedType>;
class MacroQualifiedType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static MacroQualifiedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MacroQualifiedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MacroQualifiedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::MACRO_QUALIFIED;
  }

  static std::optional<MacroQualifiedType> from(const TokenContext &c);
  static std::optional<MacroQualifiedType> from(const Type &parent);

  inline static std::optional<MacroQualifiedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return MacroQualifiedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type modified_type(void) const;
  Type underlying_type(void) const;
  bool is_sugared(void) const;
};

using InjectedClassNameTypeRange = DerivedEntityRange<TypeIterator, InjectedClassNameType>;
using InjectedClassNameTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, InjectedClassNameType>;
class InjectedClassNameType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static InjectedClassNameTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InjectedClassNameTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InjectedClassNameType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::INJECTED_CLASS_NAME;
  }

  static std::optional<InjectedClassNameType> from(const TokenContext &c);
  static std::optional<InjectedClassNameType> from(const Type &parent);

  inline static std::optional<InjectedClassNameType> from(const std::optional<Type> &parent) {
    if (parent) {
      return InjectedClassNameType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  CXXRecordDecl declaration(void) const;
  Type injected_specialization_type(void) const;
  TemplateSpecializationType injected_tst(void) const;
  bool is_sugared(void) const;
};

using FunctionTypeRange = DerivedEntityRange<TypeIterator, FunctionType>;
using FunctionTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionType>;
class FunctionType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static FunctionTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<FunctionType> from(const TokenContext &c);
  static std::optional<FunctionType> from(const Type &parent);

  inline static std::optional<FunctionType> from(const std::optional<Type> &parent) {
    if (parent) {
      return FunctionType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CallingConv call_conv(void) const;
  Type call_result_type(void) const;
  bool cmse_ns_call_attribute(void) const;
  bool has_reg_parm(void) const;
  bool no_return_attribute(void) const;
  Type return_type(void) const;
  bool is_const(void) const;
  bool is_restrict(void) const;
  bool is_volatile(void) const;
};

using FunctionProtoTypeRange = DerivedEntityRange<TypeIterator, FunctionProtoType>;
using FunctionProtoTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionProtoType>;
class FunctionProtoType : public FunctionType {
 private:
  friend class FragmentImpl;
  friend class FunctionType;
  friend class Type;
 public:
  inline static FunctionProtoTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionProtoTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionProtoType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::FUNCTION_PROTO;
  }

  static std::optional<FunctionProtoType> from(const TokenContext &c);
  static std::optional<FunctionProtoType> from(const FunctionType &parent);

  inline static std::optional<FunctionProtoType> from(const std::optional<FunctionType> &parent) {
    if (parent) {
      return FunctionProtoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionProtoType> from(const Type &parent);

  inline static std::optional<FunctionProtoType> from(const std::optional<Type> &parent) {
    if (parent) {
      return FunctionProtoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<CanThrowResult> can_throw(void) const;
  Type desugar(void) const;
  Token ellipsis_token(void) const;
  std::optional<FunctionDecl> exception_spec_declaration(void) const;
  std::optional<FunctionDecl> exception_spec_template(void) const;
  ExceptionSpecificationType exception_spec_type(void) const;
  std::optional<Expr> noexcept_expression(void) const;
  std::vector<Type> parameter_types(void) const;
  RefQualifierKind reference_qualifier(void) const;
  bool has_dependent_exception_spec(void) const;
  bool has_dynamic_exception_spec(void) const;
  bool has_exception_spec(void) const;
  bool has_ext_parameter_infos(void) const;
  bool has_instantiation_dependent_exception_spec(void) const;
  bool has_noexcept_exception_spec(void) const;
  bool has_trailing_return(void) const;
  std::optional<bool> is_nothrow(void) const;
  bool is_sugared(void) const;
  bool is_template_variadic(void) const;
  bool is_variadic(void) const;
  std::vector<Type> exception_types(void) const;
};

using FunctionNoProtoTypeRange = DerivedEntityRange<TypeIterator, FunctionNoProtoType>;
using FunctionNoProtoTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionNoProtoType>;
class FunctionNoProtoType : public FunctionType {
 private:
  friend class FragmentImpl;
  friend class FunctionType;
  friend class Type;
 public:
  inline static FunctionNoProtoTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionNoProtoTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionNoProtoType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::FUNCTION_NO_PROTO;
  }

  static std::optional<FunctionNoProtoType> from(const TokenContext &c);
  static std::optional<FunctionNoProtoType> from(const FunctionType &parent);

  inline static std::optional<FunctionNoProtoType> from(const std::optional<FunctionType> &parent) {
    if (parent) {
      return FunctionNoProtoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionNoProtoType> from(const Type &parent);

  inline static std::optional<FunctionNoProtoType> from(const std::optional<Type> &parent) {
    if (parent) {
      return FunctionNoProtoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using DependentVectorTypeRange = DerivedEntityRange<TypeIterator, DependentVectorType>;
using DependentVectorTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentVectorType>;
class DependentVectorType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DependentVectorTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentVectorTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentVectorType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_VECTOR;
  }

  static std::optional<DependentVectorType> from(const TokenContext &c);
  static std::optional<DependentVectorType> from(const Type &parent);

  inline static std::optional<DependentVectorType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentVectorType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Token attribute_token(void) const;
  Type element_type(void) const;
  Expr size_expression(void) const;
  VectorTypeVectorKind vector_kind(void) const;
  bool is_sugared(void) const;
};

using DependentSizedExtVectorTypeRange = DerivedEntityRange<TypeIterator, DependentSizedExtVectorType>;
using DependentSizedExtVectorTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentSizedExtVectorType>;
class DependentSizedExtVectorType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DependentSizedExtVectorTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentSizedExtVectorTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentSizedExtVectorType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_SIZED_EXT_VECTOR;
  }

  static std::optional<DependentSizedExtVectorType> from(const TokenContext &c);
  static std::optional<DependentSizedExtVectorType> from(const Type &parent);

  inline static std::optional<DependentSizedExtVectorType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentSizedExtVectorType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Token attribute_token(void) const;
  Type element_type(void) const;
  Expr size_expression(void) const;
  bool is_sugared(void) const;
};

using DependentBitIntTypeRange = DerivedEntityRange<TypeIterator, DependentBitIntType>;
using DependentBitIntTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentBitIntType>;
class DependentBitIntType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DependentBitIntTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentBitIntTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentBitIntType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_BIT_INT;
  }

  static std::optional<DependentBitIntType> from(const TokenContext &c);
  static std::optional<DependentBitIntType> from(const Type &parent);

  inline static std::optional<DependentBitIntType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentBitIntType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Expr num_bits_expression(void) const;
  bool is_signed(void) const;
  bool is_sugared(void) const;
  bool is_unsigned(void) const;
};

using DependentAddressSpaceTypeRange = DerivedEntityRange<TypeIterator, DependentAddressSpaceType>;
using DependentAddressSpaceTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentAddressSpaceType>;
class DependentAddressSpaceType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DependentAddressSpaceTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentAddressSpaceTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentAddressSpaceType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_ADDRESS_SPACE;
  }

  static std::optional<DependentAddressSpaceType> from(const TokenContext &c);
  static std::optional<DependentAddressSpaceType> from(const Type &parent);

  inline static std::optional<DependentAddressSpaceType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentAddressSpaceType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Expr address_space_expression(void) const;
  Token attribute_token(void) const;
  bool is_sugared(void) const;
};

using DeducedTypeRange = DerivedEntityRange<TypeIterator, DeducedType>;
using DeducedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeducedType>;
class DeducedType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DeducedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeducedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeducedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<DeducedType> from(const TokenContext &c);
  static std::optional<DeducedType> from(const Type &parent);

  inline static std::optional<DeducedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DeducedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  std::optional<Type> resolved_type(void) const;
  bool is_deduced(void) const;
  bool is_sugared(void) const;
};

using DeducedTemplateSpecializationTypeRange = DerivedEntityRange<TypeIterator, DeducedTemplateSpecializationType>;
using DeducedTemplateSpecializationTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeducedTemplateSpecializationType>;
class DeducedTemplateSpecializationType : public DeducedType {
 private:
  friend class FragmentImpl;
  friend class DeducedType;
  friend class Type;
 public:
  inline static DeducedTemplateSpecializationTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeducedTemplateSpecializationTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeducedTemplateSpecializationType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEDUCED_TEMPLATE_SPECIALIZATION;
  }

  static std::optional<DeducedTemplateSpecializationType> from(const TokenContext &c);
  static std::optional<DeducedTemplateSpecializationType> from(const DeducedType &parent);

  inline static std::optional<DeducedTemplateSpecializationType> from(const std::optional<DeducedType> &parent) {
    if (parent) {
      return DeducedTemplateSpecializationType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeducedTemplateSpecializationType> from(const Type &parent);

  inline static std::optional<DeducedTemplateSpecializationType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DeducedTemplateSpecializationType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using AutoTypeRange = DerivedEntityRange<TypeIterator, AutoType>;
using AutoTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, AutoType>;
class AutoType : public DeducedType {
 private:
  friend class FragmentImpl;
  friend class DeducedType;
  friend class Type;
 public:
  inline static AutoTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AutoTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AutoType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::AUTO;
  }

  static std::optional<AutoType> from(const TokenContext &c);
  static std::optional<AutoType> from(const DeducedType &parent);

  inline static std::optional<AutoType> from(const std::optional<DeducedType> &parent) {
    if (parent) {
      return AutoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AutoType> from(const Type &parent);

  inline static std::optional<AutoType> from(const std::optional<Type> &parent) {
    if (parent) {
      return AutoType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  AutoTypeKeyword keyword(void) const;
  std::vector<TemplateArgument> type_constraint_arguments(void) const;
  std::optional<ConceptDecl> type_constraint_concept(void) const;
  bool is_constrained(void) const;
  bool is_decltype_auto(void) const;
};

using DecltypeTypeRange = DerivedEntityRange<TypeIterator, DecltypeType>;
using DecltypeTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DecltypeType>;
class DecltypeType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static DecltypeTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DecltypeTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DecltypeType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DECLTYPE;
  }

  static std::optional<DecltypeType> from(const TokenContext &c);
  static std::optional<DecltypeType> from(const Type &parent);

  inline static std::optional<DecltypeType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DecltypeType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Expr underlying_expression(void) const;
  Type underlying_type(void) const;
  bool is_sugared(void) const;
};

using ComplexTypeRange = DerivedEntityRange<TypeIterator, ComplexType>;
using ComplexTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ComplexType>;
class ComplexType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ComplexTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ComplexTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ComplexType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::COMPLEX;
  }

  static std::optional<ComplexType> from(const TokenContext &c);
  static std::optional<ComplexType> from(const Type &parent);

  inline static std::optional<ComplexType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ComplexType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type element_type(void) const;
  bool is_sugared(void) const;
};

using BuiltinTypeRange = DerivedEntityRange<TypeIterator, BuiltinType>;
using BuiltinTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, BuiltinType>;
class BuiltinType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static BuiltinTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BuiltinTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BuiltinType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::BUILTIN;
  }

  static std::optional<BuiltinType> from(const TokenContext &c);
  static std::optional<BuiltinType> from(const Type &parent);

  inline static std::optional<BuiltinType> from(const std::optional<Type> &parent) {
    if (parent) {
      return BuiltinType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  BuiltinTypeKind builtin_kind(void) const;
  bool is_floating_point(void) const;
  bool is_integer(void) const;
  bool is_signed_integer(void) const;
  bool is_sugared(void) const;
  bool is_unsigned_integer(void) const;
};

using BlockPointerTypeRange = DerivedEntityRange<TypeIterator, BlockPointerType>;
using BlockPointerTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, BlockPointerType>;
class BlockPointerType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static BlockPointerTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BlockPointerTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BlockPointerType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::BLOCK_POINTER;
  }

  static std::optional<BlockPointerType> from(const TokenContext &c);
  static std::optional<BlockPointerType> from(const Type &parent);

  inline static std::optional<BlockPointerType> from(const std::optional<Type> &parent) {
    if (parent) {
      return BlockPointerType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using BitIntTypeRange = DerivedEntityRange<TypeIterator, BitIntType>;
using BitIntTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, BitIntType>;
class BitIntType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static BitIntTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BitIntTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BitIntType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::BIT_INT;
  }

  static std::optional<BitIntType> from(const TokenContext &c);
  static std::optional<BitIntType> from(const Type &parent);

  inline static std::optional<BitIntType> from(const std::optional<Type> &parent) {
    if (parent) {
      return BitIntType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_signed(void) const;
  bool is_sugared(void) const;
  bool is_unsigned(void) const;
};

using AttributedTypeRange = DerivedEntityRange<TypeIterator, AttributedType>;
using AttributedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, AttributedType>;
class AttributedType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static AttributedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AttributedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AttributedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::ATTRIBUTED;
  }

  static std::optional<AttributedType> from(const TokenContext &c);
  static std::optional<AttributedType> from(const Type &parent);

  inline static std::optional<AttributedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return AttributedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  AttrKind attribute_kind(void) const;
  Type equivalent_type(void) const;
  std::optional<NullabilityKind> immediate_nullability(void) const;
  Type modified_type(void) const;
  bool is_calling_conv(void) const;
  bool is_ms_type_spec(void) const;
  bool is_qualifier(void) const;
  bool is_sugared(void) const;
};

using AtomicTypeRange = DerivedEntityRange<TypeIterator, AtomicType>;
using AtomicTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, AtomicType>;
class AtomicType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static AtomicTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AtomicTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AtomicType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::ATOMIC;
  }

  static std::optional<AtomicType> from(const TokenContext &c);
  static std::optional<AtomicType> from(const Type &parent);

  inline static std::optional<AtomicType> from(const std::optional<Type> &parent) {
    if (parent) {
      return AtomicType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type value_type(void) const;
  bool is_sugared(void) const;
};

using ArrayTypeRange = DerivedEntityRange<TypeIterator, ArrayType>;
using ArrayTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArrayType>;
class ArrayType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static ArrayTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArrayTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArrayType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<ArrayType> from(const TokenContext &c);
  static std::optional<ArrayType> from(const Type &parent);

  inline static std::optional<ArrayType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type element_type(void) const;
  ArrayTypeArraySizeModifier size_modifier(void) const;
};

using VariableArrayTypeRange = DerivedEntityRange<TypeIterator, VariableArrayType>;
using VariableArrayTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, VariableArrayType>;
class VariableArrayType : public ArrayType {
 private:
  friend class FragmentImpl;
  friend class ArrayType;
  friend class Type;
 public:
  inline static VariableArrayTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VariableArrayTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VariableArrayType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::VARIABLE_ARRAY;
  }

  static std::optional<VariableArrayType> from(const TokenContext &c);
  static std::optional<VariableArrayType> from(const ArrayType &parent);

  inline static std::optional<VariableArrayType> from(const std::optional<ArrayType> &parent) {
    if (parent) {
      return VariableArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VariableArrayType> from(const Type &parent);

  inline static std::optional<VariableArrayType> from(const std::optional<Type> &parent) {
    if (parent) {
      return VariableArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  TokenRange brackets_range(void) const;
  Token l_bracket_token(void) const;
  Token r_bracket_token(void) const;
  Expr size_expression(void) const;
  bool is_sugared(void) const;
};

using IncompleteArrayTypeRange = DerivedEntityRange<TypeIterator, IncompleteArrayType>;
using IncompleteArrayTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, IncompleteArrayType>;
class IncompleteArrayType : public ArrayType {
 private:
  friend class FragmentImpl;
  friend class ArrayType;
  friend class Type;
 public:
  inline static IncompleteArrayTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IncompleteArrayTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IncompleteArrayType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::INCOMPLETE_ARRAY;
  }

  static std::optional<IncompleteArrayType> from(const TokenContext &c);
  static std::optional<IncompleteArrayType> from(const ArrayType &parent);

  inline static std::optional<IncompleteArrayType> from(const std::optional<ArrayType> &parent) {
    if (parent) {
      return IncompleteArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IncompleteArrayType> from(const Type &parent);

  inline static std::optional<IncompleteArrayType> from(const std::optional<Type> &parent) {
    if (parent) {
      return IncompleteArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using DependentSizedArrayTypeRange = DerivedEntityRange<TypeIterator, DependentSizedArrayType>;
using DependentSizedArrayTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentSizedArrayType>;
class DependentSizedArrayType : public ArrayType {
 private:
  friend class FragmentImpl;
  friend class ArrayType;
  friend class Type;
 public:
  inline static DependentSizedArrayTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentSizedArrayTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentSizedArrayType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_SIZED_ARRAY;
  }

  static std::optional<DependentSizedArrayType> from(const TokenContext &c);
  static std::optional<DependentSizedArrayType> from(const ArrayType &parent);

  inline static std::optional<DependentSizedArrayType> from(const std::optional<ArrayType> &parent) {
    if (parent) {
      return DependentSizedArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentSizedArrayType> from(const Type &parent);

  inline static std::optional<DependentSizedArrayType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentSizedArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  TokenRange brackets_range(void) const;
  Token l_bracket_token(void) const;
  Token r_bracket_token(void) const;
  Expr size_expression(void) const;
  bool is_sugared(void) const;
};

using ConstantArrayTypeRange = DerivedEntityRange<TypeIterator, ConstantArrayType>;
using ConstantArrayTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstantArrayType>;
class ConstantArrayType : public ArrayType {
 private:
  friend class FragmentImpl;
  friend class ArrayType;
  friend class Type;
 public:
  inline static ConstantArrayTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstantArrayTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstantArrayType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::CONSTANT_ARRAY;
  }

  static std::optional<ConstantArrayType> from(const TokenContext &c);
  static std::optional<ConstantArrayType> from(const ArrayType &parent);

  inline static std::optional<ConstantArrayType> from(const std::optional<ArrayType> &parent) {
    if (parent) {
      return ConstantArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstantArrayType> from(const Type &parent);

  inline static std::optional<ConstantArrayType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ConstantArrayType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  std::optional<Expr> size_expression(void) const;
  bool is_sugared(void) const;
};

using AdjustedTypeRange = DerivedEntityRange<TypeIterator, AdjustedType>;
using AdjustedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, AdjustedType>;
class AdjustedType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static AdjustedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AdjustedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AdjustedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::ADJUSTED;
  }

  static std::optional<AdjustedType> from(const TokenContext &c);
  static std::optional<AdjustedType> from(const Type &parent);

  inline static std::optional<AdjustedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return AdjustedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type resolved_type(void) const;
  Type original_type(void) const;
  bool is_sugared(void) const;
};

using DecayedTypeRange = DerivedEntityRange<TypeIterator, DecayedType>;
using DecayedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DecayedType>;
class DecayedType : public AdjustedType {
 private:
  friend class FragmentImpl;
  friend class AdjustedType;
  friend class Type;
 public:
  inline static DecayedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DecayedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DecayedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DECAYED;
  }

  static std::optional<DecayedType> from(const TokenContext &c);
  static std::optional<DecayedType> from(const AdjustedType &parent);

  inline static std::optional<DecayedType> from(const std::optional<AdjustedType> &parent) {
    if (parent) {
      return DecayedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DecayedType> from(const Type &parent);

  inline static std::optional<DecayedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DecayedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TypeWithKeywordRange = DerivedEntityRange<TypeIterator, TypeWithKeyword>;
using TypeWithKeywordContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeWithKeyword>;
class TypeWithKeyword : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TypeWithKeywordRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeWithKeywordContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeWithKeyword::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static std::optional<TypeWithKeyword> from(const TokenContext &c);
  static std::optional<TypeWithKeyword> from(const Type &parent);

  inline static std::optional<TypeWithKeyword> from(const std::optional<Type> &parent) {
    if (parent) {
      return TypeWithKeyword::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ElaboratedTypeKeyword keyword(void) const;
};

using ElaboratedTypeRange = DerivedEntityRange<TypeIterator, ElaboratedType>;
using ElaboratedTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ElaboratedType>;
class ElaboratedType : public TypeWithKeyword {
 private:
  friend class FragmentImpl;
  friend class TypeWithKeyword;
  friend class Type;
 public:
  inline static ElaboratedTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ElaboratedTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ElaboratedType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::ELABORATED;
  }

  static std::optional<ElaboratedType> from(const TokenContext &c);
  static std::optional<ElaboratedType> from(const TypeWithKeyword &parent);

  inline static std::optional<ElaboratedType> from(const std::optional<TypeWithKeyword> &parent) {
    if (parent) {
      return ElaboratedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ElaboratedType> from(const Type &parent);

  inline static std::optional<ElaboratedType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ElaboratedType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type named_type(void) const;
  std::optional<TagDecl> owned_tag_declaration(void) const;
  bool is_sugared(void) const;
};

using DependentTemplateSpecializationTypeRange = DerivedEntityRange<TypeIterator, DependentTemplateSpecializationType>;
using DependentTemplateSpecializationTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentTemplateSpecializationType>;
class DependentTemplateSpecializationType : public TypeWithKeyword {
 private:
  friend class FragmentImpl;
  friend class TypeWithKeyword;
  friend class Type;
 public:
  inline static DependentTemplateSpecializationTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentTemplateSpecializationTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentTemplateSpecializationType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_TEMPLATE_SPECIALIZATION;
  }

  static std::optional<DependentTemplateSpecializationType> from(const TokenContext &c);
  static std::optional<DependentTemplateSpecializationType> from(const TypeWithKeyword &parent);

  inline static std::optional<DependentTemplateSpecializationType> from(const std::optional<TypeWithKeyword> &parent) {
    if (parent) {
      return DependentTemplateSpecializationType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentTemplateSpecializationType> from(const Type &parent);

  inline static std::optional<DependentTemplateSpecializationType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentTemplateSpecializationType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
  std::vector<TemplateArgument> template_arguments(void) const;
};

using DependentNameTypeRange = DerivedEntityRange<TypeIterator, DependentNameType>;
using DependentNameTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentNameType>;
class DependentNameType : public TypeWithKeyword {
 private:
  friend class FragmentImpl;
  friend class TypeWithKeyword;
  friend class Type;
 public:
  inline static DependentNameTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentNameTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentNameType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::DEPENDENT_NAME;
  }

  static std::optional<DependentNameType> from(const TokenContext &c);
  static std::optional<DependentNameType> from(const TypeWithKeyword &parent);

  inline static std::optional<DependentNameType> from(const std::optional<TypeWithKeyword> &parent) {
    if (parent) {
      return DependentNameType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentNameType> from(const Type &parent);

  inline static std::optional<DependentNameType> from(const std::optional<Type> &parent) {
    if (parent) {
      return DependentNameType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  bool is_sugared(void) const;
};

using VectorTypeRange = DerivedEntityRange<TypeIterator, VectorType>;
using VectorTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, VectorType>;
class VectorType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static VectorTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VectorTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VectorType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::VECTOR;
  }

  static std::optional<VectorType> from(const TokenContext &c);
  static std::optional<VectorType> from(const Type &parent);

  inline static std::optional<VectorType> from(const std::optional<Type> &parent) {
    if (parent) {
      return VectorType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type element_type(void) const;
  VectorTypeVectorKind vector_kind(void) const;
  bool is_sugared(void) const;
};

using ExtVectorTypeRange = DerivedEntityRange<TypeIterator, ExtVectorType>;
using ExtVectorTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExtVectorType>;
class ExtVectorType : public VectorType {
 private:
  friend class FragmentImpl;
  friend class VectorType;
  friend class Type;
 public:
  inline static ExtVectorTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExtVectorTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExtVectorType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::EXT_VECTOR;
  }

  static std::optional<ExtVectorType> from(const TokenContext &c);
  static std::optional<ExtVectorType> from(const VectorType &parent);

  inline static std::optional<ExtVectorType> from(const std::optional<VectorType> &parent) {
    if (parent) {
      return ExtVectorType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExtVectorType> from(const Type &parent);

  inline static std::optional<ExtVectorType> from(const std::optional<Type> &parent) {
    if (parent) {
      return ExtVectorType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using UsingTypeRange = DerivedEntityRange<TypeIterator, UsingType>;
using UsingTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingType>;
class UsingType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static UsingTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::USING;
  }

  static std::optional<UsingType> from(const TokenContext &c);
  static std::optional<UsingType> from(const Type &parent);

  inline static std::optional<UsingType> from(const std::optional<Type> &parent) {
    if (parent) {
      return UsingType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  UsingShadowDecl found_declaration(void) const;
  Type underlying_type(void) const;
  bool is_sugared(void) const;
};

using UnresolvedUsingTypeRange = DerivedEntityRange<TypeIterator, UnresolvedUsingType>;
using UnresolvedUsingTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedUsingType>;
class UnresolvedUsingType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static UnresolvedUsingTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedUsingTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedUsingType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::UNRESOLVED_USING;
  }

  static std::optional<UnresolvedUsingType> from(const TokenContext &c);
  static std::optional<UnresolvedUsingType> from(const Type &parent);

  inline static std::optional<UnresolvedUsingType> from(const std::optional<Type> &parent) {
    if (parent) {
      return UnresolvedUsingType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  UnresolvedUsingTypenameDecl declaration(void) const;
  bool is_sugared(void) const;
};

using UnaryTransformTypeRange = DerivedEntityRange<TypeIterator, UnaryTransformType>;
using UnaryTransformTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnaryTransformType>;
class UnaryTransformType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static UnaryTransformTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnaryTransformTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnaryTransformType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::UNARY_TRANSFORM;
  }

  static std::optional<UnaryTransformType> from(const TokenContext &c);
  static std::optional<UnaryTransformType> from(const Type &parent);

  inline static std::optional<UnaryTransformType> from(const std::optional<Type> &parent) {
    if (parent) {
      return UnaryTransformType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type base_type(void) const;
  UnaryTransformTypeUTTKind utt_kind(void) const;
  Type underlying_type(void) const;
  bool is_sugared(void) const;
};

using TypedefTypeRange = DerivedEntityRange<TypeIterator, TypedefType>;
using TypedefTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypedefType>;
class TypedefType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TypedefTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypedefTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypedefType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::TYPEDEF;
  }

  static std::optional<TypedefType> from(const TokenContext &c);
  static std::optional<TypedefType> from(const Type &parent);

  inline static std::optional<TypedefType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TypedefType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  TypedefNameDecl declaration(void) const;
  bool is_sugared(void) const;
};

using TypeOfTypeRange = DerivedEntityRange<TypeIterator, TypeOfType>;
using TypeOfTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeOfType>;
class TypeOfType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TypeOfTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeOfTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeOfType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::TYPE_OF;
  }

  static std::optional<TypeOfType> from(const TokenContext &c);
  static std::optional<TypeOfType> from(const Type &parent);

  inline static std::optional<TypeOfType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TypeOfType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Type underlying_type(void) const;
  bool is_sugared(void) const;
};

using TypeOfExprTypeRange = DerivedEntityRange<TypeIterator, TypeOfExprType>;
using TypeOfExprTypeContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeOfExprType>;
class TypeOfExprType : public Type {
 private:
  friend class FragmentImpl;
  friend class Type;
 public:
  inline static TypeOfExprTypeRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeOfExprTypeContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeOfExprType::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr TypeKind static_kind(void) {
    return TypeKind::TYPE_OF_EXPR;
  }

  static std::optional<TypeOfExprType> from(const TokenContext &c);
  static std::optional<TypeOfExprType> from(const Type &parent);

  inline static std::optional<TypeOfExprType> from(const std::optional<Type> &parent) {
    if (parent) {
      return TypeOfExprType::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type desugar(void) const;
  Expr underlying_expression(void) const;
  bool is_sugared(void) const;
};

using StmtRange = DerivedEntityRange<StmtIterator, Stmt>;
using StmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, Stmt>;
using StmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, Stmt>;

class Stmt {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class Decl;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  Stmt(Stmt &&) noexcept = default;
  Stmt(const Stmt &) = default;
  Stmt &operator=(Stmt &&) noexcept = default;
  Stmt &operator=(const Stmt &) = default;

  inline Stmt(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  inline static std::optional<Stmt> from(const Stmt &self) {
    return self;
  }

  inline static std::optional<Stmt> from(const std::optional<Stmt> &self) {
    return self;
  }

  inline static std::optional<Stmt> from(const TokenContext &c) {
    return c.as_statement();
  }

  std::optional<Decl> parent_declaration(void) const;
  std::optional<Stmt> parent_statement(void) const;
  std::optional<Decl> referenced_declaration(void) const;
  EntityId id(void) const;
  UseRange<StmtUseSelector> uses(void) const;

 protected:
  static StmtIterator in_internal(const Fragment &fragment);

 public:
  inline static StmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Stmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static StmtContainingStmtRange containing(const Decl &decl);
  static StmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  Stmt ignore_containers(void) const;
  std::vector<Stmt> children(void) const;
  TokenRange tokens(void) const;
  StmtKind kind(void) const;
  Stmt strip_label_like_statements(void) const;
};

using SEHTryStmtRange = DerivedEntityRange<StmtIterator, SEHTryStmt>;
using SEHTryStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, SEHTryStmt>;
using SEHTryStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SEHTryStmt>;

class SEHTryStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SEHTryStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SEHTryStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SEHTryStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SEH_TRY_STMT;
  }

  static SEHTryStmtContainingStmtRange containing(const Decl &decl);
  static SEHTryStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SEHTryStmt> from(const TokenContext &c);
  static std::optional<SEHTryStmt> from(const Stmt &parent);

  inline static std::optional<SEHTryStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SEHTryStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  SEHExceptStmt except_handler(void) const;
  SEHFinallyStmt finally_handler(void) const;
  Stmt handler(void) const;
  bool is_cxx_try(void) const;
  CompoundStmt try_block(void) const;
  Token try_token(void) const;
};

using SEHLeaveStmtRange = DerivedEntityRange<StmtIterator, SEHLeaveStmt>;
using SEHLeaveStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, SEHLeaveStmt>;
using SEHLeaveStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SEHLeaveStmt>;

class SEHLeaveStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SEHLeaveStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SEHLeaveStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SEHLeaveStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SEH_LEAVE_STMT;
  }

  static SEHLeaveStmtContainingStmtRange containing(const Decl &decl);
  static SEHLeaveStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SEHLeaveStmt> from(const TokenContext &c);
  static std::optional<SEHLeaveStmt> from(const Stmt &parent);

  inline static std::optional<SEHLeaveStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SEHLeaveStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token leave_token(void) const;
};

using SEHFinallyStmtRange = DerivedEntityRange<StmtIterator, SEHFinallyStmt>;
using SEHFinallyStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, SEHFinallyStmt>;
using SEHFinallyStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SEHFinallyStmt>;

class SEHFinallyStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SEHFinallyStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SEHFinallyStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SEHFinallyStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SEH_FINALLY_STMT;
  }

  static SEHFinallyStmtContainingStmtRange containing(const Decl &decl);
  static SEHFinallyStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SEHFinallyStmt> from(const TokenContext &c);
  static std::optional<SEHFinallyStmt> from(const Stmt &parent);

  inline static std::optional<SEHFinallyStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SEHFinallyStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CompoundStmt block(void) const;
  Token finally_token(void) const;
};

using SEHExceptStmtRange = DerivedEntityRange<StmtIterator, SEHExceptStmt>;
using SEHExceptStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, SEHExceptStmt>;
using SEHExceptStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SEHExceptStmt>;

class SEHExceptStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SEHExceptStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SEHExceptStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SEHExceptStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SEH_EXCEPT_STMT;
  }

  static SEHExceptStmtContainingStmtRange containing(const Decl &decl);
  static SEHExceptStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SEHExceptStmt> from(const TokenContext &c);
  static std::optional<SEHExceptStmt> from(const Stmt &parent);

  inline static std::optional<SEHExceptStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SEHExceptStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CompoundStmt block(void) const;
  Token except_token(void) const;
  Expr filter_expression(void) const;
};

using ReturnStmtRange = DerivedEntityRange<StmtIterator, ReturnStmt>;
using ReturnStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ReturnStmt>;
using ReturnStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ReturnStmt>;

class ReturnStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ReturnStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ReturnStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ReturnStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::RETURN_STMT;
  }

  static ReturnStmtContainingStmtRange containing(const Decl &decl);
  static ReturnStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ReturnStmt> from(const TokenContext &c);
  static std::optional<ReturnStmt> from(const Stmt &parent);

  inline static std::optional<ReturnStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ReturnStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<VarDecl> nrvo_candidate(void) const;
  std::optional<Expr> return_value(void) const;
  Token return_token(void) const;
};

using ObjCForCollectionStmtRange = DerivedEntityRange<StmtIterator, ObjCForCollectionStmt>;
using ObjCForCollectionStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCForCollectionStmt>;
using ObjCForCollectionStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCForCollectionStmt>;

class ObjCForCollectionStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCForCollectionStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCForCollectionStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCForCollectionStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_FOR_COLLECTION_STMT;
  }

  static ObjCForCollectionStmtContainingStmtRange containing(const Decl &decl);
  static ObjCForCollectionStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCForCollectionStmt> from(const TokenContext &c);
  static std::optional<ObjCForCollectionStmt> from(const Stmt &parent);

  inline static std::optional<ObjCForCollectionStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCForCollectionStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  Expr collection(void) const;
  Stmt element(void) const;
  Token for_token(void) const;
  Token r_paren_token(void) const;
};

using ObjCAutoreleasePoolStmtRange = DerivedEntityRange<StmtIterator, ObjCAutoreleasePoolStmt>;
using ObjCAutoreleasePoolStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAutoreleasePoolStmt>;
using ObjCAutoreleasePoolStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAutoreleasePoolStmt>;

class ObjCAutoreleasePoolStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAutoreleasePoolStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAutoreleasePoolStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAutoreleasePoolStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AUTORELEASE_POOL_STMT;
  }

  static ObjCAutoreleasePoolStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAutoreleasePoolStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAutoreleasePoolStmt> from(const TokenContext &c);
  static std::optional<ObjCAutoreleasePoolStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAutoreleasePoolStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAutoreleasePoolStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  Stmt sub_statement(void) const;
};

using ObjCAtTryStmtRange = DerivedEntityRange<StmtIterator, ObjCAtTryStmt>;
using ObjCAtTryStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtTryStmt>;
using ObjCAtTryStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAtTryStmt>;

class ObjCAtTryStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAtTryStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtTryStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtTryStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AT_TRY_STMT;
  }

  static ObjCAtTryStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAtTryStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtTryStmt> from(const TokenContext &c);
  static std::optional<ObjCAtTryStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAtTryStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAtTryStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_try_token(void) const;
  ObjCAtFinallyStmt finally_statement(void) const;
  Stmt try_body(void) const;
  std::vector<ObjCAtCatchStmt> catch_statements(void) const;
};

using ObjCAtThrowStmtRange = DerivedEntityRange<StmtIterator, ObjCAtThrowStmt>;
using ObjCAtThrowStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtThrowStmt>;
using ObjCAtThrowStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAtThrowStmt>;

class ObjCAtThrowStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAtThrowStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtThrowStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtThrowStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AT_THROW_STMT;
  }

  static ObjCAtThrowStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAtThrowStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtThrowStmt> from(const TokenContext &c);
  static std::optional<ObjCAtThrowStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAtThrowStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAtThrowStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr throw_expression(void) const;
  Token throw_token(void) const;
};

using ObjCAtSynchronizedStmtRange = DerivedEntityRange<StmtIterator, ObjCAtSynchronizedStmt>;
using ObjCAtSynchronizedStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtSynchronizedStmt>;
using ObjCAtSynchronizedStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAtSynchronizedStmt>;

class ObjCAtSynchronizedStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAtSynchronizedStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtSynchronizedStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtSynchronizedStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AT_SYNCHRONIZED_STMT;
  }

  static ObjCAtSynchronizedStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAtSynchronizedStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtSynchronizedStmt> from(const TokenContext &c);
  static std::optional<ObjCAtSynchronizedStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAtSynchronizedStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAtSynchronizedStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_synchronized_token(void) const;
  CompoundStmt synch_body(void) const;
  Expr synch_expression(void) const;
};

using ObjCAtFinallyStmtRange = DerivedEntityRange<StmtIterator, ObjCAtFinallyStmt>;
using ObjCAtFinallyStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtFinallyStmt>;
using ObjCAtFinallyStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAtFinallyStmt>;

class ObjCAtFinallyStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAtFinallyStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtFinallyStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtFinallyStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AT_FINALLY_STMT;
  }

  static ObjCAtFinallyStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAtFinallyStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtFinallyStmt> from(const TokenContext &c);
  static std::optional<ObjCAtFinallyStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAtFinallyStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAtFinallyStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_finally_token(void) const;
  Stmt finally_body(void) const;
};

using ObjCAtCatchStmtRange = DerivedEntityRange<StmtIterator, ObjCAtCatchStmt>;
using ObjCAtCatchStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtCatchStmt>;
using ObjCAtCatchStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAtCatchStmt>;

class ObjCAtCatchStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ObjCAtCatchStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtCatchStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtCatchStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AT_CATCH_STMT;
  }

  static ObjCAtCatchStmtContainingStmtRange containing(const Decl &decl);
  static ObjCAtCatchStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtCatchStmt> from(const TokenContext &c);
  static std::optional<ObjCAtCatchStmt> from(const Stmt &parent);

  inline static std::optional<ObjCAtCatchStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAtCatchStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_catch_token(void) const;
  Stmt catch_body(void) const;
  VarDecl catch_parameter_declaration(void) const;
  Token r_paren_token(void) const;
  bool has_ellipsis(void) const;
};

using OMPExecutableDirectiveRange = DerivedEntityRange<StmtIterator, OMPExecutableDirective>;
using OMPExecutableDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPExecutableDirective>;
using OMPExecutableDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPExecutableDirective>;

class OMPExecutableDirective : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static OMPExecutableDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPExecutableDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPExecutableDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPExecutableDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPExecutableDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPExecutableDirective> from(const TokenContext &c);
  static std::optional<OMPExecutableDirective> from(const Stmt &parent);

  inline static std::optional<OMPExecutableDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPExecutableDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt associated_statement(void) const;
  CapturedStmt innermost_captured_statement(void) const;
  Stmt raw_statement(void) const;
  Stmt structured_block(void) const;
  bool has_associated_statement(void) const;
  bool is_standalone_directive(void) const;
};

using OMPDispatchDirectiveRange = DerivedEntityRange<StmtIterator, OMPDispatchDirective>;
using OMPDispatchDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDispatchDirective>;
using OMPDispatchDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDispatchDirective>;

class OMPDispatchDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDispatchDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDispatchDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDispatchDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DISPATCH_DIRECTIVE;
  }

  static OMPDispatchDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDispatchDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDispatchDirective> from(const TokenContext &c);
  static std::optional<OMPDispatchDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDispatchDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDispatchDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDispatchDirective> from(const Stmt &parent);

  inline static std::optional<OMPDispatchDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDispatchDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token target_call_token(void) const;
};

using OMPDepobjDirectiveRange = DerivedEntityRange<StmtIterator, OMPDepobjDirective>;
using OMPDepobjDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDepobjDirective>;
using OMPDepobjDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDepobjDirective>;

class OMPDepobjDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDepobjDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDepobjDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDepobjDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DEPOBJ_DIRECTIVE;
  }

  static OMPDepobjDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDepobjDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDepobjDirective> from(const TokenContext &c);
  static std::optional<OMPDepobjDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDepobjDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDepobjDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDepobjDirective> from(const Stmt &parent);

  inline static std::optional<OMPDepobjDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDepobjDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPCriticalDirectiveRange = DerivedEntityRange<StmtIterator, OMPCriticalDirective>;
using OMPCriticalDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCriticalDirective>;
using OMPCriticalDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPCriticalDirective>;

class OMPCriticalDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPCriticalDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCriticalDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCriticalDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_CRITICAL_DIRECTIVE;
  }

  static OMPCriticalDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPCriticalDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPCriticalDirective> from(const TokenContext &c);
  static std::optional<OMPCriticalDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPCriticalDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPCriticalDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCriticalDirective> from(const Stmt &parent);

  inline static std::optional<OMPCriticalDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPCriticalDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPCancellationPointDirectiveRange = DerivedEntityRange<StmtIterator, OMPCancellationPointDirective>;
using OMPCancellationPointDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCancellationPointDirective>;
using OMPCancellationPointDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPCancellationPointDirective>;

class OMPCancellationPointDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPCancellationPointDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCancellationPointDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCancellationPointDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_CANCELLATION_POINT_DIRECTIVE;
  }

  static OMPCancellationPointDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPCancellationPointDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPCancellationPointDirective> from(const TokenContext &c);
  static std::optional<OMPCancellationPointDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPCancellationPointDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPCancellationPointDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCancellationPointDirective> from(const Stmt &parent);

  inline static std::optional<OMPCancellationPointDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPCancellationPointDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPCancelDirectiveRange = DerivedEntityRange<StmtIterator, OMPCancelDirective>;
using OMPCancelDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCancelDirective>;
using OMPCancelDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPCancelDirective>;

class OMPCancelDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPCancelDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCancelDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCancelDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_CANCEL_DIRECTIVE;
  }

  static OMPCancelDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPCancelDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPCancelDirective> from(const TokenContext &c);
  static std::optional<OMPCancelDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPCancelDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPCancelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCancelDirective> from(const Stmt &parent);

  inline static std::optional<OMPCancelDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPCancelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPBarrierDirectiveRange = DerivedEntityRange<StmtIterator, OMPBarrierDirective>;
using OMPBarrierDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPBarrierDirective>;
using OMPBarrierDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPBarrierDirective>;

class OMPBarrierDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPBarrierDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPBarrierDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPBarrierDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_BARRIER_DIRECTIVE;
  }

  static OMPBarrierDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPBarrierDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPBarrierDirective> from(const TokenContext &c);
  static std::optional<OMPBarrierDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPBarrierDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPBarrierDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPBarrierDirective> from(const Stmt &parent);

  inline static std::optional<OMPBarrierDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPBarrierDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPAtomicDirectiveRange = DerivedEntityRange<StmtIterator, OMPAtomicDirective>;
using OMPAtomicDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPAtomicDirective>;
using OMPAtomicDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPAtomicDirective>;

class OMPAtomicDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPAtomicDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPAtomicDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPAtomicDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_ATOMIC_DIRECTIVE;
  }

  static OMPAtomicDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPAtomicDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPAtomicDirective> from(const TokenContext &c);
  static std::optional<OMPAtomicDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPAtomicDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPAtomicDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPAtomicDirective> from(const Stmt &parent);

  inline static std::optional<OMPAtomicDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPAtomicDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr expression(void) const;
  Expr update_expression(void) const;
  Expr v(void) const;
  Expr x(void) const;
  bool is_postfix_update(void) const;
  bool is_xlhs_in_rhs_part(void) const;
};

using OMPTeamsDirectiveRange = DerivedEntityRange<StmtIterator, OMPTeamsDirective>;
using OMPTeamsDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTeamsDirective>;
using OMPTeamsDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTeamsDirective>;

class OMPTeamsDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTeamsDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTeamsDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTeamsDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TEAMS_DIRECTIVE;
  }

  static OMPTeamsDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTeamsDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTeamsDirective> from(const TokenContext &c);
  static std::optional<OMPTeamsDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTeamsDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTeamsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDirective> from(const Stmt &parent);

  inline static std::optional<OMPTeamsDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTeamsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTaskyieldDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskyieldDirective>;
using OMPTaskyieldDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskyieldDirective>;
using OMPTaskyieldDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskyieldDirective>;

class OMPTaskyieldDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskyieldDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskyieldDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskyieldDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASKYIELD_DIRECTIVE;
  }

  static OMPTaskyieldDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskyieldDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskyieldDirective> from(const TokenContext &c);
  static std::optional<OMPTaskyieldDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskyieldDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskyieldDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskyieldDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskyieldDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskyieldDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTaskwaitDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskwaitDirective>;
using OMPTaskwaitDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskwaitDirective>;
using OMPTaskwaitDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskwaitDirective>;

class OMPTaskwaitDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskwaitDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskwaitDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskwaitDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASKWAIT_DIRECTIVE;
  }

  static OMPTaskwaitDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskwaitDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskwaitDirective> from(const TokenContext &c);
  static std::optional<OMPTaskwaitDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskwaitDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskwaitDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskwaitDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskwaitDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskwaitDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTaskgroupDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskgroupDirective>;
using OMPTaskgroupDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskgroupDirective>;
using OMPTaskgroupDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskgroupDirective>;

class OMPTaskgroupDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskgroupDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskgroupDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskgroupDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASKGROUP_DIRECTIVE;
  }

  static OMPTaskgroupDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskgroupDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskgroupDirective> from(const TokenContext &c);
  static std::optional<OMPTaskgroupDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskgroupDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskgroupDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskgroupDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskgroupDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskgroupDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr reduction_reference(void) const;
};

using OMPTaskDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskDirective>;
using OMPTaskDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskDirective>;
using OMPTaskDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskDirective>;

class OMPTaskDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASK_DIRECTIVE;
  }

  static OMPTaskDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskDirective> from(const TokenContext &c);
  static std::optional<OMPTaskDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_cancel(void) const;
};

using OMPTargetUpdateDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetUpdateDirective>;
using OMPTargetUpdateDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetUpdateDirective>;
using OMPTargetUpdateDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetUpdateDirective>;

class OMPTargetUpdateDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetUpdateDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetUpdateDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetUpdateDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_UPDATE_DIRECTIVE;
  }

  static OMPTargetUpdateDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetUpdateDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetUpdateDirective> from(const TokenContext &c);
  static std::optional<OMPTargetUpdateDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetUpdateDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetUpdateDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetUpdateDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetUpdateDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetUpdateDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetTeamsDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetTeamsDirective>;
using OMPTargetTeamsDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetTeamsDirective>;
using OMPTargetTeamsDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetTeamsDirective>;

class OMPTargetTeamsDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetTeamsDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetTeamsDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetTeamsDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_TEAMS_DIRECTIVE;
  }

  static OMPTargetTeamsDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetTeamsDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetTeamsDirective> from(const TokenContext &c);
  static std::optional<OMPTargetTeamsDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetTeamsDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetTeamsDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetTeamsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetParallelDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetParallelDirective>;
using OMPTargetParallelDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetParallelDirective>;
using OMPTargetParallelDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetParallelDirective>;

class OMPTargetParallelDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetParallelDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetParallelDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetParallelDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_PARALLEL_DIRECTIVE;
  }

  static OMPTargetParallelDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetParallelDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetParallelDirective> from(const TokenContext &c);
  static std::optional<OMPTargetParallelDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetParallelDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetParallelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetParallelDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetParallelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPTargetExitDataDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetExitDataDirective>;
using OMPTargetExitDataDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetExitDataDirective>;
using OMPTargetExitDataDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetExitDataDirective>;

class OMPTargetExitDataDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetExitDataDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetExitDataDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetExitDataDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_EXIT_DATA_DIRECTIVE;
  }

  static OMPTargetExitDataDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetExitDataDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetExitDataDirective> from(const TokenContext &c);
  static std::optional<OMPTargetExitDataDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetExitDataDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetExitDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetExitDataDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetExitDataDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetExitDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetEnterDataDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetEnterDataDirective>;
using OMPTargetEnterDataDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetEnterDataDirective>;
using OMPTargetEnterDataDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetEnterDataDirective>;

class OMPTargetEnterDataDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetEnterDataDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetEnterDataDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetEnterDataDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_ENTER_DATA_DIRECTIVE;
  }

  static OMPTargetEnterDataDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetEnterDataDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetEnterDataDirective> from(const TokenContext &c);
  static std::optional<OMPTargetEnterDataDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetEnterDataDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetEnterDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetEnterDataDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetEnterDataDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetEnterDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetDirective>;
using OMPTargetDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetDirective>;
using OMPTargetDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetDirective>;

class OMPTargetDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_DIRECTIVE;
  }

  static OMPTargetDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetDirective> from(const TokenContext &c);
  static std::optional<OMPTargetDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetDataDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetDataDirective>;
using OMPTargetDataDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetDataDirective>;
using OMPTargetDataDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetDataDirective>;

class OMPTargetDataDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetDataDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetDataDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetDataDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_DATA_DIRECTIVE;
  }

  static OMPTargetDataDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetDataDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetDataDirective> from(const TokenContext &c);
  static std::optional<OMPTargetDataDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetDataDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetDataDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetDataDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetDataDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPSingleDirectiveRange = DerivedEntityRange<StmtIterator, OMPSingleDirective>;
using OMPSingleDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPSingleDirective>;
using OMPSingleDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPSingleDirective>;

class OMPSingleDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPSingleDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPSingleDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPSingleDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_SINGLE_DIRECTIVE;
  }

  static OMPSingleDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPSingleDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPSingleDirective> from(const TokenContext &c);
  static std::optional<OMPSingleDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPSingleDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPSingleDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSingleDirective> from(const Stmt &parent);

  inline static std::optional<OMPSingleDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPSingleDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPSectionsDirectiveRange = DerivedEntityRange<StmtIterator, OMPSectionsDirective>;
using OMPSectionsDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPSectionsDirective>;
using OMPSectionsDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPSectionsDirective>;

class OMPSectionsDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPSectionsDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPSectionsDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPSectionsDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_SECTIONS_DIRECTIVE;
  }

  static OMPSectionsDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPSectionsDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPSectionsDirective> from(const TokenContext &c);
  static std::optional<OMPSectionsDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPSectionsDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPSectionsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSectionsDirective> from(const Stmt &parent);

  inline static std::optional<OMPSectionsDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPSectionsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPSectionDirectiveRange = DerivedEntityRange<StmtIterator, OMPSectionDirective>;
using OMPSectionDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPSectionDirective>;
using OMPSectionDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPSectionDirective>;

class OMPSectionDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPSectionDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPSectionDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPSectionDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_SECTION_DIRECTIVE;
  }

  static OMPSectionDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPSectionDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPSectionDirective> from(const TokenContext &c);
  static std::optional<OMPSectionDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPSectionDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPSectionDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSectionDirective> from(const Stmt &parent);

  inline static std::optional<OMPSectionDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPSectionDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_cancel(void) const;
};

using OMPScanDirectiveRange = DerivedEntityRange<StmtIterator, OMPScanDirective>;
using OMPScanDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPScanDirective>;
using OMPScanDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPScanDirective>;

class OMPScanDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPScanDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPScanDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPScanDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_SCAN_DIRECTIVE;
  }

  static OMPScanDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPScanDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPScanDirective> from(const TokenContext &c);
  static std::optional<OMPScanDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPScanDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPScanDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPScanDirective> from(const Stmt &parent);

  inline static std::optional<OMPScanDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPScanDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPParallelSectionsDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelSectionsDirective>;
using OMPParallelSectionsDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelSectionsDirective>;
using OMPParallelSectionsDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelSectionsDirective>;

class OMPParallelSectionsDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelSectionsDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelSectionsDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelSectionsDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_SECTIONS_DIRECTIVE;
  }

  static OMPParallelSectionsDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelSectionsDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelSectionsDirective> from(const TokenContext &c);
  static std::optional<OMPParallelSectionsDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelSectionsDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelSectionsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelSectionsDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelSectionsDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelSectionsDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPParallelMasterDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelMasterDirective>;
using OMPParallelMasterDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelMasterDirective>;
using OMPParallelMasterDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelMasterDirective>;

class OMPParallelMasterDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelMasterDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelMasterDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelMasterDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_MASTER_DIRECTIVE;
  }

  static OMPParallelMasterDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelMasterDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelMasterDirective> from(const TokenContext &c);
  static std::optional<OMPParallelMasterDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelMasterDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelMasterDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelMasterDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelMasterDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
};

using OMPParallelDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelDirective>;
using OMPParallelDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelDirective>;
using OMPParallelDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelDirective>;

class OMPParallelDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_DIRECTIVE;
  }

  static OMPParallelDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelDirective> from(const TokenContext &c);
  static std::optional<OMPParallelDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPOrderedDirectiveRange = DerivedEntityRange<StmtIterator, OMPOrderedDirective>;
using OMPOrderedDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPOrderedDirective>;
using OMPOrderedDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPOrderedDirective>;

class OMPOrderedDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPOrderedDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPOrderedDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPOrderedDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_ORDERED_DIRECTIVE;
  }

  static OMPOrderedDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPOrderedDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPOrderedDirective> from(const TokenContext &c);
  static std::optional<OMPOrderedDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPOrderedDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPOrderedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPOrderedDirective> from(const Stmt &parent);

  inline static std::optional<OMPOrderedDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPOrderedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPMetaDirectiveRange = DerivedEntityRange<StmtIterator, OMPMetaDirective>;
using OMPMetaDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPMetaDirective>;
using OMPMetaDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPMetaDirective>;

class OMPMetaDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPMetaDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPMetaDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPMetaDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_META_DIRECTIVE;
  }

  static OMPMetaDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPMetaDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPMetaDirective> from(const TokenContext &c);
  static std::optional<OMPMetaDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPMetaDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPMetaDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMetaDirective> from(const Stmt &parent);

  inline static std::optional<OMPMetaDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPMetaDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt if_statement(void) const;
};

using OMPMasterDirectiveRange = DerivedEntityRange<StmtIterator, OMPMasterDirective>;
using OMPMasterDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPMasterDirective>;
using OMPMasterDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPMasterDirective>;

class OMPMasterDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPMasterDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPMasterDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPMasterDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_MASTER_DIRECTIVE;
  }

  static OMPMasterDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPMasterDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPMasterDirective> from(const TokenContext &c);
  static std::optional<OMPMasterDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPMasterDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPMasterDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterDirective> from(const Stmt &parent);

  inline static std::optional<OMPMasterDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPMasterDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPMaskedDirectiveRange = DerivedEntityRange<StmtIterator, OMPMaskedDirective>;
using OMPMaskedDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPMaskedDirective>;
using OMPMaskedDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPMaskedDirective>;

class OMPMaskedDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPMaskedDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPMaskedDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPMaskedDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_MASKED_DIRECTIVE;
  }

  static OMPMaskedDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPMaskedDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPMaskedDirective> from(const TokenContext &c);
  static std::optional<OMPMaskedDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPMaskedDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPMaskedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMaskedDirective> from(const Stmt &parent);

  inline static std::optional<OMPMaskedDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPMaskedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPLoopBasedDirectiveRange = DerivedEntityRange<StmtIterator, OMPLoopBasedDirective>;
using OMPLoopBasedDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPLoopBasedDirective>;
using OMPLoopBasedDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPLoopBasedDirective>;

class OMPLoopBasedDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPLoopBasedDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPLoopBasedDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPLoopBasedDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPLoopBasedDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPLoopBasedDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPLoopBasedDirective> from(const TokenContext &c);
  static std::optional<OMPLoopBasedDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPLoopBasedDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPLoopBasedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPLoopBasedDirective> from(const Stmt &parent);

  inline static std::optional<OMPLoopBasedDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPLoopBasedDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPLoopTransformationDirectiveRange = DerivedEntityRange<StmtIterator, OMPLoopTransformationDirective>;
using OMPLoopTransformationDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPLoopTransformationDirective>;
using OMPLoopTransformationDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPLoopTransformationDirective>;

class OMPLoopTransformationDirective : public OMPLoopBasedDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPLoopTransformationDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPLoopTransformationDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPLoopTransformationDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPLoopTransformationDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPLoopTransformationDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPLoopTransformationDirective> from(const TokenContext &c);
  static std::optional<OMPLoopTransformationDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPLoopTransformationDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPLoopTransformationDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPLoopTransformationDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPLoopTransformationDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPLoopTransformationDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPLoopTransformationDirective> from(const Stmt &parent);

  inline static std::optional<OMPLoopTransformationDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPLoopTransformationDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt pre_initializers(void) const;
  Stmt transformed_statement(void) const;
};

using OMPUnrollDirectiveRange = DerivedEntityRange<StmtIterator, OMPUnrollDirective>;
using OMPUnrollDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPUnrollDirective>;
using OMPUnrollDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPUnrollDirective>;

class OMPUnrollDirective : public OMPLoopTransformationDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopTransformationDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPUnrollDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPUnrollDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPUnrollDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_UNROLL_DIRECTIVE;
  }

  static OMPUnrollDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPUnrollDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPUnrollDirective> from(const TokenContext &c);
  static std::optional<OMPUnrollDirective> from(const OMPLoopTransformationDirective &parent);

  inline static std::optional<OMPUnrollDirective> from(const std::optional<OMPLoopTransformationDirective> &parent) {
    if (parent) {
      return OMPUnrollDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPUnrollDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPUnrollDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPUnrollDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPUnrollDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPUnrollDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPUnrollDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPUnrollDirective> from(const Stmt &parent);

  inline static std::optional<OMPUnrollDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPUnrollDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTileDirectiveRange = DerivedEntityRange<StmtIterator, OMPTileDirective>;
using OMPTileDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTileDirective>;
using OMPTileDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTileDirective>;

class OMPTileDirective : public OMPLoopTransformationDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopTransformationDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTileDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTileDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTileDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TILE_DIRECTIVE;
  }

  static OMPTileDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTileDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTileDirective> from(const TokenContext &c);
  static std::optional<OMPTileDirective> from(const OMPLoopTransformationDirective &parent);

  inline static std::optional<OMPTileDirective> from(const std::optional<OMPLoopTransformationDirective> &parent) {
    if (parent) {
      return OMPTileDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTileDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTileDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTileDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTileDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTileDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTileDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTileDirective> from(const Stmt &parent);

  inline static std::optional<OMPTileDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTileDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPLoopDirectiveRange = DerivedEntityRange<StmtIterator, OMPLoopDirective>;
using OMPLoopDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPLoopDirective>;
using OMPLoopDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPLoopDirective>;

class OMPLoopDirective : public OMPLoopBasedDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPLoopDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPLoopDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPLoopDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPLoopDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPLoopDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPLoopDirective> from(const TokenContext &c);
  static std::optional<OMPLoopDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPLoopDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPLoopDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPLoopDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPLoopDirective> from(const Stmt &parent);

  inline static std::optional<OMPLoopDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> counters(void) const;
  std::vector<Expr> dependent_counters(void) const;
  std::vector<Expr> dependent_initializers(void) const;
  std::vector<Expr> finals(void) const;
  std::vector<Expr> finals_conditions(void) const;
  Stmt body(void) const;
  Expr calculate_last_iteration(void) const;
  Expr combined_condition(void) const;
  Expr combined_distance_condition(void) const;
  Expr combined_ensure_upper_bound(void) const;
  Expr combined_initializer(void) const;
  Expr combined_lower_bound_variable(void) const;
  Expr combined_next_lower_bound(void) const;
  Expr combined_next_upper_bound(void) const;
  Expr combined_parallel_for_in_distance_condition(void) const;
  Expr combined_upper_bound_variable(void) const;
  Expr condition(void) const;
  Expr distance_increment(void) const;
  Expr ensure_upper_bound(void) const;
  Expr increment(void) const;
  Expr initializer(void) const;
  Expr is_last_iteration_variable(void) const;
  Expr iteration_variable(void) const;
  Expr last_iteration(void) const;
  Expr lower_bound_variable(void) const;
  Expr next_lower_bound(void) const;
  Expr next_upper_bound(void) const;
  Expr num_iterations(void) const;
  Expr pre_condition(void) const;
  Stmt pre_initializers(void) const;
  Expr prev_ensure_upper_bound(void) const;
  Expr prev_lower_bound_variable(void) const;
  Expr prev_upper_bound_variable(void) const;
  Expr stride_variable(void) const;
  Expr upper_bound_variable(void) const;
  std::vector<Expr> initializers(void) const;
  std::vector<Expr> private_counters(void) const;
  std::vector<Expr> updates(void) const;
};

using OMPGenericLoopDirectiveRange = DerivedEntityRange<StmtIterator, OMPGenericLoopDirective>;
using OMPGenericLoopDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPGenericLoopDirective>;
using OMPGenericLoopDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPGenericLoopDirective>;

class OMPGenericLoopDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPGenericLoopDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPGenericLoopDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPGenericLoopDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_GENERIC_LOOP_DIRECTIVE;
  }

  static OMPGenericLoopDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPGenericLoopDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPGenericLoopDirective> from(const TokenContext &c);
  static std::optional<OMPGenericLoopDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPGenericLoopDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPGenericLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPGenericLoopDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPGenericLoopDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPGenericLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPGenericLoopDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPGenericLoopDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPGenericLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPGenericLoopDirective> from(const Stmt &parent);

  inline static std::optional<OMPGenericLoopDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPGenericLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPForSimdDirective>;
using OMPForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPForSimdDirective>;
using OMPForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPForSimdDirective>;

class OMPForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_FOR_SIMD_DIRECTIVE;
  }

  static OMPForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPForDirectiveRange = DerivedEntityRange<StmtIterator, OMPForDirective>;
using OMPForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPForDirective>;
using OMPForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPForDirective>;

class OMPForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_FOR_DIRECTIVE;
  }

  static OMPForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPForDirective> from(const TokenContext &c);
  static std::optional<OMPForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPForDirective> from(const Stmt &parent);

  inline static std::optional<OMPForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPDistributeSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPDistributeSimdDirective>;
using OMPDistributeSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDistributeSimdDirective>;
using OMPDistributeSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDistributeSimdDirective>;

class OMPDistributeSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDistributeSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDistributeSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDistributeSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DISTRIBUTE_SIMD_DIRECTIVE;
  }

  static OMPDistributeSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDistributeSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDistributeSimdDirective> from(const TokenContext &c);
  static std::optional<OMPDistributeSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPDistributeSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPDistributeSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDistributeSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPDistributeSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPDistributeParallelForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPDistributeParallelForSimdDirective>;
using OMPDistributeParallelForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDistributeParallelForSimdDirective>;
using OMPDistributeParallelForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDistributeParallelForSimdDirective>;

class OMPDistributeParallelForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDistributeParallelForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDistributeParallelForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDistributeParallelForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
  }

  static OMPDistributeParallelForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDistributeParallelForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDistributeParallelForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPDistributeParallelForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPDistributeParallelForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPDistributeParallelForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDistributeParallelForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPDistributeParallelForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPDistributeParallelForDirectiveRange = DerivedEntityRange<StmtIterator, OMPDistributeParallelForDirective>;
using OMPDistributeParallelForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDistributeParallelForDirective>;
using OMPDistributeParallelForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDistributeParallelForDirective>;

class OMPDistributeParallelForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDistributeParallelForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDistributeParallelForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDistributeParallelForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
  }

  static OMPDistributeParallelForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDistributeParallelForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDistributeParallelForDirective> from(const TokenContext &c);
  static std::optional<OMPDistributeParallelForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPDistributeParallelForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPDistributeParallelForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDistributeParallelForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeParallelForDirective> from(const Stmt &parent);

  inline static std::optional<OMPDistributeParallelForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPDistributeDirectiveRange = DerivedEntityRange<StmtIterator, OMPDistributeDirective>;
using OMPDistributeDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDistributeDirective>;
using OMPDistributeDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPDistributeDirective>;

class OMPDistributeDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPDistributeDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDistributeDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDistributeDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_DISTRIBUTE_DIRECTIVE;
  }

  static OMPDistributeDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPDistributeDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDistributeDirective> from(const TokenContext &c);
  static std::optional<OMPDistributeDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPDistributeDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPDistributeDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPDistributeDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDistributeDirective> from(const Stmt &parent);

  inline static std::optional<OMPDistributeDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTeamsDistributeSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTeamsDistributeSimdDirective>;
using OMPTeamsDistributeSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTeamsDistributeSimdDirective>;
using OMPTeamsDistributeSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTeamsDistributeSimdDirective>;

class OMPTeamsDistributeSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTeamsDistributeSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTeamsDistributeSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTeamsDistributeSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE;
  }

  static OMPTeamsDistributeSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTeamsDistributeSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTeamsDistributeSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTeamsDistributeSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTeamsDistributeSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTeamsDistributeSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTeamsDistributeSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTeamsDistributeSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTeamsDistributeParallelForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTeamsDistributeParallelForSimdDirective>;
using OMPTeamsDistributeParallelForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTeamsDistributeParallelForSimdDirective>;
using OMPTeamsDistributeParallelForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTeamsDistributeParallelForSimdDirective>;

class OMPTeamsDistributeParallelForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTeamsDistributeParallelForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTeamsDistributeParallelForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTeamsDistributeParallelForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
  }

  static OMPTeamsDistributeParallelForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTeamsDistributeParallelForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTeamsDistributeParallelForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTeamsDistributeParallelForDirectiveRange = DerivedEntityRange<StmtIterator, OMPTeamsDistributeParallelForDirective>;
using OMPTeamsDistributeParallelForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTeamsDistributeParallelForDirective>;
using OMPTeamsDistributeParallelForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTeamsDistributeParallelForDirective>;

class OMPTeamsDistributeParallelForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTeamsDistributeParallelForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTeamsDistributeParallelForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTeamsDistributeParallelForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
  }

  static OMPTeamsDistributeParallelForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTeamsDistributeParallelForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTeamsDistributeParallelForDirective> from(const TokenContext &c);
  static std::optional<OMPTeamsDistributeParallelForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTeamsDistributeParallelForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeParallelForDirective> from(const Stmt &parent);

  inline static std::optional<OMPTeamsDistributeParallelForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPTeamsDistributeDirectiveRange = DerivedEntityRange<StmtIterator, OMPTeamsDistributeDirective>;
using OMPTeamsDistributeDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTeamsDistributeDirective>;
using OMPTeamsDistributeDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTeamsDistributeDirective>;

class OMPTeamsDistributeDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTeamsDistributeDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTeamsDistributeDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTeamsDistributeDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TEAMS_DISTRIBUTE_DIRECTIVE;
  }

  static OMPTeamsDistributeDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTeamsDistributeDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTeamsDistributeDirective> from(const TokenContext &c);
  static std::optional<OMPTeamsDistributeDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTeamsDistributeDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTeamsDistributeDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTeamsDistributeDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTeamsDistributeDirective> from(const Stmt &parent);

  inline static std::optional<OMPTeamsDistributeDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTaskLoopSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskLoopSimdDirective>;
using OMPTaskLoopSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskLoopSimdDirective>;
using OMPTaskLoopSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskLoopSimdDirective>;

class OMPTaskLoopSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskLoopSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskLoopSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskLoopSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASK_LOOP_SIMD_DIRECTIVE;
  }

  static OMPTaskLoopSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskLoopSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskLoopSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTaskLoopSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTaskLoopSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTaskLoopSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskLoopSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskLoopSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTaskLoopDirectiveRange = DerivedEntityRange<StmtIterator, OMPTaskLoopDirective>;
using OMPTaskLoopDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTaskLoopDirective>;
using OMPTaskLoopDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTaskLoopDirective>;

class OMPTaskLoopDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTaskLoopDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTaskLoopDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTaskLoopDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TASK_LOOP_DIRECTIVE;
  }

  static OMPTaskLoopDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTaskLoopDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTaskLoopDirective> from(const TokenContext &c);
  static std::optional<OMPTaskLoopDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTaskLoopDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTaskLoopDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTaskLoopDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTaskLoopDirective> from(const Stmt &parent);

  inline static std::optional<OMPTaskLoopDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_cancel(void) const;
};

using OMPTargetTeamsDistributeSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetTeamsDistributeSimdDirective>;
using OMPTargetTeamsDistributeSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetTeamsDistributeSimdDirective>;
using OMPTargetTeamsDistributeSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetTeamsDistributeSimdDirective>;

class OMPTargetTeamsDistributeSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetTeamsDistributeSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetTeamsDistributeSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetTeamsDistributeSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE;
  }

  static OMPTargetTeamsDistributeSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetTeamsDistributeSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetTeamsDistributeSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetTeamsDistributeParallelForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetTeamsDistributeParallelForSimdDirective>;
using OMPTargetTeamsDistributeParallelForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetTeamsDistributeParallelForSimdDirective>;
using OMPTargetTeamsDistributeParallelForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetTeamsDistributeParallelForSimdDirective>;

class OMPTargetTeamsDistributeParallelForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetTeamsDistributeParallelForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetTeamsDistributeParallelForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetTeamsDistributeParallelForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE;
  }

  static OMPTargetTeamsDistributeParallelForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetTeamsDistributeParallelForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetTeamsDistributeParallelForDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetTeamsDistributeParallelForDirective>;
using OMPTargetTeamsDistributeParallelForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetTeamsDistributeParallelForDirective>;
using OMPTargetTeamsDistributeParallelForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetTeamsDistributeParallelForDirective>;

class OMPTargetTeamsDistributeParallelForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetTeamsDistributeParallelForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetTeamsDistributeParallelForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetTeamsDistributeParallelForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE;
  }

  static OMPTargetTeamsDistributeParallelForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetTeamsDistributeParallelForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const TokenContext &c);
  static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetTeamsDistributeParallelForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPTargetTeamsDistributeDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetTeamsDistributeDirective>;
using OMPTargetTeamsDistributeDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetTeamsDistributeDirective>;
using OMPTargetTeamsDistributeDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetTeamsDistributeDirective>;

class OMPTargetTeamsDistributeDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetTeamsDistributeDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetTeamsDistributeDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetTeamsDistributeDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE;
  }

  static OMPTargetTeamsDistributeDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetTeamsDistributeDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetTeamsDistributeDirective> from(const TokenContext &c);
  static std::optional<OMPTargetTeamsDistributeDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetTeamsDistributeDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetTeamsDistributeDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetTeamsDistributeDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetTeamsDistributeDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetSimdDirective>;
using OMPTargetSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetSimdDirective>;
using OMPTargetSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetSimdDirective>;

class OMPTargetSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_SIMD_DIRECTIVE;
  }

  static OMPTargetSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTargetSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetParallelForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetParallelForSimdDirective>;
using OMPTargetParallelForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetParallelForSimdDirective>;
using OMPTargetParallelForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetParallelForSimdDirective>;

class OMPTargetParallelForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetParallelForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetParallelForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetParallelForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE;
  }

  static OMPTargetParallelForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetParallelForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetParallelForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPTargetParallelForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetParallelForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetParallelForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetParallelForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetParallelForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPTargetParallelForDirectiveRange = DerivedEntityRange<StmtIterator, OMPTargetParallelForDirective>;
using OMPTargetParallelForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPTargetParallelForDirective>;
using OMPTargetParallelForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPTargetParallelForDirective>;

class OMPTargetParallelForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPTargetParallelForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPTargetParallelForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPTargetParallelForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_TARGET_PARALLEL_FOR_DIRECTIVE;
  }

  static OMPTargetParallelForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPTargetParallelForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPTargetParallelForDirective> from(const TokenContext &c);
  static std::optional<OMPTargetParallelForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPTargetParallelForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPTargetParallelForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPTargetParallelForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPTargetParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPTargetParallelForDirective> from(const Stmt &parent);

  inline static std::optional<OMPTargetParallelForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPTargetParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPSimdDirective>;
using OMPSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPSimdDirective>;
using OMPSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPSimdDirective>;

class OMPSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_SIMD_DIRECTIVE;
  }

  static OMPSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPSimdDirective> from(const TokenContext &c);
  static std::optional<OMPSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPParallelMasterTaskLoopSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelMasterTaskLoopSimdDirective>;
using OMPParallelMasterTaskLoopSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelMasterTaskLoopSimdDirective>;
using OMPParallelMasterTaskLoopSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelMasterTaskLoopSimdDirective>;

class OMPParallelMasterTaskLoopSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelMasterTaskLoopSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelMasterTaskLoopSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelMasterTaskLoopSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE;
  }

  static OMPParallelMasterTaskLoopSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelMasterTaskLoopSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const TokenContext &c);
  static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelMasterTaskLoopSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPParallelMasterTaskLoopDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelMasterTaskLoopDirective>;
using OMPParallelMasterTaskLoopDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelMasterTaskLoopDirective>;
using OMPParallelMasterTaskLoopDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelMasterTaskLoopDirective>;

class OMPParallelMasterTaskLoopDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelMasterTaskLoopDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelMasterTaskLoopDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelMasterTaskLoopDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE;
  }

  static OMPParallelMasterTaskLoopDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelMasterTaskLoopDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelMasterTaskLoopDirective> from(const TokenContext &c);
  static std::optional<OMPParallelMasterTaskLoopDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelMasterTaskLoopDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelMasterTaskLoopDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelMasterTaskLoopDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_cancel(void) const;
};

using OMPParallelForSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelForSimdDirective>;
using OMPParallelForSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelForSimdDirective>;
using OMPParallelForSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelForSimdDirective>;

class OMPParallelForSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelForSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelForSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelForSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_FOR_SIMD_DIRECTIVE;
  }

  static OMPParallelForSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelForSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelForSimdDirective> from(const TokenContext &c);
  static std::optional<OMPParallelForSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPParallelForSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPParallelForSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelForSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelForSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelForSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPParallelForDirectiveRange = DerivedEntityRange<StmtIterator, OMPParallelForDirective>;
using OMPParallelForDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPParallelForDirective>;
using OMPParallelForDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPParallelForDirective>;

class OMPParallelForDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPParallelForDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPParallelForDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPParallelForDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_PARALLEL_FOR_DIRECTIVE;
  }

  static OMPParallelForDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPParallelForDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPParallelForDirective> from(const TokenContext &c);
  static std::optional<OMPParallelForDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPParallelForDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPParallelForDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPParallelForDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPParallelForDirective> from(const Stmt &parent);

  inline static std::optional<OMPParallelForDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPParallelForDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr task_reduction_reference_expression(void) const;
  bool has_cancel(void) const;
};

using OMPMasterTaskLoopSimdDirectiveRange = DerivedEntityRange<StmtIterator, OMPMasterTaskLoopSimdDirective>;
using OMPMasterTaskLoopSimdDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPMasterTaskLoopSimdDirective>;
using OMPMasterTaskLoopSimdDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPMasterTaskLoopSimdDirective>;

class OMPMasterTaskLoopSimdDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPMasterTaskLoopSimdDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPMasterTaskLoopSimdDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPMasterTaskLoopSimdDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE;
  }

  static OMPMasterTaskLoopSimdDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPMasterTaskLoopSimdDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPMasterTaskLoopSimdDirective> from(const TokenContext &c);
  static std::optional<OMPMasterTaskLoopSimdDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPMasterTaskLoopSimdDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopSimdDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPMasterTaskLoopSimdDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopSimdDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPMasterTaskLoopSimdDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopSimdDirective> from(const Stmt &parent);

  inline static std::optional<OMPMasterTaskLoopSimdDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPMasterTaskLoopSimdDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPMasterTaskLoopDirectiveRange = DerivedEntityRange<StmtIterator, OMPMasterTaskLoopDirective>;
using OMPMasterTaskLoopDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPMasterTaskLoopDirective>;
using OMPMasterTaskLoopDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPMasterTaskLoopDirective>;

class OMPMasterTaskLoopDirective : public OMPLoopDirective {
 private:
  friend class FragmentImpl;
  friend class OMPLoopDirective;
  friend class OMPLoopBasedDirective;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPMasterTaskLoopDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPMasterTaskLoopDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPMasterTaskLoopDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_MASTER_TASK_LOOP_DIRECTIVE;
  }

  static OMPMasterTaskLoopDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPMasterTaskLoopDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPMasterTaskLoopDirective> from(const TokenContext &c);
  static std::optional<OMPMasterTaskLoopDirective> from(const OMPLoopDirective &parent);

  inline static std::optional<OMPMasterTaskLoopDirective> from(const std::optional<OMPLoopDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopDirective> from(const OMPLoopBasedDirective &parent);

  inline static std::optional<OMPMasterTaskLoopDirective> from(const std::optional<OMPLoopBasedDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPMasterTaskLoopDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPMasterTaskLoopDirective> from(const Stmt &parent);

  inline static std::optional<OMPMasterTaskLoopDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPMasterTaskLoopDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_cancel(void) const;
};

using OMPInteropDirectiveRange = DerivedEntityRange<StmtIterator, OMPInteropDirective>;
using OMPInteropDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPInteropDirective>;
using OMPInteropDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPInteropDirective>;

class OMPInteropDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPInteropDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPInteropDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPInteropDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_INTEROP_DIRECTIVE;
  }

  static OMPInteropDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPInteropDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPInteropDirective> from(const TokenContext &c);
  static std::optional<OMPInteropDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPInteropDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPInteropDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPInteropDirective> from(const Stmt &parent);

  inline static std::optional<OMPInteropDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPInteropDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPFlushDirectiveRange = DerivedEntityRange<StmtIterator, OMPFlushDirective>;
using OMPFlushDirectiveContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPFlushDirective>;
using OMPFlushDirectiveContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPFlushDirective>;

class OMPFlushDirective : public OMPExecutableDirective {
 private:
  friend class FragmentImpl;
  friend class OMPExecutableDirective;
  friend class Stmt;
 public:
  inline static OMPFlushDirectiveRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPFlushDirectiveContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPFlushDirective::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_FLUSH_DIRECTIVE;
  }

  static OMPFlushDirectiveContainingStmtRange containing(const Decl &decl);
  static OMPFlushDirectiveContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPFlushDirective> from(const TokenContext &c);
  static std::optional<OMPFlushDirective> from(const OMPExecutableDirective &parent);

  inline static std::optional<OMPFlushDirective> from(const std::optional<OMPExecutableDirective> &parent) {
    if (parent) {
      return OMPFlushDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPFlushDirective> from(const Stmt &parent);

  inline static std::optional<OMPFlushDirective> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPFlushDirective::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPCanonicalLoopRange = DerivedEntityRange<StmtIterator, OMPCanonicalLoop>;
using OMPCanonicalLoopContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCanonicalLoop>;
using OMPCanonicalLoopContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPCanonicalLoop>;

class OMPCanonicalLoop : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static OMPCanonicalLoopRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCanonicalLoopContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCanonicalLoop::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_CANONICAL_LOOP;
  }

  static OMPCanonicalLoopContainingStmtRange containing(const Decl &decl);
  static OMPCanonicalLoopContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPCanonicalLoop> from(const TokenContext &c);
  static std::optional<OMPCanonicalLoop> from(const Stmt &parent);

  inline static std::optional<OMPCanonicalLoop> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPCanonicalLoop::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CapturedStmt distance_func(void) const;
  Stmt loop_statement(void) const;
  CapturedStmt loop_variable_func(void) const;
  DeclRefExpr loop_variable_reference(void) const;
};

using NullStmtRange = DerivedEntityRange<StmtIterator, NullStmt>;
using NullStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, NullStmt>;
using NullStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, NullStmt>;

class NullStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static NullStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NullStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NullStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::NULL_STMT;
  }

  static NullStmtContainingStmtRange containing(const Decl &decl);
  static NullStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NullStmt> from(const TokenContext &c);
  static std::optional<NullStmt> from(const Stmt &parent);

  inline static std::optional<NullStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return NullStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token semi_token(void) const;
  bool has_leading_empty_macro(void) const;
};

using MSDependentExistsStmtRange = DerivedEntityRange<StmtIterator, MSDependentExistsStmt>;
using MSDependentExistsStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSDependentExistsStmt>;
using MSDependentExistsStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MSDependentExistsStmt>;

class MSDependentExistsStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static MSDependentExistsStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSDependentExistsStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSDependentExistsStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MS_DEPENDENT_EXISTS_STMT;
  }

  static MSDependentExistsStmtContainingStmtRange containing(const Decl &decl);
  static MSDependentExistsStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSDependentExistsStmt> from(const TokenContext &c);
  static std::optional<MSDependentExistsStmt> from(const Stmt &parent);

  inline static std::optional<MSDependentExistsStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MSDependentExistsStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token keyword_token(void) const;
  CompoundStmt sub_statement(void) const;
  bool is_if_exists(void) const;
  bool is_if_not_exists(void) const;
};

using IndirectGotoStmtRange = DerivedEntityRange<StmtIterator, IndirectGotoStmt>;
using IndirectGotoStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, IndirectGotoStmt>;
using IndirectGotoStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, IndirectGotoStmt>;

class IndirectGotoStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static IndirectGotoStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IndirectGotoStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IndirectGotoStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::INDIRECT_GOTO_STMT;
  }

  static IndirectGotoStmtContainingStmtRange containing(const Decl &decl);
  static IndirectGotoStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<IndirectGotoStmt> from(const TokenContext &c);
  static std::optional<IndirectGotoStmt> from(const Stmt &parent);

  inline static std::optional<IndirectGotoStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return IndirectGotoStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<LabelDecl> constant_target(void) const;
  Token goto_token(void) const;
  Token star_token(void) const;
  Expr target(void) const;
};

using IfStmtRange = DerivedEntityRange<StmtIterator, IfStmt>;
using IfStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, IfStmt>;
using IfStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, IfStmt>;

class IfStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static IfStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IfStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IfStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::IF_STMT;
  }

  static IfStmtContainingStmtRange containing(const Decl &decl);
  static IfStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<IfStmt> from(const TokenContext &c);
  static std::optional<IfStmt> from(const Stmt &parent);

  inline static std::optional<IfStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return IfStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr condition(void) const;
  std::optional<VarDecl> condition_variable(void) const;
  std::optional<DeclStmt> condition_variable_declaration_statement(void) const;
  std::optional<Stmt> else_(void) const;
  Token else_token(void) const;
  Token if_token(void) const;
  std::optional<Stmt> initializer(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  IfStatementKind statement_kind(void) const;
  Stmt then(void) const;
  bool has_else_storage(void) const;
  bool has_initializer_storage(void) const;
  bool has_variable_storage(void) const;
  bool is_consteval(void) const;
  bool is_constexpr(void) const;
  bool is_negated_consteval(void) const;
  bool is_non_negated_consteval(void) const;
  bool is_obj_c_availability_check(void) const;
};

using GotoStmtRange = DerivedEntityRange<StmtIterator, GotoStmt>;
using GotoStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, GotoStmt>;
using GotoStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, GotoStmt>;

class GotoStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static GotoStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GotoStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GotoStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::GOTO_STMT;
  }

  static GotoStmtContainingStmtRange containing(const Decl &decl);
  static GotoStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<GotoStmt> from(const TokenContext &c);
  static std::optional<GotoStmt> from(const Stmt &parent);

  inline static std::optional<GotoStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return GotoStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token goto_token(void) const;
  LabelDecl label(void) const;
  Token label_token(void) const;
};

using ForStmtRange = DerivedEntityRange<StmtIterator, ForStmt>;
using ForStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ForStmt>;
using ForStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ForStmt>;

class ForStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ForStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ForStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ForStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::FOR_STMT;
  }

  static ForStmtContainingStmtRange containing(const Decl &decl);
  static ForStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ForStmt> from(const TokenContext &c);
  static std::optional<ForStmt> from(const Stmt &parent);

  inline static std::optional<ForStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ForStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  std::optional<Expr> condition(void) const;
  std::optional<VarDecl> condition_variable(void) const;
  std::optional<DeclStmt> condition_variable_declaration_statement(void) const;
  Token for_token(void) const;
  std::optional<Expr> increment(void) const;
  std::optional<Stmt> initializer(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
};

using DoStmtRange = DerivedEntityRange<StmtIterator, DoStmt>;
using DoStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, DoStmt>;
using DoStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DoStmt>;

class DoStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static DoStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DoStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DoStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DO_STMT;
  }

  static DoStmtContainingStmtRange containing(const Decl &decl);
  static DoStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DoStmt> from(const TokenContext &c);
  static std::optional<DoStmt> from(const Stmt &parent);

  inline static std::optional<DoStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DoStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  Expr condition(void) const;
  Token do_token(void) const;
  Token r_paren_token(void) const;
  Token while_token(void) const;
};

using DeclStmtRange = DerivedEntityRange<StmtIterator, DeclStmt>;
using DeclStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeclStmt>;
using DeclStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DeclStmt>;

class DeclStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static DeclStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeclStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeclStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DECL_STMT;
  }

  static DeclStmtContainingStmtRange containing(const Decl &decl);
  static DeclStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DeclStmt> from(const TokenContext &c);
  static std::optional<DeclStmt> from(const Stmt &parent);

  inline static std::optional<DeclStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DeclStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations(void) const;
  std::optional<Decl> single_declaration(void) const;
  bool is_single_declaration(void) const;
};

using CoroutineBodyStmtRange = DerivedEntityRange<StmtIterator, CoroutineBodyStmt>;
using CoroutineBodyStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CoroutineBodyStmt>;
using CoroutineBodyStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CoroutineBodyStmt>;

class CoroutineBodyStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CoroutineBodyStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CoroutineBodyStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CoroutineBodyStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COROUTINE_BODY_STMT;
  }

  static CoroutineBodyStmtContainingStmtRange containing(const Decl &decl);
  static CoroutineBodyStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CoroutineBodyStmt> from(const TokenContext &c);
  static std::optional<CoroutineBodyStmt> from(const Stmt &parent);

  inline static std::optional<CoroutineBodyStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CoroutineBodyStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr allocate(void) const;
  Stmt body(void) const;
  Expr deallocate(void) const;
  Stmt exception_handler(void) const;
  Stmt fallthrough_handler(void) const;
  Stmt final_suspend_statement(void) const;
  Stmt initializer_suspend_statement(void) const;
  std::vector<Stmt> parameter_moves(void) const;
  VarDecl promise_declaration(void) const;
  Stmt promise_declaration_statement(void) const;
  Stmt result_declaration(void) const;
  Stmt return_statement(void) const;
  Stmt return_statement_on_alloc_failure(void) const;
  Expr return_value_initializer(void) const;
  bool has_dependent_promise_type(void) const;
};

using CoreturnStmtRange = DerivedEntityRange<StmtIterator, CoreturnStmt>;
using CoreturnStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CoreturnStmt>;
using CoreturnStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CoreturnStmt>;

class CoreturnStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CoreturnStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CoreturnStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CoreturnStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CORETURN_STMT;
  }

  static CoreturnStmtContainingStmtRange containing(const Decl &decl);
  static CoreturnStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CoreturnStmt> from(const TokenContext &c);
  static std::optional<CoreturnStmt> from(const Stmt &parent);

  inline static std::optional<CoreturnStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CoreturnStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token keyword_token(void) const;
  Expr operand(void) const;
  Expr promise_call(void) const;
  bool is_implicit(void) const;
};

using ContinueStmtRange = DerivedEntityRange<StmtIterator, ContinueStmt>;
using ContinueStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ContinueStmt>;
using ContinueStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ContinueStmt>;

class ContinueStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ContinueStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ContinueStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ContinueStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CONTINUE_STMT;
  }

  static ContinueStmtContainingStmtRange containing(const Decl &decl);
  static ContinueStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ContinueStmt> from(const TokenContext &c);
  static std::optional<ContinueStmt> from(const Stmt &parent);

  inline static std::optional<ContinueStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ContinueStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token continue_token(void) const;
};

using CompoundStmtRange = DerivedEntityRange<StmtIterator, CompoundStmt>;
using CompoundStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CompoundStmt>;
using CompoundStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CompoundStmt>;

class CompoundStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CompoundStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CompoundStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CompoundStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COMPOUND_STMT;
  }

  static CompoundStmtContainingStmtRange containing(const Decl &decl);
  static CompoundStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CompoundStmt> from(const TokenContext &c);
  static std::optional<CompoundStmt> from(const Stmt &parent);

  inline static std::optional<CompoundStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CompoundStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token left_brace_token(void) const;
  Token right_brace_token(void) const;
  std::optional<Stmt> statement_expression_result(void) const;
};

using CapturedStmtRange = DerivedEntityRange<StmtIterator, CapturedStmt>;
using CapturedStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CapturedStmt>;
using CapturedStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CapturedStmt>;

class CapturedStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CapturedStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CapturedStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CapturedStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CAPTURED_STMT;
  }

  static CapturedStmtContainingStmtRange containing(const Decl &decl);
  static CapturedStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CapturedStmt> from(const TokenContext &c);
  static std::optional<CapturedStmt> from(const Stmt &parent);

  inline static std::optional<CapturedStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CapturedStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CapturedDecl captured_declaration(void) const;
  RecordDecl captured_record_declaration(void) const;
  CapturedRegionKind captured_region_kind(void) const;
  Stmt captured_statement(void) const;
};

using CXXTryStmtRange = DerivedEntityRange<StmtIterator, CXXTryStmt>;
using CXXTryStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXTryStmt>;
using CXXTryStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXTryStmt>;

class CXXTryStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CXXTryStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXTryStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXTryStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_TRY_STMT;
  }

  static CXXTryStmtContainingStmtRange containing(const Decl &decl);
  static CXXTryStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXTryStmt> from(const TokenContext &c);
  static std::optional<CXXTryStmt> from(const Stmt &parent);

  inline static std::optional<CXXTryStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXTryStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CompoundStmt try_block(void) const;
  Token try_token(void) const;
  std::vector<CXXCatchStmt> handlers(void) const;
};

using CXXForRangeStmtRange = DerivedEntityRange<StmtIterator, CXXForRangeStmt>;
using CXXForRangeStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXForRangeStmt>;
using CXXForRangeStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXForRangeStmt>;

class CXXForRangeStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CXXForRangeStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXForRangeStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXForRangeStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_FOR_RANGE_STMT;
  }

  static CXXForRangeStmtContainingStmtRange containing(const Decl &decl);
  static CXXForRangeStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXForRangeStmt> from(const TokenContext &c);
  static std::optional<CXXForRangeStmt> from(const Stmt &parent);

  inline static std::optional<CXXForRangeStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXForRangeStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  DeclStmt begin_statement(void) const;
  Stmt body(void) const;
  Token coawait_token(void) const;
  Token colon_token(void) const;
  Expr condition(void) const;
  DeclStmt end_statement(void) const;
  Token for_token(void) const;
  Expr increment(void) const;
  std::optional<Stmt> initializer(void) const;
  DeclStmt loop_variable_statement(void) const;
  VarDecl loop_variable(void) const;
  Token r_paren_token(void) const;
  Expr range_initializer(void) const;
  DeclStmt range_statement(void) const;
};

using CXXCatchStmtRange = DerivedEntityRange<StmtIterator, CXXCatchStmt>;
using CXXCatchStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXCatchStmt>;
using CXXCatchStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXCatchStmt>;

class CXXCatchStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static CXXCatchStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXCatchStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXCatchStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_CATCH_STMT;
  }

  static CXXCatchStmtContainingStmtRange containing(const Decl &decl);
  static CXXCatchStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXCatchStmt> from(const TokenContext &c);
  static std::optional<CXXCatchStmt> from(const Stmt &parent);

  inline static std::optional<CXXCatchStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXCatchStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token catch_token(void) const;
  Type caught_type(void) const;
  std::optional<VarDecl> exception_declaration(void) const;
  Stmt handler_block(void) const;
};

using BreakStmtRange = DerivedEntityRange<StmtIterator, BreakStmt>;
using BreakStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, BreakStmt>;
using BreakStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, BreakStmt>;

class BreakStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static BreakStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BreakStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BreakStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::BREAK_STMT;
  }

  static BreakStmtContainingStmtRange containing(const Decl &decl);
  static BreakStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BreakStmt> from(const TokenContext &c);
  static std::optional<BreakStmt> from(const Stmt &parent);

  inline static std::optional<BreakStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return BreakStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token break_token(void) const;
};

using AsmStmtRange = DerivedEntityRange<StmtIterator, AsmStmt>;
using AsmStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, AsmStmt>;
using AsmStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AsmStmt>;

class AsmStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static AsmStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AsmStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AsmStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static AsmStmtContainingStmtRange containing(const Decl &decl);
  static AsmStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AsmStmt> from(const TokenContext &c);
  static std::optional<AsmStmt> from(const Stmt &parent);

  inline static std::optional<AsmStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AsmStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view generate_assembly_string(void) const;
  Token assembly_token(void) const;
  std::vector<Expr> inputs(void) const;
  bool is_simple(void) const;
  bool is_volatile(void) const;
  std::vector<Expr> outputs(void) const;
  std::vector<std::string_view> output_constraints(void) const;
  std::vector<Expr> output_expressions(void) const;
  std::vector<std::string_view> input_constraints(void) const;
  std::vector<Expr> input_expressions(void) const;
  std::vector<std::string_view> clobbers(void) const;
};

using MSAsmStmtRange = DerivedEntityRange<StmtIterator, MSAsmStmt>;
using MSAsmStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSAsmStmt>;
using MSAsmStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MSAsmStmt>;

class MSAsmStmt : public AsmStmt {
 private:
  friend class FragmentImpl;
  friend class AsmStmt;
  friend class Stmt;
 public:
  inline static MSAsmStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSAsmStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSAsmStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MS_ASM_STMT;
  }

  static MSAsmStmtContainingStmtRange containing(const Decl &decl);
  static MSAsmStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSAsmStmt> from(const TokenContext &c);
  static std::optional<MSAsmStmt> from(const AsmStmt &parent);

  inline static std::optional<MSAsmStmt> from(const std::optional<AsmStmt> &parent) {
    if (parent) {
      return MSAsmStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSAsmStmt> from(const Stmt &parent);

  inline static std::optional<MSAsmStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MSAsmStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<std::string_view> all_constraints(void) const;
  std::vector<Expr> all_expressions(void) const;
  std::string_view assembly_string(void) const;
  Token l_brace_token(void) const;
  bool has_braces(void) const;
};

using GCCAsmStmtRange = DerivedEntityRange<StmtIterator, GCCAsmStmt>;
using GCCAsmStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, GCCAsmStmt>;
using GCCAsmStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, GCCAsmStmt>;

class GCCAsmStmt : public AsmStmt {
 private:
  friend class FragmentImpl;
  friend class AsmStmt;
  friend class Stmt;
 public:
  inline static GCCAsmStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GCCAsmStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GCCAsmStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::GCC_ASM_STMT;
  }

  static GCCAsmStmtContainingStmtRange containing(const Decl &decl);
  static GCCAsmStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<GCCAsmStmt> from(const TokenContext &c);
  static std::optional<GCCAsmStmt> from(const AsmStmt &parent);

  inline static std::optional<GCCAsmStmt> from(const std::optional<AsmStmt> &parent) {
    if (parent) {
      return GCCAsmStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GCCAsmStmt> from(const Stmt &parent);

  inline static std::optional<GCCAsmStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return GCCAsmStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  StringLiteral assembly_string(void) const;
  Token r_paren_token(void) const;
  bool is_assembly_goto(void) const;
  std::vector<AddrLabelExpr> labels(void) const;
  std::vector<StringLiteral> output_constraint_literals(void) const;
  std::vector<std::string_view> output_names(void) const;
  std::vector<StringLiteral> input_constraint_literals(void) const;
  std::vector<std::string_view> input_names(void) const;
  std::vector<StringLiteral> clobber_string_literals(void) const;
  std::vector<AddrLabelExpr> label_expressions(void) const;
  std::vector<std::string_view> label_names(void) const;
};

using WhileStmtRange = DerivedEntityRange<StmtIterator, WhileStmt>;
using WhileStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, WhileStmt>;
using WhileStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, WhileStmt>;

class WhileStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static WhileStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static WhileStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : WhileStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::WHILE_STMT;
  }

  static WhileStmtContainingStmtRange containing(const Decl &decl);
  static WhileStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<WhileStmt> from(const TokenContext &c);
  static std::optional<WhileStmt> from(const Stmt &parent);

  inline static std::optional<WhileStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return WhileStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  Expr condition(void) const;
  std::optional<VarDecl> condition_variable(void) const;
  std::optional<DeclStmt> condition_variable_declaration_statement(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  Token while_token(void) const;
  bool has_variable_storage(void) const;
};

using ValueStmtRange = DerivedEntityRange<StmtIterator, ValueStmt>;
using ValueStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, ValueStmt>;
using ValueStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ValueStmt>;

class ValueStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static ValueStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ValueStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ValueStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static ValueStmtContainingStmtRange containing(const Decl &decl);
  static ValueStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ValueStmt> from(const TokenContext &c);
  static std::optional<ValueStmt> from(const Stmt &parent);

  inline static std::optional<ValueStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ValueStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> expression_statement(void) const;
};

using LabelStmtRange = DerivedEntityRange<StmtIterator, LabelStmt>;
using LabelStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, LabelStmt>;
using LabelStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, LabelStmt>;

class LabelStmt : public ValueStmt {
 private:
  friend class FragmentImpl;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static LabelStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LabelStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LabelStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::LABEL_STMT;
  }

  static LabelStmtContainingStmtRange containing(const Decl &decl);
  static LabelStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<LabelStmt> from(const TokenContext &c);
  static std::optional<LabelStmt> from(const ValueStmt &parent);

  inline static std::optional<LabelStmt> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return LabelStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LabelStmt> from(const Stmt &parent);

  inline static std::optional<LabelStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return LabelStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  LabelDecl declaration(void) const;
  Token identifier_token(void) const;
  std::string_view name(void) const;
  Stmt sub_statement(void) const;
  bool is_side_entry(void) const;
};

using ExprRange = DerivedEntityRange<StmtIterator, Expr>;
using ExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, Expr>;
using ExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, Expr>;

class Expr : public ValueStmt {
 private:
  friend class FragmentImpl;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Expr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static ExprContainingStmtRange containing(const Decl &decl);
  static ExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<Expr> from(const TokenContext &c);
  static std::optional<Expr> from(const ValueStmt &parent);

  inline static std::optional<Expr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return Expr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<Expr> from(const Stmt &parent);

  inline static std::optional<Expr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return Expr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_side_effects(void) const;
  Expr ignore_casts(void) const;
  Expr ignore_conversion_operator_single_step(void) const;
  Expr ignore_imp_casts(void) const;
  Expr ignore_implicit(void) const;
  Expr ignore_implicit_as_written(void) const;
  Expr ignore_parenthesis_base_casts(void) const;
  Expr ignore_parenthesis_casts(void) const;
  Expr ignore_parenthesis_imp_casts(void) const;
  Expr ignore_parenthesis_l_value_casts(void) const;
  Expr ignore_parenthesis_noop_casts(void) const;
  Expr ignore_parentheses(void) const;
  Expr ignore_unless_spelled_in_source(void) const;
  bool contains_errors(void) const;
  bool contains_unexpanded_parameter_pack(void) const;
  Expr best_dynamic_class_type_expression(void) const;
  Token expression_token(void) const;
  std::optional<ObjCPropertyRefExpr> obj_c_property(void) const;
  ExprObjectKind object_kind(void) const;
  std::optional<Decl> referenced_declaration_of_callee(void) const;
  std::optional<FieldDecl> source_bit_field(void) const;
  std::optional<Type> type(void) const;
  ExprValueKind value_kind(void) const;
  bool has_non_trivial_call(void) const;
  std::optional<bool> is_cxx98_integral_constant_expression(void) const;
  bool is_default_argument(void) const;
  bool is_gl_value(void) const;
  bool is_implicit_cxx_this(void) const;
  bool is_instantiation_dependent(void) const;
  std::optional<bool> is_integer_constant_expression(void) const;
  bool is_known_to_have_boolean_value(void) const;
  bool is_l_value(void) const;
  bool is_objcgc_candidate(void) const;
  bool is_obj_c_self_expression(void) const;
  bool is_ordinary_or_bit_field_object(void) const;
  bool is_pr_value(void) const;
  bool is_read_if_discarded_in_c_plus_plus11(void) const;
  bool is_type_dependent(void) const;
  bool is_value_dependent(void) const;
  bool is_x_value(void) const;
  bool refers_to_bit_field(void) const;
  bool refers_to_global_register_variable(void) const;
  bool refers_to_matrix_element(void) const;
  bool refers_to_vector_element(void) const;
};

using DesignatedInitUpdateExprRange = DerivedEntityRange<StmtIterator, DesignatedInitUpdateExpr>;
using DesignatedInitUpdateExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, DesignatedInitUpdateExpr>;
using DesignatedInitUpdateExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DesignatedInitUpdateExpr>;

class DesignatedInitUpdateExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static DesignatedInitUpdateExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DesignatedInitUpdateExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DesignatedInitUpdateExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DESIGNATED_INIT_UPDATE_EXPR;
  }

  static DesignatedInitUpdateExprContainingStmtRange containing(const Decl &decl);
  static DesignatedInitUpdateExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DesignatedInitUpdateExpr> from(const TokenContext &c);
  static std::optional<DesignatedInitUpdateExpr> from(const Expr &parent);

  inline static std::optional<DesignatedInitUpdateExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return DesignatedInitUpdateExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DesignatedInitUpdateExpr> from(const ValueStmt &parent);

  inline static std::optional<DesignatedInitUpdateExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return DesignatedInitUpdateExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DesignatedInitUpdateExpr> from(const Stmt &parent);

  inline static std::optional<DesignatedInitUpdateExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DesignatedInitUpdateExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  InitListExpr updater(void) const;
};

using DesignatedInitExprRange = DerivedEntityRange<StmtIterator, DesignatedInitExpr>;
using DesignatedInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, DesignatedInitExpr>;
using DesignatedInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DesignatedInitExpr>;

class DesignatedInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static DesignatedInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DesignatedInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DesignatedInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DESIGNATED_INIT_EXPR;
  }

  static DesignatedInitExprContainingStmtRange containing(const Decl &decl);
  static DesignatedInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DesignatedInitExpr> from(const TokenContext &c);
  static std::optional<DesignatedInitExpr> from(const Expr &parent);

  inline static std::optional<DesignatedInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return DesignatedInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DesignatedInitExpr> from(const ValueStmt &parent);

  inline static std::optional<DesignatedInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return DesignatedInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DesignatedInitExpr> from(const Stmt &parent);

  inline static std::optional<DesignatedInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DesignatedInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Designator> designators(void) const;
  TokenRange designators_source_range(void) const;
  Token equal_or_colon_token(void) const;
  Expr initializer(void) const;
  bool is_direct_initializer(void) const;
  bool uses_gnu_syntax(void) const;
  std::vector<Expr> sub_expressions(void) const;
};

using DependentScopeDeclRefExprRange = DerivedEntityRange<StmtIterator, DependentScopeDeclRefExpr>;
using DependentScopeDeclRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentScopeDeclRefExpr>;
using DependentScopeDeclRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DependentScopeDeclRefExpr>;

class DependentScopeDeclRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static DependentScopeDeclRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentScopeDeclRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentScopeDeclRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DEPENDENT_SCOPE_DECL_REF_EXPR;
  }

  static DependentScopeDeclRefExprContainingStmtRange containing(const Decl &decl);
  static DependentScopeDeclRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DependentScopeDeclRefExpr> from(const TokenContext &c);
  static std::optional<DependentScopeDeclRefExpr> from(const Expr &parent);

  inline static std::optional<DependentScopeDeclRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return DependentScopeDeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentScopeDeclRefExpr> from(const ValueStmt &parent);

  inline static std::optional<DependentScopeDeclRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return DependentScopeDeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentScopeDeclRefExpr> from(const Stmt &parent);

  inline static std::optional<DependentScopeDeclRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DependentScopeDeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_angle_token(void) const;
  Token r_angle_token(void) const;
  Token template_keyword_token(void) const;
  bool has_explicit_template_arguments(void) const;
  bool has_template_keyword(void) const;
};

using DependentCoawaitExprRange = DerivedEntityRange<StmtIterator, DependentCoawaitExpr>;
using DependentCoawaitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, DependentCoawaitExpr>;
using DependentCoawaitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DependentCoawaitExpr>;

class DependentCoawaitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static DependentCoawaitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DependentCoawaitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DependentCoawaitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DEPENDENT_COAWAIT_EXPR;
  }

  static DependentCoawaitExprContainingStmtRange containing(const Decl &decl);
  static DependentCoawaitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DependentCoawaitExpr> from(const TokenContext &c);
  static std::optional<DependentCoawaitExpr> from(const Expr &parent);

  inline static std::optional<DependentCoawaitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return DependentCoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentCoawaitExpr> from(const ValueStmt &parent);

  inline static std::optional<DependentCoawaitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return DependentCoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DependentCoawaitExpr> from(const Stmt &parent);

  inline static std::optional<DependentCoawaitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DependentCoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token keyword_token(void) const;
  Expr operand(void) const;
  UnresolvedLookupExpr operator_coawait_lookup(void) const;
};

using DeclRefExprRange = DerivedEntityRange<StmtIterator, DeclRefExpr>;
using DeclRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeclRefExpr>;
using DeclRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DeclRefExpr>;

class DeclRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static DeclRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeclRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeclRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DECL_REF_EXPR;
  }

  static DeclRefExprContainingStmtRange containing(const Decl &decl);
  static DeclRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DeclRefExpr> from(const TokenContext &c);
  static std::optional<DeclRefExpr> from(const Expr &parent);

  inline static std::optional<DeclRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return DeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeclRefExpr> from(const ValueStmt &parent);

  inline static std::optional<DeclRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return DeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeclRefExpr> from(const Stmt &parent);

  inline static std::optional<DeclRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DeclRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ValueDecl declaration(void) const;
  NamedDecl found_declaration(void) const;
  Token l_angle_token(void) const;
  Token r_angle_token(void) const;
  Token template_keyword_token(void) const;
  bool had_multiple_candidates(void) const;
  bool has_explicit_template_arguments(void) const;
  bool has_qualifier(void) const;
  bool has_template_keyword_and_arguments_info(void) const;
  bool has_template_keyword(void) const;
  NonOdrUseReason is_non_odr_use(void) const;
  bool refers_to_enclosing_variable_or_capture(void) const;
};

using CoroutineSuspendExprRange = DerivedEntityRange<StmtIterator, CoroutineSuspendExpr>;
using CoroutineSuspendExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CoroutineSuspendExpr>;
using CoroutineSuspendExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CoroutineSuspendExpr>;

class CoroutineSuspendExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CoroutineSuspendExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CoroutineSuspendExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CoroutineSuspendExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static CoroutineSuspendExprContainingStmtRange containing(const Decl &decl);
  static CoroutineSuspendExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CoroutineSuspendExpr> from(const TokenContext &c);
  static std::optional<CoroutineSuspendExpr> from(const Expr &parent);

  inline static std::optional<CoroutineSuspendExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CoroutineSuspendExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoroutineSuspendExpr> from(const ValueStmt &parent);

  inline static std::optional<CoroutineSuspendExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CoroutineSuspendExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoroutineSuspendExpr> from(const Stmt &parent);

  inline static std::optional<CoroutineSuspendExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CoroutineSuspendExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr common_expression(void) const;
  Token keyword_token(void) const;
  OpaqueValueExpr opaque_value(void) const;
  Expr ready_expression(void) const;
  Expr resume_expression(void) const;
  Expr suspend_expression(void) const;
};

using CoawaitExprRange = DerivedEntityRange<StmtIterator, CoawaitExpr>;
using CoawaitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CoawaitExpr>;
using CoawaitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CoawaitExpr>;

class CoawaitExpr : public CoroutineSuspendExpr {
 private:
  friend class FragmentImpl;
  friend class CoroutineSuspendExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CoawaitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CoawaitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CoawaitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COAWAIT_EXPR;
  }

  static CoawaitExprContainingStmtRange containing(const Decl &decl);
  static CoawaitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CoawaitExpr> from(const TokenContext &c);
  static std::optional<CoawaitExpr> from(const CoroutineSuspendExpr &parent);

  inline static std::optional<CoawaitExpr> from(const std::optional<CoroutineSuspendExpr> &parent) {
    if (parent) {
      return CoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoawaitExpr> from(const Expr &parent);

  inline static std::optional<CoawaitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoawaitExpr> from(const ValueStmt &parent);

  inline static std::optional<CoawaitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoawaitExpr> from(const Stmt &parent);

  inline static std::optional<CoawaitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CoawaitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr operand(void) const;
  bool is_implicit(void) const;
};

using CoyieldExprRange = DerivedEntityRange<StmtIterator, CoyieldExpr>;
using CoyieldExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CoyieldExpr>;
using CoyieldExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CoyieldExpr>;

class CoyieldExpr : public CoroutineSuspendExpr {
 private:
  friend class FragmentImpl;
  friend class CoroutineSuspendExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CoyieldExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CoyieldExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CoyieldExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COYIELD_EXPR;
  }

  static CoyieldExprContainingStmtRange containing(const Decl &decl);
  static CoyieldExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CoyieldExpr> from(const TokenContext &c);
  static std::optional<CoyieldExpr> from(const CoroutineSuspendExpr &parent);

  inline static std::optional<CoyieldExpr> from(const std::optional<CoroutineSuspendExpr> &parent) {
    if (parent) {
      return CoyieldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoyieldExpr> from(const Expr &parent);

  inline static std::optional<CoyieldExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CoyieldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoyieldExpr> from(const ValueStmt &parent);

  inline static std::optional<CoyieldExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CoyieldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CoyieldExpr> from(const Stmt &parent);

  inline static std::optional<CoyieldExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CoyieldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr operand(void) const;
};

using ConvertVectorExprRange = DerivedEntityRange<StmtIterator, ConvertVectorExpr>;
using ConvertVectorExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConvertVectorExpr>;
using ConvertVectorExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ConvertVectorExpr>;

class ConvertVectorExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ConvertVectorExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConvertVectorExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConvertVectorExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CONVERT_VECTOR_EXPR;
  }

  static ConvertVectorExprContainingStmtRange containing(const Decl &decl);
  static ConvertVectorExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConvertVectorExpr> from(const TokenContext &c);
  static std::optional<ConvertVectorExpr> from(const Expr &parent);

  inline static std::optional<ConvertVectorExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ConvertVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConvertVectorExpr> from(const ValueStmt &parent);

  inline static std::optional<ConvertVectorExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ConvertVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConvertVectorExpr> from(const Stmt &parent);

  inline static std::optional<ConvertVectorExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ConvertVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  Token r_paren_token(void) const;
  Expr src_expression(void) const;
};

using ConceptSpecializationExprRange = DerivedEntityRange<StmtIterator, ConceptSpecializationExpr>;
using ConceptSpecializationExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConceptSpecializationExpr>;
using ConceptSpecializationExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ConceptSpecializationExpr>;

class ConceptSpecializationExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ConceptSpecializationExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConceptSpecializationExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConceptSpecializationExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CONCEPT_SPECIALIZATION_EXPR;
  }

  static ConceptSpecializationExprContainingStmtRange containing(const Decl &decl);
  static ConceptSpecializationExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConceptSpecializationExpr> from(const TokenContext &c);
  static std::optional<ConceptSpecializationExpr> from(const Expr &parent);

  inline static std::optional<ConceptSpecializationExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ConceptSpecializationExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConceptSpecializationExpr> from(const ValueStmt &parent);

  inline static std::optional<ConceptSpecializationExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ConceptSpecializationExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConceptSpecializationExpr> from(const Stmt &parent);

  inline static std::optional<ConceptSpecializationExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ConceptSpecializationExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<TemplateArgument> template_arguments(void) const;
  bool is_satisfied(void) const;
};

using CompoundLiteralExprRange = DerivedEntityRange<StmtIterator, CompoundLiteralExpr>;
using CompoundLiteralExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CompoundLiteralExpr>;
using CompoundLiteralExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CompoundLiteralExpr>;

class CompoundLiteralExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CompoundLiteralExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CompoundLiteralExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CompoundLiteralExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COMPOUND_LITERAL_EXPR;
  }

  static CompoundLiteralExprContainingStmtRange containing(const Decl &decl);
  static CompoundLiteralExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CompoundLiteralExpr> from(const TokenContext &c);
  static std::optional<CompoundLiteralExpr> from(const Expr &parent);

  inline static std::optional<CompoundLiteralExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CompoundLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CompoundLiteralExpr> from(const ValueStmt &parent);

  inline static std::optional<CompoundLiteralExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CompoundLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CompoundLiteralExpr> from(const Stmt &parent);

  inline static std::optional<CompoundLiteralExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CompoundLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr initializer(void) const;
  Token l_paren_token(void) const;
  bool is_file_scope(void) const;
};

using ChooseExprRange = DerivedEntityRange<StmtIterator, ChooseExpr>;
using ChooseExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ChooseExpr>;
using ChooseExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ChooseExpr>;

class ChooseExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ChooseExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ChooseExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ChooseExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CHOOSE_EXPR;
  }

  static ChooseExprContainingStmtRange containing(const Decl &decl);
  static ChooseExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ChooseExpr> from(const TokenContext &c);
  static std::optional<ChooseExpr> from(const Expr &parent);

  inline static std::optional<ChooseExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ChooseExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ChooseExpr> from(const ValueStmt &parent);

  inline static std::optional<ChooseExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ChooseExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ChooseExpr> from(const Stmt &parent);

  inline static std::optional<ChooseExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ChooseExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  Expr chosen_sub_expression(void) const;
  Expr condition(void) const;
  Expr lhs(void) const;
  Expr rhs(void) const;
  Token r_paren_token(void) const;
  bool is_condition_dependent(void) const;
  bool is_condition_true(void) const;
};

using CharacterLiteralRange = DerivedEntityRange<StmtIterator, CharacterLiteral>;
using CharacterLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, CharacterLiteral>;
using CharacterLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CharacterLiteral>;

class CharacterLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CharacterLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CharacterLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CharacterLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CHARACTER_LITERAL;
  }

  static CharacterLiteralContainingStmtRange containing(const Decl &decl);
  static CharacterLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CharacterLiteral> from(const TokenContext &c);
  static std::optional<CharacterLiteral> from(const Expr &parent);

  inline static std::optional<CharacterLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CharacterLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CharacterLiteral> from(const ValueStmt &parent);

  inline static std::optional<CharacterLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CharacterLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CharacterLiteral> from(const Stmt &parent);

  inline static std::optional<CharacterLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CharacterLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CharacterLiteralCharacterKind character_kind(void) const;
  Token token(void) const;
};

using CastExprRange = DerivedEntityRange<StmtIterator, CastExpr>;
using CastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CastExpr>;
using CastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CastExpr>;

class CastExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static CastExprContainingStmtRange containing(const Decl &decl);
  static CastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CastExpr> from(const TokenContext &c);
  static std::optional<CastExpr> from(const Expr &parent);

  inline static std::optional<CastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CastExpr> from(const ValueStmt &parent);

  inline static std::optional<CastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CastExpr> from(const Stmt &parent);

  inline static std::optional<CastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CastKind cast_kind(void) const;
  std::string_view cast_kind_name(void) const;
  std::optional<NamedDecl> conversion_function(void) const;
  Expr sub_expression(void) const;
  Expr sub_expression_as_written(void) const;
  std::optional<FieldDecl> target_union_field(void) const;
  bool has_stored_fp_features(void) const;
};

using ImplicitCastExprRange = DerivedEntityRange<StmtIterator, ImplicitCastExpr>;
using ImplicitCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ImplicitCastExpr>;
using ImplicitCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ImplicitCastExpr>;

class ImplicitCastExpr : public CastExpr {
 private:
  friend class FragmentImpl;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ImplicitCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ImplicitCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ImplicitCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::IMPLICIT_CAST_EXPR;
  }

  static ImplicitCastExprContainingStmtRange containing(const Decl &decl);
  static ImplicitCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ImplicitCastExpr> from(const TokenContext &c);
  static std::optional<ImplicitCastExpr> from(const CastExpr &parent);

  inline static std::optional<ImplicitCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return ImplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitCastExpr> from(const Expr &parent);

  inline static std::optional<ImplicitCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ImplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitCastExpr> from(const ValueStmt &parent);

  inline static std::optional<ImplicitCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ImplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitCastExpr> from(const Stmt &parent);

  inline static std::optional<ImplicitCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ImplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_part_of_explicit_cast(void) const;
};

using ExplicitCastExprRange = DerivedEntityRange<StmtIterator, ExplicitCastExpr>;
using ExplicitCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExplicitCastExpr>;
using ExplicitCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ExplicitCastExpr>;

class ExplicitCastExpr : public CastExpr {
 private:
  friend class FragmentImpl;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ExplicitCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExplicitCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExplicitCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static ExplicitCastExprContainingStmtRange containing(const Decl &decl);
  static ExplicitCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExplicitCastExpr> from(const TokenContext &c);
  static std::optional<ExplicitCastExpr> from(const CastExpr &parent);

  inline static std::optional<ExplicitCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return ExplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExplicitCastExpr> from(const Expr &parent);

  inline static std::optional<ExplicitCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ExplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExplicitCastExpr> from(const ValueStmt &parent);

  inline static std::optional<ExplicitCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ExplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExplicitCastExpr> from(const Stmt &parent);

  inline static std::optional<ExplicitCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ExplicitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type type_as_written(void) const;
};

using CXXNamedCastExprRange = DerivedEntityRange<StmtIterator, CXXNamedCastExpr>;
using CXXNamedCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXNamedCastExpr>;
using CXXNamedCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXNamedCastExpr>;

class CXXNamedCastExpr : public ExplicitCastExpr {
 private:
  friend class FragmentImpl;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXNamedCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXNamedCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXNamedCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static CXXNamedCastExprContainingStmtRange containing(const Decl &decl);
  static CXXNamedCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXNamedCastExpr> from(const TokenContext &c);
  static std::optional<CXXNamedCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXNamedCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXNamedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNamedCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXNamedCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXNamedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNamedCastExpr> from(const Expr &parent);

  inline static std::optional<CXXNamedCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXNamedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNamedCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXNamedCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXNamedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNamedCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXNamedCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXNamedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  TokenRange angle_brackets(void) const;
  std::string_view cast_name(void) const;
  Token operator_token(void) const;
  Token r_paren_token(void) const;
};

using CXXDynamicCastExprRange = DerivedEntityRange<StmtIterator, CXXDynamicCastExpr>;
using CXXDynamicCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDynamicCastExpr>;
using CXXDynamicCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXDynamicCastExpr>;

class CXXDynamicCastExpr : public CXXNamedCastExpr {
 private:
  friend class FragmentImpl;
  friend class CXXNamedCastExpr;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXDynamicCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDynamicCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDynamicCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_DYNAMIC_CAST_EXPR;
  }

  static CXXDynamicCastExprContainingStmtRange containing(const Decl &decl);
  static CXXDynamicCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDynamicCastExpr> from(const TokenContext &c);
  static std::optional<CXXDynamicCastExpr> from(const CXXNamedCastExpr &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<CXXNamedCastExpr> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDynamicCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDynamicCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDynamicCastExpr> from(const Expr &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDynamicCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDynamicCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXDynamicCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXDynamicCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_always_null(void) const;
};

using CXXConstCastExprRange = DerivedEntityRange<StmtIterator, CXXConstCastExpr>;
using CXXConstCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXConstCastExpr>;
using CXXConstCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXConstCastExpr>;

class CXXConstCastExpr : public CXXNamedCastExpr {
 private:
  friend class FragmentImpl;
  friend class CXXNamedCastExpr;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXConstCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXConstCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXConstCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_CONST_CAST_EXPR;
  }

  static CXXConstCastExprContainingStmtRange containing(const Decl &decl);
  static CXXConstCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXConstCastExpr> from(const TokenContext &c);
  static std::optional<CXXConstCastExpr> from(const CXXNamedCastExpr &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<CXXNamedCastExpr> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstCastExpr> from(const Expr &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXConstCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXConstCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CXXAddrspaceCastExprRange = DerivedEntityRange<StmtIterator, CXXAddrspaceCastExpr>;
using CXXAddrspaceCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXAddrspaceCastExpr>;
using CXXAddrspaceCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXAddrspaceCastExpr>;

class CXXAddrspaceCastExpr : public CXXNamedCastExpr {
 private:
  friend class FragmentImpl;
  friend class CXXNamedCastExpr;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXAddrspaceCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXAddrspaceCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXAddrspaceCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_ADDRSPACE_CAST_EXPR;
  }

  static CXXAddrspaceCastExprContainingStmtRange containing(const Decl &decl);
  static CXXAddrspaceCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXAddrspaceCastExpr> from(const TokenContext &c);
  static std::optional<CXXAddrspaceCastExpr> from(const CXXNamedCastExpr &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<CXXNamedCastExpr> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXAddrspaceCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXAddrspaceCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXAddrspaceCastExpr> from(const Expr &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXAddrspaceCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXAddrspaceCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXAddrspaceCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXAddrspaceCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CXXStaticCastExprRange = DerivedEntityRange<StmtIterator, CXXStaticCastExpr>;
using CXXStaticCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXStaticCastExpr>;
using CXXStaticCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXStaticCastExpr>;

class CXXStaticCastExpr : public CXXNamedCastExpr {
 private:
  friend class FragmentImpl;
  friend class CXXNamedCastExpr;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXStaticCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXStaticCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXStaticCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_STATIC_CAST_EXPR;
  }

  static CXXStaticCastExprContainingStmtRange containing(const Decl &decl);
  static CXXStaticCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXStaticCastExpr> from(const TokenContext &c);
  static std::optional<CXXStaticCastExpr> from(const CXXNamedCastExpr &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<CXXNamedCastExpr> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStaticCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStaticCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStaticCastExpr> from(const Expr &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStaticCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStaticCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXStaticCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXStaticCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CXXReinterpretCastExprRange = DerivedEntityRange<StmtIterator, CXXReinterpretCastExpr>;
using CXXReinterpretCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXReinterpretCastExpr>;
using CXXReinterpretCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXReinterpretCastExpr>;

class CXXReinterpretCastExpr : public CXXNamedCastExpr {
 private:
  friend class FragmentImpl;
  friend class CXXNamedCastExpr;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXReinterpretCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXReinterpretCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXReinterpretCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_REINTERPRET_CAST_EXPR;
  }

  static CXXReinterpretCastExprContainingStmtRange containing(const Decl &decl);
  static CXXReinterpretCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXReinterpretCastExpr> from(const TokenContext &c);
  static std::optional<CXXReinterpretCastExpr> from(const CXXNamedCastExpr &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<CXXNamedCastExpr> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXReinterpretCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXReinterpretCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXReinterpretCastExpr> from(const Expr &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXReinterpretCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXReinterpretCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXReinterpretCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXReinterpretCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CXXFunctionalCastExprRange = DerivedEntityRange<StmtIterator, CXXFunctionalCastExpr>;
using CXXFunctionalCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXFunctionalCastExpr>;
using CXXFunctionalCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXFunctionalCastExpr>;

class CXXFunctionalCastExpr : public ExplicitCastExpr {
 private:
  friend class FragmentImpl;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXFunctionalCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXFunctionalCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXFunctionalCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_FUNCTIONAL_CAST_EXPR;
  }

  static CXXFunctionalCastExprContainingStmtRange containing(const Decl &decl);
  static CXXFunctionalCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXFunctionalCastExpr> from(const TokenContext &c);
  static std::optional<CXXFunctionalCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CXXFunctionalCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CXXFunctionalCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFunctionalCastExpr> from(const CastExpr &parent);

  inline static std::optional<CXXFunctionalCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CXXFunctionalCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFunctionalCastExpr> from(const Expr &parent);

  inline static std::optional<CXXFunctionalCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXFunctionalCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFunctionalCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXFunctionalCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXFunctionalCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFunctionalCastExpr> from(const Stmt &parent);

  inline static std::optional<CXXFunctionalCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXFunctionalCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  bool is_list_initialization(void) const;
};

using CStyleCastExprRange = DerivedEntityRange<StmtIterator, CStyleCastExpr>;
using CStyleCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CStyleCastExpr>;
using CStyleCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CStyleCastExpr>;

class CStyleCastExpr : public ExplicitCastExpr {
 private:
  friend class FragmentImpl;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CStyleCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CStyleCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CStyleCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::C_STYLE_CAST_EXPR;
  }

  static CStyleCastExprContainingStmtRange containing(const Decl &decl);
  static CStyleCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CStyleCastExpr> from(const TokenContext &c);
  static std::optional<CStyleCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<CStyleCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return CStyleCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CStyleCastExpr> from(const CastExpr &parent);

  inline static std::optional<CStyleCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return CStyleCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CStyleCastExpr> from(const Expr &parent);

  inline static std::optional<CStyleCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CStyleCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CStyleCastExpr> from(const ValueStmt &parent);

  inline static std::optional<CStyleCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CStyleCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CStyleCastExpr> from(const Stmt &parent);

  inline static std::optional<CStyleCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CStyleCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
};

using BuiltinBitCastExprRange = DerivedEntityRange<StmtIterator, BuiltinBitCastExpr>;
using BuiltinBitCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, BuiltinBitCastExpr>;
using BuiltinBitCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, BuiltinBitCastExpr>;

class BuiltinBitCastExpr : public ExplicitCastExpr {
 private:
  friend class FragmentImpl;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static BuiltinBitCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BuiltinBitCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BuiltinBitCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::BUILTIN_BIT_CAST_EXPR;
  }

  static BuiltinBitCastExprContainingStmtRange containing(const Decl &decl);
  static BuiltinBitCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BuiltinBitCastExpr> from(const TokenContext &c);
  static std::optional<BuiltinBitCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<BuiltinBitCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return BuiltinBitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinBitCastExpr> from(const CastExpr &parent);

  inline static std::optional<BuiltinBitCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return BuiltinBitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinBitCastExpr> from(const Expr &parent);

  inline static std::optional<BuiltinBitCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return BuiltinBitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinBitCastExpr> from(const ValueStmt &parent);

  inline static std::optional<BuiltinBitCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return BuiltinBitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinBitCastExpr> from(const Stmt &parent);

  inline static std::optional<BuiltinBitCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return BuiltinBitCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using ObjCBridgedCastExprRange = DerivedEntityRange<StmtIterator, ObjCBridgedCastExpr>;
using ObjCBridgedCastExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBridgedCastExpr>;
using ObjCBridgedCastExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCBridgedCastExpr>;

class ObjCBridgedCastExpr : public ExplicitCastExpr {
 private:
  friend class FragmentImpl;
  friend class ExplicitCastExpr;
  friend class CastExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCBridgedCastExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBridgedCastExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBridgedCastExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_BRIDGED_CAST_EXPR;
  }

  static ObjCBridgedCastExprContainingStmtRange containing(const Decl &decl);
  static ObjCBridgedCastExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCBridgedCastExpr> from(const TokenContext &c);
  static std::optional<ObjCBridgedCastExpr> from(const ExplicitCastExpr &parent);

  inline static std::optional<ObjCBridgedCastExpr> from(const std::optional<ExplicitCastExpr> &parent) {
    if (parent) {
      return ObjCBridgedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgedCastExpr> from(const CastExpr &parent);

  inline static std::optional<ObjCBridgedCastExpr> from(const std::optional<CastExpr> &parent) {
    if (parent) {
      return ObjCBridgedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgedCastExpr> from(const Expr &parent);

  inline static std::optional<ObjCBridgedCastExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCBridgedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgedCastExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCBridgedCastExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCBridgedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBridgedCastExpr> from(const Stmt &parent);

  inline static std::optional<ObjCBridgedCastExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCBridgedCastExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token bridge_keyword_token(void) const;
  ObjCBridgeCastKind bridge_kind(void) const;
  std::string_view bridge_kind_name(void) const;
  Token l_paren_token(void) const;
};

using CallExprRange = DerivedEntityRange<StmtIterator, CallExpr>;
using CallExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CallExpr>;
using CallExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CallExpr>;

class CallExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CallExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CallExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CallExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CALL_EXPR;
  }

  static CallExprContainingStmtRange containing(const Decl &decl);
  static CallExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CallExpr> from(const TokenContext &c);
  static std::optional<CallExpr> from(const Expr &parent);

  inline static std::optional<CallExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CallExpr> from(const ValueStmt &parent);

  inline static std::optional<CallExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CallExpr> from(const Stmt &parent);

  inline static std::optional<CallExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> arguments(void) const;
  CallExprADLCallKind adl_call_kind(void) const;
  Type call_return_type(void) const;
  Expr callee(void) const;
  std::optional<Decl> callee_declaration(void) const;
  std::optional<FunctionDecl> direct_callee(void) const;
  Token r_paren_token(void) const;
  std::optional<Attr> unused_result_attribute(void) const;
  bool has_stored_fp_features(void) const;
  bool has_unused_result_attribute(void) const;
  bool is_builtin_assume_false(void) const;
  bool is_call_to_std_move(void) const;
  bool is_unevaluated_builtin_call(void) const;
  bool uses_adl(void) const;
};

using CXXOperatorCallExprRange = DerivedEntityRange<StmtIterator, CXXOperatorCallExpr>;
using CXXOperatorCallExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXOperatorCallExpr>;
using CXXOperatorCallExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXOperatorCallExpr>;

class CXXOperatorCallExpr : public CallExpr {
 private:
  friend class FragmentImpl;
  friend class CallExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXOperatorCallExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXOperatorCallExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXOperatorCallExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_OPERATOR_CALL_EXPR;
  }

  static CXXOperatorCallExprContainingStmtRange containing(const Decl &decl);
  static CXXOperatorCallExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXOperatorCallExpr> from(const TokenContext &c);
  static std::optional<CXXOperatorCallExpr> from(const CallExpr &parent);

  inline static std::optional<CXXOperatorCallExpr> from(const std::optional<CallExpr> &parent) {
    if (parent) {
      return CXXOperatorCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXOperatorCallExpr> from(const Expr &parent);

  inline static std::optional<CXXOperatorCallExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXOperatorCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXOperatorCallExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXOperatorCallExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXOperatorCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXOperatorCallExpr> from(const Stmt &parent);

  inline static std::optional<CXXOperatorCallExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXOperatorCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OverloadedOperatorKind operator_(void) const;
  Token operator_token(void) const;
  bool is_assignment_operation(void) const;
  bool is_comparison_operation(void) const;
  bool is_infix_binary_operation(void) const;
};

using CXXMemberCallExprRange = DerivedEntityRange<StmtIterator, CXXMemberCallExpr>;
using CXXMemberCallExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXMemberCallExpr>;
using CXXMemberCallExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXMemberCallExpr>;

class CXXMemberCallExpr : public CallExpr {
 private:
  friend class FragmentImpl;
  friend class CallExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXMemberCallExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXMemberCallExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXMemberCallExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_MEMBER_CALL_EXPR;
  }

  static CXXMemberCallExprContainingStmtRange containing(const Decl &decl);
  static CXXMemberCallExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXMemberCallExpr> from(const TokenContext &c);
  static std::optional<CXXMemberCallExpr> from(const CallExpr &parent);

  inline static std::optional<CXXMemberCallExpr> from(const std::optional<CallExpr> &parent) {
    if (parent) {
      return CXXMemberCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMemberCallExpr> from(const Expr &parent);

  inline static std::optional<CXXMemberCallExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXMemberCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMemberCallExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXMemberCallExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXMemberCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMemberCallExpr> from(const Stmt &parent);

  inline static std::optional<CXXMemberCallExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXMemberCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr implicit_object_argument(void) const;
  std::optional<CXXMethodDecl> method_declaration(void) const;
  Type object_type(void) const;
  CXXRecordDecl record_declaration(void) const;
};

using CUDAKernelCallExprRange = DerivedEntityRange<StmtIterator, CUDAKernelCallExpr>;
using CUDAKernelCallExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CUDAKernelCallExpr>;
using CUDAKernelCallExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CUDAKernelCallExpr>;

class CUDAKernelCallExpr : public CallExpr {
 private:
  friend class FragmentImpl;
  friend class CallExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CUDAKernelCallExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CUDAKernelCallExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CUDAKernelCallExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CUDA_KERNEL_CALL_EXPR;
  }

  static CUDAKernelCallExprContainingStmtRange containing(const Decl &decl);
  static CUDAKernelCallExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CUDAKernelCallExpr> from(const TokenContext &c);
  static std::optional<CUDAKernelCallExpr> from(const CallExpr &parent);

  inline static std::optional<CUDAKernelCallExpr> from(const std::optional<CallExpr> &parent) {
    if (parent) {
      return CUDAKernelCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAKernelCallExpr> from(const Expr &parent);

  inline static std::optional<CUDAKernelCallExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CUDAKernelCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAKernelCallExpr> from(const ValueStmt &parent);

  inline static std::optional<CUDAKernelCallExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CUDAKernelCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CUDAKernelCallExpr> from(const Stmt &parent);

  inline static std::optional<CUDAKernelCallExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CUDAKernelCallExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CallExpr config(void) const;
};

using UserDefinedLiteralRange = DerivedEntityRange<StmtIterator, UserDefinedLiteral>;
using UserDefinedLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, UserDefinedLiteral>;
using UserDefinedLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, UserDefinedLiteral>;

class UserDefinedLiteral : public CallExpr {
 private:
  friend class FragmentImpl;
  friend class CallExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static UserDefinedLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UserDefinedLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UserDefinedLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::USER_DEFINED_LITERAL;
  }

  static UserDefinedLiteralContainingStmtRange containing(const Decl &decl);
  static UserDefinedLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UserDefinedLiteral> from(const TokenContext &c);
  static std::optional<UserDefinedLiteral> from(const CallExpr &parent);

  inline static std::optional<UserDefinedLiteral> from(const std::optional<CallExpr> &parent) {
    if (parent) {
      return UserDefinedLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UserDefinedLiteral> from(const Expr &parent);

  inline static std::optional<UserDefinedLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return UserDefinedLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UserDefinedLiteral> from(const ValueStmt &parent);

  inline static std::optional<UserDefinedLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return UserDefinedLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UserDefinedLiteral> from(const Stmt &parent);

  inline static std::optional<UserDefinedLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return UserDefinedLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr cooked_literal(void) const;
  UserDefinedLiteralLiteralOperatorKind literal_operator_kind(void) const;
  Token ud_suffix_token(void) const;
};

using CXXUuidofExprRange = DerivedEntityRange<StmtIterator, CXXUuidofExpr>;
using CXXUuidofExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXUuidofExpr>;
using CXXUuidofExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXUuidofExpr>;

class CXXUuidofExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXUuidofExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXUuidofExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXUuidofExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_UUIDOF_EXPR;
  }

  static CXXUuidofExprContainingStmtRange containing(const Decl &decl);
  static CXXUuidofExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXUuidofExpr> from(const TokenContext &c);
  static std::optional<CXXUuidofExpr> from(const Expr &parent);

  inline static std::optional<CXXUuidofExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXUuidofExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXUuidofExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXUuidofExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXUuidofExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXUuidofExpr> from(const Stmt &parent);

  inline static std::optional<CXXUuidofExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXUuidofExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> expression_operand(void) const;
  MSGuidDecl guid_declaration(void) const;
  Type type_operand(void) const;
  Type type_operand_source_info(void) const;
  bool is_type_operand(void) const;
};

using CXXUnresolvedConstructExprRange = DerivedEntityRange<StmtIterator, CXXUnresolvedConstructExpr>;
using CXXUnresolvedConstructExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXUnresolvedConstructExpr>;
using CXXUnresolvedConstructExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXUnresolvedConstructExpr>;

class CXXUnresolvedConstructExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXUnresolvedConstructExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXUnresolvedConstructExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXUnresolvedConstructExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_UNRESOLVED_CONSTRUCT_EXPR;
  }

  static CXXUnresolvedConstructExprContainingStmtRange containing(const Decl &decl);
  static CXXUnresolvedConstructExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXUnresolvedConstructExpr> from(const TokenContext &c);
  static std::optional<CXXUnresolvedConstructExpr> from(const Expr &parent);

  inline static std::optional<CXXUnresolvedConstructExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXUnresolvedConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXUnresolvedConstructExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXUnresolvedConstructExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXUnresolvedConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXUnresolvedConstructExpr> from(const Stmt &parent);

  inline static std::optional<CXXUnresolvedConstructExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXUnresolvedConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> arguments(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  Type type_as_written(void) const;
  bool is_list_initialization(void) const;
};

using CXXTypeidExprRange = DerivedEntityRange<StmtIterator, CXXTypeidExpr>;
using CXXTypeidExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXTypeidExpr>;
using CXXTypeidExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXTypeidExpr>;

class CXXTypeidExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXTypeidExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXTypeidExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXTypeidExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_TYPEID_EXPR;
  }

  static CXXTypeidExprContainingStmtRange containing(const Decl &decl);
  static CXXTypeidExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXTypeidExpr> from(const TokenContext &c);
  static std::optional<CXXTypeidExpr> from(const Expr &parent);

  inline static std::optional<CXXTypeidExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXTypeidExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXTypeidExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXTypeidExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXTypeidExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXTypeidExpr> from(const Stmt &parent);

  inline static std::optional<CXXTypeidExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXTypeidExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> expression_operand(void) const;
  Type type_operand(void) const;
  Type type_operand_source_info(void) const;
  std::optional<bool> is_most_derived(void) const;
  bool is_potentially_evaluated(void) const;
  bool is_type_operand(void) const;
};

using CXXThrowExprRange = DerivedEntityRange<StmtIterator, CXXThrowExpr>;
using CXXThrowExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXThrowExpr>;
using CXXThrowExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXThrowExpr>;

class CXXThrowExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXThrowExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXThrowExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXThrowExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_THROW_EXPR;
  }

  static CXXThrowExprContainingStmtRange containing(const Decl &decl);
  static CXXThrowExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXThrowExpr> from(const TokenContext &c);
  static std::optional<CXXThrowExpr> from(const Expr &parent);

  inline static std::optional<CXXThrowExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXThrowExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXThrowExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXThrowExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXThrowExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXThrowExpr> from(const Stmt &parent);

  inline static std::optional<CXXThrowExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXThrowExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> sub_expression(void) const;
  Token throw_token(void) const;
  bool is_thrown_variable_in_scope(void) const;
};

using CXXThisExprRange = DerivedEntityRange<StmtIterator, CXXThisExpr>;
using CXXThisExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXThisExpr>;
using CXXThisExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXThisExpr>;

class CXXThisExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXThisExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXThisExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXThisExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_THIS_EXPR;
  }

  static CXXThisExprContainingStmtRange containing(const Decl &decl);
  static CXXThisExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXThisExpr> from(const TokenContext &c);
  static std::optional<CXXThisExpr> from(const Expr &parent);

  inline static std::optional<CXXThisExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXThisExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXThisExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXThisExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXThisExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXThisExpr> from(const Stmt &parent);

  inline static std::optional<CXXThisExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXThisExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
  bool is_implicit(void) const;
};

using CXXStdInitializerListExprRange = DerivedEntityRange<StmtIterator, CXXStdInitializerListExpr>;
using CXXStdInitializerListExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXStdInitializerListExpr>;
using CXXStdInitializerListExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXStdInitializerListExpr>;

class CXXStdInitializerListExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXStdInitializerListExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXStdInitializerListExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXStdInitializerListExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_STD_INITIALIZER_LIST_EXPR;
  }

  static CXXStdInitializerListExprContainingStmtRange containing(const Decl &decl);
  static CXXStdInitializerListExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXStdInitializerListExpr> from(const TokenContext &c);
  static std::optional<CXXStdInitializerListExpr> from(const Expr &parent);

  inline static std::optional<CXXStdInitializerListExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXStdInitializerListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStdInitializerListExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXStdInitializerListExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXStdInitializerListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXStdInitializerListExpr> from(const Stmt &parent);

  inline static std::optional<CXXStdInitializerListExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXStdInitializerListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr sub_expression(void) const;
};

using CXXScalarValueInitExprRange = DerivedEntityRange<StmtIterator, CXXScalarValueInitExpr>;
using CXXScalarValueInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXScalarValueInitExpr>;
using CXXScalarValueInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXScalarValueInitExpr>;

class CXXScalarValueInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXScalarValueInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXScalarValueInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXScalarValueInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_SCALAR_VALUE_INIT_EXPR;
  }

  static CXXScalarValueInitExprContainingStmtRange containing(const Decl &decl);
  static CXXScalarValueInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXScalarValueInitExpr> from(const TokenContext &c);
  static std::optional<CXXScalarValueInitExpr> from(const Expr &parent);

  inline static std::optional<CXXScalarValueInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXScalarValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXScalarValueInitExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXScalarValueInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXScalarValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXScalarValueInitExpr> from(const Stmt &parent);

  inline static std::optional<CXXScalarValueInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXScalarValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token r_paren_token(void) const;
};

using CXXRewrittenBinaryOperatorRange = DerivedEntityRange<StmtIterator, CXXRewrittenBinaryOperator>;
using CXXRewrittenBinaryOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXRewrittenBinaryOperator>;
using CXXRewrittenBinaryOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXRewrittenBinaryOperator>;

class CXXRewrittenBinaryOperator : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXRewrittenBinaryOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXRewrittenBinaryOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXRewrittenBinaryOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_REWRITTEN_BINARY_OPERATOR;
  }

  static CXXRewrittenBinaryOperatorContainingStmtRange containing(const Decl &decl);
  static CXXRewrittenBinaryOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXRewrittenBinaryOperator> from(const TokenContext &c);
  static std::optional<CXXRewrittenBinaryOperator> from(const Expr &parent);

  inline static std::optional<CXXRewrittenBinaryOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXRewrittenBinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRewrittenBinaryOperator> from(const ValueStmt &parent);

  inline static std::optional<CXXRewrittenBinaryOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXRewrittenBinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRewrittenBinaryOperator> from(const Stmt &parent);

  inline static std::optional<CXXRewrittenBinaryOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXRewrittenBinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr lhs(void) const;
  BinaryOperatorKind opcode(void) const;
  std::string_view opcode_string(void) const;
  BinaryOperatorKind operator_(void) const;
  Token operator_token(void) const;
  Expr rhs(void) const;
  Expr semantic_form(void) const;
  bool is_assignment_operation(void) const;
  bool is_comparison_operation(void) const;
  bool is_reversed(void) const;
};

using CXXPseudoDestructorExprRange = DerivedEntityRange<StmtIterator, CXXPseudoDestructorExpr>;
using CXXPseudoDestructorExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXPseudoDestructorExpr>;
using CXXPseudoDestructorExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXPseudoDestructorExpr>;

class CXXPseudoDestructorExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXPseudoDestructorExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXPseudoDestructorExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXPseudoDestructorExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_PSEUDO_DESTRUCTOR_EXPR;
  }

  static CXXPseudoDestructorExprContainingStmtRange containing(const Decl &decl);
  static CXXPseudoDestructorExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXPseudoDestructorExpr> from(const TokenContext &c);
  static std::optional<CXXPseudoDestructorExpr> from(const Expr &parent);

  inline static std::optional<CXXPseudoDestructorExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXPseudoDestructorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXPseudoDestructorExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXPseudoDestructorExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXPseudoDestructorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXPseudoDestructorExpr> from(const Stmt &parent);

  inline static std::optional<CXXPseudoDestructorExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXPseudoDestructorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Token colon_colon_token(void) const;
  Type destroyed_type(void) const;
  Token destroyed_type_token(void) const;
  Token operator_token(void) const;
  std::optional<Type> scope_type(void) const;
  Token tilde_token(void) const;
  bool has_qualifier(void) const;
  bool is_arrow(void) const;
};

using CXXNullPtrLiteralExprRange = DerivedEntityRange<StmtIterator, CXXNullPtrLiteralExpr>;
using CXXNullPtrLiteralExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXNullPtrLiteralExpr>;
using CXXNullPtrLiteralExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXNullPtrLiteralExpr>;

class CXXNullPtrLiteralExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXNullPtrLiteralExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXNullPtrLiteralExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXNullPtrLiteralExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_NULL_PTR_LITERAL_EXPR;
  }

  static CXXNullPtrLiteralExprContainingStmtRange containing(const Decl &decl);
  static CXXNullPtrLiteralExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXNullPtrLiteralExpr> from(const TokenContext &c);
  static std::optional<CXXNullPtrLiteralExpr> from(const Expr &parent);

  inline static std::optional<CXXNullPtrLiteralExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXNullPtrLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNullPtrLiteralExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXNullPtrLiteralExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXNullPtrLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNullPtrLiteralExpr> from(const Stmt &parent);

  inline static std::optional<CXXNullPtrLiteralExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXNullPtrLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
};

using CXXNoexceptExprRange = DerivedEntityRange<StmtIterator, CXXNoexceptExpr>;
using CXXNoexceptExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXNoexceptExpr>;
using CXXNoexceptExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXNoexceptExpr>;

class CXXNoexceptExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXNoexceptExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXNoexceptExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXNoexceptExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_NOEXCEPT_EXPR;
  }

  static CXXNoexceptExprContainingStmtRange containing(const Decl &decl);
  static CXXNoexceptExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXNoexceptExpr> from(const TokenContext &c);
  static std::optional<CXXNoexceptExpr> from(const Expr &parent);

  inline static std::optional<CXXNoexceptExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXNoexceptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNoexceptExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXNoexceptExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXNoexceptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNoexceptExpr> from(const Stmt &parent);

  inline static std::optional<CXXNoexceptExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXNoexceptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr operand(void) const;
  bool value(void) const;
};

using CXXNewExprRange = DerivedEntityRange<StmtIterator, CXXNewExpr>;
using CXXNewExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXNewExpr>;
using CXXNewExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXNewExpr>;

class CXXNewExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXNewExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXNewExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXNewExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_NEW_EXPR;
  }

  static CXXNewExprContainingStmtRange containing(const Decl &decl);
  static CXXNewExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXNewExpr> from(const TokenContext &c);
  static std::optional<CXXNewExpr> from(const Expr &parent);

  inline static std::optional<CXXNewExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXNewExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNewExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXNewExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXNewExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXNewExpr> from(const Stmt &parent);

  inline static std::optional<CXXNewExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXNewExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool does_usual_array_delete_want_size(void) const;
  Type allocated_type(void) const;
  std::optional<Expr> array_size(void) const;
  std::optional<CXXConstructExpr> construct_expression(void) const;
  TokenRange direct_initializer_range(void) const;
  CXXNewExprInitializationStyle initialization_style(void) const;
  std::optional<Expr> initializer(void) const;
  FunctionDecl operator_delete(void) const;
  FunctionDecl operator_new(void) const;
  TokenRange type_id_parentheses(void) const;
  bool has_initializer(void) const;
  bool is_array(void) const;
  bool is_global_new(void) const;
  bool is_parenthesis_type_id(void) const;
  bool pass_alignment(void) const;
  std::vector<Expr> placement_arguments(void) const;
  bool should_null_check_allocation(void) const;
};

using CXXInheritedCtorInitExprRange = DerivedEntityRange<StmtIterator, CXXInheritedCtorInitExpr>;
using CXXInheritedCtorInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXInheritedCtorInitExpr>;
using CXXInheritedCtorInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXInheritedCtorInitExpr>;

class CXXInheritedCtorInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXInheritedCtorInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXInheritedCtorInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXInheritedCtorInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_INHERITED_CTOR_INIT_EXPR;
  }

  static CXXInheritedCtorInitExprContainingStmtRange containing(const Decl &decl);
  static CXXInheritedCtorInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXInheritedCtorInitExpr> from(const TokenContext &c);
  static std::optional<CXXInheritedCtorInitExpr> from(const Expr &parent);

  inline static std::optional<CXXInheritedCtorInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXInheritedCtorInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXInheritedCtorInitExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXInheritedCtorInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXInheritedCtorInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXInheritedCtorInitExpr> from(const Stmt &parent);

  inline static std::optional<CXXInheritedCtorInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXInheritedCtorInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool constructs_virtual_base(void) const;
  CXXConstructExprConstructionKind construction_kind(void) const;
  CXXConstructorDecl constructor(void) const;
  Token token(void) const;
  bool inherited_from_virtual_base(void) const;
};

using CXXFoldExprRange = DerivedEntityRange<StmtIterator, CXXFoldExpr>;
using CXXFoldExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXFoldExpr>;
using CXXFoldExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXFoldExpr>;

class CXXFoldExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXFoldExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXFoldExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXFoldExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_FOLD_EXPR;
  }

  static CXXFoldExprContainingStmtRange containing(const Decl &decl);
  static CXXFoldExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXFoldExpr> from(const TokenContext &c);
  static std::optional<CXXFoldExpr> from(const Expr &parent);

  inline static std::optional<CXXFoldExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXFoldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFoldExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXFoldExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXFoldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXFoldExpr> from(const Stmt &parent);

  inline static std::optional<CXXFoldExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXFoldExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  UnresolvedLookupExpr callee(void) const;
  Token ellipsis_token(void) const;
  Expr initializer(void) const;
  Expr lhs(void) const;
  Token l_paren_token(void) const;
  std::optional<unsigned> num_expansions(void) const;
  BinaryOperatorKind operator_(void) const;
  Expr pattern(void) const;
  Expr rhs(void) const;
  Token r_paren_token(void) const;
  bool is_left_fold(void) const;
  bool is_right_fold(void) const;
};

using CXXDependentScopeMemberExprRange = DerivedEntityRange<StmtIterator, CXXDependentScopeMemberExpr>;
using CXXDependentScopeMemberExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDependentScopeMemberExpr>;
using CXXDependentScopeMemberExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXDependentScopeMemberExpr>;

class CXXDependentScopeMemberExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXDependentScopeMemberExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDependentScopeMemberExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDependentScopeMemberExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_DEPENDENT_SCOPE_MEMBER_EXPR;
  }

  static CXXDependentScopeMemberExprContainingStmtRange containing(const Decl &decl);
  static CXXDependentScopeMemberExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDependentScopeMemberExpr> from(const TokenContext &c);
  static std::optional<CXXDependentScopeMemberExpr> from(const Expr &parent);

  inline static std::optional<CXXDependentScopeMemberExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXDependentScopeMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDependentScopeMemberExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXDependentScopeMemberExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXDependentScopeMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDependentScopeMemberExpr> from(const Stmt &parent);

  inline static std::optional<CXXDependentScopeMemberExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXDependentScopeMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> base(void) const;
  Type base_type(void) const;
  std::optional<NamedDecl> first_qualifier_found_in_scope(void) const;
  Token l_angle_token(void) const;
  Token member_token(void) const;
  Token operator_token(void) const;
  Token r_angle_token(void) const;
  Token template_keyword_token(void) const;
  bool has_explicit_template_arguments(void) const;
  bool has_template_keyword(void) const;
  bool is_arrow(void) const;
  bool is_implicit_access(void) const;
};

using CXXDeleteExprRange = DerivedEntityRange<StmtIterator, CXXDeleteExpr>;
using CXXDeleteExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDeleteExpr>;
using CXXDeleteExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXDeleteExpr>;

class CXXDeleteExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXDeleteExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDeleteExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDeleteExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_DELETE_EXPR;
  }

  static CXXDeleteExprContainingStmtRange containing(const Decl &decl);
  static CXXDeleteExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDeleteExpr> from(const TokenContext &c);
  static std::optional<CXXDeleteExpr> from(const Expr &parent);

  inline static std::optional<CXXDeleteExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXDeleteExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeleteExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXDeleteExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXDeleteExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeleteExpr> from(const Stmt &parent);

  inline static std::optional<CXXDeleteExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXDeleteExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool does_usual_array_delete_want_size(void) const;
  Expr argument(void) const;
  Type destroyed_type(void) const;
  FunctionDecl operator_delete(void) const;
  bool is_array_form(void) const;
  bool is_array_form_as_written(void) const;
  bool is_global_delete(void) const;
};

using CXXDefaultInitExprRange = DerivedEntityRange<StmtIterator, CXXDefaultInitExpr>;
using CXXDefaultInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDefaultInitExpr>;
using CXXDefaultInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXDefaultInitExpr>;

class CXXDefaultInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXDefaultInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDefaultInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDefaultInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_DEFAULT_INIT_EXPR;
  }

  static CXXDefaultInitExprContainingStmtRange containing(const Decl &decl);
  static CXXDefaultInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDefaultInitExpr> from(const TokenContext &c);
  static std::optional<CXXDefaultInitExpr> from(const Expr &parent);

  inline static std::optional<CXXDefaultInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXDefaultInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDefaultInitExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXDefaultInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXDefaultInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDefaultInitExpr> from(const Stmt &parent);

  inline static std::optional<CXXDefaultInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXDefaultInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> expression(void) const;
  FieldDecl field(void) const;
  Token used_token(void) const;
};

using CXXDefaultArgExprRange = DerivedEntityRange<StmtIterator, CXXDefaultArgExpr>;
using CXXDefaultArgExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDefaultArgExpr>;
using CXXDefaultArgExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXDefaultArgExpr>;

class CXXDefaultArgExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXDefaultArgExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDefaultArgExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDefaultArgExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_DEFAULT_ARG_EXPR;
  }

  static CXXDefaultArgExprContainingStmtRange containing(const Decl &decl);
  static CXXDefaultArgExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDefaultArgExpr> from(const TokenContext &c);
  static std::optional<CXXDefaultArgExpr> from(const Expr &parent);

  inline static std::optional<CXXDefaultArgExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXDefaultArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDefaultArgExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXDefaultArgExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXDefaultArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDefaultArgExpr> from(const Stmt &parent);

  inline static std::optional<CXXDefaultArgExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXDefaultArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr expression(void) const;
  ParmVarDecl parameter(void) const;
  Token used_token(void) const;
};

using CXXConstructExprRange = DerivedEntityRange<StmtIterator, CXXConstructExpr>;
using CXXConstructExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXConstructExpr>;
using CXXConstructExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXConstructExpr>;

class CXXConstructExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXConstructExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXConstructExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXConstructExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_CONSTRUCT_EXPR;
  }

  static CXXConstructExprContainingStmtRange containing(const Decl &decl);
  static CXXConstructExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXConstructExpr> from(const TokenContext &c);
  static std::optional<CXXConstructExpr> from(const Expr &parent);

  inline static std::optional<CXXConstructExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXConstructExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructExpr> from(const Stmt &parent);

  inline static std::optional<CXXConstructExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXConstructExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> arguments(void) const;
  CXXConstructExprConstructionKind construction_kind(void) const;
  CXXConstructorDecl constructor(void) const;
  Token token(void) const;
  TokenRange parenthesis_or_brace_range(void) const;
  bool had_multiple_candidates(void) const;
  bool is_elidable(void) const;
  bool is_list_initialization(void) const;
  bool is_std_initializer_list_initialization(void) const;
  bool requires_zero_initialization(void) const;
};

using CXXTemporaryObjectExprRange = DerivedEntityRange<StmtIterator, CXXTemporaryObjectExpr>;
using CXXTemporaryObjectExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXTemporaryObjectExpr>;
using CXXTemporaryObjectExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXTemporaryObjectExpr>;

class CXXTemporaryObjectExpr : public CXXConstructExpr {
 private:
  friend class FragmentImpl;
  friend class CXXConstructExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXTemporaryObjectExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXTemporaryObjectExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXTemporaryObjectExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_TEMPORARY_OBJECT_EXPR;
  }

  static CXXTemporaryObjectExprContainingStmtRange containing(const Decl &decl);
  static CXXTemporaryObjectExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXTemporaryObjectExpr> from(const TokenContext &c);
  static std::optional<CXXTemporaryObjectExpr> from(const CXXConstructExpr &parent);

  inline static std::optional<CXXTemporaryObjectExpr> from(const std::optional<CXXConstructExpr> &parent) {
    if (parent) {
      return CXXTemporaryObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXTemporaryObjectExpr> from(const Expr &parent);

  inline static std::optional<CXXTemporaryObjectExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXTemporaryObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXTemporaryObjectExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXTemporaryObjectExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXTemporaryObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXTemporaryObjectExpr> from(const Stmt &parent);

  inline static std::optional<CXXTemporaryObjectExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXTemporaryObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using CXXBoolLiteralExprRange = DerivedEntityRange<StmtIterator, CXXBoolLiteralExpr>;
using CXXBoolLiteralExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXBoolLiteralExpr>;
using CXXBoolLiteralExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXBoolLiteralExpr>;

class CXXBoolLiteralExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXBoolLiteralExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXBoolLiteralExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXBoolLiteralExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_BOOL_LITERAL_EXPR;
  }

  static CXXBoolLiteralExprContainingStmtRange containing(const Decl &decl);
  static CXXBoolLiteralExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXBoolLiteralExpr> from(const TokenContext &c);
  static std::optional<CXXBoolLiteralExpr> from(const Expr &parent);

  inline static std::optional<CXXBoolLiteralExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXBoolLiteralExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXBoolLiteralExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXBoolLiteralExpr> from(const Stmt &parent);

  inline static std::optional<CXXBoolLiteralExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
  bool value(void) const;
};

using CXXBindTemporaryExprRange = DerivedEntityRange<StmtIterator, CXXBindTemporaryExpr>;
using CXXBindTemporaryExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXBindTemporaryExpr>;
using CXXBindTemporaryExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CXXBindTemporaryExpr>;

class CXXBindTemporaryExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CXXBindTemporaryExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXBindTemporaryExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXBindTemporaryExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CXX_BIND_TEMPORARY_EXPR;
  }

  static CXXBindTemporaryExprContainingStmtRange containing(const Decl &decl);
  static CXXBindTemporaryExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXBindTemporaryExpr> from(const TokenContext &c);
  static std::optional<CXXBindTemporaryExpr> from(const Expr &parent);

  inline static std::optional<CXXBindTemporaryExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CXXBindTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXBindTemporaryExpr> from(const ValueStmt &parent);

  inline static std::optional<CXXBindTemporaryExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CXXBindTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXBindTemporaryExpr> from(const Stmt &parent);

  inline static std::optional<CXXBindTemporaryExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CXXBindTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr sub_expression(void) const;
};

using BlockExprRange = DerivedEntityRange<StmtIterator, BlockExpr>;
using BlockExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, BlockExpr>;
using BlockExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, BlockExpr>;

class BlockExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static BlockExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BlockExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BlockExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::BLOCK_EXPR;
  }

  static BlockExprContainingStmtRange containing(const Decl &decl);
  static BlockExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BlockExpr> from(const TokenContext &c);
  static std::optional<BlockExpr> from(const Expr &parent);

  inline static std::optional<BlockExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return BlockExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BlockExpr> from(const ValueStmt &parent);

  inline static std::optional<BlockExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return BlockExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BlockExpr> from(const Stmt &parent);

  inline static std::optional<BlockExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return BlockExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  BlockDecl block_declaration(void) const;
  Stmt body(void) const;
  Token caret_token(void) const;
  FunctionProtoType function_type(void) const;
};

using BinaryOperatorRange = DerivedEntityRange<StmtIterator, BinaryOperator>;
using BinaryOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, BinaryOperator>;
using BinaryOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, BinaryOperator>;

class BinaryOperator : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static BinaryOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BinaryOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BinaryOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::BINARY_OPERATOR;
  }

  static BinaryOperatorContainingStmtRange containing(const Decl &decl);
  static BinaryOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BinaryOperator> from(const TokenContext &c);
  static std::optional<BinaryOperator> from(const Expr &parent);

  inline static std::optional<BinaryOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return BinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BinaryOperator> from(const ValueStmt &parent);

  inline static std::optional<BinaryOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return BinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BinaryOperator> from(const Stmt &parent);

  inline static std::optional<BinaryOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return BinaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr lhs(void) const;
  BinaryOperatorKind opcode(void) const;
  std::string_view opcode_string(void) const;
  Token operator_token(void) const;
  Expr rhs(void) const;
  bool has_stored_fp_features(void) const;
  bool is_additive_operation(void) const;
  bool is_assignment_operation(void) const;
  bool is_bitwise_operation(void) const;
  bool is_comma_operation(void) const;
  bool is_comparison_operation(void) const;
  bool is_compound_assignment_operation(void) const;
  bool is_equality_operation(void) const;
  bool is_logical_operation(void) const;
  bool is_multiplicative_operation(void) const;
  bool is_pointer_memory_operation(void) const;
  bool is_relational_operation(void) const;
  bool is_shift_assign_operation(void) const;
  bool is_shift_operation(void) const;
};

using CompoundAssignOperatorRange = DerivedEntityRange<StmtIterator, CompoundAssignOperator>;
using CompoundAssignOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, CompoundAssignOperator>;
using CompoundAssignOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CompoundAssignOperator>;

class CompoundAssignOperator : public BinaryOperator {
 private:
  friend class FragmentImpl;
  friend class BinaryOperator;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static CompoundAssignOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CompoundAssignOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CompoundAssignOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::COMPOUND_ASSIGN_OPERATOR;
  }

  static CompoundAssignOperatorContainingStmtRange containing(const Decl &decl);
  static CompoundAssignOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CompoundAssignOperator> from(const TokenContext &c);
  static std::optional<CompoundAssignOperator> from(const BinaryOperator &parent);

  inline static std::optional<CompoundAssignOperator> from(const std::optional<BinaryOperator> &parent) {
    if (parent) {
      return CompoundAssignOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CompoundAssignOperator> from(const Expr &parent);

  inline static std::optional<CompoundAssignOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return CompoundAssignOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CompoundAssignOperator> from(const ValueStmt &parent);

  inline static std::optional<CompoundAssignOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return CompoundAssignOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CompoundAssignOperator> from(const Stmt &parent);

  inline static std::optional<CompoundAssignOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CompoundAssignOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type computation_lhs_type(void) const;
  Type computation_result_type(void) const;
};

using AtomicExprRange = DerivedEntityRange<StmtIterator, AtomicExpr>;
using AtomicExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, AtomicExpr>;
using AtomicExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AtomicExpr>;

class AtomicExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static AtomicExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AtomicExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AtomicExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ATOMIC_EXPR;
  }

  static AtomicExprContainingStmtRange containing(const Decl &decl);
  static AtomicExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AtomicExpr> from(const TokenContext &c);
  static std::optional<AtomicExpr> from(const Expr &parent);

  inline static std::optional<AtomicExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return AtomicExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AtomicExpr> from(const ValueStmt &parent);

  inline static std::optional<AtomicExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return AtomicExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AtomicExpr> from(const Stmt &parent);

  inline static std::optional<AtomicExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AtomicExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  AtomicExprAtomicOp operation(void) const;
  Expr order(void) const;
  std::optional<Expr> order_fail(void) const;
  Expr pointer(void) const;
  Token r_paren_token(void) const;
  std::optional<Expr> scope(void) const;
  std::optional<Expr> value1(void) const;
  std::optional<Expr> value2(void) const;
  Type value_type(void) const;
  std::optional<Expr> weak(void) const;
  bool is_cmp_x_chg(void) const;
  bool is_open_cl(void) const;
  bool is_volatile(void) const;
  std::vector<Expr> sub_expressions(void) const;
};

using AsTypeExprRange = DerivedEntityRange<StmtIterator, AsTypeExpr>;
using AsTypeExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, AsTypeExpr>;
using AsTypeExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AsTypeExpr>;

class AsTypeExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static AsTypeExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AsTypeExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AsTypeExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::AS_TYPE_EXPR;
  }

  static AsTypeExprContainingStmtRange containing(const Decl &decl);
  static AsTypeExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AsTypeExpr> from(const TokenContext &c);
  static std::optional<AsTypeExpr> from(const Expr &parent);

  inline static std::optional<AsTypeExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return AsTypeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AsTypeExpr> from(const ValueStmt &parent);

  inline static std::optional<AsTypeExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return AsTypeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AsTypeExpr> from(const Stmt &parent);

  inline static std::optional<AsTypeExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AsTypeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  Token r_paren_token(void) const;
  Expr src_expression(void) const;
};

using ArrayTypeTraitExprRange = DerivedEntityRange<StmtIterator, ArrayTypeTraitExpr>;
using ArrayTypeTraitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArrayTypeTraitExpr>;
using ArrayTypeTraitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ArrayTypeTraitExpr>;

class ArrayTypeTraitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ArrayTypeTraitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArrayTypeTraitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArrayTypeTraitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ARRAY_TYPE_TRAIT_EXPR;
  }

  static ArrayTypeTraitExprContainingStmtRange containing(const Decl &decl);
  static ArrayTypeTraitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ArrayTypeTraitExpr> from(const TokenContext &c);
  static std::optional<ArrayTypeTraitExpr> from(const Expr &parent);

  inline static std::optional<ArrayTypeTraitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ArrayTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayTypeTraitExpr> from(const ValueStmt &parent);

  inline static std::optional<ArrayTypeTraitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ArrayTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayTypeTraitExpr> from(const Stmt &parent);

  inline static std::optional<ArrayTypeTraitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ArrayTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr dimension_expression(void) const;
  Type queried_type(void) const;
  ArrayTypeTrait trait(void) const;
};

using ArraySubscriptExprRange = DerivedEntityRange<StmtIterator, ArraySubscriptExpr>;
using ArraySubscriptExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArraySubscriptExpr>;
using ArraySubscriptExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ArraySubscriptExpr>;

class ArraySubscriptExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ArraySubscriptExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArraySubscriptExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArraySubscriptExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ARRAY_SUBSCRIPT_EXPR;
  }

  static ArraySubscriptExprContainingStmtRange containing(const Decl &decl);
  static ArraySubscriptExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ArraySubscriptExpr> from(const TokenContext &c);
  static std::optional<ArraySubscriptExpr> from(const Expr &parent);

  inline static std::optional<ArraySubscriptExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ArraySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArraySubscriptExpr> from(const ValueStmt &parent);

  inline static std::optional<ArraySubscriptExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ArraySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArraySubscriptExpr> from(const Stmt &parent);

  inline static std::optional<ArraySubscriptExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ArraySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Expr index(void) const;
  Expr lhs(void) const;
  Token r_bracket_token(void) const;
  Expr rhs(void) const;
};

using ArrayInitLoopExprRange = DerivedEntityRange<StmtIterator, ArrayInitLoopExpr>;
using ArrayInitLoopExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArrayInitLoopExpr>;
using ArrayInitLoopExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ArrayInitLoopExpr>;

class ArrayInitLoopExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ArrayInitLoopExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArrayInitLoopExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArrayInitLoopExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ARRAY_INIT_LOOP_EXPR;
  }

  static ArrayInitLoopExprContainingStmtRange containing(const Decl &decl);
  static ArrayInitLoopExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ArrayInitLoopExpr> from(const TokenContext &c);
  static std::optional<ArrayInitLoopExpr> from(const Expr &parent);

  inline static std::optional<ArrayInitLoopExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ArrayInitLoopExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayInitLoopExpr> from(const ValueStmt &parent);

  inline static std::optional<ArrayInitLoopExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ArrayInitLoopExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayInitLoopExpr> from(const Stmt &parent);

  inline static std::optional<ArrayInitLoopExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ArrayInitLoopExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  OpaqueValueExpr common_expression(void) const;
  Expr sub_expression(void) const;
};

using ArrayInitIndexExprRange = DerivedEntityRange<StmtIterator, ArrayInitIndexExpr>;
using ArrayInitIndexExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ArrayInitIndexExpr>;
using ArrayInitIndexExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ArrayInitIndexExpr>;

class ArrayInitIndexExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ArrayInitIndexExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ArrayInitIndexExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ArrayInitIndexExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ARRAY_INIT_INDEX_EXPR;
  }

  static ArrayInitIndexExprContainingStmtRange containing(const Decl &decl);
  static ArrayInitIndexExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ArrayInitIndexExpr> from(const TokenContext &c);
  static std::optional<ArrayInitIndexExpr> from(const Expr &parent);

  inline static std::optional<ArrayInitIndexExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ArrayInitIndexExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayInitIndexExpr> from(const ValueStmt &parent);

  inline static std::optional<ArrayInitIndexExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ArrayInitIndexExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ArrayInitIndexExpr> from(const Stmt &parent);

  inline static std::optional<ArrayInitIndexExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ArrayInitIndexExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using AddrLabelExprRange = DerivedEntityRange<StmtIterator, AddrLabelExpr>;
using AddrLabelExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, AddrLabelExpr>;
using AddrLabelExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AddrLabelExpr>;

class AddrLabelExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static AddrLabelExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AddrLabelExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AddrLabelExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ADDR_LABEL_EXPR;
  }

  static AddrLabelExprContainingStmtRange containing(const Decl &decl);
  static AddrLabelExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AddrLabelExpr> from(const TokenContext &c);
  static std::optional<AddrLabelExpr> from(const Expr &parent);

  inline static std::optional<AddrLabelExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return AddrLabelExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AddrLabelExpr> from(const ValueStmt &parent);

  inline static std::optional<AddrLabelExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return AddrLabelExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AddrLabelExpr> from(const Stmt &parent);

  inline static std::optional<AddrLabelExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AddrLabelExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token amp_amp_token(void) const;
  LabelDecl label(void) const;
  Token label_token(void) const;
};

using AbstractConditionalOperatorRange = DerivedEntityRange<StmtIterator, AbstractConditionalOperator>;
using AbstractConditionalOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, AbstractConditionalOperator>;
using AbstractConditionalOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AbstractConditionalOperator>;

class AbstractConditionalOperator : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static AbstractConditionalOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AbstractConditionalOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AbstractConditionalOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static AbstractConditionalOperatorContainingStmtRange containing(const Decl &decl);
  static AbstractConditionalOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AbstractConditionalOperator> from(const TokenContext &c);
  static std::optional<AbstractConditionalOperator> from(const Expr &parent);

  inline static std::optional<AbstractConditionalOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return AbstractConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AbstractConditionalOperator> from(const ValueStmt &parent);

  inline static std::optional<AbstractConditionalOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return AbstractConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AbstractConditionalOperator> from(const Stmt &parent);

  inline static std::optional<AbstractConditionalOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AbstractConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token colon_token(void) const;
  Expr condition(void) const;
  Expr false_expression(void) const;
  Token question_token(void) const;
  Expr true_expression(void) const;
};

using ConditionalOperatorRange = DerivedEntityRange<StmtIterator, ConditionalOperator>;
using ConditionalOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConditionalOperator>;
using ConditionalOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ConditionalOperator>;

class ConditionalOperator : public AbstractConditionalOperator {
 private:
  friend class FragmentImpl;
  friend class AbstractConditionalOperator;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ConditionalOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConditionalOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConditionalOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CONDITIONAL_OPERATOR;
  }

  static ConditionalOperatorContainingStmtRange containing(const Decl &decl);
  static ConditionalOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConditionalOperator> from(const TokenContext &c);
  static std::optional<ConditionalOperator> from(const AbstractConditionalOperator &parent);

  inline static std::optional<ConditionalOperator> from(const std::optional<AbstractConditionalOperator> &parent) {
    if (parent) {
      return ConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConditionalOperator> from(const Expr &parent);

  inline static std::optional<ConditionalOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConditionalOperator> from(const ValueStmt &parent);

  inline static std::optional<ConditionalOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConditionalOperator> from(const Stmt &parent);

  inline static std::optional<ConditionalOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr lhs(void) const;
  Expr rhs(void) const;
};

using BinaryConditionalOperatorRange = DerivedEntityRange<StmtIterator, BinaryConditionalOperator>;
using BinaryConditionalOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, BinaryConditionalOperator>;
using BinaryConditionalOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, BinaryConditionalOperator>;

class BinaryConditionalOperator : public AbstractConditionalOperator {
 private:
  friend class FragmentImpl;
  friend class AbstractConditionalOperator;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static BinaryConditionalOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BinaryConditionalOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BinaryConditionalOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::BINARY_CONDITIONAL_OPERATOR;
  }

  static BinaryConditionalOperatorContainingStmtRange containing(const Decl &decl);
  static BinaryConditionalOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BinaryConditionalOperator> from(const TokenContext &c);
  static std::optional<BinaryConditionalOperator> from(const AbstractConditionalOperator &parent);

  inline static std::optional<BinaryConditionalOperator> from(const std::optional<AbstractConditionalOperator> &parent) {
    if (parent) {
      return BinaryConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BinaryConditionalOperator> from(const Expr &parent);

  inline static std::optional<BinaryConditionalOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return BinaryConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BinaryConditionalOperator> from(const ValueStmt &parent);

  inline static std::optional<BinaryConditionalOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return BinaryConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BinaryConditionalOperator> from(const Stmt &parent);

  inline static std::optional<BinaryConditionalOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return BinaryConditionalOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr common(void) const;
  OpaqueValueExpr opaque_value(void) const;
};

using VAArgExprRange = DerivedEntityRange<StmtIterator, VAArgExpr>;
using VAArgExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, VAArgExpr>;
using VAArgExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, VAArgExpr>;

class VAArgExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static VAArgExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VAArgExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VAArgExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::VA_ARG_EXPR;
  }

  static VAArgExprContainingStmtRange containing(const Decl &decl);
  static VAArgExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<VAArgExpr> from(const TokenContext &c);
  static std::optional<VAArgExpr> from(const Expr &parent);

  inline static std::optional<VAArgExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return VAArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VAArgExpr> from(const ValueStmt &parent);

  inline static std::optional<VAArgExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return VAArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VAArgExpr> from(const Stmt &parent);

  inline static std::optional<VAArgExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return VAArgExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  Token r_paren_token(void) const;
  Expr sub_expression(void) const;
  Type written_type(void) const;
  bool is_microsoft_abi(void) const;
};

using UnaryOperatorRange = DerivedEntityRange<StmtIterator, UnaryOperator>;
using UnaryOperatorContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnaryOperator>;
using UnaryOperatorContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, UnaryOperator>;

class UnaryOperator : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static UnaryOperatorRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnaryOperatorContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnaryOperator::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::UNARY_OPERATOR;
  }

  static UnaryOperatorContainingStmtRange containing(const Decl &decl);
  static UnaryOperatorContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnaryOperator> from(const TokenContext &c);
  static std::optional<UnaryOperator> from(const Expr &parent);

  inline static std::optional<UnaryOperator> from(const std::optional<Expr> &parent) {
    if (parent) {
      return UnaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnaryOperator> from(const ValueStmt &parent);

  inline static std::optional<UnaryOperator> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return UnaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnaryOperator> from(const Stmt &parent);

  inline static std::optional<UnaryOperator> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return UnaryOperator::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool can_overflow(void) const;
  UnaryOperatorKind opcode(void) const;
  Token operator_token(void) const;
  Expr sub_expression(void) const;
  bool has_stored_fp_features(void) const;
  bool is_arithmetic_operation(void) const;
  bool is_decrement_operation(void) const;
  bool is_increment_decrement_operation(void) const;
  bool is_increment_operation(void) const;
  bool is_postfix(void) const;
  bool is_prefix(void) const;
};

using UnaryExprOrTypeTraitExprRange = DerivedEntityRange<StmtIterator, UnaryExprOrTypeTraitExpr>;
using UnaryExprOrTypeTraitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnaryExprOrTypeTraitExpr>;
using UnaryExprOrTypeTraitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, UnaryExprOrTypeTraitExpr>;

class UnaryExprOrTypeTraitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static UnaryExprOrTypeTraitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnaryExprOrTypeTraitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnaryExprOrTypeTraitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::UNARY_EXPR_OR_TYPE_TRAIT_EXPR;
  }

  static UnaryExprOrTypeTraitExprContainingStmtRange containing(const Decl &decl);
  static UnaryExprOrTypeTraitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnaryExprOrTypeTraitExpr> from(const TokenContext &c);
  static std::optional<UnaryExprOrTypeTraitExpr> from(const Expr &parent);

  inline static std::optional<UnaryExprOrTypeTraitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return UnaryExprOrTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnaryExprOrTypeTraitExpr> from(const ValueStmt &parent);

  inline static std::optional<UnaryExprOrTypeTraitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return UnaryExprOrTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnaryExprOrTypeTraitExpr> from(const Stmt &parent);

  inline static std::optional<UnaryExprOrTypeTraitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return UnaryExprOrTypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> argument_expression(void) const;
  std::optional<Type> argument_type(void) const;
  UnaryExprOrTypeTrait expression_or_trait_kind(void) const;
  Token operator_token(void) const;
  Token r_paren_token(void) const;
  Type type_of_argument(void) const;
  bool is_argument_type(void) const;
};

using TypoExprRange = DerivedEntityRange<StmtIterator, TypoExpr>;
using TypoExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypoExpr>;
using TypoExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, TypoExpr>;

class TypoExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static TypoExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypoExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypoExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::TYPO_EXPR;
  }

  static TypoExprContainingStmtRange containing(const Decl &decl);
  static TypoExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypoExpr> from(const TokenContext &c);
  static std::optional<TypoExpr> from(const Expr &parent);

  inline static std::optional<TypoExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return TypoExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypoExpr> from(const ValueStmt &parent);

  inline static std::optional<TypoExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return TypoExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypoExpr> from(const Stmt &parent);

  inline static std::optional<TypoExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return TypoExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TypeTraitExprRange = DerivedEntityRange<StmtIterator, TypeTraitExpr>;
using TypeTraitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeTraitExpr>;
using TypeTraitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, TypeTraitExpr>;

class TypeTraitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static TypeTraitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeTraitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeTraitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::TYPE_TRAIT_EXPR;
  }

  static TypeTraitExprContainingStmtRange containing(const Decl &decl);
  static TypeTraitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypeTraitExpr> from(const TokenContext &c);
  static std::optional<TypeTraitExpr> from(const Expr &parent);

  inline static std::optional<TypeTraitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return TypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeTraitExpr> from(const ValueStmt &parent);

  inline static std::optional<TypeTraitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return TypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeTraitExpr> from(const Stmt &parent);

  inline static std::optional<TypeTraitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return TypeTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  TypeTrait trait(void) const;
  std::optional<bool> value(void) const;
  std::vector<Type> arguments(void) const;
};

using SubstNonTypeTemplateParmPackExprRange = DerivedEntityRange<StmtIterator, SubstNonTypeTemplateParmPackExpr>;
using SubstNonTypeTemplateParmPackExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, SubstNonTypeTemplateParmPackExpr>;
using SubstNonTypeTemplateParmPackExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SubstNonTypeTemplateParmPackExpr>;

class SubstNonTypeTemplateParmPackExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static SubstNonTypeTemplateParmPackExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SubstNonTypeTemplateParmPackExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SubstNonTypeTemplateParmPackExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_PACK_EXPR;
  }

  static SubstNonTypeTemplateParmPackExprContainingStmtRange containing(const Decl &decl);
  static SubstNonTypeTemplateParmPackExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SubstNonTypeTemplateParmPackExpr> from(const TokenContext &c);
  static std::optional<SubstNonTypeTemplateParmPackExpr> from(const Expr &parent);

  inline static std::optional<SubstNonTypeTemplateParmPackExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SubstNonTypeTemplateParmPackExpr> from(const ValueStmt &parent);

  inline static std::optional<SubstNonTypeTemplateParmPackExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SubstNonTypeTemplateParmPackExpr> from(const Stmt &parent);

  inline static std::optional<SubstNonTypeTemplateParmPackExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  NonTypeTemplateParmDecl parameter_pack(void) const;
  Token parameter_pack_token(void) const;
};

using SubstNonTypeTemplateParmExprRange = DerivedEntityRange<StmtIterator, SubstNonTypeTemplateParmExpr>;
using SubstNonTypeTemplateParmExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, SubstNonTypeTemplateParmExpr>;
using SubstNonTypeTemplateParmExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SubstNonTypeTemplateParmExpr>;

class SubstNonTypeTemplateParmExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static SubstNonTypeTemplateParmExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SubstNonTypeTemplateParmExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SubstNonTypeTemplateParmExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SUBST_NON_TYPE_TEMPLATE_PARM_EXPR;
  }

  static SubstNonTypeTemplateParmExprContainingStmtRange containing(const Decl &decl);
  static SubstNonTypeTemplateParmExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SubstNonTypeTemplateParmExpr> from(const TokenContext &c);
  static std::optional<SubstNonTypeTemplateParmExpr> from(const Expr &parent);

  inline static std::optional<SubstNonTypeTemplateParmExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SubstNonTypeTemplateParmExpr> from(const ValueStmt &parent);

  inline static std::optional<SubstNonTypeTemplateParmExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SubstNonTypeTemplateParmExpr> from(const Stmt &parent);

  inline static std::optional<SubstNonTypeTemplateParmExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SubstNonTypeTemplateParmExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token name_token(void) const;
  NonTypeTemplateParmDecl parameter(void) const;
  Type parameter_type(void) const;
  Expr replacement(void) const;
  bool is_reference_parameter(void) const;
};

using StringLiteralRange = DerivedEntityRange<StmtIterator, StringLiteral>;
using StringLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, StringLiteral>;
using StringLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, StringLiteral>;

class StringLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static StringLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StringLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StringLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::STRING_LITERAL;
  }

  static StringLiteralContainingStmtRange containing(const Decl &decl);
  static StringLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<StringLiteral> from(const TokenContext &c);
  static std::optional<StringLiteral> from(const Expr &parent);

  inline static std::optional<StringLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return StringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StringLiteral> from(const ValueStmt &parent);

  inline static std::optional<StringLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return StringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StringLiteral> from(const Stmt &parent);

  inline static std::optional<StringLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return StringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<bool> contains_non_ascii(void) const;
  std::optional<bool> contains_non_ascii_or_null(void) const;
  std::string_view bytes(void) const;
  StringLiteralStringKind string_kind(void) const;
  std::optional<std::string_view> string(void) const;
  bool is_ascii(void) const;
  bool is_pascal(void) const;
  bool is_utf16(void) const;
  bool is_utf32(void) const;
  bool is_utf8(void) const;
  bool is_wide(void) const;
};

using StmtExprRange = DerivedEntityRange<StmtIterator, StmtExpr>;
using StmtExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, StmtExpr>;
using StmtExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, StmtExpr>;

class StmtExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static StmtExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StmtExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StmtExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::STMT_EXPR;
  }

  static StmtExprContainingStmtRange containing(const Decl &decl);
  static StmtExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<StmtExpr> from(const TokenContext &c);
  static std::optional<StmtExpr> from(const Expr &parent);

  inline static std::optional<StmtExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return StmtExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StmtExpr> from(const ValueStmt &parent);

  inline static std::optional<StmtExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return StmtExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<StmtExpr> from(const Stmt &parent);

  inline static std::optional<StmtExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return StmtExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  CompoundStmt sub_statement(void) const;
};

using SourceLocExprRange = DerivedEntityRange<StmtIterator, SourceLocExpr>;
using SourceLocExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, SourceLocExpr>;
using SourceLocExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SourceLocExpr>;

class SourceLocExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static SourceLocExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SourceLocExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SourceLocExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SOURCE_LOC_EXPR;
  }

  static SourceLocExprContainingStmtRange containing(const Decl &decl);
  static SourceLocExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SourceLocExpr> from(const TokenContext &c);
  static std::optional<SourceLocExpr> from(const Expr &parent);

  inline static std::optional<SourceLocExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return SourceLocExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SourceLocExpr> from(const ValueStmt &parent);

  inline static std::optional<SourceLocExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return SourceLocExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SourceLocExpr> from(const Stmt &parent);

  inline static std::optional<SourceLocExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SourceLocExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view builtin_string(void) const;
  SourceLocExprIdentKind identifier_kind(void) const;
  Token token(void) const;
  bool is_int_type(void) const;
  bool is_string_type(void) const;
};

using SizeOfPackExprRange = DerivedEntityRange<StmtIterator, SizeOfPackExpr>;
using SizeOfPackExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, SizeOfPackExpr>;
using SizeOfPackExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SizeOfPackExpr>;

class SizeOfPackExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static SizeOfPackExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SizeOfPackExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SizeOfPackExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SIZE_OF_PACK_EXPR;
  }

  static SizeOfPackExprContainingStmtRange containing(const Decl &decl);
  static SizeOfPackExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SizeOfPackExpr> from(const TokenContext &c);
  static std::optional<SizeOfPackExpr> from(const Expr &parent);

  inline static std::optional<SizeOfPackExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return SizeOfPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SizeOfPackExpr> from(const ValueStmt &parent);

  inline static std::optional<SizeOfPackExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return SizeOfPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SizeOfPackExpr> from(const Stmt &parent);

  inline static std::optional<SizeOfPackExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SizeOfPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token operator_token(void) const;
  NamedDecl pack(void) const;
  std::optional<unsigned> pack_length(void) const;
  Token pack_token(void) const;
  std::optional<std::vector<TemplateArgument>> partial_arguments(void) const;
  Token r_paren_token(void) const;
  bool is_partially_substituted(void) const;
};

using ShuffleVectorExprRange = DerivedEntityRange<StmtIterator, ShuffleVectorExpr>;
using ShuffleVectorExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ShuffleVectorExpr>;
using ShuffleVectorExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ShuffleVectorExpr>;

class ShuffleVectorExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ShuffleVectorExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ShuffleVectorExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ShuffleVectorExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SHUFFLE_VECTOR_EXPR;
  }

  static ShuffleVectorExprContainingStmtRange containing(const Decl &decl);
  static ShuffleVectorExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ShuffleVectorExpr> from(const TokenContext &c);
  static std::optional<ShuffleVectorExpr> from(const Expr &parent);

  inline static std::optional<ShuffleVectorExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ShuffleVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ShuffleVectorExpr> from(const ValueStmt &parent);

  inline static std::optional<ShuffleVectorExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ShuffleVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ShuffleVectorExpr> from(const Stmt &parent);

  inline static std::optional<ShuffleVectorExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ShuffleVectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token builtin_token(void) const;
  Token r_paren_token(void) const;
};

using SYCLUniqueStableNameExprRange = DerivedEntityRange<StmtIterator, SYCLUniqueStableNameExpr>;
using SYCLUniqueStableNameExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, SYCLUniqueStableNameExpr>;
using SYCLUniqueStableNameExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SYCLUniqueStableNameExpr>;

class SYCLUniqueStableNameExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static SYCLUniqueStableNameExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SYCLUniqueStableNameExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SYCLUniqueStableNameExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SYCL_UNIQUE_STABLE_NAME_EXPR;
  }

  static SYCLUniqueStableNameExprContainingStmtRange containing(const Decl &decl);
  static SYCLUniqueStableNameExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SYCLUniqueStableNameExpr> from(const TokenContext &c);
  static std::optional<SYCLUniqueStableNameExpr> from(const Expr &parent);

  inline static std::optional<SYCLUniqueStableNameExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return SYCLUniqueStableNameExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SYCLUniqueStableNameExpr> from(const ValueStmt &parent);

  inline static std::optional<SYCLUniqueStableNameExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return SYCLUniqueStableNameExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<SYCLUniqueStableNameExpr> from(const Stmt &parent);

  inline static std::optional<SYCLUniqueStableNameExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SYCLUniqueStableNameExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view compute_name(void) const;
  Token l_paren_token(void) const;
  Token token(void) const;
  Token r_paren_token(void) const;
};

using RequiresExprRange = DerivedEntityRange<StmtIterator, RequiresExpr>;
using RequiresExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, RequiresExpr>;
using RequiresExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, RequiresExpr>;

class RequiresExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static RequiresExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RequiresExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RequiresExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::REQUIRES_EXPR;
  }

  static RequiresExprContainingStmtRange containing(const Decl &decl);
  static RequiresExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<RequiresExpr> from(const TokenContext &c);
  static std::optional<RequiresExpr> from(const Expr &parent);

  inline static std::optional<RequiresExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return RequiresExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RequiresExpr> from(const ValueStmt &parent);

  inline static std::optional<RequiresExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return RequiresExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RequiresExpr> from(const Stmt &parent);

  inline static std::optional<RequiresExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return RequiresExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  RequiresExprBodyDecl body(void) const;
  std::vector<ParmVarDecl> local_parameters(void) const;
  Token r_brace_token(void) const;
  Token requires_keyword_token(void) const;
  bool is_satisfied(void) const;
};

using RecoveryExprRange = DerivedEntityRange<StmtIterator, RecoveryExpr>;
using RecoveryExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, RecoveryExpr>;
using RecoveryExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, RecoveryExpr>;

class RecoveryExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static RecoveryExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RecoveryExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RecoveryExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::RECOVERY_EXPR;
  }

  static RecoveryExprContainingStmtRange containing(const Decl &decl);
  static RecoveryExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<RecoveryExpr> from(const TokenContext &c);
  static std::optional<RecoveryExpr> from(const Expr &parent);

  inline static std::optional<RecoveryExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return RecoveryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecoveryExpr> from(const ValueStmt &parent);

  inline static std::optional<RecoveryExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return RecoveryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecoveryExpr> from(const Stmt &parent);

  inline static std::optional<RecoveryExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return RecoveryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> sub_expressions(void) const;
};

using PseudoObjectExprRange = DerivedEntityRange<StmtIterator, PseudoObjectExpr>;
using PseudoObjectExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, PseudoObjectExpr>;
using PseudoObjectExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, PseudoObjectExpr>;

class PseudoObjectExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static PseudoObjectExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PseudoObjectExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PseudoObjectExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::PSEUDO_OBJECT_EXPR;
  }

  static PseudoObjectExprContainingStmtRange containing(const Decl &decl);
  static PseudoObjectExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<PseudoObjectExpr> from(const TokenContext &c);
  static std::optional<PseudoObjectExpr> from(const Expr &parent);

  inline static std::optional<PseudoObjectExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return PseudoObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PseudoObjectExpr> from(const ValueStmt &parent);

  inline static std::optional<PseudoObjectExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return PseudoObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PseudoObjectExpr> from(const Stmt &parent);

  inline static std::optional<PseudoObjectExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return PseudoObjectExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr result_expression(void) const;
  Expr syntactic_form(void) const;
  std::vector<Expr> semantics(void) const;
  std::vector<Expr> semantic_expressions(void) const;
};

using PredefinedExprRange = DerivedEntityRange<StmtIterator, PredefinedExpr>;
using PredefinedExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, PredefinedExpr>;
using PredefinedExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, PredefinedExpr>;

class PredefinedExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static PredefinedExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PredefinedExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PredefinedExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::PREDEFINED_EXPR;
  }

  static PredefinedExprContainingStmtRange containing(const Decl &decl);
  static PredefinedExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<PredefinedExpr> from(const TokenContext &c);
  static std::optional<PredefinedExpr> from(const Expr &parent);

  inline static std::optional<PredefinedExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return PredefinedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PredefinedExpr> from(const ValueStmt &parent);

  inline static std::optional<PredefinedExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return PredefinedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PredefinedExpr> from(const Stmt &parent);

  inline static std::optional<PredefinedExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return PredefinedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  StringLiteral function_name(void) const;
  PredefinedExprIdentKind identifier_kind(void) const;
  std::string_view identifier_kind_name(void) const;
  Token token(void) const;
};

using ParenListExprRange = DerivedEntityRange<StmtIterator, ParenListExpr>;
using ParenListExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParenListExpr>;
using ParenListExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ParenListExpr>;

class ParenListExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ParenListExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParenListExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParenListExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::PAREN_LIST_EXPR;
  }

  static ParenListExprContainingStmtRange containing(const Decl &decl);
  static ParenListExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ParenListExpr> from(const TokenContext &c);
  static std::optional<ParenListExpr> from(const Expr &parent);

  inline static std::optional<ParenListExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ParenListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParenListExpr> from(const ValueStmt &parent);

  inline static std::optional<ParenListExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ParenListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParenListExpr> from(const Stmt &parent);

  inline static std::optional<ParenListExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ParenListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  std::vector<Expr> expressions(void) const;
};

using ParenExprRange = DerivedEntityRange<StmtIterator, ParenExpr>;
using ParenExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParenExpr>;
using ParenExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ParenExpr>;

class ParenExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ParenExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParenExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParenExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::PAREN_EXPR;
  }

  static ParenExprContainingStmtRange containing(const Decl &decl);
  static ParenExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ParenExpr> from(const TokenContext &c);
  static std::optional<ParenExpr> from(const Expr &parent);

  inline static std::optional<ParenExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ParenExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParenExpr> from(const ValueStmt &parent);

  inline static std::optional<ParenExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ParenExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParenExpr> from(const Stmt &parent);

  inline static std::optional<ParenExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ParenExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  Expr sub_expression(void) const;
};

using PackExpansionExprRange = DerivedEntityRange<StmtIterator, PackExpansionExpr>;
using PackExpansionExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, PackExpansionExpr>;
using PackExpansionExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, PackExpansionExpr>;

class PackExpansionExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static PackExpansionExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PackExpansionExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PackExpansionExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::PACK_EXPANSION_EXPR;
  }

  static PackExpansionExprContainingStmtRange containing(const Decl &decl);
  static PackExpansionExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<PackExpansionExpr> from(const TokenContext &c);
  static std::optional<PackExpansionExpr> from(const Expr &parent);

  inline static std::optional<PackExpansionExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return PackExpansionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PackExpansionExpr> from(const ValueStmt &parent);

  inline static std::optional<PackExpansionExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return PackExpansionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<PackExpansionExpr> from(const Stmt &parent);

  inline static std::optional<PackExpansionExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return PackExpansionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token ellipsis_token(void) const;
  std::optional<unsigned> num_expansions(void) const;
  Expr pattern(void) const;
};

using OverloadExprRange = DerivedEntityRange<StmtIterator, OverloadExpr>;
using OverloadExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OverloadExpr>;
using OverloadExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OverloadExpr>;

class OverloadExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OverloadExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OverloadExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OverloadExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OverloadExprContainingStmtRange containing(const Decl &decl);
  static OverloadExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OverloadExpr> from(const TokenContext &c);
  static std::optional<OverloadExpr> from(const Expr &parent);

  inline static std::optional<OverloadExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OverloadExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OverloadExpr> from(const ValueStmt &parent);

  inline static std::optional<OverloadExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OverloadExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OverloadExpr> from(const Stmt &parent);

  inline static std::optional<OverloadExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OverloadExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token l_angle_token(void) const;
  Token name_token(void) const;
  std::optional<CXXRecordDecl> naming_class(void) const;
  Token r_angle_token(void) const;
  Token template_keyword_token(void) const;
  bool has_explicit_template_arguments(void) const;
  bool has_template_keyword(void) const;
};

using UnresolvedMemberExprRange = DerivedEntityRange<StmtIterator, UnresolvedMemberExpr>;
using UnresolvedMemberExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedMemberExpr>;
using UnresolvedMemberExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, UnresolvedMemberExpr>;

class UnresolvedMemberExpr : public OverloadExpr {
 private:
  friend class FragmentImpl;
  friend class OverloadExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static UnresolvedMemberExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedMemberExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedMemberExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::UNRESOLVED_MEMBER_EXPR;
  }

  static UnresolvedMemberExprContainingStmtRange containing(const Decl &decl);
  static UnresolvedMemberExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnresolvedMemberExpr> from(const TokenContext &c);
  static std::optional<UnresolvedMemberExpr> from(const OverloadExpr &parent);

  inline static std::optional<UnresolvedMemberExpr> from(const std::optional<OverloadExpr> &parent) {
    if (parent) {
      return UnresolvedMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedMemberExpr> from(const Expr &parent);

  inline static std::optional<UnresolvedMemberExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return UnresolvedMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedMemberExpr> from(const ValueStmt &parent);

  inline static std::optional<UnresolvedMemberExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return UnresolvedMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedMemberExpr> from(const Stmt &parent);

  inline static std::optional<UnresolvedMemberExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return UnresolvedMemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Type base_type(void) const;
  Token member_token(void) const;
  Token operator_token(void) const;
  bool has_unresolved_using(void) const;
  bool is_arrow(void) const;
  bool is_implicit_access(void) const;
};

using UnresolvedLookupExprRange = DerivedEntityRange<StmtIterator, UnresolvedLookupExpr>;
using UnresolvedLookupExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedLookupExpr>;
using UnresolvedLookupExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, UnresolvedLookupExpr>;

class UnresolvedLookupExpr : public OverloadExpr {
 private:
  friend class FragmentImpl;
  friend class OverloadExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static UnresolvedLookupExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedLookupExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedLookupExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::UNRESOLVED_LOOKUP_EXPR;
  }

  static UnresolvedLookupExprContainingStmtRange containing(const Decl &decl);
  static UnresolvedLookupExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnresolvedLookupExpr> from(const TokenContext &c);
  static std::optional<UnresolvedLookupExpr> from(const OverloadExpr &parent);

  inline static std::optional<UnresolvedLookupExpr> from(const std::optional<OverloadExpr> &parent) {
    if (parent) {
      return UnresolvedLookupExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedLookupExpr> from(const Expr &parent);

  inline static std::optional<UnresolvedLookupExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return UnresolvedLookupExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedLookupExpr> from(const ValueStmt &parent);

  inline static std::optional<UnresolvedLookupExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return UnresolvedLookupExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedLookupExpr> from(const Stmt &parent);

  inline static std::optional<UnresolvedLookupExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return UnresolvedLookupExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_overloaded(void) const;
  bool requires_adl(void) const;
};

using OpaqueValueExprRange = DerivedEntityRange<StmtIterator, OpaqueValueExpr>;
using OpaqueValueExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OpaqueValueExpr>;
using OpaqueValueExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OpaqueValueExpr>;

class OpaqueValueExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OpaqueValueExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OpaqueValueExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OpaqueValueExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OPAQUE_VALUE_EXPR;
  }

  static OpaqueValueExprContainingStmtRange containing(const Decl &decl);
  static OpaqueValueExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OpaqueValueExpr> from(const TokenContext &c);
  static std::optional<OpaqueValueExpr> from(const Expr &parent);

  inline static std::optional<OpaqueValueExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OpaqueValueExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpaqueValueExpr> from(const ValueStmt &parent);

  inline static std::optional<OpaqueValueExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OpaqueValueExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OpaqueValueExpr> from(const Stmt &parent);

  inline static std::optional<OpaqueValueExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OpaqueValueExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
  Expr source_expression(void) const;
  bool is_unique(void) const;
};

using OffsetOfExprRange = DerivedEntityRange<StmtIterator, OffsetOfExpr>;
using OffsetOfExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OffsetOfExpr>;
using OffsetOfExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OffsetOfExpr>;

class OffsetOfExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OffsetOfExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OffsetOfExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OffsetOfExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OFFSET_OF_EXPR;
  }

  static OffsetOfExprContainingStmtRange containing(const Decl &decl);
  static OffsetOfExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OffsetOfExpr> from(const TokenContext &c);
  static std::optional<OffsetOfExpr> from(const Expr &parent);

  inline static std::optional<OffsetOfExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OffsetOfExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OffsetOfExpr> from(const ValueStmt &parent);

  inline static std::optional<OffsetOfExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OffsetOfExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OffsetOfExpr> from(const Stmt &parent);

  inline static std::optional<OffsetOfExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OffsetOfExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token operator_token(void) const;
  Token r_paren_token(void) const;
};

using ObjCSubscriptRefExprRange = DerivedEntityRange<StmtIterator, ObjCSubscriptRefExpr>;
using ObjCSubscriptRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCSubscriptRefExpr>;
using ObjCSubscriptRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCSubscriptRefExpr>;

class ObjCSubscriptRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCSubscriptRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCSubscriptRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCSubscriptRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_SUBSCRIPT_REF_EXPR;
  }

  static ObjCSubscriptRefExprContainingStmtRange containing(const Decl &decl);
  static ObjCSubscriptRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCSubscriptRefExpr> from(const TokenContext &c);
  static std::optional<ObjCSubscriptRefExpr> from(const Expr &parent);

  inline static std::optional<ObjCSubscriptRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCSubscriptRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCSubscriptRefExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCSubscriptRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCSubscriptRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCSubscriptRefExpr> from(const Stmt &parent);

  inline static std::optional<ObjCSubscriptRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCSubscriptRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCMethodDecl at_index_method_declaration(void) const;
  Expr base_expression(void) const;
  Expr key_expression(void) const;
  Token r_bracket_token(void) const;
  bool is_array_subscript_reference_expression(void) const;
};

using ObjCStringLiteralRange = DerivedEntityRange<StmtIterator, ObjCStringLiteral>;
using ObjCStringLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCStringLiteral>;
using ObjCStringLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCStringLiteral>;

class ObjCStringLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCStringLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCStringLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCStringLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_STRING_LITERAL;
  }

  static ObjCStringLiteralContainingStmtRange containing(const Decl &decl);
  static ObjCStringLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCStringLiteral> from(const TokenContext &c);
  static std::optional<ObjCStringLiteral> from(const Expr &parent);

  inline static std::optional<ObjCStringLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCStringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCStringLiteral> from(const ValueStmt &parent);

  inline static std::optional<ObjCStringLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCStringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCStringLiteral> from(const Stmt &parent);

  inline static std::optional<ObjCStringLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCStringLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  StringLiteral string(void) const;
};

using ObjCSelectorExprRange = DerivedEntityRange<StmtIterator, ObjCSelectorExpr>;
using ObjCSelectorExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCSelectorExpr>;
using ObjCSelectorExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCSelectorExpr>;

class ObjCSelectorExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCSelectorExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCSelectorExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCSelectorExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_SELECTOR_EXPR;
  }

  static ObjCSelectorExprContainingStmtRange containing(const Decl &decl);
  static ObjCSelectorExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCSelectorExpr> from(const TokenContext &c);
  static std::optional<ObjCSelectorExpr> from(const Expr &parent);

  inline static std::optional<ObjCSelectorExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCSelectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCSelectorExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCSelectorExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCSelectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCSelectorExpr> from(const Stmt &parent);

  inline static std::optional<ObjCSelectorExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCSelectorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  Token r_paren_token(void) const;
};

using ObjCProtocolExprRange = DerivedEntityRange<StmtIterator, ObjCProtocolExpr>;
using ObjCProtocolExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCProtocolExpr>;
using ObjCProtocolExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCProtocolExpr>;

class ObjCProtocolExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCProtocolExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCProtocolExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCProtocolExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_PROTOCOL_EXPR;
  }

  static ObjCProtocolExprContainingStmtRange containing(const Decl &decl);
  static ObjCProtocolExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCProtocolExpr> from(const TokenContext &c);
  static std::optional<ObjCProtocolExpr> from(const Expr &parent);

  inline static std::optional<ObjCProtocolExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCProtocolExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCProtocolExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCProtocolExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCProtocolExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCProtocolExpr> from(const Stmt &parent);

  inline static std::optional<ObjCProtocolExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCProtocolExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  ObjCProtocolDecl protocol(void) const;
  Token protocol_id_token(void) const;
  Token r_paren_token(void) const;
};

using ObjCPropertyRefExprRange = DerivedEntityRange<StmtIterator, ObjCPropertyRefExpr>;
using ObjCPropertyRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCPropertyRefExpr>;
using ObjCPropertyRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCPropertyRefExpr>;

class ObjCPropertyRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCPropertyRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCPropertyRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCPropertyRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_PROPERTY_REF_EXPR;
  }

  static ObjCPropertyRefExprContainingStmtRange containing(const Decl &decl);
  static ObjCPropertyRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCPropertyRefExpr> from(const TokenContext &c);
  static std::optional<ObjCPropertyRefExpr> from(const Expr &parent);

  inline static std::optional<ObjCPropertyRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCPropertyRefExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCPropertyRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCPropertyRefExpr> from(const Stmt &parent);

  inline static std::optional<ObjCPropertyRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  ObjCInterfaceDecl class_receiver(void) const;
  ObjCPropertyDecl explicit_property(void) const;
  ObjCMethodDecl implicit_property_getter(void) const;
  ObjCMethodDecl implicit_property_setter(void) const;
  Token token(void) const;
  Token receiver_token(void) const;
  Type receiver_type(void) const;
  Type super_receiver_type(void) const;
  bool is_class_receiver(void) const;
  bool is_explicit_property(void) const;
  bool is_implicit_property(void) const;
  bool is_messaging_getter(void) const;
  bool is_messaging_setter(void) const;
  bool is_object_receiver(void) const;
  bool is_super_receiver(void) const;
};

using ObjCMessageExprRange = DerivedEntityRange<StmtIterator, ObjCMessageExpr>;
using ObjCMessageExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCMessageExpr>;
using ObjCMessageExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCMessageExpr>;

class ObjCMessageExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCMessageExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCMessageExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCMessageExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_MESSAGE_EXPR;
  }

  static ObjCMessageExprContainingStmtRange containing(const Decl &decl);
  static ObjCMessageExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCMessageExpr> from(const TokenContext &c);
  static std::optional<ObjCMessageExpr> from(const Expr &parent);

  inline static std::optional<ObjCMessageExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCMessageExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCMessageExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCMessageExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCMessageExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCMessageExpr> from(const Stmt &parent);

  inline static std::optional<ObjCMessageExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCMessageExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> arguments(void) const;
  Type call_return_type(void) const;
  Type class_receiver(void) const;
  Type class_receiver_type(void) const;
  Expr instance_receiver(void) const;
  Token left_token(void) const;
  ObjCMethodDecl method_declaration(void) const;
  ObjCMethodFamily method_family(void) const;
  ObjCInterfaceDecl receiver_interface(void) const;
  ObjCMessageExprReceiverKind receiver_kind(void) const;
  TokenRange receiver_range(void) const;
  Type receiver_type(void) const;
  Token right_token(void) const;
  Token selector_start_token(void) const;
  Token super_token(void) const;
  Type super_type(void) const;
  bool is_class_message(void) const;
  bool is_delegate_initializer_call(void) const;
  bool is_implicit(void) const;
  bool is_instance_message(void) const;
  std::vector<Token> selector_tokens(void) const;
};

using ObjCIvarRefExprRange = DerivedEntityRange<StmtIterator, ObjCIvarRefExpr>;
using ObjCIvarRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCIvarRefExpr>;
using ObjCIvarRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCIvarRefExpr>;

class ObjCIvarRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCIvarRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCIvarRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCIvarRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_IVAR_REF_EXPR;
  }

  static ObjCIvarRefExprContainingStmtRange containing(const Decl &decl);
  static ObjCIvarRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCIvarRefExpr> from(const TokenContext &c);
  static std::optional<ObjCIvarRefExpr> from(const Expr &parent);

  inline static std::optional<ObjCIvarRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCIvarRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarRefExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCIvarRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCIvarRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarRefExpr> from(const Stmt &parent);

  inline static std::optional<ObjCIvarRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCIvarRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  ObjCIvarDecl declaration(void) const;
  Token token(void) const;
  Token operation_token(void) const;
  bool is_arrow(void) const;
  bool is_free_instance_variable(void) const;
};

using ObjCIsaExprRange = DerivedEntityRange<StmtIterator, ObjCIsaExpr>;
using ObjCIsaExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCIsaExpr>;
using ObjCIsaExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCIsaExpr>;

class ObjCIsaExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCIsaExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCIsaExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCIsaExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_ISA_EXPR;
  }

  static ObjCIsaExprContainingStmtRange containing(const Decl &decl);
  static ObjCIsaExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCIsaExpr> from(const TokenContext &c);
  static std::optional<ObjCIsaExpr> from(const Expr &parent);

  inline static std::optional<ObjCIsaExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCIsaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIsaExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCIsaExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCIsaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIsaExpr> from(const Stmt &parent);

  inline static std::optional<ObjCIsaExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCIsaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Token base_token_end(void) const;
  Token isa_member_token(void) const;
  Token operation_token(void) const;
  bool is_arrow(void) const;
};

using ObjCIndirectCopyRestoreExprRange = DerivedEntityRange<StmtIterator, ObjCIndirectCopyRestoreExpr>;
using ObjCIndirectCopyRestoreExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCIndirectCopyRestoreExpr>;
using ObjCIndirectCopyRestoreExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCIndirectCopyRestoreExpr>;

class ObjCIndirectCopyRestoreExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCIndirectCopyRestoreExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCIndirectCopyRestoreExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCIndirectCopyRestoreExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_INDIRECT_COPY_RESTORE_EXPR;
  }

  static ObjCIndirectCopyRestoreExprContainingStmtRange containing(const Decl &decl);
  static ObjCIndirectCopyRestoreExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCIndirectCopyRestoreExpr> from(const TokenContext &c);
  static std::optional<ObjCIndirectCopyRestoreExpr> from(const Expr &parent);

  inline static std::optional<ObjCIndirectCopyRestoreExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCIndirectCopyRestoreExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIndirectCopyRestoreExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCIndirectCopyRestoreExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCIndirectCopyRestoreExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIndirectCopyRestoreExpr> from(const Stmt &parent);

  inline static std::optional<ObjCIndirectCopyRestoreExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCIndirectCopyRestoreExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr sub_expression(void) const;
  bool should_copy(void) const;
};

using ObjCEncodeExprRange = DerivedEntityRange<StmtIterator, ObjCEncodeExpr>;
using ObjCEncodeExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCEncodeExpr>;
using ObjCEncodeExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCEncodeExpr>;

class ObjCEncodeExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCEncodeExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCEncodeExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCEncodeExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_ENCODE_EXPR;
  }

  static ObjCEncodeExprContainingStmtRange containing(const Decl &decl);
  static ObjCEncodeExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCEncodeExpr> from(const TokenContext &c);
  static std::optional<ObjCEncodeExpr> from(const Expr &parent);

  inline static std::optional<ObjCEncodeExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCEncodeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCEncodeExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCEncodeExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCEncodeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCEncodeExpr> from(const Stmt &parent);

  inline static std::optional<ObjCEncodeExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCEncodeExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  Type encoded_type(void) const;
  Token r_paren_token(void) const;
};

using ObjCDictionaryLiteralRange = DerivedEntityRange<StmtIterator, ObjCDictionaryLiteral>;
using ObjCDictionaryLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCDictionaryLiteral>;
using ObjCDictionaryLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCDictionaryLiteral>;

class ObjCDictionaryLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCDictionaryLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCDictionaryLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCDictionaryLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_DICTIONARY_LITERAL;
  }

  static ObjCDictionaryLiteralContainingStmtRange containing(const Decl &decl);
  static ObjCDictionaryLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCDictionaryLiteral> from(const TokenContext &c);
  static std::optional<ObjCDictionaryLiteral> from(const Expr &parent);

  inline static std::optional<ObjCDictionaryLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCDictionaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCDictionaryLiteral> from(const ValueStmt &parent);

  inline static std::optional<ObjCDictionaryLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCDictionaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCDictionaryLiteral> from(const Stmt &parent);

  inline static std::optional<ObjCDictionaryLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCDictionaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCMethodDecl dictionary_with_objects_method(void) const;
};

using ObjCBoxedExprRange = DerivedEntityRange<StmtIterator, ObjCBoxedExpr>;
using ObjCBoxedExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBoxedExpr>;
using ObjCBoxedExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCBoxedExpr>;

class ObjCBoxedExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCBoxedExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBoxedExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBoxedExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_BOXED_EXPR;
  }

  static ObjCBoxedExprContainingStmtRange containing(const Decl &decl);
  static ObjCBoxedExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCBoxedExpr> from(const TokenContext &c);
  static std::optional<ObjCBoxedExpr> from(const Expr &parent);

  inline static std::optional<ObjCBoxedExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCBoxedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBoxedExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCBoxedExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCBoxedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBoxedExpr> from(const Stmt &parent);

  inline static std::optional<ObjCBoxedExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCBoxedExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  ObjCMethodDecl boxing_method(void) const;
  Expr sub_expression(void) const;
  bool is_expressible_as_constant_initializer(void) const;
};

using ObjCBoolLiteralExprRange = DerivedEntityRange<StmtIterator, ObjCBoolLiteralExpr>;
using ObjCBoolLiteralExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCBoolLiteralExpr>;
using ObjCBoolLiteralExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCBoolLiteralExpr>;

class ObjCBoolLiteralExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCBoolLiteralExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCBoolLiteralExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCBoolLiteralExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_BOOL_LITERAL_EXPR;
  }

  static ObjCBoolLiteralExprContainingStmtRange containing(const Decl &decl);
  static ObjCBoolLiteralExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCBoolLiteralExpr> from(const TokenContext &c);
  static std::optional<ObjCBoolLiteralExpr> from(const Expr &parent);

  inline static std::optional<ObjCBoolLiteralExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBoolLiteralExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCBoolLiteralExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCBoolLiteralExpr> from(const Stmt &parent);

  inline static std::optional<ObjCBoolLiteralExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCBoolLiteralExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
  bool value(void) const;
};

using ObjCAvailabilityCheckExprRange = DerivedEntityRange<StmtIterator, ObjCAvailabilityCheckExpr>;
using ObjCAvailabilityCheckExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAvailabilityCheckExpr>;
using ObjCAvailabilityCheckExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCAvailabilityCheckExpr>;

class ObjCAvailabilityCheckExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCAvailabilityCheckExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAvailabilityCheckExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAvailabilityCheckExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_AVAILABILITY_CHECK_EXPR;
  }

  static ObjCAvailabilityCheckExprContainingStmtRange containing(const Decl &decl);
  static ObjCAvailabilityCheckExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAvailabilityCheckExpr> from(const TokenContext &c);
  static std::optional<ObjCAvailabilityCheckExpr> from(const Expr &parent);

  inline static std::optional<ObjCAvailabilityCheckExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCAvailabilityCheckExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAvailabilityCheckExpr> from(const ValueStmt &parent);

  inline static std::optional<ObjCAvailabilityCheckExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCAvailabilityCheckExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAvailabilityCheckExpr> from(const Stmt &parent);

  inline static std::optional<ObjCAvailabilityCheckExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCAvailabilityCheckExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_version(void) const;
};

using ObjCArrayLiteralRange = DerivedEntityRange<StmtIterator, ObjCArrayLiteral>;
using ObjCArrayLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCArrayLiteral>;
using ObjCArrayLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ObjCArrayLiteral>;

class ObjCArrayLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ObjCArrayLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCArrayLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCArrayLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OBJ_C_ARRAY_LITERAL;
  }

  static ObjCArrayLiteralContainingStmtRange containing(const Decl &decl);
  static ObjCArrayLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCArrayLiteral> from(const TokenContext &c);
  static std::optional<ObjCArrayLiteral> from(const Expr &parent);

  inline static std::optional<ObjCArrayLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ObjCArrayLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCArrayLiteral> from(const ValueStmt &parent);

  inline static std::optional<ObjCArrayLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ObjCArrayLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCArrayLiteral> from(const Stmt &parent);

  inline static std::optional<ObjCArrayLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ObjCArrayLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCMethodDecl array_with_objects_method(void) const;
  std::vector<Expr> elements(void) const;
};

using OMPIteratorExprRange = DerivedEntityRange<StmtIterator, OMPIteratorExpr>;
using OMPIteratorExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPIteratorExpr>;
using OMPIteratorExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPIteratorExpr>;

class OMPIteratorExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OMPIteratorExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPIteratorExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPIteratorExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_ITERATOR_EXPR;
  }

  static OMPIteratorExprContainingStmtRange containing(const Decl &decl);
  static OMPIteratorExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPIteratorExpr> from(const TokenContext &c);
  static std::optional<OMPIteratorExpr> from(const Expr &parent);

  inline static std::optional<OMPIteratorExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OMPIteratorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPIteratorExpr> from(const ValueStmt &parent);

  inline static std::optional<OMPIteratorExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OMPIteratorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPIteratorExpr> from(const Stmt &parent);

  inline static std::optional<OMPIteratorExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPIteratorExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token iterator_kw_token(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
};

using OMPArrayShapingExprRange = DerivedEntityRange<StmtIterator, OMPArrayShapingExpr>;
using OMPArrayShapingExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPArrayShapingExpr>;
using OMPArrayShapingExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPArrayShapingExpr>;

class OMPArrayShapingExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OMPArrayShapingExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPArrayShapingExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPArrayShapingExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_ARRAY_SHAPING_EXPR;
  }

  static OMPArrayShapingExprContainingStmtRange containing(const Decl &decl);
  static OMPArrayShapingExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPArrayShapingExpr> from(const TokenContext &c);
  static std::optional<OMPArrayShapingExpr> from(const Expr &parent);

  inline static std::optional<OMPArrayShapingExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OMPArrayShapingExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPArrayShapingExpr> from(const ValueStmt &parent);

  inline static std::optional<OMPArrayShapingExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OMPArrayShapingExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPArrayShapingExpr> from(const Stmt &parent);

  inline static std::optional<OMPArrayShapingExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPArrayShapingExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  std::vector<Expr> dimensions(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
};

using OMPArraySectionExprRange = DerivedEntityRange<StmtIterator, OMPArraySectionExpr>;
using OMPArraySectionExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPArraySectionExpr>;
using OMPArraySectionExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, OMPArraySectionExpr>;

class OMPArraySectionExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static OMPArraySectionExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPArraySectionExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPArraySectionExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::OMP_ARRAY_SECTION_EXPR;
  }

  static OMPArraySectionExprContainingStmtRange containing(const Decl &decl);
  static OMPArraySectionExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPArraySectionExpr> from(const TokenContext &c);
  static std::optional<OMPArraySectionExpr> from(const Expr &parent);

  inline static std::optional<OMPArraySectionExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return OMPArraySectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPArraySectionExpr> from(const ValueStmt &parent);

  inline static std::optional<OMPArraySectionExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return OMPArraySectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPArraySectionExpr> from(const Stmt &parent);

  inline static std::optional<OMPArraySectionExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return OMPArraySectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Token first_colon_token(void) const;
  Token second_colon_token(void) const;
  Expr length(void) const;
  Expr lower_bound(void) const;
  Token r_bracket_token(void) const;
  Expr stride(void) const;
};

using NoInitExprRange = DerivedEntityRange<StmtIterator, NoInitExpr>;
using NoInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, NoInitExpr>;
using NoInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, NoInitExpr>;

class NoInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static NoInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NoInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NoInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::NO_INIT_EXPR;
  }

  static NoInitExprContainingStmtRange containing(const Decl &decl);
  static NoInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NoInitExpr> from(const TokenContext &c);
  static std::optional<NoInitExpr> from(const Expr &parent);

  inline static std::optional<NoInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return NoInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoInitExpr> from(const ValueStmt &parent);

  inline static std::optional<NoInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return NoInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NoInitExpr> from(const Stmt &parent);

  inline static std::optional<NoInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return NoInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using MemberExprRange = DerivedEntityRange<StmtIterator, MemberExpr>;
using MemberExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, MemberExpr>;
using MemberExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MemberExpr>;

class MemberExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static MemberExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MemberExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MemberExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MEMBER_EXPR;
  }

  static MemberExprContainingStmtRange containing(const Decl &decl);
  static MemberExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MemberExpr> from(const TokenContext &c);
  static std::optional<MemberExpr> from(const Expr &parent);

  inline static std::optional<MemberExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return MemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MemberExpr> from(const ValueStmt &parent);

  inline static std::optional<MemberExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return MemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MemberExpr> from(const Stmt &parent);

  inline static std::optional<MemberExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MemberExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Token l_angle_token(void) const;
  ValueDecl member_declaration(void) const;
  Token member_token(void) const;
  Token operator_token(void) const;
  Token r_angle_token(void) const;
  Token template_keyword_token(void) const;
  bool had_multiple_candidates(void) const;
  bool has_explicit_template_arguments(void) const;
  bool has_qualifier(void) const;
  bool has_template_keyword(void) const;
  bool is_arrow(void) const;
  bool is_implicit_access(void) const;
  NonOdrUseReason is_non_odr_use(void) const;
};

using MatrixSubscriptExprRange = DerivedEntityRange<StmtIterator, MatrixSubscriptExpr>;
using MatrixSubscriptExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, MatrixSubscriptExpr>;
using MatrixSubscriptExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MatrixSubscriptExpr>;

class MatrixSubscriptExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static MatrixSubscriptExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MatrixSubscriptExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MatrixSubscriptExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MATRIX_SUBSCRIPT_EXPR;
  }

  static MatrixSubscriptExprContainingStmtRange containing(const Decl &decl);
  static MatrixSubscriptExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MatrixSubscriptExpr> from(const TokenContext &c);
  static std::optional<MatrixSubscriptExpr> from(const Expr &parent);

  inline static std::optional<MatrixSubscriptExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return MatrixSubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MatrixSubscriptExpr> from(const ValueStmt &parent);

  inline static std::optional<MatrixSubscriptExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return MatrixSubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MatrixSubscriptExpr> from(const Stmt &parent);

  inline static std::optional<MatrixSubscriptExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MatrixSubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Expr column_index(void) const;
  Token r_bracket_token(void) const;
  Expr row_index(void) const;
  bool is_incomplete(void) const;
};

using MaterializeTemporaryExprRange = DerivedEntityRange<StmtIterator, MaterializeTemporaryExpr>;
using MaterializeTemporaryExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, MaterializeTemporaryExpr>;
using MaterializeTemporaryExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MaterializeTemporaryExpr>;

class MaterializeTemporaryExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static MaterializeTemporaryExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MaterializeTemporaryExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MaterializeTemporaryExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MATERIALIZE_TEMPORARY_EXPR;
  }

  static MaterializeTemporaryExprContainingStmtRange containing(const Decl &decl);
  static MaterializeTemporaryExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MaterializeTemporaryExpr> from(const TokenContext &c);
  static std::optional<MaterializeTemporaryExpr> from(const Expr &parent);

  inline static std::optional<MaterializeTemporaryExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return MaterializeTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MaterializeTemporaryExpr> from(const ValueStmt &parent);

  inline static std::optional<MaterializeTemporaryExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return MaterializeTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MaterializeTemporaryExpr> from(const Stmt &parent);

  inline static std::optional<MaterializeTemporaryExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MaterializeTemporaryExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<ValueDecl> extending_declaration(void) const;
  std::optional<LifetimeExtendedTemporaryDecl> lifetime_extended_temporary_declaration(void) const;
  StorageDuration storage_duration(void) const;
  Expr sub_expression(void) const;
  bool is_bound_to_lvalue_reference(void) const;
  bool is_usable_in_constant_expressions(void) const;
};

using MSPropertySubscriptExprRange = DerivedEntityRange<StmtIterator, MSPropertySubscriptExpr>;
using MSPropertySubscriptExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSPropertySubscriptExpr>;
using MSPropertySubscriptExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MSPropertySubscriptExpr>;

class MSPropertySubscriptExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static MSPropertySubscriptExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSPropertySubscriptExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSPropertySubscriptExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MS_PROPERTY_SUBSCRIPT_EXPR;
  }

  static MSPropertySubscriptExprContainingStmtRange containing(const Decl &decl);
  static MSPropertySubscriptExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSPropertySubscriptExpr> from(const TokenContext &c);
  static std::optional<MSPropertySubscriptExpr> from(const Expr &parent);

  inline static std::optional<MSPropertySubscriptExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return MSPropertySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertySubscriptExpr> from(const ValueStmt &parent);

  inline static std::optional<MSPropertySubscriptExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return MSPropertySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertySubscriptExpr> from(const Stmt &parent);

  inline static std::optional<MSPropertySubscriptExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MSPropertySubscriptExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base(void) const;
  Expr index(void) const;
  Token r_bracket_token(void) const;
};

using MSPropertyRefExprRange = DerivedEntityRange<StmtIterator, MSPropertyRefExpr>;
using MSPropertyRefExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSPropertyRefExpr>;
using MSPropertyRefExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, MSPropertyRefExpr>;

class MSPropertyRefExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static MSPropertyRefExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSPropertyRefExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSPropertyRefExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::MS_PROPERTY_REF_EXPR;
  }

  static MSPropertyRefExprContainingStmtRange containing(const Decl &decl);
  static MSPropertyRefExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSPropertyRefExpr> from(const TokenContext &c);
  static std::optional<MSPropertyRefExpr> from(const Expr &parent);

  inline static std::optional<MSPropertyRefExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return MSPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertyRefExpr> from(const ValueStmt &parent);

  inline static std::optional<MSPropertyRefExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return MSPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertyRefExpr> from(const Stmt &parent);

  inline static std::optional<MSPropertyRefExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return MSPropertyRefExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr base_expression(void) const;
  Token member_token(void) const;
  MSPropertyDecl property_declaration(void) const;
  bool is_arrow(void) const;
  bool is_implicit_access(void) const;
};

using LambdaExprRange = DerivedEntityRange<StmtIterator, LambdaExpr>;
using LambdaExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, LambdaExpr>;
using LambdaExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, LambdaExpr>;

class LambdaExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static LambdaExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LambdaExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LambdaExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::LAMBDA_EXPR;
  }

  static LambdaExprContainingStmtRange containing(const Decl &decl);
  static LambdaExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<LambdaExpr> from(const TokenContext &c);
  static std::optional<LambdaExpr> from(const Expr &parent);

  inline static std::optional<LambdaExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return LambdaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LambdaExpr> from(const ValueStmt &parent);

  inline static std::optional<LambdaExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return LambdaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LambdaExpr> from(const Stmt &parent);

  inline static std::optional<LambdaExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return LambdaExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  CXXMethodDecl call_operator(void) const;
  LambdaCaptureDefault capture_default(void) const;
  Token capture_default_token(void) const;
  CompoundStmt compound_statement_body(void) const;
  std::vector<NamedDecl> explicit_template_parameters(void) const;
  TokenRange introducer_range(void) const;
  CXXRecordDecl lambda_class(void) const;
  std::optional<TemplateParameterList> template_parameter_list(void) const;
  std::optional<Expr> trailing_requires_clause(void) const;
  bool has_explicit_parameters(void) const;
  bool has_explicit_result_type(void) const;
  bool is_generic_lambda(void) const;
  bool is_mutable(void) const;
};

using IntegerLiteralRange = DerivedEntityRange<StmtIterator, IntegerLiteral>;
using IntegerLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, IntegerLiteral>;
using IntegerLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, IntegerLiteral>;

class IntegerLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static IntegerLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IntegerLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IntegerLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::INTEGER_LITERAL;
  }

  static IntegerLiteralContainingStmtRange containing(const Decl &decl);
  static IntegerLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<IntegerLiteral> from(const TokenContext &c);
  static std::optional<IntegerLiteral> from(const Expr &parent);

  inline static std::optional<IntegerLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return IntegerLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IntegerLiteral> from(const ValueStmt &parent);

  inline static std::optional<IntegerLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return IntegerLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IntegerLiteral> from(const Stmt &parent);

  inline static std::optional<IntegerLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return IntegerLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
};

using InitListExprRange = DerivedEntityRange<StmtIterator, InitListExpr>;
using InitListExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, InitListExpr>;
using InitListExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, InitListExpr>;

class InitListExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static InitListExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static InitListExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : InitListExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::INIT_LIST_EXPR;
  }

  static InitListExprContainingStmtRange containing(const Decl &decl);
  static InitListExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<InitListExpr> from(const TokenContext &c);
  static std::optional<InitListExpr> from(const Expr &parent);

  inline static std::optional<InitListExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return InitListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<InitListExpr> from(const ValueStmt &parent);

  inline static std::optional<InitListExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return InitListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<InitListExpr> from(const Stmt &parent);

  inline static std::optional<InitListExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return InitListExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> array_filler(void) const;
  std::optional<FieldDecl> initialized_field_in_union(void) const;
  Token l_brace_token(void) const;
  Token r_brace_token(void) const;
  std::optional<InitListExpr> semantic_form(void) const;
  std::optional<InitListExpr> syntactic_form(void) const;
  bool had_array_range_designator(void) const;
  bool has_array_filler(void) const;
  std::vector<Expr> initializers(void) const;
  bool is_explicit(void) const;
  bool is_semantic_form(void) const;
  bool is_string_literal_initializer(void) const;
  bool is_syntactic_form(void) const;
  std::optional<bool> is_transparent(void) const;
};

using ImplicitValueInitExprRange = DerivedEntityRange<StmtIterator, ImplicitValueInitExpr>;
using ImplicitValueInitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ImplicitValueInitExpr>;
using ImplicitValueInitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ImplicitValueInitExpr>;

class ImplicitValueInitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ImplicitValueInitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ImplicitValueInitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ImplicitValueInitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::IMPLICIT_VALUE_INIT_EXPR;
  }

  static ImplicitValueInitExprContainingStmtRange containing(const Decl &decl);
  static ImplicitValueInitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ImplicitValueInitExpr> from(const TokenContext &c);
  static std::optional<ImplicitValueInitExpr> from(const Expr &parent);

  inline static std::optional<ImplicitValueInitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ImplicitValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitValueInitExpr> from(const ValueStmt &parent);

  inline static std::optional<ImplicitValueInitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ImplicitValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitValueInitExpr> from(const Stmt &parent);

  inline static std::optional<ImplicitValueInitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ImplicitValueInitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using ImaginaryLiteralRange = DerivedEntityRange<StmtIterator, ImaginaryLiteral>;
using ImaginaryLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, ImaginaryLiteral>;
using ImaginaryLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ImaginaryLiteral>;

class ImaginaryLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ImaginaryLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ImaginaryLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ImaginaryLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::IMAGINARY_LITERAL;
  }

  static ImaginaryLiteralContainingStmtRange containing(const Decl &decl);
  static ImaginaryLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ImaginaryLiteral> from(const TokenContext &c);
  static std::optional<ImaginaryLiteral> from(const Expr &parent);

  inline static std::optional<ImaginaryLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ImaginaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImaginaryLiteral> from(const ValueStmt &parent);

  inline static std::optional<ImaginaryLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ImaginaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImaginaryLiteral> from(const Stmt &parent);

  inline static std::optional<ImaginaryLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ImaginaryLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr sub_expression(void) const;
};

using GenericSelectionExprRange = DerivedEntityRange<StmtIterator, GenericSelectionExpr>;
using GenericSelectionExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, GenericSelectionExpr>;
using GenericSelectionExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, GenericSelectionExpr>;

class GenericSelectionExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static GenericSelectionExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GenericSelectionExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GenericSelectionExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::GENERIC_SELECTION_EXPR;
  }

  static GenericSelectionExprContainingStmtRange containing(const Decl &decl);
  static GenericSelectionExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<GenericSelectionExpr> from(const TokenContext &c);
  static std::optional<GenericSelectionExpr> from(const Expr &parent);

  inline static std::optional<GenericSelectionExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return GenericSelectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GenericSelectionExpr> from(const ValueStmt &parent);

  inline static std::optional<GenericSelectionExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return GenericSelectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GenericSelectionExpr> from(const Stmt &parent);

  inline static std::optional<GenericSelectionExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return GenericSelectionExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> association_expressions(void) const;
  Expr controlling_expression(void) const;
  Token default_token(void) const;
  Token generic_token(void) const;
  Token r_paren_token(void) const;
  Expr result_expression(void) const;
  bool is_result_dependent(void) const;
};

using GNUNullExprRange = DerivedEntityRange<StmtIterator, GNUNullExpr>;
using GNUNullExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, GNUNullExpr>;
using GNUNullExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, GNUNullExpr>;

class GNUNullExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static GNUNullExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static GNUNullExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : GNUNullExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::GNU_NULL_EXPR;
  }

  static GNUNullExprContainingStmtRange containing(const Decl &decl);
  static GNUNullExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<GNUNullExpr> from(const TokenContext &c);
  static std::optional<GNUNullExpr> from(const Expr &parent);

  inline static std::optional<GNUNullExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return GNUNullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GNUNullExpr> from(const ValueStmt &parent);

  inline static std::optional<GNUNullExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return GNUNullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<GNUNullExpr> from(const Stmt &parent);

  inline static std::optional<GNUNullExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return GNUNullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token_token(void) const;
};

using FunctionParmPackExprRange = DerivedEntityRange<StmtIterator, FunctionParmPackExpr>;
using FunctionParmPackExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionParmPackExpr>;
using FunctionParmPackExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, FunctionParmPackExpr>;

class FunctionParmPackExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static FunctionParmPackExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionParmPackExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionParmPackExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::FUNCTION_PARM_PACK_EXPR;
  }

  static FunctionParmPackExprContainingStmtRange containing(const Decl &decl);
  static FunctionParmPackExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FunctionParmPackExpr> from(const TokenContext &c);
  static std::optional<FunctionParmPackExpr> from(const Expr &parent);

  inline static std::optional<FunctionParmPackExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return FunctionParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionParmPackExpr> from(const ValueStmt &parent);

  inline static std::optional<FunctionParmPackExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return FunctionParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionParmPackExpr> from(const Stmt &parent);

  inline static std::optional<FunctionParmPackExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return FunctionParmPackExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  VarDecl parameter_pack(void) const;
  Token parameter_pack_token(void) const;
  std::vector<VarDecl> expansions(void) const;
};

using FullExprRange = DerivedEntityRange<StmtIterator, FullExpr>;
using FullExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, FullExpr>;
using FullExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, FullExpr>;

class FullExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static FullExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FullExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FullExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static FullExprContainingStmtRange containing(const Decl &decl);
  static FullExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FullExpr> from(const TokenContext &c);
  static std::optional<FullExpr> from(const Expr &parent);

  inline static std::optional<FullExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return FullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FullExpr> from(const ValueStmt &parent);

  inline static std::optional<FullExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return FullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FullExpr> from(const Stmt &parent);

  inline static std::optional<FullExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return FullExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr sub_expression(void) const;
};

using ExprWithCleanupsRange = DerivedEntityRange<StmtIterator, ExprWithCleanups>;
using ExprWithCleanupsContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExprWithCleanups>;
using ExprWithCleanupsContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ExprWithCleanups>;

class ExprWithCleanups : public FullExpr {
 private:
  friend class FragmentImpl;
  friend class FullExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ExprWithCleanupsRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExprWithCleanupsContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExprWithCleanups::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::EXPR_WITH_CLEANUPS;
  }

  static ExprWithCleanupsContainingStmtRange containing(const Decl &decl);
  static ExprWithCleanupsContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExprWithCleanups> from(const TokenContext &c);
  static std::optional<ExprWithCleanups> from(const FullExpr &parent);

  inline static std::optional<ExprWithCleanups> from(const std::optional<FullExpr> &parent) {
    if (parent) {
      return ExprWithCleanups::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExprWithCleanups> from(const Expr &parent);

  inline static std::optional<ExprWithCleanups> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ExprWithCleanups::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExprWithCleanups> from(const ValueStmt &parent);

  inline static std::optional<ExprWithCleanups> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ExprWithCleanups::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExprWithCleanups> from(const Stmt &parent);

  inline static std::optional<ExprWithCleanups> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ExprWithCleanups::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool cleanups_have_side_effects(void) const;
};

using ConstantExprRange = DerivedEntityRange<StmtIterator, ConstantExpr>;
using ConstantExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstantExpr>;
using ConstantExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ConstantExpr>;

class ConstantExpr : public FullExpr {
 private:
  friend class FragmentImpl;
  friend class FullExpr;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ConstantExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstantExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstantExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CONSTANT_EXPR;
  }

  static ConstantExprContainingStmtRange containing(const Decl &decl);
  static ConstantExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConstantExpr> from(const TokenContext &c);
  static std::optional<ConstantExpr> from(const FullExpr &parent);

  inline static std::optional<ConstantExpr> from(const std::optional<FullExpr> &parent) {
    if (parent) {
      return ConstantExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstantExpr> from(const Expr &parent);

  inline static std::optional<ConstantExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ConstantExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstantExpr> from(const ValueStmt &parent);

  inline static std::optional<ConstantExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ConstantExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstantExpr> from(const Stmt &parent);

  inline static std::optional<ConstantExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ConstantExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ConstantExprResultStorageKind result_storage_kind(void) const;
  bool has_ap_value_result(void) const;
  bool is_immediate_invocation(void) const;
};

using FloatingLiteralRange = DerivedEntityRange<StmtIterator, FloatingLiteral>;
using FloatingLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, FloatingLiteral>;
using FloatingLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, FloatingLiteral>;

class FloatingLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static FloatingLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FloatingLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FloatingLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::FLOATING_LITERAL;
  }

  static FloatingLiteralContainingStmtRange containing(const Decl &decl);
  static FloatingLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FloatingLiteral> from(const TokenContext &c);
  static std::optional<FloatingLiteral> from(const Expr &parent);

  inline static std::optional<FloatingLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return FloatingLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FloatingLiteral> from(const ValueStmt &parent);

  inline static std::optional<FloatingLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return FloatingLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FloatingLiteral> from(const Stmt &parent);

  inline static std::optional<FloatingLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return FloatingLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
  bool is_exact(void) const;
};

using FixedPointLiteralRange = DerivedEntityRange<StmtIterator, FixedPointLiteral>;
using FixedPointLiteralContainingTokenRange = DerivedEntityRange<TokenContextIterator, FixedPointLiteral>;
using FixedPointLiteralContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, FixedPointLiteral>;

class FixedPointLiteral : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static FixedPointLiteralRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FixedPointLiteralContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FixedPointLiteral::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::FIXED_POINT_LITERAL;
  }

  static FixedPointLiteralContainingStmtRange containing(const Decl &decl);
  static FixedPointLiteralContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FixedPointLiteral> from(const TokenContext &c);
  static std::optional<FixedPointLiteral> from(const Expr &parent);

  inline static std::optional<FixedPointLiteral> from(const std::optional<Expr> &parent) {
    if (parent) {
      return FixedPointLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FixedPointLiteral> from(const ValueStmt &parent);

  inline static std::optional<FixedPointLiteral> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return FixedPointLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FixedPointLiteral> from(const Stmt &parent);

  inline static std::optional<FixedPointLiteral> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return FixedPointLiteral::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token token(void) const;
};

using ExtVectorElementExprRange = DerivedEntityRange<StmtIterator, ExtVectorElementExpr>;
using ExtVectorElementExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExtVectorElementExpr>;
using ExtVectorElementExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ExtVectorElementExpr>;

class ExtVectorElementExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ExtVectorElementExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExtVectorElementExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExtVectorElementExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::EXT_VECTOR_ELEMENT_EXPR;
  }

  static ExtVectorElementExprContainingStmtRange containing(const Decl &decl);
  static ExtVectorElementExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExtVectorElementExpr> from(const TokenContext &c);
  static std::optional<ExtVectorElementExpr> from(const Expr &parent);

  inline static std::optional<ExtVectorElementExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ExtVectorElementExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExtVectorElementExpr> from(const ValueStmt &parent);

  inline static std::optional<ExtVectorElementExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ExtVectorElementExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExtVectorElementExpr> from(const Stmt &parent);

  inline static std::optional<ExtVectorElementExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ExtVectorElementExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool contains_duplicate_elements(void) const;
  Token accessor_token(void) const;
  Expr base(void) const;
  bool is_arrow(void) const;
};

using ExpressionTraitExprRange = DerivedEntityRange<StmtIterator, ExpressionTraitExpr>;
using ExpressionTraitExprContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExpressionTraitExpr>;
using ExpressionTraitExprContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, ExpressionTraitExpr>;

class ExpressionTraitExpr : public Expr {
 private:
  friend class FragmentImpl;
  friend class Expr;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static ExpressionTraitExprRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExpressionTraitExprContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExpressionTraitExpr::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::EXPRESSION_TRAIT_EXPR;
  }

  static ExpressionTraitExprContainingStmtRange containing(const Decl &decl);
  static ExpressionTraitExprContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExpressionTraitExpr> from(const TokenContext &c);
  static std::optional<ExpressionTraitExpr> from(const Expr &parent);

  inline static std::optional<ExpressionTraitExpr> from(const std::optional<Expr> &parent) {
    if (parent) {
      return ExpressionTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExpressionTraitExpr> from(const ValueStmt &parent);

  inline static std::optional<ExpressionTraitExpr> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return ExpressionTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ExpressionTraitExpr> from(const Stmt &parent);

  inline static std::optional<ExpressionTraitExpr> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return ExpressionTraitExpr::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr queried_expression(void) const;
  ExpressionTrait trait(void) const;
  bool value(void) const;
};

using AttributedStmtRange = DerivedEntityRange<StmtIterator, AttributedStmt>;
using AttributedStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, AttributedStmt>;
using AttributedStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, AttributedStmt>;

class AttributedStmt : public ValueStmt {
 private:
  friend class FragmentImpl;
  friend class ValueStmt;
  friend class Stmt;
 public:
  inline static AttributedStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AttributedStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AttributedStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::ATTRIBUTED_STMT;
  }

  static AttributedStmtContainingStmtRange containing(const Decl &decl);
  static AttributedStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AttributedStmt> from(const TokenContext &c);
  static std::optional<AttributedStmt> from(const ValueStmt &parent);

  inline static std::optional<AttributedStmt> from(const std::optional<ValueStmt> &parent) {
    if (parent) {
      return AttributedStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<AttributedStmt> from(const Stmt &parent);

  inline static std::optional<AttributedStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return AttributedStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token attribute_token(void) const;
  std::vector<Attr> attributes(void) const;
  Stmt sub_statement(void) const;
};

using SwitchStmtRange = DerivedEntityRange<StmtIterator, SwitchStmt>;
using SwitchStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwitchStmt>;
using SwitchStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SwitchStmt>;

class SwitchStmt : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SwitchStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwitchStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwitchStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::SWITCH_STMT;
  }

  static SwitchStmtContainingStmtRange containing(const Decl &decl);
  static SwitchStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SwitchStmt> from(const TokenContext &c);
  static std::optional<SwitchStmt> from(const Stmt &parent);

  inline static std::optional<SwitchStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SwitchStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Stmt body(void) const;
  Expr condition(void) const;
  std::optional<VarDecl> condition_variable(void) const;
  std::optional<DeclStmt> condition_variable_declaration_statement(void) const;
  std::optional<Stmt> initializer(void) const;
  Token l_paren_token(void) const;
  Token r_paren_token(void) const;
  std::optional<SwitchCase> first_switch_case(void) const;
  Token switch_token(void) const;
  bool has_initializer_storage(void) const;
  bool has_variable_storage(void) const;
  bool is_all_enum_cases_covered(void) const;
};

using SwitchCaseRange = DerivedEntityRange<StmtIterator, SwitchCase>;
using SwitchCaseContainingTokenRange = DerivedEntityRange<TokenContextIterator, SwitchCase>;
using SwitchCaseContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, SwitchCase>;

class SwitchCase : public Stmt {
 private:
  friend class FragmentImpl;
  friend class Stmt;
 public:
  inline static SwitchCaseRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static SwitchCaseContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : SwitchCase::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static SwitchCaseContainingStmtRange containing(const Decl &decl);
  static SwitchCaseContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<SwitchCase> from(const TokenContext &c);
  static std::optional<SwitchCase> from(const Stmt &parent);

  inline static std::optional<SwitchCase> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return SwitchCase::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token colon_token(void) const;
  Token keyword_token(void) const;
  std::optional<SwitchCase> next_switch_case(void) const;
  Stmt sub_statement(void) const;
};

using DefaultStmtRange = DerivedEntityRange<StmtIterator, DefaultStmt>;
using DefaultStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, DefaultStmt>;
using DefaultStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, DefaultStmt>;

class DefaultStmt : public SwitchCase {
 private:
  friend class FragmentImpl;
  friend class SwitchCase;
  friend class Stmt;
 public:
  inline static DefaultStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DefaultStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DefaultStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::DEFAULT_STMT;
  }

  static DefaultStmtContainingStmtRange containing(const Decl &decl);
  static DefaultStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DefaultStmt> from(const TokenContext &c);
  static std::optional<DefaultStmt> from(const SwitchCase &parent);

  inline static std::optional<DefaultStmt> from(const std::optional<SwitchCase> &parent) {
    if (parent) {
      return DefaultStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DefaultStmt> from(const Stmt &parent);

  inline static std::optional<DefaultStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return DefaultStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token default_token(void) const;
};

using CaseStmtRange = DerivedEntityRange<StmtIterator, CaseStmt>;
using CaseStmtContainingTokenRange = DerivedEntityRange<TokenContextIterator, CaseStmt>;
using CaseStmtContainingStmtRange = DerivedEntityRange<ParentStmtIteratorImpl<Stmt>, CaseStmt>;

class CaseStmt : public SwitchCase {
 private:
  friend class FragmentImpl;
  friend class SwitchCase;
  friend class Stmt;
 public:
  inline static CaseStmtRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CaseStmtContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CaseStmt::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr StmtKind static_kind(void) {
    return StmtKind::CASE_STMT;
  }

  static CaseStmtContainingStmtRange containing(const Decl &decl);
  static CaseStmtContainingStmtRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CaseStmt> from(const TokenContext &c);
  static std::optional<CaseStmt> from(const SwitchCase &parent);

  inline static std::optional<CaseStmt> from(const std::optional<SwitchCase> &parent) {
    if (parent) {
      return CaseStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CaseStmt> from(const Stmt &parent);

  inline static std::optional<CaseStmt> from(const std::optional<Stmt> &parent) {
    if (parent) {
      return CaseStmt::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool case_statement_is_gnu_range(void) const;
  Token case_token(void) const;
  Token ellipsis_token(void) const;
  Expr lhs(void) const;
  std::optional<Expr> rhs(void) const;
};

using DeclRange = DerivedEntityRange<DeclIterator, Decl>;
using DeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, Decl>;
using DeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, Decl>;

class Decl {
 protected:
  friend class Attr;
  friend class AttrIterator;
  friend class DeclIterator;
  friend class File;
  friend class Fragment;
  friend class FragmentImpl;
  friend class Index;
  friend class ReferenceIterator;
  friend class ReferenceIteratorImpl;
  friend class Stmt;
  friend class StmtIterator;
  friend class TokenContext;
  friend class Type;
  friend class TypeIterator;
  friend class UseBase;
  friend class UseIteratorImpl;
  template <typename> friend class UseIterator;

  std::shared_ptr<const FragmentImpl> fragment;
  unsigned offset_;

 public:
  Decl(Decl &&) noexcept = default;
  Decl(const Decl &) = default;
  Decl &operator=(Decl &&) noexcept = default;
  Decl &operator=(const Decl &) = default;

  inline Decl(std::shared_ptr<const FragmentImpl> fragment_, unsigned offset__)
      : fragment(std::move(fragment_)),
        offset_(offset__) {}

  inline static std::optional<Decl> from(const Decl &self) {
    return self;
  }

  inline static std::optional<Decl> from(const std::optional<Decl> &self) {
    return self;
  }

  inline static std::optional<Decl> from(const TokenContext &c) {
    return c.as_declaration();
  }

  std::optional<Decl> parent_declaration(void) const;
  std::optional<Stmt> parent_statement(void) const;
  std::optional<Decl> definition(void) const;
  bool is_definition(void) const;
  std::vector<Decl> redeclarations(void) const;
  EntityId id(void) const;
  UseRange<DeclUseSelector> uses(void) const;
  ReferenceRange references(void) const;

 protected:
  static DeclIterator in_internal(const Fragment &fragment);

 public:
  inline static DeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : Decl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static DeclContainingDeclRange containing(const Decl &decl);
  static DeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  std::vector<Attr> attributes(void) const;
  AccessSpecifier access(void) const;
  AvailabilityResult availability(void) const;
  std::optional<Attr> defining_attribute(void) const;
  std::optional<TemplateParameterList> described_template_parameters(void) const;
  std::optional<ExternalSourceSymbolAttr> external_source_symbol_attribute(void) const;
  DeclFriendObjectKind friend_object_kind(void) const;
  std::optional<FunctionType> function_type(void) const;
  DeclModuleOwnershipKind module_ownership_kind(void) const;
  std::optional<Decl> non_closure_context(void) const;
  bool has_attributes(void) const;
  bool has_defining_attribute(void) const;
  bool has_owning_module(void) const;
  bool has_tag_identifier_namespace(void) const;
  bool is_defined_outside_function_or_method(void) const;
  bool is_deprecated(void) const;
  bool is_function_or_function_template(void) const;
  bool is_implicit(void) const;
  bool is_in_anonymous_namespace(void) const;
  bool is_in_export_declaration_context(void) const;
  bool is_in_local_scope_for_instantiation(void) const;
  bool is_in_std_namespace(void) const;
  bool is_invalid_declaration(void) const;
  bool is_module_private(void) const;
  bool is_out_of_line(void) const;
  bool is_parameter_pack(void) const;
  bool is_template_declaration(void) const;
  bool is_template_parameter(void) const;
  bool is_template_parameter_pack(void) const;
  bool is_templated(void) const;
  bool is_top_level_declaration_in_obj_c_container(void) const;
  bool is_unavailable(void) const;
  bool is_unconditionally_visible(void) const;
  bool is_weak_imported(void) const;
  std::vector<Decl> redeclarations_visible_in_translation_unit(void) const;
  DeclKind kind(void) const;
  DeclCategory category(void) const;
  Token token(void) const;
  TokenRange tokens(void) const;
};

using ClassScopeFunctionSpecializationDeclRange = DerivedEntityRange<DeclIterator, ClassScopeFunctionSpecializationDecl>;
using ClassScopeFunctionSpecializationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ClassScopeFunctionSpecializationDecl>;
using ClassScopeFunctionSpecializationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ClassScopeFunctionSpecializationDecl>;

class ClassScopeFunctionSpecializationDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static ClassScopeFunctionSpecializationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ClassScopeFunctionSpecializationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ClassScopeFunctionSpecializationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CLASS_SCOPE_FUNCTION_SPECIALIZATION;
  }

  static ClassScopeFunctionSpecializationDeclContainingDeclRange containing(const Decl &decl);
  static ClassScopeFunctionSpecializationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ClassScopeFunctionSpecializationDecl> from(const TokenContext &c);
  static std::optional<ClassScopeFunctionSpecializationDecl> from(const Decl &parent);

  inline static std::optional<ClassScopeFunctionSpecializationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ClassScopeFunctionSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CXXMethodDecl specialization(void) const;
  bool has_explicit_template_arguments(void) const;
};

using CapturedDeclRange = DerivedEntityRange<DeclIterator, CapturedDecl>;
using CapturedDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CapturedDecl>;
using CapturedDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CapturedDecl>;

class CapturedDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static CapturedDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CapturedDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CapturedDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CAPTURED;
  }

  static CapturedDeclContainingDeclRange containing(const Decl &decl);
  static CapturedDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CapturedDecl> from(const TokenContext &c);
  static std::optional<CapturedDecl> from(const Decl &parent);

  inline static std::optional<CapturedDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CapturedDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ImplicitParamDecl context_parameter(void) const;
  bool is_nothrow(void) const;
  std::vector<ImplicitParamDecl> parameters(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using BlockDeclRange = DerivedEntityRange<DeclIterator, BlockDecl>;
using BlockDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, BlockDecl>;
using BlockDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, BlockDecl>;

class BlockDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static BlockDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BlockDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BlockDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::BLOCK;
  }

  static BlockDeclContainingDeclRange containing(const Decl &decl);
  static BlockDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BlockDecl> from(const TokenContext &c);
  static std::optional<BlockDecl> from(const Decl &parent);

  inline static std::optional<BlockDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return BlockDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool block_missing_return_type(void) const;
  bool can_avoid_copy_to_heap(void) const;
  bool captures_cxx_this(void) const;
  bool does_not_escape(void) const;
  std::optional<Decl> block_mangling_context_declaration(void) const;
  Token caret_token(void) const;
  CompoundStmt compound_body(void) const;
  Type signature_as_written(void) const;
  bool has_captures(void) const;
  bool is_conversion_from_lambda(void) const;
  bool is_variadic(void) const;
  std::vector<ParmVarDecl> parameters(void) const;
  std::vector<ParmVarDecl> parameter_declarations(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using AccessSpecDeclRange = DerivedEntityRange<DeclIterator, AccessSpecDecl>;
using AccessSpecDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, AccessSpecDecl>;
using AccessSpecDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, AccessSpecDecl>;

class AccessSpecDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static AccessSpecDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static AccessSpecDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : AccessSpecDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::ACCESS_SPEC;
  }

  static AccessSpecDeclContainingDeclRange containing(const Decl &decl);
  static AccessSpecDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<AccessSpecDecl> from(const TokenContext &c);
  static std::optional<AccessSpecDecl> from(const Decl &parent);

  inline static std::optional<AccessSpecDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return AccessSpecDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token access_specifier_token(void) const;
  Token colon_token(void) const;
};

using OMPDeclarativeDirectiveDeclRange = DerivedEntityRange<DeclIterator, OMPDeclarativeDirectiveDecl>;
using OMPDeclarativeDirectiveDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclarativeDirectiveDecl>;
using OMPDeclarativeDirectiveDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPDeclarativeDirectiveDecl>;

class OMPDeclarativeDirectiveDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static OMPDeclarativeDirectiveDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclarativeDirectiveDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclarativeDirectiveDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPDeclarativeDirectiveDeclContainingDeclRange containing(const Decl &decl);
  static OMPDeclarativeDirectiveDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDeclarativeDirectiveDecl> from(const TokenContext &c);
  static std::optional<OMPDeclarativeDirectiveDecl> from(const Decl &parent);

  inline static std::optional<OMPDeclarativeDirectiveDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPDeclarativeDirectiveDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPThreadPrivateDeclRange = DerivedEntityRange<DeclIterator, OMPThreadPrivateDecl>;
using OMPThreadPrivateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPThreadPrivateDecl>;
using OMPThreadPrivateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPThreadPrivateDecl>;

class OMPThreadPrivateDecl : public OMPDeclarativeDirectiveDecl {
 private:
  friend class FragmentImpl;
  friend class OMPDeclarativeDirectiveDecl;
  friend class Decl;
 public:
  inline static OMPThreadPrivateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPThreadPrivateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPThreadPrivateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_THREAD_PRIVATE;
  }

  static OMPThreadPrivateDeclContainingDeclRange containing(const Decl &decl);
  static OMPThreadPrivateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPThreadPrivateDecl> from(const TokenContext &c);
  static std::optional<OMPThreadPrivateDecl> from(const OMPDeclarativeDirectiveDecl &parent);

  inline static std::optional<OMPThreadPrivateDecl> from(const std::optional<OMPDeclarativeDirectiveDecl> &parent) {
    if (parent) {
      return OMPThreadPrivateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPThreadPrivateDecl> from(const Decl &parent);

  inline static std::optional<OMPThreadPrivateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPThreadPrivateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> varlists(void) const;
};

using OMPRequiresDeclRange = DerivedEntityRange<DeclIterator, OMPRequiresDecl>;
using OMPRequiresDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPRequiresDecl>;
using OMPRequiresDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPRequiresDecl>;

class OMPRequiresDecl : public OMPDeclarativeDirectiveDecl {
 private:
  friend class FragmentImpl;
  friend class OMPDeclarativeDirectiveDecl;
  friend class Decl;
 public:
  inline static OMPRequiresDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPRequiresDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPRequiresDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_REQUIRES;
  }

  static OMPRequiresDeclContainingDeclRange containing(const Decl &decl);
  static OMPRequiresDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPRequiresDecl> from(const TokenContext &c);
  static std::optional<OMPRequiresDecl> from(const OMPDeclarativeDirectiveDecl &parent);

  inline static std::optional<OMPRequiresDecl> from(const std::optional<OMPDeclarativeDirectiveDecl> &parent) {
    if (parent) {
      return OMPRequiresDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPRequiresDecl> from(const Decl &parent);

  inline static std::optional<OMPRequiresDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPRequiresDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPAllocateDeclRange = DerivedEntityRange<DeclIterator, OMPAllocateDecl>;
using OMPAllocateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPAllocateDecl>;
using OMPAllocateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPAllocateDecl>;

class OMPAllocateDecl : public OMPDeclarativeDirectiveDecl {
 private:
  friend class FragmentImpl;
  friend class OMPDeclarativeDirectiveDecl;
  friend class Decl;
 public:
  inline static OMPAllocateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPAllocateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPAllocateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_ALLOCATE;
  }

  static OMPAllocateDeclContainingDeclRange containing(const Decl &decl);
  static OMPAllocateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPAllocateDecl> from(const TokenContext &c);
  static std::optional<OMPAllocateDecl> from(const OMPDeclarativeDirectiveDecl &parent);

  inline static std::optional<OMPAllocateDecl> from(const std::optional<OMPDeclarativeDirectiveDecl> &parent) {
    if (parent) {
      return OMPAllocateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPAllocateDecl> from(const Decl &parent);

  inline static std::optional<OMPAllocateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPAllocateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Expr> varlists(void) const;
};

using TranslationUnitDeclRange = DerivedEntityRange<DeclIterator, TranslationUnitDecl>;
using TranslationUnitDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TranslationUnitDecl>;
using TranslationUnitDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TranslationUnitDecl>;

class TranslationUnitDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static TranslationUnitDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TranslationUnitDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TranslationUnitDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TRANSLATION_UNIT;
  }

  static TranslationUnitDeclContainingDeclRange containing(const Decl &decl);
  static TranslationUnitDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TranslationUnitDecl> from(const TokenContext &c);
  static std::optional<TranslationUnitDecl> from(const Decl &parent);

  inline static std::optional<TranslationUnitDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TranslationUnitDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations_in_context(void) const;
};

using StaticAssertDeclRange = DerivedEntityRange<DeclIterator, StaticAssertDecl>;
using StaticAssertDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, StaticAssertDecl>;
using StaticAssertDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, StaticAssertDecl>;

class StaticAssertDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static StaticAssertDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static StaticAssertDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : StaticAssertDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::STATIC_ASSERT;
  }

  static StaticAssertDeclContainingDeclRange containing(const Decl &decl);
  static StaticAssertDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<StaticAssertDecl> from(const TokenContext &c);
  static std::optional<StaticAssertDecl> from(const Decl &parent);

  inline static std::optional<StaticAssertDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return StaticAssertDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr assert_expression(void) const;
  StringLiteral message(void) const;
  Token r_paren_token(void) const;
  bool is_failed(void) const;
};

using RequiresExprBodyDeclRange = DerivedEntityRange<DeclIterator, RequiresExprBodyDecl>;
using RequiresExprBodyDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, RequiresExprBodyDecl>;
using RequiresExprBodyDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, RequiresExprBodyDecl>;

class RequiresExprBodyDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static RequiresExprBodyDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RequiresExprBodyDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RequiresExprBodyDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::REQUIRES_EXPR_BODY;
  }

  static RequiresExprBodyDeclContainingDeclRange containing(const Decl &decl);
  static RequiresExprBodyDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<RequiresExprBodyDecl> from(const TokenContext &c);
  static std::optional<RequiresExprBodyDecl> from(const Decl &parent);

  inline static std::optional<RequiresExprBodyDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return RequiresExprBodyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations_in_context(void) const;
};

using PragmaDetectMismatchDeclRange = DerivedEntityRange<DeclIterator, PragmaDetectMismatchDecl>;
using PragmaDetectMismatchDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaDetectMismatchDecl>;
using PragmaDetectMismatchDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, PragmaDetectMismatchDecl>;

class PragmaDetectMismatchDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static PragmaDetectMismatchDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaDetectMismatchDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaDetectMismatchDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::PRAGMA_DETECT_MISMATCH;
  }

  static PragmaDetectMismatchDeclContainingDeclRange containing(const Decl &decl);
  static PragmaDetectMismatchDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<PragmaDetectMismatchDecl> from(const TokenContext &c);
  static std::optional<PragmaDetectMismatchDecl> from(const Decl &parent);

  inline static std::optional<PragmaDetectMismatchDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return PragmaDetectMismatchDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view name(void) const;
  std::string_view value(void) const;
};

using PragmaCommentDeclRange = DerivedEntityRange<DeclIterator, PragmaCommentDecl>;
using PragmaCommentDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, PragmaCommentDecl>;
using PragmaCommentDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, PragmaCommentDecl>;

class PragmaCommentDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static PragmaCommentDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static PragmaCommentDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : PragmaCommentDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::PRAGMA_COMMENT;
  }

  static PragmaCommentDeclContainingDeclRange containing(const Decl &decl);
  static PragmaCommentDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<PragmaCommentDecl> from(const TokenContext &c);
  static std::optional<PragmaCommentDecl> from(const Decl &parent);

  inline static std::optional<PragmaCommentDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return PragmaCommentDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view argument(void) const;
  PragmaMSCommentKind comment_kind(void) const;
};

using ObjCPropertyImplDeclRange = DerivedEntityRange<DeclIterator, ObjCPropertyImplDecl>;
using ObjCPropertyImplDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCPropertyImplDecl>;
using ObjCPropertyImplDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCPropertyImplDecl>;

class ObjCPropertyImplDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static ObjCPropertyImplDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCPropertyImplDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCPropertyImplDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_PROPERTY_IMPL;
  }

  static ObjCPropertyImplDeclContainingDeclRange containing(const Decl &decl);
  static ObjCPropertyImplDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCPropertyImplDecl> from(const TokenContext &c);
  static std::optional<ObjCPropertyImplDecl> from(const Decl &parent);

  inline static std::optional<ObjCPropertyImplDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCPropertyImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr getter_cxx_constructor(void) const;
  ObjCMethodDecl getter_method_declaration(void) const;
  ObjCPropertyDecl property_declaration(void) const;
  ObjCPropertyImplDeclKind property_implementation(void) const;
  ObjCIvarDecl property_instance_variable_declaration(void) const;
  Token property_instance_variable_declaration_token(void) const;
  Expr setter_cxx_assignment(void) const;
  ObjCMethodDecl setter_method_declaration(void) const;
  bool is_instance_variable_name_specified(void) const;
};

using NamedDeclRange = DerivedEntityRange<DeclIterator, NamedDecl>;
using NamedDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, NamedDecl>;
using NamedDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, NamedDecl>;

class NamedDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static NamedDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NamedDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NamedDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::NAMED;
  }

  static NamedDeclContainingDeclRange containing(const Decl &decl);
  static NamedDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NamedDecl> from(const TokenContext &c);
  static std::optional<NamedDecl> from(const Decl &parent);

  inline static std::optional<NamedDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return NamedDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Linkage formal_linkage(void) const;
  std::string_view name(void) const;
  std::optional<ObjCStringFormatFamily> obj_cf_string_formatting_family(void) const;
  std::string_view qualified_name_as_string(void) const;
  NamedDecl underlying_declaration(void) const;
  Visibility visibility(void) const;
  bool has_external_formal_linkage(void) const;
  bool has_linkage(void) const;
  bool has_linkage_been_computed(void) const;
  bool is_cxx_class_member(void) const;
  bool is_cxx_instance_member(void) const;
  bool is_externally_declarable(void) const;
  bool is_externally_visible(void) const;
  bool is_linkage_valid(void) const;
};

using LabelDeclRange = DerivedEntityRange<DeclIterator, LabelDecl>;
using LabelDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, LabelDecl>;
using LabelDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, LabelDecl>;

class LabelDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static LabelDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LabelDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LabelDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::LABEL;
  }

  static LabelDeclContainingDeclRange containing(const Decl &decl);
  static LabelDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<LabelDecl> from(const TokenContext &c);
  static std::optional<LabelDecl> from(const NamedDecl &parent);

  inline static std::optional<LabelDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return LabelDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<LabelDecl> from(const Decl &parent);

  inline static std::optional<LabelDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return LabelDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view ms_assembly_label(void) const;
  LabelStmt statement(void) const;
  bool is_gnu_local(void) const;
  bool is_ms_assembly_label(void) const;
  bool is_resolved_ms_assembly_label(void) const;
};

using BaseUsingDeclRange = DerivedEntityRange<DeclIterator, BaseUsingDecl>;
using BaseUsingDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, BaseUsingDecl>;
using BaseUsingDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, BaseUsingDecl>;

class BaseUsingDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static BaseUsingDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BaseUsingDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BaseUsingDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::BASE_USING;
  }

  static BaseUsingDeclContainingDeclRange containing(const Decl &decl);
  static BaseUsingDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BaseUsingDecl> from(const TokenContext &c);
  static std::optional<BaseUsingDecl> from(const NamedDecl &parent);

  inline static std::optional<BaseUsingDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return BaseUsingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BaseUsingDecl> from(const Decl &parent);

  inline static std::optional<BaseUsingDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return BaseUsingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<UsingShadowDecl> shadows(void) const;
};

using UsingEnumDeclRange = DerivedEntityRange<DeclIterator, UsingEnumDecl>;
using UsingEnumDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingEnumDecl>;
using UsingEnumDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UsingEnumDecl>;

class UsingEnumDecl : public BaseUsingDecl {
 private:
  friend class FragmentImpl;
  friend class BaseUsingDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UsingEnumDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingEnumDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingEnumDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::USING_ENUM;
  }

  static UsingEnumDeclContainingDeclRange containing(const Decl &decl);
  static UsingEnumDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UsingEnumDecl> from(const TokenContext &c);
  static std::optional<UsingEnumDecl> from(const BaseUsingDecl &parent);

  inline static std::optional<UsingEnumDecl> from(const std::optional<BaseUsingDecl> &parent) {
    if (parent) {
      return UsingEnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingEnumDecl> from(const NamedDecl &parent);

  inline static std::optional<UsingEnumDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UsingEnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingEnumDecl> from(const Decl &parent);

  inline static std::optional<UsingEnumDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UsingEnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  EnumDecl enum_declaration(void) const;
  Token enum_token(void) const;
  Token using_token(void) const;
};

using UsingDeclRange = DerivedEntityRange<DeclIterator, UsingDecl>;
using UsingDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingDecl>;
using UsingDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UsingDecl>;

class UsingDecl : public BaseUsingDecl {
 private:
  friend class FragmentImpl;
  friend class BaseUsingDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UsingDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::USING;
  }

  static UsingDeclContainingDeclRange containing(const Decl &decl);
  static UsingDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UsingDecl> from(const TokenContext &c);
  static std::optional<UsingDecl> from(const BaseUsingDecl &parent);

  inline static std::optional<UsingDecl> from(const std::optional<BaseUsingDecl> &parent) {
    if (parent) {
      return UsingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingDecl> from(const NamedDecl &parent);

  inline static std::optional<UsingDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UsingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingDecl> from(const Decl &parent);

  inline static std::optional<UsingDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UsingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token using_token(void) const;
  bool has_typename(void) const;
  bool is_access_declaration(void) const;
};

using ValueDeclRange = DerivedEntityRange<DeclIterator, ValueDecl>;
using ValueDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ValueDecl>;
using ValueDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ValueDecl>;

class ValueDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ValueDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ValueDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ValueDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::VALUE;
  }

  static ValueDeclContainingDeclRange containing(const Decl &decl);
  static ValueDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ValueDecl> from(const TokenContext &c);
  static std::optional<ValueDecl> from(const NamedDecl &parent);

  inline static std::optional<ValueDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ValueDecl> from(const Decl &parent);

  inline static std::optional<ValueDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type type(void) const;
  bool is_weak(void) const;
};

using UnresolvedUsingValueDeclRange = DerivedEntityRange<DeclIterator, UnresolvedUsingValueDecl>;
using UnresolvedUsingValueDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedUsingValueDecl>;
using UnresolvedUsingValueDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UnresolvedUsingValueDecl>;

class UnresolvedUsingValueDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UnresolvedUsingValueDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedUsingValueDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedUsingValueDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::UNRESOLVED_USING_VALUE;
  }

  static UnresolvedUsingValueDeclContainingDeclRange containing(const Decl &decl);
  static UnresolvedUsingValueDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnresolvedUsingValueDecl> from(const TokenContext &c);
  static std::optional<UnresolvedUsingValueDecl> from(const ValueDecl &parent);

  inline static std::optional<UnresolvedUsingValueDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return UnresolvedUsingValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedUsingValueDecl> from(const NamedDecl &parent);

  inline static std::optional<UnresolvedUsingValueDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UnresolvedUsingValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedUsingValueDecl> from(const Decl &parent);

  inline static std::optional<UnresolvedUsingValueDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UnresolvedUsingValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token ellipsis_token(void) const;
  Token using_token(void) const;
  bool is_access_declaration(void) const;
  bool is_pack_expansion(void) const;
};

using TemplateParamObjectDeclRange = DerivedEntityRange<DeclIterator, TemplateParamObjectDecl>;
using TemplateParamObjectDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateParamObjectDecl>;
using TemplateParamObjectDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TemplateParamObjectDecl>;

class TemplateParamObjectDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TemplateParamObjectDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateParamObjectDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateParamObjectDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TEMPLATE_PARAM_OBJECT;
  }

  static TemplateParamObjectDeclContainingDeclRange containing(const Decl &decl);
  static TemplateParamObjectDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TemplateParamObjectDecl> from(const TokenContext &c);
  static std::optional<TemplateParamObjectDecl> from(const ValueDecl &parent);

  inline static std::optional<TemplateParamObjectDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return TemplateParamObjectDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateParamObjectDecl> from(const NamedDecl &parent);

  inline static std::optional<TemplateParamObjectDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TemplateParamObjectDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateParamObjectDecl> from(const Decl &parent);

  inline static std::optional<TemplateParamObjectDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TemplateParamObjectDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPDeclareReductionDeclRange = DerivedEntityRange<DeclIterator, OMPDeclareReductionDecl>;
using OMPDeclareReductionDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclareReductionDecl>;
using OMPDeclareReductionDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPDeclareReductionDecl>;

class OMPDeclareReductionDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static OMPDeclareReductionDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclareReductionDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclareReductionDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_DECLARE_REDUCTION;
  }

  static OMPDeclareReductionDeclContainingDeclRange containing(const Decl &decl);
  static OMPDeclareReductionDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDeclareReductionDecl> from(const TokenContext &c);
  static std::optional<OMPDeclareReductionDecl> from(const ValueDecl &parent);

  inline static std::optional<OMPDeclareReductionDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return OMPDeclareReductionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareReductionDecl> from(const NamedDecl &parent);

  inline static std::optional<OMPDeclareReductionDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return OMPDeclareReductionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareReductionDecl> from(const Decl &parent);

  inline static std::optional<OMPDeclareReductionDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPDeclareReductionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr combiner(void) const;
  Expr combiner_in(void) const;
  Expr combiner_out(void) const;
  Expr initializer_original(void) const;
  Expr initializer_private(void) const;
  Expr initializer(void) const;
  OMPDeclareReductionDeclInitKind initializer_kind(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using MSGuidDeclRange = DerivedEntityRange<DeclIterator, MSGuidDecl>;
using MSGuidDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSGuidDecl>;
using MSGuidDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, MSGuidDecl>;

class MSGuidDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static MSGuidDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSGuidDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSGuidDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::MS_GUID;
  }

  static MSGuidDeclContainingDeclRange containing(const Decl &decl);
  static MSGuidDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSGuidDecl> from(const TokenContext &c);
  static std::optional<MSGuidDecl> from(const ValueDecl &parent);

  inline static std::optional<MSGuidDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return MSGuidDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSGuidDecl> from(const NamedDecl &parent);

  inline static std::optional<MSGuidDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return MSGuidDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSGuidDecl> from(const Decl &parent);

  inline static std::optional<MSGuidDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return MSGuidDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using IndirectFieldDeclRange = DerivedEntityRange<DeclIterator, IndirectFieldDecl>;
using IndirectFieldDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, IndirectFieldDecl>;
using IndirectFieldDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, IndirectFieldDecl>;

class IndirectFieldDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static IndirectFieldDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static IndirectFieldDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : IndirectFieldDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::INDIRECT_FIELD;
  }

  static IndirectFieldDeclContainingDeclRange containing(const Decl &decl);
  static IndirectFieldDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<IndirectFieldDecl> from(const TokenContext &c);
  static std::optional<IndirectFieldDecl> from(const ValueDecl &parent);

  inline static std::optional<IndirectFieldDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return IndirectFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IndirectFieldDecl> from(const NamedDecl &parent);

  inline static std::optional<IndirectFieldDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return IndirectFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<IndirectFieldDecl> from(const Decl &parent);

  inline static std::optional<IndirectFieldDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return IndirectFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<NamedDecl> chain(void) const;
  std::optional<FieldDecl> anonymous_field(void) const;
  std::optional<VarDecl> variable_declaration(void) const;
};

using EnumConstantDeclRange = DerivedEntityRange<DeclIterator, EnumConstantDecl>;
using EnumConstantDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnumConstantDecl>;
using EnumConstantDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, EnumConstantDecl>;

class EnumConstantDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static EnumConstantDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnumConstantDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnumConstantDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::ENUM_CONSTANT;
  }

  static EnumConstantDeclContainingDeclRange containing(const Decl &decl);
  static EnumConstantDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<EnumConstantDecl> from(const TokenContext &c);
  static std::optional<EnumConstantDecl> from(const ValueDecl &parent);

  inline static std::optional<EnumConstantDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return EnumConstantDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumConstantDecl> from(const NamedDecl &parent);

  inline static std::optional<EnumConstantDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return EnumConstantDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumConstantDecl> from(const Decl &parent);

  inline static std::optional<EnumConstantDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return EnumConstantDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> initializer_expression(void) const;
};

using DeclaratorDeclRange = DerivedEntityRange<DeclIterator, DeclaratorDecl>;
using DeclaratorDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, DeclaratorDecl>;
using DeclaratorDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, DeclaratorDecl>;

class DeclaratorDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static DeclaratorDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DeclaratorDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DeclaratorDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::DECLARATOR;
  }

  static DeclaratorDeclContainingDeclRange containing(const Decl &decl);
  static DeclaratorDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DeclaratorDecl> from(const TokenContext &c);
  static std::optional<DeclaratorDecl> from(const ValueDecl &parent);

  inline static std::optional<DeclaratorDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return DeclaratorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeclaratorDecl> from(const NamedDecl &parent);

  inline static std::optional<DeclaratorDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return DeclaratorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DeclaratorDecl> from(const Decl &parent);

  inline static std::optional<DeclaratorDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return DeclaratorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token first_inner_token(void) const;
  Token first_outer_token(void) const;
  std::optional<Expr> trailing_requires_clause(void) const;
  Token type_spec_end_token(void) const;
  Token type_spec_start_token(void) const;
  std::vector<TemplateParameterList> template_parameter_lists(void) const;
};

using VarDeclRange = DerivedEntityRange<DeclIterator, VarDecl>;
using VarDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, VarDecl>;
using VarDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, VarDecl>;

class VarDecl : public DeclaratorDecl {
 private:
  friend class FragmentImpl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static VarDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VarDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VarDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::VAR;
  }

  static VarDeclContainingDeclRange containing(const Decl &decl);
  static VarDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<VarDecl> from(const TokenContext &c);
  static std::optional<VarDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<VarDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return VarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarDecl> from(const ValueDecl &parent);

  inline static std::optional<VarDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return VarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarDecl> from(const NamedDecl &parent);

  inline static std::optional<VarDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return VarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarDecl> from(const Decl &parent);

  inline static std::optional<VarDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return VarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<VarDecl> acting_definition(void) const;
  std::optional<Expr> initializer(void) const;
  VarDeclInitializationStyle initializer_style(void) const;
  std::optional<VarDecl> initializing_declaration(void) const;
  std::optional<VarDecl> instantiated_from_static_data_member(void) const;
  LanguageLinkage language_linkage(void) const;
  Token point_of_instantiation(void) const;
  StorageClass storage_class(void) const;
  StorageDuration storage_duration(void) const;
  VarDeclTLSKind tls_kind(void) const;
  ThreadStorageClassSpecifier tsc_spec(void) const;
  std::optional<VarDecl> template_instantiation_pattern(void) const;
  TemplateSpecializationKind template_specialization_kind(void) const;
  TemplateSpecializationKind template_specialization_kind_for_instantiation(void) const;
  bool has_constant_initialization(void) const;
  bool has_dependent_alignment(void) const;
  bool has_external_storage(void) const;
  bool has_global_storage(void) const;
  std::optional<bool> has_ice_initializer(void) const;
  bool has_initializer(void) const;
  bool has_local_storage(void) const;
  bool is_arc_pseudo_strong(void) const;
  bool is_cxx_for_range_declaration(void) const;
  bool is_constexpr(void) const;
  bool is_direct_initializer(void) const;
  bool is_escaping_byref(void) const;
  bool is_exception_variable(void) const;
  bool is_extern_c(void) const;
  bool is_file_variable_declaration(void) const;
  bool is_function_or_method_variable_declaration(void) const;
  bool is_in_extern_c_context(void) const;
  bool is_in_extern_cxx_context(void) const;
  bool is_initializer_capture(void) const;
  bool is_inline(void) const;
  bool is_inline_specified(void) const;
  bool is_known_to_be_defined(void) const;
  bool is_local_variable_declaration(void) const;
  bool is_local_variable_declaration_or_parm(void) const;
  bool is_nrvo_variable(void) const;
  bool is_no_destroy(void) const;
  bool is_non_escaping_byref(void) const;
  bool is_obj_c_for_declaration(void) const;
  bool is_previous_declaration_in_same_block_scope(void) const;
  bool is_static_data_member(void) const;
  bool is_static_local(void) const;
  bool is_demoted_definition(void) const;
  bool is_usable_in_constant_expressions(void) const;
  bool might_be_usable_in_constant_expressions(void) const;
  QualTypeDestructionKind needs_destruction(void) const;
};

using ParmVarDeclRange = DerivedEntityRange<DeclIterator, ParmVarDecl>;
using ParmVarDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ParmVarDecl>;
using ParmVarDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ParmVarDecl>;

class ParmVarDecl : public VarDecl {
 private:
  friend class FragmentImpl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ParmVarDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ParmVarDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ParmVarDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::PARM_VAR;
  }

  static ParmVarDeclContainingDeclRange containing(const Decl &decl);
  static ParmVarDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ParmVarDecl> from(const TokenContext &c);
  static std::optional<ParmVarDecl> from(const VarDecl &parent);

  inline static std::optional<ParmVarDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return ParmVarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParmVarDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<ParmVarDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return ParmVarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParmVarDecl> from(const ValueDecl &parent);

  inline static std::optional<ParmVarDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return ParmVarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParmVarDecl> from(const NamedDecl &parent);

  inline static std::optional<ParmVarDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ParmVarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ParmVarDecl> from(const Decl &parent);

  inline static std::optional<ParmVarDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ParmVarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> default_argument(void) const;
  TokenRange default_argument_range(void) const;
  DeclObjCDeclQualifier obj_c_decl_qualifier(void) const;
  Type original_type(void) const;
  std::optional<Expr> uninstantiated_default_argument(void) const;
  bool has_default_argument(void) const;
  bool has_inherited_default_argument(void) const;
  bool has_uninstantiated_default_argument(void) const;
  bool has_unparsed_default_argument(void) const;
  bool is_destroyed_in_callee(void) const;
  bool is_knr_promoted(void) const;
  bool is_obj_c_method_parameter(void) const;
};

using OMPCapturedExprDeclRange = DerivedEntityRange<DeclIterator, OMPCapturedExprDecl>;
using OMPCapturedExprDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPCapturedExprDecl>;
using OMPCapturedExprDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPCapturedExprDecl>;

class OMPCapturedExprDecl : public VarDecl {
 private:
  friend class FragmentImpl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static OMPCapturedExprDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPCapturedExprDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPCapturedExprDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_CAPTURED_EXPR;
  }

  static OMPCapturedExprDeclContainingDeclRange containing(const Decl &decl);
  static OMPCapturedExprDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPCapturedExprDecl> from(const TokenContext &c);
  static std::optional<OMPCapturedExprDecl> from(const VarDecl &parent);

  inline static std::optional<OMPCapturedExprDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return OMPCapturedExprDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCapturedExprDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<OMPCapturedExprDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return OMPCapturedExprDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCapturedExprDecl> from(const ValueDecl &parent);

  inline static std::optional<OMPCapturedExprDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return OMPCapturedExprDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCapturedExprDecl> from(const NamedDecl &parent);

  inline static std::optional<OMPCapturedExprDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return OMPCapturedExprDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPCapturedExprDecl> from(const Decl &parent);

  inline static std::optional<OMPCapturedExprDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPCapturedExprDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using ImplicitParamDeclRange = DerivedEntityRange<DeclIterator, ImplicitParamDecl>;
using ImplicitParamDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ImplicitParamDecl>;
using ImplicitParamDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ImplicitParamDecl>;

class ImplicitParamDecl : public VarDecl {
 private:
  friend class FragmentImpl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ImplicitParamDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ImplicitParamDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ImplicitParamDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::IMPLICIT_PARAM;
  }

  static ImplicitParamDeclContainingDeclRange containing(const Decl &decl);
  static ImplicitParamDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ImplicitParamDecl> from(const TokenContext &c);
  static std::optional<ImplicitParamDecl> from(const VarDecl &parent);

  inline static std::optional<ImplicitParamDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return ImplicitParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitParamDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<ImplicitParamDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return ImplicitParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitParamDecl> from(const ValueDecl &parent);

  inline static std::optional<ImplicitParamDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return ImplicitParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitParamDecl> from(const NamedDecl &parent);

  inline static std::optional<ImplicitParamDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ImplicitParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ImplicitParamDecl> from(const Decl &parent);

  inline static std::optional<ImplicitParamDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ImplicitParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ImplicitParamDeclImplicitParamKind parameter_kind(void) const;
};

using DecompositionDeclRange = DerivedEntityRange<DeclIterator, DecompositionDecl>;
using DecompositionDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, DecompositionDecl>;
using DecompositionDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, DecompositionDecl>;

class DecompositionDecl : public VarDecl {
 private:
  friend class FragmentImpl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static DecompositionDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static DecompositionDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : DecompositionDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::DECOMPOSITION;
  }

  static DecompositionDeclContainingDeclRange containing(const Decl &decl);
  static DecompositionDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<DecompositionDecl> from(const TokenContext &c);
  static std::optional<DecompositionDecl> from(const VarDecl &parent);

  inline static std::optional<DecompositionDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return DecompositionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DecompositionDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<DecompositionDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return DecompositionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DecompositionDecl> from(const ValueDecl &parent);

  inline static std::optional<DecompositionDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return DecompositionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DecompositionDecl> from(const NamedDecl &parent);

  inline static std::optional<DecompositionDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return DecompositionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<DecompositionDecl> from(const Decl &parent);

  inline static std::optional<DecompositionDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return DecompositionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<BindingDecl> bindings(void) const;
};

using VarTemplateSpecializationDeclRange = DerivedEntityRange<DeclIterator, VarTemplateSpecializationDecl>;
using VarTemplateSpecializationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, VarTemplateSpecializationDecl>;
using VarTemplateSpecializationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, VarTemplateSpecializationDecl>;

class VarTemplateSpecializationDecl : public VarDecl {
 private:
  friend class FragmentImpl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static VarTemplateSpecializationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VarTemplateSpecializationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VarTemplateSpecializationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::VAR_TEMPLATE_SPECIALIZATION;
  }

  static VarTemplateSpecializationDeclContainingDeclRange containing(const Decl &decl);
  static VarTemplateSpecializationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<VarTemplateSpecializationDecl> from(const TokenContext &c);
  static std::optional<VarTemplateSpecializationDecl> from(const VarDecl &parent);

  inline static std::optional<VarTemplateSpecializationDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return VarTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateSpecializationDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<VarTemplateSpecializationDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return VarTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateSpecializationDecl> from(const ValueDecl &parent);

  inline static std::optional<VarTemplateSpecializationDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return VarTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateSpecializationDecl> from(const NamedDecl &parent);

  inline static std::optional<VarTemplateSpecializationDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return VarTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateSpecializationDecl> from(const Decl &parent);

  inline static std::optional<VarTemplateSpecializationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return VarTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token extern_token(void) const;
  TemplateSpecializationKind specialization_kind(void) const;
  std::vector<TemplateArgument> template_arguments(void) const;
  std::vector<TemplateArgument> template_instantiation_arguments(void) const;
  Token template_keyword_token(void) const;
  Type type_as_written(void) const;
  bool is_class_scope_explicit_specialization(void) const;
  bool is_explicit_instantiation_or_specialization(void) const;
  bool is_explicit_specialization(void) const;
};

using VarTemplatePartialSpecializationDeclRange = DerivedEntityRange<DeclIterator, VarTemplatePartialSpecializationDecl>;
using VarTemplatePartialSpecializationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, VarTemplatePartialSpecializationDecl>;
using VarTemplatePartialSpecializationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, VarTemplatePartialSpecializationDecl>;

class VarTemplatePartialSpecializationDecl : public VarTemplateSpecializationDecl {
 private:
  friend class FragmentImpl;
  friend class VarTemplateSpecializationDecl;
  friend class VarDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static VarTemplatePartialSpecializationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VarTemplatePartialSpecializationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VarTemplatePartialSpecializationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::VAR_TEMPLATE_PARTIAL_SPECIALIZATION;
  }

  static VarTemplatePartialSpecializationDeclContainingDeclRange containing(const Decl &decl);
  static VarTemplatePartialSpecializationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<VarTemplatePartialSpecializationDecl> from(const TokenContext &c);
  static std::optional<VarTemplatePartialSpecializationDecl> from(const VarTemplateSpecializationDecl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<VarTemplateSpecializationDecl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplatePartialSpecializationDecl> from(const VarDecl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<VarDecl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplatePartialSpecializationDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplatePartialSpecializationDecl> from(const ValueDecl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplatePartialSpecializationDecl> from(const NamedDecl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplatePartialSpecializationDecl> from(const Decl &parent);

  inline static std::optional<VarTemplatePartialSpecializationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return VarTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using NonTypeTemplateParmDeclRange = DerivedEntityRange<DeclIterator, NonTypeTemplateParmDecl>;
using NonTypeTemplateParmDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, NonTypeTemplateParmDecl>;
using NonTypeTemplateParmDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, NonTypeTemplateParmDecl>;

class NonTypeTemplateParmDecl : public DeclaratorDecl {
 private:
  friend class FragmentImpl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static NonTypeTemplateParmDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NonTypeTemplateParmDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NonTypeTemplateParmDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::NON_TYPE_TEMPLATE_PARM;
  }

  static NonTypeTemplateParmDeclContainingDeclRange containing(const Decl &decl);
  static NonTypeTemplateParmDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NonTypeTemplateParmDecl> from(const TokenContext &c);
  static std::optional<NonTypeTemplateParmDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<NonTypeTemplateParmDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return NonTypeTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NonTypeTemplateParmDecl> from(const ValueDecl &parent);

  inline static std::optional<NonTypeTemplateParmDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return NonTypeTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NonTypeTemplateParmDecl> from(const NamedDecl &parent);

  inline static std::optional<NonTypeTemplateParmDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return NonTypeTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NonTypeTemplateParmDecl> from(const Decl &parent);

  inline static std::optional<NonTypeTemplateParmDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return NonTypeTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool default_argument_was_inherited(void) const;
  std::optional<Expr> default_argument(void) const;
  Token default_argument_token(void) const;
  std::optional<unsigned> num_expansion_types(void) const;
  std::optional<Expr> placeholder_type_constraint(void) const;
  bool has_default_argument(void) const;
  bool has_placeholder_type_constraint(void) const;
  bool is_expanded_parameter_pack(void) const;
  bool is_pack_expansion(void) const;
  std::vector<Type> expansion_types(void) const;
};

using MSPropertyDeclRange = DerivedEntityRange<DeclIterator, MSPropertyDecl>;
using MSPropertyDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, MSPropertyDecl>;
using MSPropertyDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, MSPropertyDecl>;

class MSPropertyDecl : public DeclaratorDecl {
 private:
  friend class FragmentImpl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static MSPropertyDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static MSPropertyDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : MSPropertyDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::MS_PROPERTY;
  }

  static MSPropertyDeclContainingDeclRange containing(const Decl &decl);
  static MSPropertyDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<MSPropertyDecl> from(const TokenContext &c);
  static std::optional<MSPropertyDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<MSPropertyDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return MSPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertyDecl> from(const ValueDecl &parent);

  inline static std::optional<MSPropertyDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return MSPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertyDecl> from(const NamedDecl &parent);

  inline static std::optional<MSPropertyDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return MSPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<MSPropertyDecl> from(const Decl &parent);

  inline static std::optional<MSPropertyDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return MSPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool has_getter(void) const;
  bool has_setter(void) const;
};

using FunctionDeclRange = DerivedEntityRange<DeclIterator, FunctionDecl>;
using FunctionDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionDecl>;
using FunctionDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FunctionDecl>;

class FunctionDecl : public DeclaratorDecl {
 private:
  friend class FragmentImpl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static FunctionDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FUNCTION;
  }

  static FunctionDeclContainingDeclRange containing(const Decl &decl);
  static FunctionDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FunctionDecl> from(const TokenContext &c);
  static std::optional<FunctionDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<FunctionDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return FunctionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionDecl> from(const ValueDecl &parent);

  inline static std::optional<FunctionDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return FunctionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionDecl> from(const NamedDecl &parent);

  inline static std::optional<FunctionDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return FunctionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionDecl> from(const Decl &parent);

  inline static std::optional<FunctionDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FunctionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool uses_fp_intrin(void) const;
  std::optional<bool> does_declaration_force_externally_visible_definition(void) const;
  bool does_this_declaration_have_a_body(void) const;
  Type call_result_type(void) const;
  ConstexprSpecKind constexpr_kind(void) const;
  Type declared_return_type(void) const;
  Token ellipsis_token(void) const;
  TokenRange exception_spec_source_range(void) const;
  ExceptionSpecificationType exception_spec_type(void) const;
  std::optional<FunctionDecl> instantiated_from_member_function(void) const;
  LanguageLinkage language_linkage(void) const;
  MultiVersionKind multi_version_kind(void) const;
  std::optional<unsigned> odr_hash(void) const;
  OverloadedOperatorKind overloaded_operator(void) const;
  TokenRange parameters_source_range(void) const;
  Token point_of_instantiation(void) const;
  Type return_type(void) const;
  TokenRange return_type_source_range(void) const;
  StorageClass storage_class(void) const;
  std::optional<FunctionDecl> template_instantiation_pattern(void) const;
  TemplateSpecializationKind template_specialization_kind(void) const;
  TemplateSpecializationKind template_specialization_kind_for_instantiation(void) const;
  FunctionDeclTemplatedKind templated_kind(void) const;
  bool has_implicit_return_zero(void) const;
  bool has_inherited_prototype(void) const;
  bool has_one_parameter_or_default_arguments(void) const;
  bool has_prototype(void) const;
  bool has_skipped_body(void) const;
  bool has_trivial_body(void) const;
  bool has_written_prototype(void) const;
  bool instantiation_is_pending(void) const;
  bool is_cpu_dispatch_multi_version(void) const;
  bool is_cpu_specific_multi_version(void) const;
  bool is_consteval(void) const;
  bool is_constexpr(void) const;
  bool is_constexpr_specified(void) const;
  bool is_defaulted(void) const;
  bool is_deleted(void) const;
  bool is_deleted_as_written(void) const;
  bool is_destroying_operator_delete(void) const;
  bool is_explicitly_defaulted(void) const;
  bool is_extern_c(void) const;
  bool is_function_template_specialization(void) const;
  bool is_global(void) const;
  bool is_implicitly_instantiable(void) const;
  bool is_in_extern_c_context(void) const;
  bool is_in_extern_cxx_context(void) const;
  bool is_inline_builtin_declaration(void) const;
  std::optional<bool> is_inline_definition_externally_visible(void) const;
  bool is_inline_specified(void) const;
  bool is_inlined(void) const;
  bool is_late_template_parsed(void) const;
  std::optional<bool> is_ms_extern_inline(void) const;
  bool is_msvcrt_entry_point(void) const;
  bool is_main(void) const;
  bool is_multi_version(void) const;
  bool is_no_return(void) const;
  bool is_overloaded_operator(void) const;
  bool is_pure(void) const;
  bool is_replaceable_global_allocation_function(void) const;
  std::optional<bool> is_reserved_global_placement_operator(void) const;
  bool is_static(void) const;
  bool is_target_clones_multi_version(void) const;
  bool is_target_multi_version(void) const;
  bool is_template_instantiation(void) const;
  bool is_this_declaration_instantiated_from_a_friend_definition(void) const;
  bool is_trivial(void) const;
  bool is_trivial_for_call(void) const;
  bool is_user_provided(void) const;
  bool is_variadic(void) const;
  bool is_virtual_as_written(void) const;
  std::vector<ParmVarDecl> parameters(void) const;
  bool uses_seh_try(void) const;
  bool will_have_body(void) const;
  std::optional<Stmt> body(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using CXXMethodDeclRange = DerivedEntityRange<DeclIterator, CXXMethodDecl>;
using CXXMethodDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXMethodDecl>;
using CXXMethodDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXMethodDecl>;

class CXXMethodDecl : public FunctionDecl {
 private:
  friend class FragmentImpl;
  friend class FunctionDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXMethodDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXMethodDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXMethodDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_METHOD;
  }

  static CXXMethodDeclContainingDeclRange containing(const Decl &decl);
  static CXXMethodDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXMethodDecl> from(const TokenContext &c);
  static std::optional<CXXMethodDecl> from(const FunctionDecl &parent);

  inline static std::optional<CXXMethodDecl> from(const std::optional<FunctionDecl> &parent) {
    if (parent) {
      return CXXMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMethodDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<CXXMethodDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return CXXMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMethodDecl> from(const ValueDecl &parent);

  inline static std::optional<CXXMethodDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return CXXMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMethodDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXMethodDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXMethodDecl> from(const Decl &parent);

  inline static std::optional<CXXMethodDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  RefQualifierKind reference_qualifier(void) const;
  std::optional<Type> this_object_type(void) const;
  std::optional<Type> this_type(void) const;
  bool has_inline_body(void) const;
  bool is_const(void) const;
  bool is_copy_assignment_operator(void) const;
  bool is_instance(void) const;
  bool is_lambda_static_invoker(void) const;
  bool is_move_assignment_operator(void) const;
  bool is_virtual(void) const;
  bool is_volatile(void) const;
  std::vector<CXXMethodDecl> overridden_methods(void) const;
  std::vector<ParmVarDecl> parameter_declarations(void) const;
};

using CXXDestructorDeclRange = DerivedEntityRange<DeclIterator, CXXDestructorDecl>;
using CXXDestructorDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDestructorDecl>;
using CXXDestructorDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXDestructorDecl>;

class CXXDestructorDecl : public CXXMethodDecl {
 private:
  friend class FragmentImpl;
  friend class CXXMethodDecl;
  friend class FunctionDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXDestructorDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDestructorDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDestructorDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_DESTRUCTOR;
  }

  static CXXDestructorDeclContainingDeclRange containing(const Decl &decl);
  static CXXDestructorDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDestructorDecl> from(const TokenContext &c);
  static std::optional<CXXDestructorDecl> from(const CXXMethodDecl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<CXXMethodDecl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDestructorDecl> from(const FunctionDecl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<FunctionDecl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDestructorDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDestructorDecl> from(const ValueDecl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDestructorDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDestructorDecl> from(const Decl &parent);

  inline static std::optional<CXXDestructorDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXDestructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<FunctionDecl> operator_delete(void) const;
  std::optional<Expr> operator_delete_this_argument(void) const;
};

using CXXConversionDeclRange = DerivedEntityRange<DeclIterator, CXXConversionDecl>;
using CXXConversionDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXConversionDecl>;
using CXXConversionDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXConversionDecl>;

class CXXConversionDecl : public CXXMethodDecl {
 private:
  friend class FragmentImpl;
  friend class CXXMethodDecl;
  friend class FunctionDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXConversionDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXConversionDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXConversionDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_CONVERSION;
  }

  static CXXConversionDeclContainingDeclRange containing(const Decl &decl);
  static CXXConversionDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXConversionDecl> from(const TokenContext &c);
  static std::optional<CXXConversionDecl> from(const CXXMethodDecl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<CXXMethodDecl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConversionDecl> from(const FunctionDecl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<FunctionDecl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConversionDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConversionDecl> from(const ValueDecl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConversionDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConversionDecl> from(const Decl &parent);

  inline static std::optional<CXXConversionDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXConversionDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Type conversion_type(void) const;
  bool is_explicit(void) const;
  bool is_lambda_to_block_pointer_conversion(void) const;
};

using CXXConstructorDeclRange = DerivedEntityRange<DeclIterator, CXXConstructorDecl>;
using CXXConstructorDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXConstructorDecl>;
using CXXConstructorDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXConstructorDecl>;

class CXXConstructorDecl : public CXXMethodDecl {
 private:
  friend class FragmentImpl;
  friend class CXXMethodDecl;
  friend class FunctionDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXConstructorDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXConstructorDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXConstructorDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_CONSTRUCTOR;
  }

  static CXXConstructorDeclContainingDeclRange containing(const Decl &decl);
  static CXXConstructorDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXConstructorDecl> from(const TokenContext &c);
  static std::optional<CXXConstructorDecl> from(const CXXMethodDecl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<CXXMethodDecl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructorDecl> from(const FunctionDecl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<FunctionDecl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructorDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructorDecl> from(const ValueDecl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructorDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXConstructorDecl> from(const Decl &parent);

  inline static std::optional<CXXConstructorDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXConstructorDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<CXXConstructorDecl> target_constructor(void) const;
  bool is_default_constructor(void) const;
  bool is_delegating_constructor(void) const;
  bool is_explicit(void) const;
  bool is_inheriting_constructor(void) const;
  bool is_specialization_copying_object(void) const;
};

using CXXDeductionGuideDeclRange = DerivedEntityRange<DeclIterator, CXXDeductionGuideDecl>;
using CXXDeductionGuideDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXDeductionGuideDecl>;
using CXXDeductionGuideDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXDeductionGuideDecl>;

class CXXDeductionGuideDecl : public FunctionDecl {
 private:
  friend class FragmentImpl;
  friend class FunctionDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXDeductionGuideDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXDeductionGuideDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXDeductionGuideDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_DEDUCTION_GUIDE;
  }

  static CXXDeductionGuideDeclContainingDeclRange containing(const Decl &decl);
  static CXXDeductionGuideDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXDeductionGuideDecl> from(const TokenContext &c);
  static std::optional<CXXDeductionGuideDecl> from(const FunctionDecl &parent);

  inline static std::optional<CXXDeductionGuideDecl> from(const std::optional<FunctionDecl> &parent) {
    if (parent) {
      return CXXDeductionGuideDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeductionGuideDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<CXXDeductionGuideDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return CXXDeductionGuideDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeductionGuideDecl> from(const ValueDecl &parent);

  inline static std::optional<CXXDeductionGuideDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return CXXDeductionGuideDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeductionGuideDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXDeductionGuideDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXDeductionGuideDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXDeductionGuideDecl> from(const Decl &parent);

  inline static std::optional<CXXDeductionGuideDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXDeductionGuideDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  CXXConstructorDecl corresponding_constructor(void) const;
  bool is_copy_deduction_candidate(void) const;
  bool is_explicit(void) const;
  std::vector<ParmVarDecl> parameter_declarations(void) const;
};

using FieldDeclRange = DerivedEntityRange<DeclIterator, FieldDecl>;
using FieldDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FieldDecl>;
using FieldDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FieldDecl>;

class FieldDecl : public DeclaratorDecl {
 private:
  friend class FragmentImpl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static FieldDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FieldDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FieldDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FIELD;
  }

  static FieldDeclContainingDeclRange containing(const Decl &decl);
  static FieldDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FieldDecl> from(const TokenContext &c);
  static std::optional<FieldDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<FieldDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return FieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FieldDecl> from(const ValueDecl &parent);

  inline static std::optional<FieldDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return FieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FieldDecl> from(const NamedDecl &parent);

  inline static std::optional<FieldDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return FieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FieldDecl> from(const Decl &parent);

  inline static std::optional<FieldDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Expr> bit_width(void) const;
  std::optional<VariableArrayType> captured_vla_type(void) const;
  InClassInitStyle in_class_initializer_style(void) const;
  std::optional<Expr> in_class_initializer(void) const;
  bool has_captured_vla_type(void) const;
  bool has_in_class_initializer(void) const;
  bool is_anonymous_struct_or_union(void) const;
  bool is_bit_field(void) const;
  bool is_mutable(void) const;
  bool is_unnamed_bitfield(void) const;
  bool is_zero_length_bit_field(void) const;
  bool is_zero_size(void) const;
};

using ObjCIvarDeclRange = DerivedEntityRange<DeclIterator, ObjCIvarDecl>;
using ObjCIvarDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCIvarDecl>;
using ObjCIvarDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCIvarDecl>;

class ObjCIvarDecl : public FieldDecl {
 private:
  friend class FragmentImpl;
  friend class FieldDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCIvarDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCIvarDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCIvarDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_IVAR;
  }

  static ObjCIvarDeclContainingDeclRange containing(const Decl &decl);
  static ObjCIvarDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCIvarDecl> from(const TokenContext &c);
  static std::optional<ObjCIvarDecl> from(const FieldDecl &parent);

  inline static std::optional<ObjCIvarDecl> from(const std::optional<FieldDecl> &parent) {
    if (parent) {
      return ObjCIvarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<ObjCIvarDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return ObjCIvarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarDecl> from(const ValueDecl &parent);

  inline static std::optional<ObjCIvarDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return ObjCIvarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCIvarDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCIvarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCIvarDecl> from(const Decl &parent);

  inline static std::optional<ObjCIvarDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCIvarDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCIvarDeclAccessControl access_control(void) const;
  ObjCIvarDeclAccessControl canonical_access_control(void) const;
  ObjCInterfaceDecl containing_interface(void) const;
  ObjCIvarDecl next_instance_variable(void) const;
  bool synthesize(void) const;
};

using ObjCAtDefsFieldDeclRange = DerivedEntityRange<DeclIterator, ObjCAtDefsFieldDecl>;
using ObjCAtDefsFieldDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCAtDefsFieldDecl>;
using ObjCAtDefsFieldDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCAtDefsFieldDecl>;

class ObjCAtDefsFieldDecl : public FieldDecl {
 private:
  friend class FragmentImpl;
  friend class FieldDecl;
  friend class DeclaratorDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCAtDefsFieldDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCAtDefsFieldDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCAtDefsFieldDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_AT_DEFS_FIELD;
  }

  static ObjCAtDefsFieldDeclContainingDeclRange containing(const Decl &decl);
  static ObjCAtDefsFieldDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCAtDefsFieldDecl> from(const TokenContext &c);
  static std::optional<ObjCAtDefsFieldDecl> from(const FieldDecl &parent);

  inline static std::optional<ObjCAtDefsFieldDecl> from(const std::optional<FieldDecl> &parent) {
    if (parent) {
      return ObjCAtDefsFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAtDefsFieldDecl> from(const DeclaratorDecl &parent);

  inline static std::optional<ObjCAtDefsFieldDecl> from(const std::optional<DeclaratorDecl> &parent) {
    if (parent) {
      return ObjCAtDefsFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAtDefsFieldDecl> from(const ValueDecl &parent);

  inline static std::optional<ObjCAtDefsFieldDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return ObjCAtDefsFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAtDefsFieldDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCAtDefsFieldDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCAtDefsFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCAtDefsFieldDecl> from(const Decl &parent);

  inline static std::optional<ObjCAtDefsFieldDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCAtDefsFieldDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using BindingDeclRange = DerivedEntityRange<DeclIterator, BindingDecl>;
using BindingDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, BindingDecl>;
using BindingDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, BindingDecl>;

class BindingDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static BindingDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BindingDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BindingDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::BINDING;
  }

  static BindingDeclContainingDeclRange containing(const Decl &decl);
  static BindingDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BindingDecl> from(const TokenContext &c);
  static std::optional<BindingDecl> from(const ValueDecl &parent);

  inline static std::optional<BindingDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return BindingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BindingDecl> from(const NamedDecl &parent);

  inline static std::optional<BindingDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return BindingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BindingDecl> from(const Decl &parent);

  inline static std::optional<BindingDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return BindingDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr binding(void) const;
  ValueDecl decomposed_declaration(void) const;
  VarDecl holding_variable(void) const;
};

using OMPDeclarativeDirectiveValueDeclRange = DerivedEntityRange<DeclIterator, OMPDeclarativeDirectiveValueDecl>;
using OMPDeclarativeDirectiveValueDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclarativeDirectiveValueDecl>;
using OMPDeclarativeDirectiveValueDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPDeclarativeDirectiveValueDecl>;

class OMPDeclarativeDirectiveValueDecl : public ValueDecl {
 private:
  friend class FragmentImpl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static OMPDeclarativeDirectiveValueDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclarativeDirectiveValueDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclarativeDirectiveValueDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  static OMPDeclarativeDirectiveValueDeclContainingDeclRange containing(const Decl &decl);
  static OMPDeclarativeDirectiveValueDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDeclarativeDirectiveValueDecl> from(const TokenContext &c);
  static std::optional<OMPDeclarativeDirectiveValueDecl> from(const ValueDecl &parent);

  inline static std::optional<OMPDeclarativeDirectiveValueDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return OMPDeclarativeDirectiveValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclarativeDirectiveValueDecl> from(const NamedDecl &parent);

  inline static std::optional<OMPDeclarativeDirectiveValueDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return OMPDeclarativeDirectiveValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclarativeDirectiveValueDecl> from(const Decl &parent);

  inline static std::optional<OMPDeclarativeDirectiveValueDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPDeclarativeDirectiveValueDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using OMPDeclareMapperDeclRange = DerivedEntityRange<DeclIterator, OMPDeclareMapperDecl>;
using OMPDeclareMapperDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, OMPDeclareMapperDecl>;
using OMPDeclareMapperDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, OMPDeclareMapperDecl>;

class OMPDeclareMapperDecl : public OMPDeclarativeDirectiveValueDecl {
 private:
  friend class FragmentImpl;
  friend class OMPDeclarativeDirectiveValueDecl;
  friend class ValueDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static OMPDeclareMapperDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static OMPDeclareMapperDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : OMPDeclareMapperDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OMP_DECLARE_MAPPER;
  }

  static OMPDeclareMapperDeclContainingDeclRange containing(const Decl &decl);
  static OMPDeclareMapperDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<OMPDeclareMapperDecl> from(const TokenContext &c);
  static std::optional<OMPDeclareMapperDecl> from(const OMPDeclarativeDirectiveValueDecl &parent);

  inline static std::optional<OMPDeclareMapperDecl> from(const std::optional<OMPDeclarativeDirectiveValueDecl> &parent) {
    if (parent) {
      return OMPDeclareMapperDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareMapperDecl> from(const ValueDecl &parent);

  inline static std::optional<OMPDeclareMapperDecl> from(const std::optional<ValueDecl> &parent) {
    if (parent) {
      return OMPDeclareMapperDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareMapperDecl> from(const NamedDecl &parent);

  inline static std::optional<OMPDeclareMapperDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return OMPDeclareMapperDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<OMPDeclareMapperDecl> from(const Decl &parent);

  inline static std::optional<OMPDeclareMapperDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return OMPDeclareMapperDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr mapper_variable_reference(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using UsingShadowDeclRange = DerivedEntityRange<DeclIterator, UsingShadowDecl>;
using UsingShadowDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingShadowDecl>;
using UsingShadowDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UsingShadowDecl>;

class UsingShadowDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UsingShadowDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingShadowDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingShadowDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::USING_SHADOW;
  }

  static UsingShadowDeclContainingDeclRange containing(const Decl &decl);
  static UsingShadowDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UsingShadowDecl> from(const TokenContext &c);
  static std::optional<UsingShadowDecl> from(const NamedDecl &parent);

  inline static std::optional<UsingShadowDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UsingShadowDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingShadowDecl> from(const Decl &parent);

  inline static std::optional<UsingShadowDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UsingShadowDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  BaseUsingDecl introducer(void) const;
  std::optional<UsingShadowDecl> next_using_shadow_declaration(void) const;
  NamedDecl target_declaration(void) const;
};

using ConstructorUsingShadowDeclRange = DerivedEntityRange<DeclIterator, ConstructorUsingShadowDecl>;
using ConstructorUsingShadowDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConstructorUsingShadowDecl>;
using ConstructorUsingShadowDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ConstructorUsingShadowDecl>;

class ConstructorUsingShadowDecl : public UsingShadowDecl {
 private:
  friend class FragmentImpl;
  friend class UsingShadowDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ConstructorUsingShadowDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConstructorUsingShadowDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConstructorUsingShadowDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CONSTRUCTOR_USING_SHADOW;
  }

  static ConstructorUsingShadowDeclContainingDeclRange containing(const Decl &decl);
  static ConstructorUsingShadowDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConstructorUsingShadowDecl> from(const TokenContext &c);
  static std::optional<ConstructorUsingShadowDecl> from(const UsingShadowDecl &parent);

  inline static std::optional<ConstructorUsingShadowDecl> from(const std::optional<UsingShadowDecl> &parent) {
    if (parent) {
      return ConstructorUsingShadowDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstructorUsingShadowDecl> from(const NamedDecl &parent);

  inline static std::optional<ConstructorUsingShadowDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ConstructorUsingShadowDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConstructorUsingShadowDecl> from(const Decl &parent);

  inline static std::optional<ConstructorUsingShadowDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ConstructorUsingShadowDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool constructs_virtual_base(void) const;
  CXXRecordDecl constructed_base_class(void) const;
  std::optional<ConstructorUsingShadowDecl> constructed_base_class_shadow_declaration(void) const;
  CXXRecordDecl nominated_base_class(void) const;
  std::optional<ConstructorUsingShadowDecl> nominated_base_class_shadow_declaration(void) const;
};

using UsingPackDeclRange = DerivedEntityRange<DeclIterator, UsingPackDecl>;
using UsingPackDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingPackDecl>;
using UsingPackDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UsingPackDecl>;

class UsingPackDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UsingPackDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingPackDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingPackDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::USING_PACK;
  }

  static UsingPackDeclContainingDeclRange containing(const Decl &decl);
  static UsingPackDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UsingPackDecl> from(const TokenContext &c);
  static std::optional<UsingPackDecl> from(const NamedDecl &parent);

  inline static std::optional<UsingPackDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UsingPackDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingPackDecl> from(const Decl &parent);

  inline static std::optional<UsingPackDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UsingPackDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<NamedDecl> expansions(void) const;
  NamedDecl instantiated_from_using_declaration(void) const;
};

using UsingDirectiveDeclRange = DerivedEntityRange<DeclIterator, UsingDirectiveDecl>;
using UsingDirectiveDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UsingDirectiveDecl>;
using UsingDirectiveDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UsingDirectiveDecl>;

class UsingDirectiveDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UsingDirectiveDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UsingDirectiveDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UsingDirectiveDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::USING_DIRECTIVE;
  }

  static UsingDirectiveDeclContainingDeclRange containing(const Decl &decl);
  static UsingDirectiveDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UsingDirectiveDecl> from(const TokenContext &c);
  static std::optional<UsingDirectiveDecl> from(const NamedDecl &parent);

  inline static std::optional<UsingDirectiveDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UsingDirectiveDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UsingDirectiveDecl> from(const Decl &parent);

  inline static std::optional<UsingDirectiveDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UsingDirectiveDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token identifier_token(void) const;
  Token namespace_key_token(void) const;
  NamedDecl nominated_namespace_as_written(void) const;
  Token using_token(void) const;
};

using UnresolvedUsingIfExistsDeclRange = DerivedEntityRange<DeclIterator, UnresolvedUsingIfExistsDecl>;
using UnresolvedUsingIfExistsDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedUsingIfExistsDecl>;
using UnresolvedUsingIfExistsDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UnresolvedUsingIfExistsDecl>;

class UnresolvedUsingIfExistsDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UnresolvedUsingIfExistsDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedUsingIfExistsDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedUsingIfExistsDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::UNRESOLVED_USING_IF_EXISTS;
  }

  static UnresolvedUsingIfExistsDeclContainingDeclRange containing(const Decl &decl);
  static UnresolvedUsingIfExistsDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnresolvedUsingIfExistsDecl> from(const TokenContext &c);
  static std::optional<UnresolvedUsingIfExistsDecl> from(const NamedDecl &parent);

  inline static std::optional<UnresolvedUsingIfExistsDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UnresolvedUsingIfExistsDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedUsingIfExistsDecl> from(const Decl &parent);

  inline static std::optional<UnresolvedUsingIfExistsDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UnresolvedUsingIfExistsDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TypeDeclRange = DerivedEntityRange<DeclIterator, TypeDecl>;
using TypeDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeDecl>;
using TypeDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TypeDecl>;

class TypeDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TypeDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TYPE;
  }

  static TypeDeclContainingDeclRange containing(const Decl &decl);
  static TypeDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypeDecl> from(const TokenContext &c);
  static std::optional<TypeDecl> from(const NamedDecl &parent);

  inline static std::optional<TypeDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TypeDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeDecl> from(const Decl &parent);

  inline static std::optional<TypeDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TypeDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<Type> type_for_declaration(void) const;
};

using TemplateTypeParmDeclRange = DerivedEntityRange<DeclIterator, TemplateTypeParmDecl>;
using TemplateTypeParmDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateTypeParmDecl>;
using TemplateTypeParmDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TemplateTypeParmDecl>;

class TemplateTypeParmDecl : public TypeDecl {
 private:
  friend class FragmentImpl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TemplateTypeParmDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateTypeParmDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateTypeParmDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TEMPLATE_TYPE_PARM;
  }

  static TemplateTypeParmDeclContainingDeclRange containing(const Decl &decl);
  static TemplateTypeParmDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TemplateTypeParmDecl> from(const TokenContext &c);
  static std::optional<TemplateTypeParmDecl> from(const TypeDecl &parent);

  inline static std::optional<TemplateTypeParmDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return TemplateTypeParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateTypeParmDecl> from(const NamedDecl &parent);

  inline static std::optional<TemplateTypeParmDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TemplateTypeParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateTypeParmDecl> from(const Decl &parent);

  inline static std::optional<TemplateTypeParmDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TemplateTypeParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool default_argument_was_inherited(void) const;
  std::optional<Type> default_argument(void) const;
  std::optional<Type> default_argument_info(void) const;
  Token default_argument_token(void) const;
  bool has_default_argument(void) const;
  bool has_type_constraint(void) const;
  bool is_expanded_parameter_pack(void) const;
  bool is_pack_expansion(void) const;
  bool was_declared_with_typename(void) const;
};

using TagDeclRange = DerivedEntityRange<DeclIterator, TagDecl>;
using TagDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TagDecl>;
using TagDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TagDecl>;

class TagDecl : public TypeDecl {
 private:
  friend class FragmentImpl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TagDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TagDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TagDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TAG;
  }

  static TagDeclContainingDeclRange containing(const Decl &decl);
  static TagDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TagDecl> from(const TokenContext &c);
  static std::optional<TagDecl> from(const TypeDecl &parent);

  inline static std::optional<TagDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return TagDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TagDecl> from(const NamedDecl &parent);

  inline static std::optional<TagDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TagDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TagDecl> from(const Decl &parent);

  inline static std::optional<TagDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TagDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  TokenRange brace_range(void) const;
  Token first_inner_token(void) const;
  Token first_outer_token(void) const;
  TagTypeKind tag_kind(void) const;
  std::optional<TypedefNameDecl> typedef_name_for_anonymous_declaration(void) const;
  bool has_name_for_linkage(void) const;
  bool is_being_defined(void) const;
  bool is_class(void) const;
  bool is_complete_definition(void) const;
  bool is_complete_definition_required(void) const;
  bool is_dependent_type(void) const;
  bool is_embedded_in_declarator(void) const;
  bool is_enum(void) const;
  bool is_free_standing(void) const;
  bool is_interface(void) const;
  bool is_struct(void) const;
  bool is_union(void) const;
  bool may_have_out_of_date_definition(void) const;
  std::vector<TemplateParameterList> template_parameter_lists(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using RecordDeclRange = DerivedEntityRange<DeclIterator, RecordDecl>;
using RecordDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, RecordDecl>;
using RecordDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, RecordDecl>;

class RecordDecl : public TagDecl {
 private:
  friend class FragmentImpl;
  friend class TagDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static RecordDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RecordDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RecordDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::RECORD;
  }

  static RecordDeclContainingDeclRange containing(const Decl &decl);
  static RecordDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<RecordDecl> from(const TokenContext &c);
  static std::optional<RecordDecl> from(const TagDecl &parent);

  inline static std::optional<RecordDecl> from(const std::optional<TagDecl> &parent) {
    if (parent) {
      return RecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecordDecl> from(const TypeDecl &parent);

  inline static std::optional<RecordDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return RecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecordDecl> from(const NamedDecl &parent);

  inline static std::optional<RecordDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return RecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RecordDecl> from(const Decl &parent);

  inline static std::optional<RecordDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return RecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool can_pass_in_registers(void) const;
  std::vector<FieldDecl> fields(void) const;
  RecordDeclArgPassingKind argument_passing_restrictions(void) const;
  bool has_flexible_array_member(void) const;
  bool has_loaded_fields_from_external_storage(void) const;
  bool has_non_trivial_to_primitive_copy_c_union(void) const;
  bool has_non_trivial_to_primitive_default_initialize_c_union(void) const;
  bool has_non_trivial_to_primitive_destruct_c_union(void) const;
  bool has_object_member(void) const;
  bool has_volatile_member(void) const;
  bool is_anonymous_struct_or_union(void) const;
  bool is_captured_record(void) const;
  bool is_injected_class_name(void) const;
  bool is_lambda(void) const;
  bool is_ms_struct(void) const;
  bool is_non_trivial_to_primitive_copy(void) const;
  bool is_non_trivial_to_primitive_default_initialize(void) const;
  bool is_non_trivial_to_primitive_destroy(void) const;
  bool is_or_contains_union(void) const;
  bool is_parameter_destroyed_in_callee(void) const;
  bool may_insert_extra_padding(void) const;
};

using CXXRecordDeclRange = DerivedEntityRange<DeclIterator, CXXRecordDecl>;
using CXXRecordDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, CXXRecordDecl>;
using CXXRecordDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, CXXRecordDecl>;

class CXXRecordDecl : public RecordDecl {
 private:
  friend class FragmentImpl;
  friend class RecordDecl;
  friend class TagDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static CXXRecordDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static CXXRecordDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : CXXRecordDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CXX_RECORD;
  }

  static CXXRecordDeclContainingDeclRange containing(const Decl &decl);
  static CXXRecordDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<CXXRecordDecl> from(const TokenContext &c);
  static std::optional<CXXRecordDecl> from(const RecordDecl &parent);

  inline static std::optional<CXXRecordDecl> from(const std::optional<RecordDecl> &parent) {
    if (parent) {
      return CXXRecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRecordDecl> from(const TagDecl &parent);

  inline static std::optional<CXXRecordDecl> from(const std::optional<TagDecl> &parent) {
    if (parent) {
      return CXXRecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRecordDecl> from(const TypeDecl &parent);

  inline static std::optional<CXXRecordDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return CXXRecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRecordDecl> from(const NamedDecl &parent);

  inline static std::optional<CXXRecordDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return CXXRecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<CXXRecordDecl> from(const Decl &parent);

  inline static std::optional<CXXRecordDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return CXXRecordDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<bool> allow_const_default_initializer(void) const;
  std::optional<std::vector<CXXBaseSpecifier>> bases(void) const;
  std::optional<MSInheritanceModel> calculate_inheritance_model(void) const;
  std::vector<CXXConstructorDecl> constructors(void) const;
  std::optional<std::vector<FriendDecl>> friends(void) const;
  std::optional<CXXDestructorDecl> destructor(void) const;
  std::optional<TemplateParameterList> generic_lambda_template_parameter_list(void) const;
  std::optional<CXXRecordDecl> instantiated_from_member_class(void) const;
  std::optional<CXXMethodDecl> lambda_call_operator(void) const;
  std::optional<LambdaCaptureDefault> lambda_capture_default(void) const;
  std::optional<Decl> lambda_context_declaration(void) const;
  std::optional<std::vector<NamedDecl>> lambda_explicit_template_parameters(void) const;
  std::optional<unsigned> lambda_mangling_number(void) const;
  std::optional<Type> lambda_type(void) const;
  std::optional<MSInheritanceModel> ms_inheritance_model(void) const;
  MSVtorDispMode ms_vtor_disp_mode(void) const;
  std::optional<unsigned> num_bases(void) const;
  std::optional<unsigned> num_virtual_bases(void) const;
  std::optional<unsigned> odr_hash(void) const;
  std::optional<CXXRecordDecl> template_instantiation_pattern(void) const;
  TemplateSpecializationKind template_specialization_kind(void) const;
  std::optional<bool> has_any_dependent_bases(void) const;
  std::optional<bool> has_constexpr_default_constructor(void) const;
  std::optional<bool> has_constexpr_destructor(void) const;
  std::optional<bool> has_constexpr_non_copy_move_constructor(void) const;
  std::optional<bool> has_copy_assignment_with_const_parameter(void) const;
  std::optional<bool> has_copy_constructor_with_const_parameter(void) const;
  std::optional<bool> has_default_constructor(void) const;
  std::optional<bool> has_definition(void) const;
  std::optional<bool> has_direct_fields(void) const;
  std::optional<bool> has_friends(void) const;
  std::optional<bool> has_in_class_initializer(void) const;
  std::optional<bool> has_inherited_assignment(void) const;
  std::optional<bool> has_inherited_constructor(void) const;
  std::optional<bool> has_initializer_method(void) const;
  std::optional<bool> has_irrelevant_destructor(void) const;
  std::optional<bool> has_known_lambda_internal_linkage(void) const;
  std::optional<bool> has_move_assignment(void) const;
  std::optional<bool> has_move_constructor(void) const;
  std::optional<bool> has_mutable_fields(void) const;
  std::optional<bool> has_non_literal_type_fields_or_bases(void) const;
  std::optional<bool> has_non_trivial_copy_assignment(void) const;
  std::optional<bool> has_non_trivial_copy_constructor(void) const;
  std::optional<bool> has_non_trivial_copy_constructor_for_call(void) const;
  std::optional<bool> has_non_trivial_default_constructor(void) const;
  std::optional<bool> has_non_trivial_destructor(void) const;
  std::optional<bool> has_non_trivial_destructor_for_call(void) const;
  std::optional<bool> has_non_trivial_move_assignment(void) const;
  std::optional<bool> has_non_trivial_move_constructor(void) const;
  std::optional<bool> has_non_trivial_move_constructor_for_call(void) const;
  std::optional<bool> has_private_fields(void) const;
  std::optional<bool> has_protected_fields(void) const;
  std::optional<bool> has_simple_copy_assignment(void) const;
  std::optional<bool> has_simple_copy_constructor(void) const;
  std::optional<bool> has_simple_destructor(void) const;
  std::optional<bool> has_simple_move_assignment(void) const;
  std::optional<bool> has_simple_move_constructor(void) const;
  std::optional<bool> has_trivial_copy_assignment(void) const;
  std::optional<bool> has_trivial_copy_constructor(void) const;
  std::optional<bool> has_trivial_copy_constructor_for_call(void) const;
  std::optional<bool> has_trivial_default_constructor(void) const;
  std::optional<bool> has_trivial_destructor(void) const;
  std::optional<bool> has_trivial_destructor_for_call(void) const;
  std::optional<bool> has_trivial_move_assignment(void) const;
  std::optional<bool> has_trivial_move_constructor(void) const;
  std::optional<bool> has_trivial_move_constructor_for_call(void) const;
  std::optional<bool> has_uninitialized_reference_member(void) const;
  std::optional<bool> has_user_declared_constructor(void) const;
  std::optional<bool> has_user_declared_copy_assignment(void) const;
  std::optional<bool> has_user_declared_copy_constructor(void) const;
  std::optional<bool> has_user_declared_destructor(void) const;
  std::optional<bool> has_user_declared_move_assignment(void) const;
  std::optional<bool> has_user_declared_move_constructor(void) const;
  std::optional<bool> has_user_declared_move_operation(void) const;
  std::optional<bool> has_user_provided_default_constructor(void) const;
  std::optional<bool> has_variant_members(void) const;
  std::optional<bool> implicit_copy_assignment_has_const_parameter(void) const;
  std::optional<bool> implicit_copy_constructor_has_const_parameter(void) const;
  std::optional<bool> is_abstract(void) const;
  std::optional<bool> is_aggregate(void) const;
  std::optional<bool> is_any_destructor_no_return(void) const;
  std::optional<bool> is_c_like(void) const;
  std::optional<bool> is_cxx11_standard_layout(void) const;
  bool is_dependent_lambda(void) const;
  std::optional<bool> is_dynamic_class(void) const;
  std::optional<bool> is_effectively_final(void) const;
  std::optional<bool> is_empty(void) const;
  bool is_generic_lambda(void) const;
  std::optional<bool> is_interface_like(void) const;
  std::optional<bool> is_literal(void) const;
  std::optional<FunctionDecl> is_local_class(void) const;
  std::optional<bool> is_pod(void) const;
  std::optional<bool> is_polymorphic(void) const;
  std::optional<bool> is_standard_layout(void) const;
  std::optional<bool> is_structural(void) const;
  std::optional<bool> is_trivial(void) const;
  std::optional<bool> is_trivially_copyable(void) const;
  std::optional<bool> lambda_is_default_constructible_and_assignable(void) const;
  std::optional<bool> may_be_abstract(void) const;
  std::optional<bool> may_be_dynamic_class(void) const;
  std::optional<bool> may_be_non_dynamic_class(void) const;
  std::optional<std::vector<CXXMethodDecl>> methods(void) const;
  std::optional<bool> needs_implicit_copy_assignment(void) const;
  std::optional<bool> needs_implicit_copy_constructor(void) const;
  std::optional<bool> needs_implicit_default_constructor(void) const;
  std::optional<bool> needs_implicit_destructor(void) const;
  std::optional<bool> needs_implicit_move_assignment(void) const;
  std::optional<bool> needs_implicit_move_constructor(void) const;
  std::optional<bool> needs_overload_resolution_for_copy_assignment(void) const;
  std::optional<bool> needs_overload_resolution_for_copy_constructor(void) const;
  std::optional<bool> needs_overload_resolution_for_destructor(void) const;
  std::optional<bool> needs_overload_resolution_for_move_assignment(void) const;
  std::optional<bool> needs_overload_resolution_for_move_constructor(void) const;
  std::optional<bool> null_field_offset_is_zero(void) const;
  std::optional<std::vector<CXXBaseSpecifier>> virtual_bases(void) const;
};

using ClassTemplateSpecializationDeclRange = DerivedEntityRange<DeclIterator, ClassTemplateSpecializationDecl>;
using ClassTemplateSpecializationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ClassTemplateSpecializationDecl>;
using ClassTemplateSpecializationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ClassTemplateSpecializationDecl>;

class ClassTemplateSpecializationDecl : public CXXRecordDecl {
 private:
  friend class FragmentImpl;
  friend class CXXRecordDecl;
  friend class RecordDecl;
  friend class TagDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ClassTemplateSpecializationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ClassTemplateSpecializationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ClassTemplateSpecializationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CLASS_TEMPLATE_SPECIALIZATION;
  }

  static ClassTemplateSpecializationDeclContainingDeclRange containing(const Decl &decl);
  static ClassTemplateSpecializationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ClassTemplateSpecializationDecl> from(const TokenContext &c);
  static std::optional<ClassTemplateSpecializationDecl> from(const CXXRecordDecl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<CXXRecordDecl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateSpecializationDecl> from(const RecordDecl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<RecordDecl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateSpecializationDecl> from(const TagDecl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<TagDecl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateSpecializationDecl> from(const TypeDecl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateSpecializationDecl> from(const NamedDecl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateSpecializationDecl> from(const Decl &parent);

  inline static std::optional<ClassTemplateSpecializationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ClassTemplateSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token extern_token(void) const;
  Token point_of_instantiation(void) const;
  TemplateSpecializationKind specialization_kind(void) const;
  std::vector<TemplateArgument> template_arguments(void) const;
  std::vector<TemplateArgument> template_instantiation_arguments(void) const;
  Token template_keyword_token(void) const;
  std::optional<Type> type_as_written(void) const;
  bool is_class_scope_explicit_specialization(void) const;
  bool is_explicit_instantiation_or_specialization(void) const;
  bool is_explicit_specialization(void) const;
};

using ClassTemplatePartialSpecializationDeclRange = DerivedEntityRange<DeclIterator, ClassTemplatePartialSpecializationDecl>;
using ClassTemplatePartialSpecializationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ClassTemplatePartialSpecializationDecl>;
using ClassTemplatePartialSpecializationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ClassTemplatePartialSpecializationDecl>;

class ClassTemplatePartialSpecializationDecl : public ClassTemplateSpecializationDecl {
 private:
  friend class FragmentImpl;
  friend class ClassTemplateSpecializationDecl;
  friend class CXXRecordDecl;
  friend class RecordDecl;
  friend class TagDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ClassTemplatePartialSpecializationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ClassTemplatePartialSpecializationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ClassTemplatePartialSpecializationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CLASS_TEMPLATE_PARTIAL_SPECIALIZATION;
  }

  static ClassTemplatePartialSpecializationDeclContainingDeclRange containing(const Decl &decl);
  static ClassTemplatePartialSpecializationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const TokenContext &c);
  static std::optional<ClassTemplatePartialSpecializationDecl> from(const ClassTemplateSpecializationDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<ClassTemplateSpecializationDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const CXXRecordDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<CXXRecordDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const RecordDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<RecordDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const TagDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<TagDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const TypeDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const NamedDecl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplatePartialSpecializationDecl> from(const Decl &parent);

  inline static std::optional<ClassTemplatePartialSpecializationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ClassTemplatePartialSpecializationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using EnumDeclRange = DerivedEntityRange<DeclIterator, EnumDecl>;
using EnumDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, EnumDecl>;
using EnumDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, EnumDecl>;

class EnumDecl : public TagDecl {
 private:
  friend class FragmentImpl;
  friend class TagDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static EnumDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EnumDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EnumDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::ENUM;
  }

  static EnumDeclContainingDeclRange containing(const Decl &decl);
  static EnumDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<EnumDecl> from(const TokenContext &c);
  static std::optional<EnumDecl> from(const TagDecl &parent);

  inline static std::optional<EnumDecl> from(const std::optional<TagDecl> &parent) {
    if (parent) {
      return EnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumDecl> from(const TypeDecl &parent);

  inline static std::optional<EnumDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return EnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumDecl> from(const NamedDecl &parent);

  inline static std::optional<EnumDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return EnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<EnumDecl> from(const Decl &parent);

  inline static std::optional<EnumDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return EnumDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<EnumConstantDecl> enumerators(void) const;
  std::optional<EnumDecl> instantiated_from_member_enum(void) const;
  std::optional<Type> integer_type(void) const;
  TokenRange integer_type_range(void) const;
  std::optional<unsigned> odr_hash(void) const;
  std::optional<Type> promotion_type(void) const;
  std::optional<EnumDecl> template_instantiation_pattern(void) const;
  TemplateSpecializationKind template_specialization_kind(void) const;
  bool is_closed(void) const;
  bool is_closed_flag(void) const;
  bool is_closed_non_flag(void) const;
  bool is_complete(void) const;
  bool is_fixed(void) const;
  bool is_scoped(void) const;
  bool is_scoped_using_class_tag(void) const;
};

using UnresolvedUsingTypenameDeclRange = DerivedEntityRange<DeclIterator, UnresolvedUsingTypenameDecl>;
using UnresolvedUsingTypenameDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, UnresolvedUsingTypenameDecl>;
using UnresolvedUsingTypenameDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, UnresolvedUsingTypenameDecl>;

class UnresolvedUsingTypenameDecl : public TypeDecl {
 private:
  friend class FragmentImpl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static UnresolvedUsingTypenameDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static UnresolvedUsingTypenameDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : UnresolvedUsingTypenameDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::UNRESOLVED_USING_TYPENAME;
  }

  static UnresolvedUsingTypenameDeclContainingDeclRange containing(const Decl &decl);
  static UnresolvedUsingTypenameDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<UnresolvedUsingTypenameDecl> from(const TokenContext &c);
  static std::optional<UnresolvedUsingTypenameDecl> from(const TypeDecl &parent);

  inline static std::optional<UnresolvedUsingTypenameDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return UnresolvedUsingTypenameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedUsingTypenameDecl> from(const NamedDecl &parent);

  inline static std::optional<UnresolvedUsingTypenameDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return UnresolvedUsingTypenameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<UnresolvedUsingTypenameDecl> from(const Decl &parent);

  inline static std::optional<UnresolvedUsingTypenameDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return UnresolvedUsingTypenameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token ellipsis_token(void) const;
  Token typename_token(void) const;
  Token using_token(void) const;
  bool is_pack_expansion(void) const;
};

using TypedefNameDeclRange = DerivedEntityRange<DeclIterator, TypedefNameDecl>;
using TypedefNameDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypedefNameDecl>;
using TypedefNameDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TypedefNameDecl>;

class TypedefNameDecl : public TypeDecl {
 private:
  friend class FragmentImpl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TypedefNameDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypedefNameDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypedefNameDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TYPEDEF_NAME;
  }

  static TypedefNameDeclContainingDeclRange containing(const Decl &decl);
  static TypedefNameDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypedefNameDecl> from(const TokenContext &c);
  static std::optional<TypedefNameDecl> from(const TypeDecl &parent);

  inline static std::optional<TypedefNameDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return TypedefNameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypedefNameDecl> from(const NamedDecl &parent);

  inline static std::optional<TypedefNameDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TypedefNameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypedefNameDecl> from(const Decl &parent);

  inline static std::optional<TypedefNameDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TypedefNameDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<TagDecl> anonymous_declaration_with_typedef_name(void) const;
  Type underlying_type(void) const;
  bool is_moded(void) const;
  bool is_transparent_tag(void) const;
};

using TypedefDeclRange = DerivedEntityRange<DeclIterator, TypedefDecl>;
using TypedefDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypedefDecl>;
using TypedefDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TypedefDecl>;

class TypedefDecl : public TypedefNameDecl {
 private:
  friend class FragmentImpl;
  friend class TypedefNameDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TypedefDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypedefDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypedefDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TYPEDEF;
  }

  static TypedefDeclContainingDeclRange containing(const Decl &decl);
  static TypedefDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypedefDecl> from(const TokenContext &c);
  static std::optional<TypedefDecl> from(const TypedefNameDecl &parent);

  inline static std::optional<TypedefDecl> from(const std::optional<TypedefNameDecl> &parent) {
    if (parent) {
      return TypedefDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypedefDecl> from(const TypeDecl &parent);

  inline static std::optional<TypedefDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return TypedefDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypedefDecl> from(const NamedDecl &parent);

  inline static std::optional<TypedefDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TypedefDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypedefDecl> from(const Decl &parent);

  inline static std::optional<TypedefDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TypedefDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TypeAliasDeclRange = DerivedEntityRange<DeclIterator, TypeAliasDecl>;
using TypeAliasDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeAliasDecl>;
using TypeAliasDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TypeAliasDecl>;

class TypeAliasDecl : public TypedefNameDecl {
 private:
  friend class FragmentImpl;
  friend class TypedefNameDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TypeAliasDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeAliasDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeAliasDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TYPE_ALIAS;
  }

  static TypeAliasDeclContainingDeclRange containing(const Decl &decl);
  static TypeAliasDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypeAliasDecl> from(const TokenContext &c);
  static std::optional<TypeAliasDecl> from(const TypedefNameDecl &parent);

  inline static std::optional<TypeAliasDecl> from(const std::optional<TypedefNameDecl> &parent) {
    if (parent) {
      return TypeAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasDecl> from(const TypeDecl &parent);

  inline static std::optional<TypeAliasDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return TypeAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasDecl> from(const NamedDecl &parent);

  inline static std::optional<TypeAliasDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TypeAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasDecl> from(const Decl &parent);

  inline static std::optional<TypeAliasDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TypeAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<TypeAliasTemplateDecl> described_alias_template(void) const;
};

using ObjCTypeParamDeclRange = DerivedEntityRange<DeclIterator, ObjCTypeParamDecl>;
using ObjCTypeParamDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCTypeParamDecl>;
using ObjCTypeParamDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCTypeParamDecl>;

class ObjCTypeParamDecl : public TypedefNameDecl {
 private:
  friend class FragmentImpl;
  friend class TypedefNameDecl;
  friend class TypeDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCTypeParamDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCTypeParamDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCTypeParamDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_TYPE_PARAM;
  }

  static ObjCTypeParamDeclContainingDeclRange containing(const Decl &decl);
  static ObjCTypeParamDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCTypeParamDecl> from(const TokenContext &c);
  static std::optional<ObjCTypeParamDecl> from(const TypedefNameDecl &parent);

  inline static std::optional<ObjCTypeParamDecl> from(const std::optional<TypedefNameDecl> &parent) {
    if (parent) {
      return ObjCTypeParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCTypeParamDecl> from(const TypeDecl &parent);

  inline static std::optional<ObjCTypeParamDecl> from(const std::optional<TypeDecl> &parent) {
    if (parent) {
      return ObjCTypeParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCTypeParamDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCTypeParamDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCTypeParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCTypeParamDecl> from(const Decl &parent);

  inline static std::optional<ObjCTypeParamDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCTypeParamDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token colon_token(void) const;
  ObjCTypeParamVariance variance(void) const;
  Token variance_token(void) const;
  bool has_explicit_bound(void) const;
};

using TemplateDeclRange = DerivedEntityRange<DeclIterator, TemplateDecl>;
using TemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateDecl>;
using TemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TemplateDecl>;

class TemplateDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TEMPLATE;
  }

  static TemplateDeclContainingDeclRange containing(const Decl &decl);
  static TemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TemplateDecl> from(const TokenContext &c);
  static std::optional<TemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<TemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateDecl> from(const Decl &parent);

  inline static std::optional<TemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using RedeclarableTemplateDeclRange = DerivedEntityRange<DeclIterator, RedeclarableTemplateDecl>;
using RedeclarableTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, RedeclarableTemplateDecl>;
using RedeclarableTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, RedeclarableTemplateDecl>;

class RedeclarableTemplateDecl : public TemplateDecl {
 private:
  friend class FragmentImpl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static RedeclarableTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static RedeclarableTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : RedeclarableTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::REDECLARABLE_TEMPLATE;
  }

  static RedeclarableTemplateDeclContainingDeclRange containing(const Decl &decl);
  static RedeclarableTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<RedeclarableTemplateDecl> from(const TokenContext &c);
  static std::optional<RedeclarableTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<RedeclarableTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return RedeclarableTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RedeclarableTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<RedeclarableTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return RedeclarableTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<RedeclarableTemplateDecl> from(const Decl &parent);

  inline static std::optional<RedeclarableTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return RedeclarableTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using FunctionTemplateDeclRange = DerivedEntityRange<DeclIterator, FunctionTemplateDecl>;
using FunctionTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FunctionTemplateDecl>;
using FunctionTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FunctionTemplateDecl>;

class FunctionTemplateDecl : public RedeclarableTemplateDecl {
 private:
  friend class FragmentImpl;
  friend class RedeclarableTemplateDecl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static FunctionTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FunctionTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FunctionTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FUNCTION_TEMPLATE;
  }

  static FunctionTemplateDeclContainingDeclRange containing(const Decl &decl);
  static FunctionTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FunctionTemplateDecl> from(const TokenContext &c);
  static std::optional<FunctionTemplateDecl> from(const RedeclarableTemplateDecl &parent);

  inline static std::optional<FunctionTemplateDecl> from(const std::optional<RedeclarableTemplateDecl> &parent) {
    if (parent) {
      return FunctionTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<FunctionTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return FunctionTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<FunctionTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return FunctionTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<FunctionTemplateDecl> from(const Decl &parent);

  inline static std::optional<FunctionTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FunctionTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using ClassTemplateDeclRange = DerivedEntityRange<DeclIterator, ClassTemplateDecl>;
using ClassTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ClassTemplateDecl>;
using ClassTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ClassTemplateDecl>;

class ClassTemplateDecl : public RedeclarableTemplateDecl {
 private:
  friend class FragmentImpl;
  friend class RedeclarableTemplateDecl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ClassTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ClassTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ClassTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CLASS_TEMPLATE;
  }

  static ClassTemplateDeclContainingDeclRange containing(const Decl &decl);
  static ClassTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ClassTemplateDecl> from(const TokenContext &c);
  static std::optional<ClassTemplateDecl> from(const RedeclarableTemplateDecl &parent);

  inline static std::optional<ClassTemplateDecl> from(const std::optional<RedeclarableTemplateDecl> &parent) {
    if (parent) {
      return ClassTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<ClassTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return ClassTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<ClassTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ClassTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ClassTemplateDecl> from(const Decl &parent);

  inline static std::optional<ClassTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ClassTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using VarTemplateDeclRange = DerivedEntityRange<DeclIterator, VarTemplateDecl>;
using VarTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, VarTemplateDecl>;
using VarTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, VarTemplateDecl>;

class VarTemplateDecl : public RedeclarableTemplateDecl {
 private:
  friend class FragmentImpl;
  friend class RedeclarableTemplateDecl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static VarTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static VarTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : VarTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::VAR_TEMPLATE;
  }

  static VarTemplateDeclContainingDeclRange containing(const Decl &decl);
  static VarTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<VarTemplateDecl> from(const TokenContext &c);
  static std::optional<VarTemplateDecl> from(const RedeclarableTemplateDecl &parent);

  inline static std::optional<VarTemplateDecl> from(const std::optional<RedeclarableTemplateDecl> &parent) {
    if (parent) {
      return VarTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<VarTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return VarTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<VarTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return VarTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<VarTemplateDecl> from(const Decl &parent);

  inline static std::optional<VarTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return VarTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TypeAliasTemplateDeclRange = DerivedEntityRange<DeclIterator, TypeAliasTemplateDecl>;
using TypeAliasTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TypeAliasTemplateDecl>;
using TypeAliasTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TypeAliasTemplateDecl>;

class TypeAliasTemplateDecl : public RedeclarableTemplateDecl {
 private:
  friend class FragmentImpl;
  friend class RedeclarableTemplateDecl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TypeAliasTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TypeAliasTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TypeAliasTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TYPE_ALIAS_TEMPLATE;
  }

  static TypeAliasTemplateDeclContainingDeclRange containing(const Decl &decl);
  static TypeAliasTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TypeAliasTemplateDecl> from(const TokenContext &c);
  static std::optional<TypeAliasTemplateDecl> from(const RedeclarableTemplateDecl &parent);

  inline static std::optional<TypeAliasTemplateDecl> from(const std::optional<RedeclarableTemplateDecl> &parent) {
    if (parent) {
      return TypeAliasTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<TypeAliasTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return TypeAliasTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<TypeAliasTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TypeAliasTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TypeAliasTemplateDecl> from(const Decl &parent);

  inline static std::optional<TypeAliasTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TypeAliasTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<TypeAliasTemplateDecl> instantiated_from_member_template(void) const;
  TypeAliasDecl templated_declaration(void) const;
};

using ConceptDeclRange = DerivedEntityRange<DeclIterator, ConceptDecl>;
using ConceptDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ConceptDecl>;
using ConceptDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ConceptDecl>;

class ConceptDecl : public TemplateDecl {
 private:
  friend class FragmentImpl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ConceptDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ConceptDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ConceptDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::CONCEPT;
  }

  static ConceptDeclContainingDeclRange containing(const Decl &decl);
  static ConceptDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ConceptDecl> from(const TokenContext &c);
  static std::optional<ConceptDecl> from(const TemplateDecl &parent);

  inline static std::optional<ConceptDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return ConceptDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConceptDecl> from(const NamedDecl &parent);

  inline static std::optional<ConceptDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ConceptDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ConceptDecl> from(const Decl &parent);

  inline static std::optional<ConceptDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ConceptDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Expr constraint_expression(void) const;
  bool is_type_concept(void) const;
};

using BuiltinTemplateDeclRange = DerivedEntityRange<DeclIterator, BuiltinTemplateDecl>;
using BuiltinTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, BuiltinTemplateDecl>;
using BuiltinTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, BuiltinTemplateDecl>;

class BuiltinTemplateDecl : public TemplateDecl {
 private:
  friend class FragmentImpl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static BuiltinTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static BuiltinTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : BuiltinTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::BUILTIN_TEMPLATE;
  }

  static BuiltinTemplateDeclContainingDeclRange containing(const Decl &decl);
  static BuiltinTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<BuiltinTemplateDecl> from(const TokenContext &c);
  static std::optional<BuiltinTemplateDecl> from(const TemplateDecl &parent);

  inline static std::optional<BuiltinTemplateDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return BuiltinTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinTemplateDecl> from(const NamedDecl &parent);

  inline static std::optional<BuiltinTemplateDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return BuiltinTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<BuiltinTemplateDecl> from(const Decl &parent);

  inline static std::optional<BuiltinTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return BuiltinTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using TemplateTemplateParmDeclRange = DerivedEntityRange<DeclIterator, TemplateTemplateParmDecl>;
using TemplateTemplateParmDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, TemplateTemplateParmDecl>;
using TemplateTemplateParmDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, TemplateTemplateParmDecl>;

class TemplateTemplateParmDecl : public TemplateDecl {
 private:
  friend class FragmentImpl;
  friend class TemplateDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static TemplateTemplateParmDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static TemplateTemplateParmDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : TemplateTemplateParmDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::TEMPLATE_TEMPLATE_PARM;
  }

  static TemplateTemplateParmDeclContainingDeclRange containing(const Decl &decl);
  static TemplateTemplateParmDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<TemplateTemplateParmDecl> from(const TokenContext &c);
  static std::optional<TemplateTemplateParmDecl> from(const TemplateDecl &parent);

  inline static std::optional<TemplateTemplateParmDecl> from(const std::optional<TemplateDecl> &parent) {
    if (parent) {
      return TemplateTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateTemplateParmDecl> from(const NamedDecl &parent);

  inline static std::optional<TemplateTemplateParmDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return TemplateTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<TemplateTemplateParmDecl> from(const Decl &parent);

  inline static std::optional<TemplateTemplateParmDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return TemplateTemplateParmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using ObjCPropertyDeclRange = DerivedEntityRange<DeclIterator, ObjCPropertyDecl>;
using ObjCPropertyDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCPropertyDecl>;
using ObjCPropertyDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCPropertyDecl>;

class ObjCPropertyDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCPropertyDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCPropertyDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCPropertyDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_PROPERTY;
  }

  static ObjCPropertyDeclContainingDeclRange containing(const Decl &decl);
  static ObjCPropertyDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCPropertyDecl> from(const TokenContext &c);
  static std::optional<ObjCPropertyDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCPropertyDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCPropertyDecl> from(const Decl &parent);

  inline static std::optional<ObjCPropertyDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCPropertyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token at_token(void) const;
  ObjCMethodDecl getter_method_declaration(void) const;
  Token getter_name_token(void) const;
  Token l_paren_token(void) const;
  ObjCPropertyDeclPropertyControl property_implementation(void) const;
  ObjCIvarDecl property_instance_variable_declaration(void) const;
  ObjCPropertyQueryKind query_kind(void) const;
  ObjCPropertyDeclSetterKind setter_kind(void) const;
  ObjCMethodDecl setter_method_declaration(void) const;
  Token setter_name_token(void) const;
  Type type(void) const;
  bool is_atomic(void) const;
  bool is_class_property(void) const;
  bool is_direct_property(void) const;
  bool is_instance_property(void) const;
  bool is_optional(void) const;
  bool is_read_only(void) const;
  bool is_retaining(void) const;
};

using ObjCMethodDeclRange = DerivedEntityRange<DeclIterator, ObjCMethodDecl>;
using ObjCMethodDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCMethodDecl>;
using ObjCMethodDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCMethodDecl>;

class ObjCMethodDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCMethodDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCMethodDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCMethodDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_METHOD;
  }

  static ObjCMethodDeclContainingDeclRange containing(const Decl &decl);
  static ObjCMethodDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCMethodDecl> from(const TokenContext &c);
  static std::optional<ObjCMethodDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCMethodDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCMethodDecl> from(const Decl &parent);

  inline static std::optional<ObjCMethodDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCMethodDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool defined_in_ns_object(void) const;
  ObjCPropertyDecl find_property_declaration(void) const;
  ObjCInterfaceDecl class_interface(void) const;
  ImplicitParamDecl command_declaration(void) const;
  Token declarator_end_token(void) const;
  ObjCMethodDeclImplementationControl implementation_control(void) const;
  ObjCMethodFamily method_family(void) const;
  DeclObjCDeclQualifier obj_c_decl_qualifier(void) const;
  Type return_type(void) const;
  TokenRange return_type_source_range(void) const;
  Token selector_start_token(void) const;
  ImplicitParamDecl self_declaration(void) const;
  bool has_parameter_destroyed_in_callee(void) const;
  bool has_redeclaration(void) const;
  bool has_related_result_type(void) const;
  bool has_skipped_body(void) const;
  bool is_class_method(void) const;
  bool is_defined(void) const;
  bool is_designated_initializer_for_the_interface(void) const;
  bool is_direct_method(void) const;
  bool is_instance_method(void) const;
  bool is_optional(void) const;
  bool is_overriding(void) const;
  bool is_property_accessor(void) const;
  bool is_redeclaration(void) const;
  bool is_synthesized_accessor_stub(void) const;
  bool is_this_declaration_a_designated_initializer(void) const;
  bool is_variadic(void) const;
  std::vector<ParmVarDecl> parameters(void) const;
  std::vector<Token> selector_tokens(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using ObjCContainerDeclRange = DerivedEntityRange<DeclIterator, ObjCContainerDecl>;
using ObjCContainerDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCContainerDecl>;
using ObjCContainerDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCContainerDecl>;

class ObjCContainerDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCContainerDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCContainerDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCContainerDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_CONTAINER;
  }

  static ObjCContainerDeclContainingDeclRange containing(const Decl &decl);
  static ObjCContainerDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCContainerDecl> from(const TokenContext &c);
  static std::optional<ObjCContainerDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCContainerDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCContainerDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCContainerDecl> from(const Decl &parent);

  inline static std::optional<ObjCContainerDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCContainerDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<ObjCMethodDecl> class_methods(void) const;
  std::vector<ObjCPropertyDecl> class_properties(void) const;
  TokenRange at_end_range(void) const;
  Token at_start_token(void) const;
  std::vector<ObjCMethodDecl> instance_methods(void) const;
  std::vector<ObjCPropertyDecl> instance_properties(void) const;
  std::vector<ObjCMethodDecl> methods(void) const;
  std::vector<ObjCPropertyDecl> properties(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using ObjCCategoryDeclRange = DerivedEntityRange<DeclIterator, ObjCCategoryDecl>;
using ObjCCategoryDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCCategoryDecl>;
using ObjCCategoryDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCCategoryDecl>;

class ObjCCategoryDecl : public ObjCContainerDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCCategoryDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCCategoryDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCCategoryDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_CATEGORY;
  }

  static ObjCCategoryDeclContainingDeclRange containing(const Decl &decl);
  static ObjCCategoryDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCCategoryDecl> from(const TokenContext &c);
  static std::optional<ObjCCategoryDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCCategoryDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCCategoryDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCategoryDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCCategoryDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCCategoryDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCategoryDecl> from(const Decl &parent);

  inline static std::optional<ObjCCategoryDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCCategoryDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  bool is_class_extension(void) const;
  Token category_name_token(void) const;
  ObjCInterfaceDecl class_interface(void) const;
  ObjCCategoryImplDecl implementation(void) const;
  Token instance_variable_l_brace_token(void) const;
  Token instance_variable_r_brace_token(void) const;
  ObjCCategoryDecl next_class_category(void) const;
  std::vector<ObjCIvarDecl> instance_variables(void) const;
  std::vector<Token> protocol_tokens(void) const;
  std::vector<ObjCProtocolDecl> protocols(void) const;
};

using ObjCProtocolDeclRange = DerivedEntityRange<DeclIterator, ObjCProtocolDecl>;
using ObjCProtocolDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCProtocolDecl>;
using ObjCProtocolDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCProtocolDecl>;

class ObjCProtocolDecl : public ObjCContainerDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCProtocolDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCProtocolDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCProtocolDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_PROTOCOL;
  }

  static ObjCProtocolDeclContainingDeclRange containing(const Decl &decl);
  static ObjCProtocolDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCProtocolDecl> from(const TokenContext &c);
  static std::optional<ObjCProtocolDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCProtocolDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCProtocolDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCProtocolDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCProtocolDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCProtocolDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCProtocolDecl> from(const Decl &parent);

  inline static std::optional<ObjCProtocolDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCProtocolDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::string_view obj_c_runtime_name_as_string(void) const;
  bool has_definition(void) const;
  bool is_non_runtime_protocol(void) const;
  std::vector<Token> protocol_tokens(void) const;
  std::vector<ObjCProtocolDecl> protocols(void) const;
};

using ObjCInterfaceDeclRange = DerivedEntityRange<DeclIterator, ObjCInterfaceDecl>;
using ObjCInterfaceDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCInterfaceDecl>;
using ObjCInterfaceDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCInterfaceDecl>;

class ObjCInterfaceDecl : public ObjCContainerDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCInterfaceDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCInterfaceDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCInterfaceDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_INTERFACE;
  }

  static ObjCInterfaceDeclContainingDeclRange containing(const Decl &decl);
  static ObjCInterfaceDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCInterfaceDecl> from(const TokenContext &c);
  static std::optional<ObjCInterfaceDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCInterfaceDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCInterfaceDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCInterfaceDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCInterfaceDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCInterfaceDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCInterfaceDecl> from(const Decl &parent);

  inline static std::optional<ObjCInterfaceDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCInterfaceDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<ObjCProtocolDecl> all_referenced_protocols(void) const;
  bool declares_or_inherits_designated_initializers(void) const;
  Token end_of_definition_token(void) const;
  ObjCImplementationDecl implementation(void) const;
  std::string_view obj_c_runtime_name_as_string(void) const;
  std::optional<ObjCInterfaceDecl> super_class(void) const;
  Token super_class_token(void) const;
  std::optional<Type> super_class_type(void) const;
  Type type_for_declaration(void) const;
  bool has_definition(void) const;
  bool has_designated_initializers(void) const;
  bool is_arc_weakref_unavailable(void) const;
  bool is_implicit_interface_declaration(void) const;
  ObjCInterfaceDecl is_obj_c_requires_property_definitions(void) const;
  std::vector<ObjCIvarDecl> instance_variables(void) const;
  std::vector<ObjCCategoryDecl> known_categories(void) const;
  std::vector<ObjCCategoryDecl> known_extensions(void) const;
  std::vector<Token> protocol_tokens(void) const;
  std::vector<ObjCProtocolDecl> protocols(void) const;
  std::vector<ObjCCategoryDecl> visible_categories(void) const;
  std::vector<ObjCCategoryDecl> visible_extensions(void) const;
};

using ObjCImplDeclRange = DerivedEntityRange<DeclIterator, ObjCImplDecl>;
using ObjCImplDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCImplDecl>;
using ObjCImplDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCImplDecl>;

class ObjCImplDecl : public ObjCContainerDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCImplDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCImplDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCImplDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_IMPL;
  }

  static ObjCImplDeclContainingDeclRange containing(const Decl &decl);
  static ObjCImplDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCImplDecl> from(const TokenContext &c);
  static std::optional<ObjCImplDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCImplDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCImplDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCImplDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCImplDecl> from(const Decl &parent);

  inline static std::optional<ObjCImplDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCInterfaceDecl class_interface(void) const;
  std::vector<ObjCPropertyImplDecl> property_implementations(void) const;
};

using ObjCCategoryImplDeclRange = DerivedEntityRange<DeclIterator, ObjCCategoryImplDecl>;
using ObjCCategoryImplDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCCategoryImplDecl>;
using ObjCCategoryImplDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCCategoryImplDecl>;

class ObjCCategoryImplDecl : public ObjCImplDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCImplDecl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCCategoryImplDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCCategoryImplDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCCategoryImplDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_CATEGORY_IMPL;
  }

  static ObjCCategoryImplDeclContainingDeclRange containing(const Decl &decl);
  static ObjCCategoryImplDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCCategoryImplDecl> from(const TokenContext &c);
  static std::optional<ObjCCategoryImplDecl> from(const ObjCImplDecl &parent);

  inline static std::optional<ObjCCategoryImplDecl> from(const std::optional<ObjCImplDecl> &parent) {
    if (parent) {
      return ObjCCategoryImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCategoryImplDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCCategoryImplDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCCategoryImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCategoryImplDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCCategoryImplDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCCategoryImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCategoryImplDecl> from(const Decl &parent);

  inline static std::optional<ObjCCategoryImplDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCCategoryImplDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCCategoryDecl category_declaration(void) const;
  Token category_name_token(void) const;
};

using ObjCImplementationDeclRange = DerivedEntityRange<DeclIterator, ObjCImplementationDecl>;
using ObjCImplementationDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCImplementationDecl>;
using ObjCImplementationDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCImplementationDecl>;

class ObjCImplementationDecl : public ObjCImplDecl {
 private:
  friend class FragmentImpl;
  friend class ObjCImplDecl;
  friend class ObjCContainerDecl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCImplementationDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCImplementationDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCImplementationDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_IMPLEMENTATION;
  }

  static ObjCImplementationDeclContainingDeclRange containing(const Decl &decl);
  static ObjCImplementationDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCImplementationDecl> from(const TokenContext &c);
  static std::optional<ObjCImplementationDecl> from(const ObjCImplDecl &parent);

  inline static std::optional<ObjCImplementationDecl> from(const std::optional<ObjCImplDecl> &parent) {
    if (parent) {
      return ObjCImplementationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCImplementationDecl> from(const ObjCContainerDecl &parent);

  inline static std::optional<ObjCImplementationDecl> from(const std::optional<ObjCContainerDecl> &parent) {
    if (parent) {
      return ObjCImplementationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCImplementationDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCImplementationDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCImplementationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCImplementationDecl> from(const Decl &parent);

  inline static std::optional<ObjCImplementationDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCImplementationDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token instance_variable_l_brace_token(void) const;
  Token instance_variable_r_brace_token(void) const;
  std::string_view obj_c_runtime_name_as_string(void) const;
  ObjCInterfaceDecl super_class(void) const;
  Token super_class_token(void) const;
  bool has_destructors(void) const;
  bool has_non_zero_constructors(void) const;
  std::vector<ObjCIvarDecl> instance_variables(void) const;
};

using ObjCCompatibleAliasDeclRange = DerivedEntityRange<DeclIterator, ObjCCompatibleAliasDecl>;
using ObjCCompatibleAliasDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ObjCCompatibleAliasDecl>;
using ObjCCompatibleAliasDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ObjCCompatibleAliasDecl>;

class ObjCCompatibleAliasDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static ObjCCompatibleAliasDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ObjCCompatibleAliasDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ObjCCompatibleAliasDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::OBJ_C_COMPATIBLE_ALIAS;
  }

  static ObjCCompatibleAliasDeclContainingDeclRange containing(const Decl &decl);
  static ObjCCompatibleAliasDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ObjCCompatibleAliasDecl> from(const TokenContext &c);
  static std::optional<ObjCCompatibleAliasDecl> from(const NamedDecl &parent);

  inline static std::optional<ObjCCompatibleAliasDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return ObjCCompatibleAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<ObjCCompatibleAliasDecl> from(const Decl &parent);

  inline static std::optional<ObjCCompatibleAliasDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ObjCCompatibleAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  ObjCInterfaceDecl class_interface(void) const;
};

using NamespaceDeclRange = DerivedEntityRange<DeclIterator, NamespaceDecl>;
using NamespaceDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, NamespaceDecl>;
using NamespaceDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, NamespaceDecl>;

class NamespaceDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static NamespaceDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NamespaceDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NamespaceDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::NAMESPACE;
  }

  static NamespaceDeclContainingDeclRange containing(const Decl &decl);
  static NamespaceDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NamespaceDecl> from(const TokenContext &c);
  static std::optional<NamespaceDecl> from(const NamedDecl &parent);

  inline static std::optional<NamespaceDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return NamespaceDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NamespaceDecl> from(const Decl &parent);

  inline static std::optional<NamespaceDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return NamespaceDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations_in_context(void) const;
};

using NamespaceAliasDeclRange = DerivedEntityRange<DeclIterator, NamespaceAliasDecl>;
using NamespaceAliasDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, NamespaceAliasDecl>;
using NamespaceAliasDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, NamespaceAliasDecl>;

class NamespaceAliasDecl : public NamedDecl {
 private:
  friend class FragmentImpl;
  friend class NamedDecl;
  friend class Decl;
 public:
  inline static NamespaceAliasDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static NamespaceAliasDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : NamespaceAliasDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::NAMESPACE_ALIAS;
  }

  static NamespaceAliasDeclContainingDeclRange containing(const Decl &decl);
  static NamespaceAliasDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<NamespaceAliasDecl> from(const TokenContext &c);
  static std::optional<NamespaceAliasDecl> from(const NamedDecl &parent);

  inline static std::optional<NamespaceAliasDecl> from(const std::optional<NamedDecl> &parent) {
    if (parent) {
      return NamespaceAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  static std::optional<NamespaceAliasDecl> from(const Decl &parent);

  inline static std::optional<NamespaceAliasDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return NamespaceAliasDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token alias_token(void) const;
  NamedDecl aliased_namespace(void) const;
  Token namespace_token(void) const;
  Token target_name_token(void) const;
};

using LinkageSpecDeclRange = DerivedEntityRange<DeclIterator, LinkageSpecDecl>;
using LinkageSpecDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, LinkageSpecDecl>;
using LinkageSpecDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, LinkageSpecDecl>;

class LinkageSpecDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static LinkageSpecDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LinkageSpecDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LinkageSpecDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::LINKAGE_SPEC;
  }

  static LinkageSpecDeclContainingDeclRange containing(const Decl &decl);
  static LinkageSpecDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<LinkageSpecDecl> from(const TokenContext &c);
  static std::optional<LinkageSpecDecl> from(const Decl &parent);

  inline static std::optional<LinkageSpecDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return LinkageSpecDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations_in_context(void) const;
};

using LifetimeExtendedTemporaryDeclRange = DerivedEntityRange<DeclIterator, LifetimeExtendedTemporaryDecl>;
using LifetimeExtendedTemporaryDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, LifetimeExtendedTemporaryDecl>;
using LifetimeExtendedTemporaryDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, LifetimeExtendedTemporaryDecl>;

class LifetimeExtendedTemporaryDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static LifetimeExtendedTemporaryDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static LifetimeExtendedTemporaryDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : LifetimeExtendedTemporaryDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::LIFETIME_EXTENDED_TEMPORARY;
  }

  static LifetimeExtendedTemporaryDeclContainingDeclRange containing(const Decl &decl);
  static LifetimeExtendedTemporaryDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<LifetimeExtendedTemporaryDecl> from(const TokenContext &c);
  static std::optional<LifetimeExtendedTemporaryDecl> from(const Decl &parent);

  inline static std::optional<LifetimeExtendedTemporaryDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return LifetimeExtendedTemporaryDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Stmt> children_expression(void) const;
  ValueDecl extending_declaration(void) const;
  StorageDuration storage_duration(void) const;
  Expr temporary_expression(void) const;
};

using ImportDeclRange = DerivedEntityRange<DeclIterator, ImportDecl>;
using ImportDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ImportDecl>;
using ImportDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ImportDecl>;

class ImportDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static ImportDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ImportDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ImportDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::IMPORT;
  }

  static ImportDeclContainingDeclRange containing(const Decl &decl);
  static ImportDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ImportDecl> from(const TokenContext &c);
  static std::optional<ImportDecl> from(const Decl &parent);

  inline static std::optional<ImportDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ImportDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Token> identifier_tokens(void) const;
};

using FriendTemplateDeclRange = DerivedEntityRange<DeclIterator, FriendTemplateDecl>;
using FriendTemplateDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FriendTemplateDecl>;
using FriendTemplateDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FriendTemplateDecl>;

class FriendTemplateDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static FriendTemplateDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FriendTemplateDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FriendTemplateDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FRIEND_TEMPLATE;
  }

  static FriendTemplateDeclContainingDeclRange containing(const Decl &decl);
  static FriendTemplateDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FriendTemplateDecl> from(const TokenContext &c);
  static std::optional<FriendTemplateDecl> from(const Decl &parent);

  inline static std::optional<FriendTemplateDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FriendTemplateDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

using FriendDeclRange = DerivedEntityRange<DeclIterator, FriendDecl>;
using FriendDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FriendDecl>;
using FriendDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FriendDecl>;

class FriendDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static FriendDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FriendDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FriendDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FRIEND;
  }

  static FriendDeclContainingDeclRange containing(const Decl &decl);
  static FriendDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FriendDecl> from(const TokenContext &c);
  static std::optional<FriendDecl> from(const Decl &parent);

  inline static std::optional<FriendDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FriendDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::optional<NamedDecl> friend_declaration(void) const;
  Token friend_token(void) const;
  std::optional<Type> friend_type(void) const;
  bool is_unsupported_friend(void) const;
  std::vector<TemplateParameterList> friend_type_template_parameter_lists(void) const;
};

using FileScopeAsmDeclRange = DerivedEntityRange<DeclIterator, FileScopeAsmDecl>;
using FileScopeAsmDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, FileScopeAsmDecl>;
using FileScopeAsmDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, FileScopeAsmDecl>;

class FileScopeAsmDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static FileScopeAsmDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static FileScopeAsmDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : FileScopeAsmDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::FILE_SCOPE_ASM;
  }

  static FileScopeAsmDeclContainingDeclRange containing(const Decl &decl);
  static FileScopeAsmDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<FileScopeAsmDecl> from(const TokenContext &c);
  static std::optional<FileScopeAsmDecl> from(const Decl &parent);

  inline static std::optional<FileScopeAsmDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return FileScopeAsmDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token assembly_token(void) const;
  StringLiteral assembly_string(void) const;
  Token r_paren_token(void) const;
};

using ExternCContextDeclRange = DerivedEntityRange<DeclIterator, ExternCContextDecl>;
using ExternCContextDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExternCContextDecl>;
using ExternCContextDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ExternCContextDecl>;

class ExternCContextDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static ExternCContextDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExternCContextDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExternCContextDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::EXTERN_C_CONTEXT;
  }

  static ExternCContextDeclContainingDeclRange containing(const Decl &decl);
  static ExternCContextDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExternCContextDecl> from(const TokenContext &c);
  static std::optional<ExternCContextDecl> from(const Decl &parent);

  inline static std::optional<ExternCContextDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ExternCContextDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  std::vector<Decl> declarations_in_context(void) const;
};

using ExportDeclRange = DerivedEntityRange<DeclIterator, ExportDecl>;
using ExportDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, ExportDecl>;
using ExportDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, ExportDecl>;

class ExportDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static ExportDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static ExportDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : ExportDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::EXPORT;
  }

  static ExportDeclContainingDeclRange containing(const Decl &decl);
  static ExportDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<ExportDecl> from(const TokenContext &c);
  static std::optional<ExportDecl> from(const Decl &parent);

  inline static std::optional<ExportDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return ExportDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

  Token export_token(void) const;
  Token r_brace_token(void) const;
  bool has_braces(void) const;
  std::vector<Decl> declarations_in_context(void) const;
};

using EmptyDeclRange = DerivedEntityRange<DeclIterator, EmptyDecl>;
using EmptyDeclContainingTokenRange = DerivedEntityRange<TokenContextIterator, EmptyDecl>;
using EmptyDeclContainingDeclRange = DerivedEntityRange<ParentDeclIteratorImpl<Decl>, EmptyDecl>;

class EmptyDecl : public Decl {
 private:
  friend class FragmentImpl;
  friend class Decl;
 public:
  inline static EmptyDeclRange in(const Fragment &frag) {
    return in_internal(frag);
  }

  inline static EmptyDeclContainingTokenRange containing(const Token &tok) {
    return TokenContextIterator(TokenContext::of(tok));
  }

  inline bool contains(const Token &tok) {
    for(auto &parent : EmptyDecl::containing(tok)) {
      if(parent.id() == id()) { return true; }
    }
    return false;
  }

  inline static constexpr DeclKind static_kind(void) {
    return DeclKind::EMPTY;
  }

  static EmptyDeclContainingDeclRange containing(const Decl &decl);
  static EmptyDeclContainingDeclRange containing(const Stmt &stmt);

  bool contains(const Decl &decl);
  bool contains(const Stmt &stmt);

  static std::optional<EmptyDecl> from(const TokenContext &c);
  static std::optional<EmptyDecl> from(const Decl &parent);

  inline static std::optional<EmptyDecl> from(const std::optional<Decl> &parent) {
    if (parent) {
      return EmptyDecl::from(parent.value());
    } else {
      return std::nullopt;
    }
  }

};

enum class DeclUseSelector : unsigned short {
  ACTING_DEFINITION,
  ALIASED_NAMESPACE,
  ANONYMOUS_DECLARATION_WITH_TYPEDEF_NAME,
  ANONYMOUS_FIELD,
  ARRAY_WITH_OBJECTS_METHOD,
  AS_CXX_RECORD_DECLARATION,
  AS_DECLARATION,
  AS_RECORD_DECLARATION,
  AS_TAG_DECLARATION,
  AT_INDEX_METHOD_DECLARATION,
  BLOCK_DECLARATION,
  BLOCK_MANGLING_CONTEXT_DECLARATION,
  BODY,
  BOXING_METHOD,
  CALL_OPERATOR,
  CALLEE_DECLARATION,
  CAPTURED_DECLARATION,
  CAPTURED_RECORD_DECLARATION,
  CATCH_PARAMETER_DECLARATION,
  CATEGORY_DECLARATION,
  CLASS_INTERFACE,
  CLASS_RECEIVER,
  COMMAND_DECLARATION,
  CONDITION_VARIABLE,
  CONSTANT_TARGET,
  CONSTRUCTED_BASE_CLASS,
  CONSTRUCTED_BASE_CLASS_SHADOW_DECLARATION,
  CONSTRUCTOR,
  CONTAINING_INTERFACE,
  CONTEXT_PARAMETER,
  CONVERSION_FUNCTION,
  CORRESPONDING_CONSTRUCTOR,
  DECLARATION,
  DECOMPOSED_DECLARATION,
  DESCRIBED_ALIAS_TEMPLATE,
  DESTRUCTOR,
  DICTIONARY_WITH_OBJECTS_METHOD,
  DIRECT_CALLEE,
  ENUM_DECLARATION,
  ERROR_DOMAIN,
  EXCEPTION_DECLARATION,
  EXCEPTION_SPEC_DECLARATION,
  EXCEPTION_SPEC_TEMPLATE,
  EXPLICIT_PROPERTY,
  EXTENDING_DECLARATION,
  FIELD,
  FIND_PROPERTY_DECLARATION,
  FIRST_QUALIFIER_FOUND_IN_SCOPE,
  FOUND_DECLARATION,
  FRIEND_DECLARATION,
  FUNCTION,
  FUNCTION_DECLARATION,
  GETTER_METHOD_DECLARATION,
  GUID_DECLARATION,
  HOLDING_VARIABLE,
  IMPLEMENTATION,
  IMPLICIT_PROPERTY_GETTER,
  IMPLICIT_PROPERTY_SETTER,
  INITIALIZED_FIELD_IN_UNION,
  INITIALIZING_DECLARATION,
  INSTANTIATED_FROM_MEMBER_CLASS,
  INSTANTIATED_FROM_MEMBER_ENUM,
  INSTANTIATED_FROM_MEMBER_FUNCTION,
  INSTANTIATED_FROM_MEMBER_TEMPLATE,
  INSTANTIATED_FROM_STATIC_DATA_MEMBER,
  INSTANTIATED_FROM_USING_DECLARATION,
  INTERFACE,
  INTERFACE_DECLARATION,
  INTRODUCER,
  IS_LOCAL_CLASS,
  IS_OBJ_C_REQUIRES_PROPERTY_DEFINITIONS,
  LABEL,
  LAMBDA_CALL_OPERATOR,
  LAMBDA_CLASS,
  LAMBDA_CONTEXT_DECLARATION,
  LIFETIME_EXTENDED_TEMPORARY_DECLARATION,
  LOOP_VARIABLE,
  MEMBER_DECLARATION,
  METHOD_DECLARATION,
  MOST_RECENT_CXX_RECORD_DECLARATION,
  NAMING_CLASS,
  NEXT_CLASS_CATEGORY,
  NEXT_INSTANCE_VARIABLE,
  NEXT_USING_SHADOW_DECLARATION,
  NOMINATED_BASE_CLASS,
  NOMINATED_BASE_CLASS_SHADOW_DECLARATION,
  NOMINATED_NAMESPACE_AS_WRITTEN,
  NON_CLOSURE_CONTEXT,
  NRVO_CANDIDATE,
  OPERATOR_DELETE,
  OPERATOR_NEW,
  OWNED_TAG_DECLARATION,
  PACK,
  PARAMETER,
  PARAMETER_PACK,
  PARENT,
  POINTEE_CXX_RECORD_DECLARATION,
  PROMISE_DECLARATION,
  PROPERTY_DECLARATION,
  PROPERTY_INSTANCE_VARIABLE_DECLARATION,
  PROTOCOL,
  RECEIVER_INTERFACE,
  RECORD_DECLARATION,
  REFERENCED_DECLARATION,
  REFERENCED_DECLARATION_OF_CALLEE,
  SELF_DECLARATION,
  SETTER_METHOD_DECLARATION,
  SINGLE_DECLARATION,
  SOURCE_BIT_FIELD,
  SPECIALIZATION,
  SUPER_CLASS,
  TARGET_CONSTRUCTOR,
  TARGET_DECLARATION,
  TARGET_UNION_FIELD,
  TEMPLATE_INSTANTIATION_PATTERN,
  TEMPLATED_DECLARATION,
  TYPE_CONSTRAINT_CONCEPT,
  TYPEDEF_NAME_FOR_ANONYMOUS_DECLARATION,
  UNDERLYING_DECLARATION,
  VARIABLE_DECLARATION,
};

inline static const char *EnumerationName(DeclUseSelector) {
  return "DeclUseSelector";
}

inline static constexpr unsigned NumEnumerators(DeclUseSelector) {
  return 120;
}

const char *EnumeratorName(DeclUseSelector);

enum class StmtUseSelector : unsigned short {
  ADDRESS_SPACE_EXPRESSION,
  ALIGNMENT,
  ALIGNMENT_EXPRESSION,
  ALLOCATE,
  ALLOCATOR,
  ARGUMENT,
  ARGUMENT_EXPRESSION,
  ARRAY_FILLER,
  ARRAY_SIZE,
  ASSEMBLY_STRING,
  ASSERT_EXPRESSION,
  ASSOCIATED_STATEMENT,
  BASE,
  BASE_EXPRESSION,
  BEGIN_STATEMENT,
  BEST_DYNAMIC_CLASS_TYPE_EXPRESSION,
  BINDING,
  BIT_WIDTH,
  BLOCK,
  BODY,
  CALCULATE_LAST_ITERATION,
  CALLEE,
  CAPTURED_STATEMENT,
  CATCH_BODY,
  CHOSEN_SUB_EXPRESSION,
  COLLECTION,
  COLUMN_EXPRESSION,
  COLUMN_INDEX,
  COMBINED_CONDITION,
  COMBINED_DISTANCE_CONDITION,
  COMBINED_ENSURE_UPPER_BOUND,
  COMBINED_INITIALIZER,
  COMBINED_LOWER_BOUND_VARIABLE,
  COMBINED_NEXT_LOWER_BOUND,
  COMBINED_NEXT_UPPER_BOUND,
  COMBINED_PARALLEL_FOR_IN_DISTANCE_CONDITION,
  COMBINED_UPPER_BOUND_VARIABLE,
  COMBINER,
  COMBINER_IN,
  COMBINER_OUT,
  COMMON,
  COMMON_EXPRESSION,
  COMPOUND_BODY,
  COMPOUND_STATEMENT_BODY,
  CONDITION,
  CONDITION_VARIABLE_DECLARATION_STATEMENT,
  CONFIG,
  CONSTRAINT_EXPRESSION,
  CONSTRUCT_EXPRESSION,
  CONTROLLING_EXPRESSION,
  COOKED_LITERAL,
  DEALLOCATE,
  DEFAULT_ARGUMENT,
  DIMENSION_EXPRESSION,
  DISTANCE_FUNC,
  DISTANCE_INCREMENT,
  ELEMENT,
  ELSE_,
  END_STATEMENT,
  ENSURE_UPPER_BOUND,
  EXCEPT_HANDLER,
  EXCEPTION_HANDLER,
  EXPRESSION,
  EXPRESSION_OPERAND,
  EXPRESSION_STATEMENT,
  FALLTHROUGH_HANDLER,
  FALSE_EXPRESSION,
  FILTER_EXPRESSION,
  FINAL_SUSPEND_STATEMENT,
  FINALLY_BODY,
  FINALLY_HANDLER,
  FINALLY_STATEMENT,
  FIRST_SWITCH_CASE,
  FUNCTION_NAME,
  GETTER_CXX_CONSTRUCTOR,
  HANDLER,
  HANDLER_BLOCK,
  IF_STATEMENT,
  IGNORE_CASTS,
  IGNORE_CONTAINERS,
  IGNORE_CONVERSION_OPERATOR_SINGLE_STEP,
  IGNORE_IMP_CASTS,
  IGNORE_IMPLICIT,
  IGNORE_IMPLICIT_AS_WRITTEN,
  IGNORE_PARENTHESES,
  IGNORE_PARENTHESIS_BASE_CASTS,
  IGNORE_PARENTHESIS_CASTS,
  IGNORE_PARENTHESIS_IMP_CASTS,
  IGNORE_PARENTHESIS_L_VALUE_CASTS,
  IGNORE_PARENTHESIS_NOOP_CASTS,
  IGNORE_UNLESS_SPELLED_IN_SOURCE,
  IMPLICIT_OBJECT_ARGUMENT,
  IN_CLASS_INITIALIZER,
  INCREMENT,
  INDEX,
  INDIRECT_EXPRESSION,
  INITIALIZER,
  INITIALIZER_EXPRESSION,
  INITIALIZER_ORIGINAL,
  INITIALIZER_PRIVATE,
  INITIALIZER_SUSPEND_STATEMENT,
  INNERMOST_CAPTURED_STATEMENT,
  INSTANCE_RECEIVER,
  IS_LAST_ITERATION_VARIABLE,
  ITERATION_VARIABLE,
  KEY_EXPRESSION,
  LAST_ITERATION,
  LENGTH,
  LHS,
  LOOP_STATEMENT,
  LOOP_VARIABLE_FUNC,
  LOOP_VARIABLE_REFERENCE,
  LOOP_VARIABLE_STATEMENT,
  LOWER_BOUND,
  LOWER_BOUND_VARIABLE,
  MAPPER_VARIABLE_REFERENCE,
  MAX,
  MAX_THREADS,
  MESSAGE,
  MIN,
  MIN_BLOCKS,
  NEXT_LOWER_BOUND,
  NEXT_SWITCH_CASE,
  NEXT_UPPER_BOUND,
  NOEXCEPT_EXPRESSION,
  NUM_BITS_EXPRESSION,
  NUM_ITERATIONS,
  OBJ_C_PROPERTY,
  OFFSET,
  OPAQUE_VALUE,
  OPERAND,
  OPERATOR_COAWAIT_LOOKUP,
  OPERATOR_DELETE_THIS_ARGUMENT,
  ORDER,
  ORDER_FAIL,
  PATTERN,
  PLACEHOLDER_TYPE_CONSTRAINT,
  POINTER,
  PRE_CONDITION,
  PRE_INITIALIZERS,
  PREV_ENSURE_UPPER_BOUND,
  PREV_LOWER_BOUND_VARIABLE,
  PREV_UPPER_BOUND_VARIABLE,
  PROMISE_CALL,
  PROMISE_DECLARATION_STATEMENT,
  QUERIED_EXPRESSION,
  RANGE_INITIALIZER,
  RANGE_STATEMENT,
  RAW_STATEMENT,
  READY_EXPRESSION,
  REDUCTION_REFERENCE,
  REFERENCE,
  REPLACEMENT,
  REQUIRES_CLAUSE,
  RESULT_DECLARATION,
  RESULT_EXPRESSION,
  RESUME_EXPRESSION,
  RETURN_STATEMENT,
  RETURN_STATEMENT_ON_ALLOC_FAILURE,
  RETURN_VALUE,
  RETURN_VALUE_INITIALIZER,
  RHS,
  ROW_EXPRESSION,
  ROW_INDEX,
  SCOPE,
  SEMANTIC_FORM,
  SETTER_CXX_ASSIGNMENT,
  SIMDLEN,
  SIZE_EXPRESSION,
  SOURCE_EXPRESSION,
  SRC_EXPRESSION,
  STATEMENT,
  STATEMENT_EXPRESSION_RESULT,
  STRIDE,
  STRIDE_VARIABLE,
  STRING,
  STRIP_LABEL_LIKE_STATEMENTS,
  STRUCTURED_BLOCK,
  SUB_EXPRESSION,
  SUB_EXPRESSION_AS_WRITTEN,
  SUB_STATEMENT,
  SUCCESS_VALUE,
  SUSPEND_EXPRESSION,
  SYNCH_BODY,
  SYNCH_EXPRESSION,
  SYNTACTIC_FORM,
  TARGET,
  TASK_REDUCTION_REFERENCE_EXPRESSION,
  TEMPORARY_EXPRESSION,
  THEN,
  THROW_EXPRESSION,
  TRAILING_REQUIRES_CLAUSE,
  TRANSFORMED_STATEMENT,
  TRUE_EXPRESSION,
  TRY_BLOCK,
  TRY_BODY,
  UNDERLYING_EXPRESSION,
  UNINSTANTIATED_DEFAULT_ARGUMENT,
  UPDATE_EXPRESSION,
  UPDATER,
  UPPER_BOUND_VARIABLE,
  V,
  VALUE,
  VALUE1,
  VALUE2,
  VARIANT_FUNC_REFERENCE,
  WEAK,
  X,
};

inline static const char *EnumerationName(StmtUseSelector) {
  return "StmtUseSelector";
}

inline static constexpr unsigned NumEnumerators(StmtUseSelector) {
  return 208;
}

const char *EnumeratorName(StmtUseSelector);

enum class TypeUseSelector : unsigned short {
  ALIASED_TYPE,
  ALIGNMENT_TYPE,
  ALLOCATED_TYPE,
  ARGUMENT_TYPE,
  ARRAY_ELEMENT_TYPE_NO_TYPE_QUALIFIED,
  AS_COMPLEX_INTEGER_TYPE,
  AS_OBJ_C_INTERFACE_POINTER_TYPE,
  AS_OBJ_C_INTERFACE_TYPE,
  AS_OBJ_C_QUALIFIED_CLASS_TYPE,
  AS_OBJ_C_QUALIFIED_ID_TYPE,
  AS_OBJ_C_QUALIFIED_INTERFACE_TYPE,
  AS_PLACEHOLDER_TYPE,
  AS_STRUCTURE_TYPE,
  AS_TYPE,
  AS_UNION_TYPE,
  ATOMIC_UNQUALIFIED_TYPE,
  BASE_TYPE,
  CALL_RESULT_TYPE,
  CALL_RETURN_TYPE,
  CANONICAL_TYPE,
  CAPTURED_VLA_TYPE,
  CAUGHT_TYPE,
  CLASS_,
  CLASS_RECEIVER,
  CLASS_RECEIVER_TYPE,
  COMPUTATION_LHS_TYPE,
  COMPUTATION_RESULT_TYPE,
  CONTAINED_AUTO_TYPE,
  CONTAINED_DEDUCED_TYPE,
  CONVERSION_TYPE,
  DECLARED_RETURN_TYPE,
  DEFAULT_ARGUMENT,
  DEFAULT_ARGUMENT_INFO,
  DEREF_TYPE,
  DEREF_TYPE_TOKEN,
  DESTROYED_TYPE,
  DESUGAR,
  DESUGARED_TYPE,
  ELEMENT_TYPE,
  ENCODED_TYPE,
  EQUIVALENT_TYPE,
  FRIEND_TYPE,
  FUNCTION_TYPE,
  IGNORE_PARENTHESES,
  INJECTED_SPECIALIZATION_TYPE,
  INJECTED_TST,
  INNER_TYPE,
  INTEGER_TYPE,
  INTERFACE,
  INTERFACE_TOKEN,
  INTERFACE_TYPE,
  LAMBDA_TYPE,
  LOCAL_UNQUALIFIED_TYPE,
  LOCALLY_UNQUALIFIED_SINGLE_STEP_DESUGARED_TYPE,
  MATCHING_C_TYPE,
  MATCHING_C_TYPE_TOKEN,
  MODIFIED_TYPE,
  NAMED_TYPE,
  NON_L_VALUE_EXPRESSION_TYPE,
  NON_PACK_EXPANSION_TYPE,
  NON_REFERENCE_TYPE,
  NULL_POINTER_TYPE,
  OBJECT_TYPE,
  ORIGINAL_TYPE,
  PARAMETER_TYPE,
  PARAMETER_TYPE_FOR_DECLARATION,
  PATTERN,
  POINTEE_OR_ARRAY_ELEMENT_TYPE,
  POINTEE_TYPE,
  POINTEE_TYPE_AS_WRITTEN,
  PROMOTION_TYPE,
  QUERIED_TYPE,
  RECEIVER_TYPE,
  REPLACED_PARAMETER,
  REPLACEMENT_TYPE,
  RESOLVED_TYPE,
  RETURN_TYPE,
  SCOPE_TYPE,
  SIGNATURE_AS_WRITTEN,
  SINGLE_STEP_DESUGARED_TYPE,
  STRIP_OBJ_C_KIND_OF_TYPE,
  STRIP_OBJ_C_KIND_OF_TYPE_AND_QUALIFIERS,
  SUPER_CLASS_TYPE,
  SUPER_RECEIVER_TYPE,
  SUPER_TYPE,
  SVE_ELEMENT_TYPE,
  THIS_OBJECT_TYPE,
  THIS_TYPE,
  TYPE,
  TYPE_AS_WRITTEN,
  TYPE_FOR_DECLARATION,
  TYPE_HINT,
  TYPE_HINT_TOKEN,
  TYPE_OF_ARGUMENT,
  TYPE_OPERAND,
  TYPE_OPERAND_SOURCE_INFO,
  TYPEDEF_TYPE,
  TYPEDEF_TYPE_TOKEN,
  UNDERLYING_TYPE,
  UNQUALIFIED_DESUGARED_TYPE,
  UNQUALIFIED_TYPE,
  VALUE_TYPE,
  WITH_CONST,
  WITH_RESTRICT,
  WITH_VOLATILE,
  WITHOUT_LOCAL_FAST_QUALIFIERS,
  WRITTEN_TYPE,
};

inline static const char *EnumerationName(TypeUseSelector) {
  return "TypeUseSelector";
}

inline static constexpr unsigned NumEnumerators(TypeUseSelector) {
  return 107;
}

const char *EnumeratorName(TypeUseSelector);

enum class TokenUseSelector : unsigned short {
  ACCESS_SPECIFIER_TOKEN,
  ACCESSOR_TOKEN,
  ALIAS_TOKEN,
  AMP_AMP_TOKEN,
  ASSEMBLY_TOKEN,
  AT_CATCH_TOKEN,
  AT_FINALLY_TOKEN,
  AT_START_TOKEN,
  AT_SYNCHRONIZED_TOKEN,
  AT_TOKEN,
  AT_TRY_TOKEN,
  ATTRIBUTE_TOKEN,
  BASE_TOKEN_END,
  BASE_TYPE_TOKEN,
  BREAK_TOKEN,
  BRIDGE_KEYWORD_TOKEN,
  BUILTIN_TOKEN,
  CAPTURE_DEFAULT_TOKEN,
  CARET_TOKEN,
  CASE_TOKEN,
  CATCH_TOKEN,
  CATEGORY_NAME_TOKEN,
  COAWAIT_TOKEN,
  COLON_COLON_TOKEN,
  COLON_TOKEN,
  CONTINUE_TOKEN,
  DECLARATOR_END_TOKEN,
  DEFAULT_ARGUMENT_TOKEN,
  DEFAULT_TOKEN,
  DESTROYED_TYPE_TOKEN,
  DO_TOKEN,
  DOT_TOKEN,
  ELLIPSIS_TOKEN,
  ELSE_TOKEN,
  END_OF_DEFINITION_TOKEN,
  ENUM_TOKEN,
  EQUAL_OR_COLON_TOKEN,
  EXCEPT_TOKEN,
  EXPORT_TOKEN,
  EXPRESSION_TOKEN,
  EXTERN_TOKEN,
  FIELD_TOKEN,
  FINALLY_TOKEN,
  FIRST_COLON_TOKEN,
  FIRST_INNER_TOKEN,
  FIRST_OUTER_TOKEN,
  FOR_TOKEN,
  FRIEND_TOKEN,
  GENERIC_TOKEN,
  GETTER_NAME_TOKEN,
  GOTO_TOKEN,
  IDENTIFIER_TOKEN,
  IF_TOKEN,
  INSTANCE_VARIABLE_L_BRACE_TOKEN,
  INSTANCE_VARIABLE_R_BRACE_TOKEN,
  ISA_MEMBER_TOKEN,
  ITERATOR_KW_TOKEN,
  KEYWORD_TOKEN,
  L_ANGLE_TOKEN,
  L_BRACE_TOKEN,
  L_BRACKET_TOKEN,
  L_PAREN_TOKEN,
  LABEL_TOKEN,
  LEAVE_TOKEN,
  LEFT_ANGLE_TOKEN,
  LEFT_BRACE_TOKEN,
  LEFT_BRACKET_TOKEN,
  LEFT_TOKEN,
  MEMBER_TOKEN,
  NAME_TOKEN,
  NAMESPACE_KEY_TOKEN,
  NAMESPACE_TOKEN,
  OPERATION_TOKEN,
  OPERATOR_TOKEN,
  PACK_TOKEN,
  PARAMETER_PACK_TOKEN,
  POINT_OF_INSTANTIATION,
  PROPERTY_INSTANCE_VARIABLE_DECLARATION_TOKEN,
  PROTOCOL_ID_TOKEN,
  QUESTION_TOKEN,
  R_ANGLE_TOKEN,
  R_BRACE_TOKEN,
  R_BRACKET_TOKEN,
  R_PAREN_TOKEN,
  RECEIVER_TOKEN,
  REQUIRES_KEYWORD_TOKEN,
  RETURN_TOKEN,
  RIGHT_ANGLE_TOKEN,
  RIGHT_BRACE_TOKEN,
  RIGHT_BRACKET_TOKEN,
  RIGHT_TOKEN,
  SECOND_COLON_TOKEN,
  SELECTOR_START_TOKEN,
  SEMI_TOKEN,
  SETTER_NAME_TOKEN,
  STAR_TOKEN,
  SUPER_CLASS_TOKEN,
  SUPER_TOKEN,
  SWITCH_TOKEN,
  TARGET_CALL_TOKEN,
  TARGET_NAME_TOKEN,
  TEMPLATE_KEYWORD_TOKEN,
  THROW_TOKEN,
  TILDE_TOKEN,
  TOKEN,
  TOKEN_TOKEN,
  TRY_TOKEN,
  TYPE_SPEC_END_TOKEN,
  TYPE_SPEC_START_TOKEN,
  TYPENAME_TOKEN,
  UD_SUFFIX_TOKEN,
  USED_TOKEN,
  USING_TOKEN,
  VARIANCE_TOKEN,
  WHILE_TOKEN,
};

inline static const char *EnumerationName(TokenUseSelector) {
  return "TokenUseSelector";
}

inline static constexpr unsigned NumEnumerators(TokenUseSelector) {
  return 115;
}

const char *EnumeratorName(TokenUseSelector);

enum class AttrUseSelector : unsigned short {
  DEFINING_ATTRIBUTE,
  EXTERNAL_SOURCE_SYMBOL_ATTRIBUTE,
  UNUSED_RESULT_ATTRIBUTE,
};

inline static const char *EnumerationName(AttrUseSelector) {
  return "AttrUseSelector";
}

inline static constexpr unsigned NumEnumerators(AttrUseSelector) {
  return 3;
}

const char *EnumeratorName(AttrUseSelector);

static_assert(sizeof(AlignValueAttr) == sizeof(Attr));

static_assert(sizeof(AliasAttr) == sizeof(Attr));

static_assert(sizeof(AbiTagAttr) == sizeof(Attr));

static_assert(sizeof(TypeAttr) == sizeof(Attr));

static_assert(sizeof(SPtrAttr) == sizeof(TypeAttr));

static_assert(sizeof(Ptr64Attr) == sizeof(TypeAttr));

static_assert(sizeof(Ptr32Attr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLPrivateAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLLocalAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLGlobalHostAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLGlobalDeviceAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLGlobalAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLGenericAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(OpenCLConstantAddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(ObjCKindOfAttr) == sizeof(TypeAttr));

static_assert(sizeof(ObjCInertUnsafeUnretainedAttr) == sizeof(TypeAttr));

static_assert(sizeof(ObjCGCAttr) == sizeof(TypeAttr));

static_assert(sizeof(NoDerefAttr) == sizeof(TypeAttr));

static_assert(sizeof(CmseNSCallAttr) == sizeof(TypeAttr));

static_assert(sizeof(BTFTypeTagAttr) == sizeof(TypeAttr));

static_assert(sizeof(ArmMveStrictPolymorphismAttr) == sizeof(TypeAttr));

static_assert(sizeof(AddressSpaceAttr) == sizeof(TypeAttr));

static_assert(sizeof(UPtrAttr) == sizeof(TypeAttr));

static_assert(sizeof(TypeNullableResultAttr) == sizeof(TypeAttr));

static_assert(sizeof(TypeNullableAttr) == sizeof(TypeAttr));

static_assert(sizeof(TypeNullUnspecifiedAttr) == sizeof(TypeAttr));

static_assert(sizeof(TypeNonNullAttr) == sizeof(TypeAttr));

static_assert(sizeof(ThreadAttr) == sizeof(Attr));

static_assert(sizeof(SwiftObjCMembersAttr) == sizeof(Attr));

static_assert(sizeof(StmtAttr) == sizeof(Attr));

static_assert(sizeof(OpenCLUnrollHintAttr) == sizeof(StmtAttr));

static_assert(sizeof(MustTailAttr) == sizeof(StmtAttr));

static_assert(sizeof(LikelyAttr) == sizeof(StmtAttr));

static_assert(sizeof(FallThroughAttr) == sizeof(StmtAttr));

static_assert(sizeof(UnlikelyAttr) == sizeof(StmtAttr));

static_assert(sizeof(SuppressAttr) == sizeof(StmtAttr));

static_assert(sizeof(RenderScriptKernelAttr) == sizeof(Attr));

static_assert(sizeof(OverloadableAttr) == sizeof(Attr));

static_assert(sizeof(OpenCLAccessAttr) == sizeof(Attr));

static_assert(sizeof(ObjCRuntimeVisibleAttr) == sizeof(Attr));

static_assert(sizeof(ObjCRuntimeNameAttr) == sizeof(Attr));

static_assert(sizeof(ObjCNonRuntimeProtocolAttr) == sizeof(Attr));

static_assert(sizeof(ObjCNonLazyClassAttr) == sizeof(Attr));

static_assert(sizeof(ObjCDirectMembersAttr) == sizeof(Attr));

static_assert(sizeof(ObjCDirectAttr) == sizeof(Attr));

static_assert(sizeof(ObjCDesignatedInitializerAttr) == sizeof(Attr));

static_assert(sizeof(ObjCClassStubAttr) == sizeof(Attr));

static_assert(sizeof(ObjCBoxableAttr) == sizeof(Attr));

static_assert(sizeof(OMPReferencedVarAttr) == sizeof(Attr));

static_assert(sizeof(OMPDeclareSimdDeclAttr) == sizeof(Attr));

static_assert(sizeof(OMPCaptureKindAttr) == sizeof(Attr));

static_assert(sizeof(NoEscapeAttr) == sizeof(Attr));

static_assert(sizeof(NoBuiltinAttr) == sizeof(Attr));

static_assert(sizeof(ModeAttr) == sizeof(Attr));

static_assert(sizeof(LoopHintAttr) == sizeof(Attr));

static_assert(sizeof(LoaderUninitializedAttr) == sizeof(Attr));

static_assert(sizeof(InitSegAttr) == sizeof(Attr));

static_assert(sizeof(InheritableAttr) == sizeof(Attr));

static_assert(sizeof(IBOutletCollectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(IBOutletAttr) == sizeof(InheritableAttr));

static_assert(sizeof(IBActionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(HotAttr) == sizeof(InheritableAttr));

static_assert(sizeof(HIPManagedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(GuardedVarAttr) == sizeof(InheritableAttr));

static_assert(sizeof(GuardedByAttr) == sizeof(InheritableAttr));

static_assert(sizeof(GNUInlineAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FormatAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FormatArgAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FlattenAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FlagEnumAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FinalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(FastCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ExternalSourceSymbolAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ExclusiveTrylockFunctionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ExcludeFromExplicitInstantiationAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ErrorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(EnumExtensibilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(EnforceTCBLeafAttr) == sizeof(InheritableAttr));

static_assert(sizeof(EnforceTCBAttr) == sizeof(InheritableAttr));

static_assert(sizeof(EnableIfAttr) == sizeof(InheritableAttr));

static_assert(sizeof(EmptyBasesAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DisableTailCallsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DisableSanitizerInstrumentationAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DiagnoseIfAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DiagnoseAsBuiltinAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DestructorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DeprecatedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DeclOrStmtAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoMergeAttr) == sizeof(DeclOrStmtAttr));

static_assert(sizeof(DLLImportStaticLocalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DLLImportAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DLLExportStaticLocalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(DLLExportAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConvergentAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConsumableSetOnReadAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConsumableAutoCastAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConsumableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConstructorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConstInitAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ConstAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CommonAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ColdAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CodeSegAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CmseNSEntryAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CleanupAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CapturedRecordAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CallbackAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CallableWhenAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CXX11NoReturnAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDASharedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDALaunchBoundsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDAInvalidTargetAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDAHostAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDAGlobalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDADeviceBuiltinTextureTypeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDADeviceBuiltinSurfaceTypeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDADeviceAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CUDAConstantAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CPUSpecificAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CPUDispatchAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFUnknownTransferAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFReturnsRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFReturnsNotRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFICanonicalJumpTableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFGuardAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CFAuditedTransferAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CDeclAttr) == sizeof(InheritableAttr));

static_assert(sizeof(C11NoReturnAttr) == sizeof(InheritableAttr));

static_assert(sizeof(BuiltinAttr) == sizeof(InheritableAttr));

static_assert(sizeof(BlocksAttr) == sizeof(InheritableAttr));

static_assert(sizeof(BTFDeclTagAttr) == sizeof(InheritableAttr));

static_assert(sizeof(BPFPreserveAccessIndexAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AvailabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AssumptionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AssumeAlignedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AssertSharedLockAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AssertExclusiveLockAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AssertCapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AsmLabelAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ArtificialAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ArmBuiltinAliasAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ArgumentWithTypeTagAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ArcWeakrefUnavailableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AnyX86NoCfCheckAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AnyX86NoCallerSavedRegistersAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AnyX86InterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AnalyzerNoReturnAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AlwaysInlineAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AlwaysDestroyAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AllocSizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AllocAlignAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AlignedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AlignNaturalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AlignMac68kAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AcquiredBeforeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AcquiredAfterAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AcquireHandleAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AcquireCapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AVRSignalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AVRInterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ARMInterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AMDGPUWavesPerEUAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AMDGPUNumVGPRAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AMDGPUNumSGPRAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AMDGPUFlatWorkGroupSizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(AArch64VectorPcsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(XRayLogArgsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(XRayInstrumentAttr) == sizeof(InheritableAttr));

static_assert(sizeof(X86ForceAlignArgPointerAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WorkGroupSizeHintAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WebAssemblyImportNameAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WebAssemblyImportModuleAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WebAssemblyExportNameAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WeakRefAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WeakImportAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WeakAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WarnUnusedResultAttr) == sizeof(InheritableAttr));

static_assert(sizeof(WarnUnusedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(VisibilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(VectorCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(VecTypeHintAttr) == sizeof(InheritableAttr));

static_assert(sizeof(VecReturnAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UuidAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UsingIfExistsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UsedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UnusedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UninitializedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(UnavailableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TypeVisibilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TypeTagForDatatypeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TryAcquireCapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TrivialABIAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TransparentUnionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ThisCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TestTypestateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TargetClonesAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TargetAttr) == sizeof(InheritableAttr));

static_assert(sizeof(TLSModelAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SysVABIAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftPrivateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftNewTypeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftNameAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftErrorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftBridgedTypedefAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftBridgeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftAttrAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftAsyncNameAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftAsyncErrorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftAsyncCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SwiftAsyncAttr) == sizeof(InheritableAttr));

static_assert(sizeof(StrictFPAttr) == sizeof(InheritableAttr));

static_assert(sizeof(StdCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(StandaloneDebugAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SpeculativeLoadHardeningAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SharedTrylockFunctionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SetTypestateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SentinelAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SelectAnyAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ScopedLockableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SYCLSpecialClassAttr) == sizeof(InheritableAttr));

static_assert(sizeof(SYCLKernelAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReturnsTwiceAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReturnsNonNullAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReturnTypestateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(RetainAttr) == sizeof(InheritableAttr));

static_assert(sizeof(RestrictAttr) == sizeof(InheritableAttr));

static_assert(sizeof(RequiresCapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReqdWorkGroupSizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReleaseCapabilityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ReinitializesAttr) == sizeof(InheritableAttr));

static_assert(sizeof(RegCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(RISCVInterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PureAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PtGuardedVarAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PtGuardedByAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PreserveMostAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PreserveAllAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PreferredNameAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PragmaClangTextSectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PragmaClangRodataSectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PragmaClangRelroSectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PragmaClangDataSectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PragmaClangBSSSectionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PointerAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PcsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PatchableFunctionEntryAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PascalAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ParamTypestateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(PackedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OwnershipAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OwnerAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OverrideAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OptimizeNoneAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OpenCLKernelAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OpenCLIntelReqdSubGroupSizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCSubclassingRestrictedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCRootClassAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCReturnsInnerPointerAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCRequiresSuperAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCRequiresPropertyDefsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCPreciseLifetimeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCOwnershipAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCNSObjectAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCMethodFamilyAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCIndependentClassAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCExternallyRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCExplicitProtocolImplAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCExceptionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCBridgeRelatedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCBridgeMutableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(ObjCBridgeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OSReturnsRetainedOnZeroAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OSReturnsRetainedOnNonZeroAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OSReturnsRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OSReturnsNotRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OSConsumesThisAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OMPThreadPrivateDeclAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OMPDeclareVariantAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OMPDeclareTargetDeclAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OMPCaptureNoInitAttr) == sizeof(InheritableAttr));

static_assert(sizeof(OMPAllocateDeclAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NotTailCalledAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoUniqueAddressAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoThrowAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoThreadSafetyAnalysisAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoStackProtectorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoSplitStackAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoSpeculativeLoadHardeningAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoSanitizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoReturnAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoProfileFunctionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoMips16Attr) == sizeof(InheritableAttr));

static_assert(sizeof(NoMicroMipsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoInstrumentFunctionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoInlineAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoDuplicateAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoDestroyAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoDebugAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoCommonAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NoAliasAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NakedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NSReturnsRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NSReturnsNotRetainedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NSReturnsAutoreleasedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NSErrorDomainAttr) == sizeof(InheritableAttr));

static_assert(sizeof(NSConsumesSelfAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MipsShortCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MipsLongCallAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MipsInterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(Mips16Attr) == sizeof(InheritableAttr));

static_assert(sizeof(MinVectorWidthAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MinSizeAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MicroMipsAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MayAliasAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MaxFieldAlignmentAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSVtorDispAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSStructAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSP430InterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSNoVTableAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSInheritanceAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSAllocatorAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MSABIAttr) == sizeof(InheritableAttr));

static_assert(sizeof(MIGServerRoutineAttr) == sizeof(InheritableAttr));

static_assert(sizeof(M68kInterruptAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LocksExcludedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LockReturnedAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LifetimeBoundAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LeafAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LayoutVersionAttr) == sizeof(InheritableAttr));

static_assert(sizeof(LTOVisibilityPublicAttr) == sizeof(InheritableAttr));

static_assert(sizeof(InternalLinkageAttr) == sizeof(InheritableAttr));

static_assert(sizeof(IntelOclBiccAttr) == sizeof(InheritableAttr));

static_assert(sizeof(InitPriorityAttr) == sizeof(InheritableAttr));

static_assert(sizeof(InheritableParamAttr) == sizeof(InheritableAttr));

static_assert(sizeof(CarriesDependencyAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(CFConsumedAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(AnnotateAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(UseHandleAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(ReleaseHandleAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(PassObjectSizeAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(ParameterABIAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(SwiftIndirectResultAttr) == sizeof(ParameterABIAttr));

static_assert(sizeof(SwiftErrorResultAttr) == sizeof(ParameterABIAttr));

static_assert(sizeof(SwiftContextAttr) == sizeof(ParameterABIAttr));

static_assert(sizeof(SwiftAsyncContextAttr) == sizeof(ParameterABIAttr));

static_assert(sizeof(OSConsumedAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(NonNullAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(NSConsumedAttr) == sizeof(InheritableParamAttr));

static_assert(sizeof(IFuncAttr) == sizeof(Attr));

static_assert(sizeof(CalledOnceAttr) == sizeof(Attr));

static_assert(sizeof(BuiltinAliasAttr) == sizeof(Attr));

static_assert(sizeof(TemplateTypeParmType) == sizeof(Type));

static_assert(sizeof(TemplateSpecializationType) == sizeof(Type));

static_assert(sizeof(TagType) == sizeof(Type));

static_assert(sizeof(RecordType) == sizeof(TagType));

static_assert(sizeof(EnumType) == sizeof(TagType));

static_assert(sizeof(SubstTemplateTypeParmType) == sizeof(Type));

static_assert(sizeof(SubstTemplateTypeParmPackType) == sizeof(Type));

static_assert(sizeof(ReferenceType) == sizeof(Type));

static_assert(sizeof(RValueReferenceType) == sizeof(ReferenceType));

static_assert(sizeof(LValueReferenceType) == sizeof(ReferenceType));

static_assert(sizeof(PointerType) == sizeof(Type));

static_assert(sizeof(PipeType) == sizeof(Type));

static_assert(sizeof(ParenType) == sizeof(Type));

static_assert(sizeof(PackExpansionType) == sizeof(Type));

static_assert(sizeof(ObjCTypeParamType) == sizeof(Type));

static_assert(sizeof(ObjCObjectType) == sizeof(Type));

static_assert(sizeof(ObjCInterfaceType) == sizeof(ObjCObjectType));

static_assert(sizeof(ObjCObjectPointerType) == sizeof(Type));

static_assert(sizeof(MemberPointerType) == sizeof(Type));

static_assert(sizeof(MatrixType) == sizeof(Type));

static_assert(sizeof(DependentSizedMatrixType) == sizeof(MatrixType));

static_assert(sizeof(ConstantMatrixType) == sizeof(MatrixType));

static_assert(sizeof(MacroQualifiedType) == sizeof(Type));

static_assert(sizeof(InjectedClassNameType) == sizeof(Type));

static_assert(sizeof(FunctionType) == sizeof(Type));

static_assert(sizeof(FunctionProtoType) == sizeof(FunctionType));

static_assert(sizeof(FunctionNoProtoType) == sizeof(FunctionType));

static_assert(sizeof(DependentVectorType) == sizeof(Type));

static_assert(sizeof(DependentSizedExtVectorType) == sizeof(Type));

static_assert(sizeof(DependentBitIntType) == sizeof(Type));

static_assert(sizeof(DependentAddressSpaceType) == sizeof(Type));

static_assert(sizeof(DeducedType) == sizeof(Type));

static_assert(sizeof(DeducedTemplateSpecializationType) == sizeof(DeducedType));

static_assert(sizeof(AutoType) == sizeof(DeducedType));

static_assert(sizeof(DecltypeType) == sizeof(Type));

static_assert(sizeof(ComplexType) == sizeof(Type));

static_assert(sizeof(BuiltinType) == sizeof(Type));

static_assert(sizeof(BlockPointerType) == sizeof(Type));

static_assert(sizeof(BitIntType) == sizeof(Type));

static_assert(sizeof(AttributedType) == sizeof(Type));

static_assert(sizeof(AtomicType) == sizeof(Type));

static_assert(sizeof(ArrayType) == sizeof(Type));

static_assert(sizeof(VariableArrayType) == sizeof(ArrayType));

static_assert(sizeof(IncompleteArrayType) == sizeof(ArrayType));

static_assert(sizeof(DependentSizedArrayType) == sizeof(ArrayType));

static_assert(sizeof(ConstantArrayType) == sizeof(ArrayType));

static_assert(sizeof(AdjustedType) == sizeof(Type));

static_assert(sizeof(DecayedType) == sizeof(AdjustedType));

static_assert(sizeof(TypeWithKeyword) == sizeof(Type));

static_assert(sizeof(ElaboratedType) == sizeof(TypeWithKeyword));

static_assert(sizeof(DependentTemplateSpecializationType) == sizeof(TypeWithKeyword));

static_assert(sizeof(DependentNameType) == sizeof(TypeWithKeyword));

static_assert(sizeof(VectorType) == sizeof(Type));

static_assert(sizeof(ExtVectorType) == sizeof(VectorType));

static_assert(sizeof(UsingType) == sizeof(Type));

static_assert(sizeof(UnresolvedUsingType) == sizeof(Type));

static_assert(sizeof(UnaryTransformType) == sizeof(Type));

static_assert(sizeof(TypedefType) == sizeof(Type));

static_assert(sizeof(TypeOfType) == sizeof(Type));

static_assert(sizeof(TypeOfExprType) == sizeof(Type));

static_assert(sizeof(SEHTryStmt) == sizeof(Stmt));

static_assert(sizeof(SEHLeaveStmt) == sizeof(Stmt));

static_assert(sizeof(SEHFinallyStmt) == sizeof(Stmt));

static_assert(sizeof(SEHExceptStmt) == sizeof(Stmt));

static_assert(sizeof(ReturnStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCForCollectionStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAutoreleasePoolStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAtTryStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAtThrowStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAtSynchronizedStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAtFinallyStmt) == sizeof(Stmt));

static_assert(sizeof(ObjCAtCatchStmt) == sizeof(Stmt));

static_assert(sizeof(OMPExecutableDirective) == sizeof(Stmt));

static_assert(sizeof(OMPDispatchDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPDepobjDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPCriticalDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPCancellationPointDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPCancelDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPBarrierDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPAtomicDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTeamsDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTaskyieldDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTaskwaitDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTaskgroupDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTaskDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetUpdateDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetTeamsDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetParallelDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetExitDataDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetEnterDataDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPTargetDataDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPSingleDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPSectionsDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPSectionDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPScanDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPParallelSectionsDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPParallelMasterDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPParallelDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPOrderedDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPMetaDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPMasterDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPMaskedDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPLoopBasedDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPLoopTransformationDirective) == sizeof(OMPLoopBasedDirective));

static_assert(sizeof(OMPUnrollDirective) == sizeof(OMPLoopTransformationDirective));

static_assert(sizeof(OMPTileDirective) == sizeof(OMPLoopTransformationDirective));

static_assert(sizeof(OMPLoopDirective) == sizeof(OMPLoopBasedDirective));

static_assert(sizeof(OMPGenericLoopDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPDistributeSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPDistributeParallelForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPDistributeParallelForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPDistributeDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTeamsDistributeSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTeamsDistributeParallelForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTeamsDistributeParallelForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTeamsDistributeDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTaskLoopSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTaskLoopDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetTeamsDistributeSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetTeamsDistributeParallelForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetTeamsDistributeParallelForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetTeamsDistributeDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetParallelForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPTargetParallelForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPParallelMasterTaskLoopSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPParallelMasterTaskLoopDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPParallelForSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPParallelForDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPMasterTaskLoopSimdDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPMasterTaskLoopDirective) == sizeof(OMPLoopDirective));

static_assert(sizeof(OMPInteropDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPFlushDirective) == sizeof(OMPExecutableDirective));

static_assert(sizeof(OMPCanonicalLoop) == sizeof(Stmt));

static_assert(sizeof(NullStmt) == sizeof(Stmt));

static_assert(sizeof(MSDependentExistsStmt) == sizeof(Stmt));

static_assert(sizeof(IndirectGotoStmt) == sizeof(Stmt));

static_assert(sizeof(IfStmt) == sizeof(Stmt));

static_assert(sizeof(GotoStmt) == sizeof(Stmt));

static_assert(sizeof(ForStmt) == sizeof(Stmt));

static_assert(sizeof(DoStmt) == sizeof(Stmt));

static_assert(sizeof(DeclStmt) == sizeof(Stmt));

static_assert(sizeof(CoroutineBodyStmt) == sizeof(Stmt));

static_assert(sizeof(CoreturnStmt) == sizeof(Stmt));

static_assert(sizeof(ContinueStmt) == sizeof(Stmt));

static_assert(sizeof(CompoundStmt) == sizeof(Stmt));

static_assert(sizeof(CapturedStmt) == sizeof(Stmt));

static_assert(sizeof(CXXTryStmt) == sizeof(Stmt));

static_assert(sizeof(CXXForRangeStmt) == sizeof(Stmt));

static_assert(sizeof(CXXCatchStmt) == sizeof(Stmt));

static_assert(sizeof(BreakStmt) == sizeof(Stmt));

static_assert(sizeof(AsmStmt) == sizeof(Stmt));

static_assert(sizeof(MSAsmStmt) == sizeof(AsmStmt));

static_assert(sizeof(GCCAsmStmt) == sizeof(AsmStmt));

static_assert(sizeof(WhileStmt) == sizeof(Stmt));

static_assert(sizeof(ValueStmt) == sizeof(Stmt));

static_assert(sizeof(LabelStmt) == sizeof(ValueStmt));

static_assert(sizeof(Expr) == sizeof(ValueStmt));

static_assert(sizeof(DesignatedInitUpdateExpr) == sizeof(Expr));

static_assert(sizeof(DesignatedInitExpr) == sizeof(Expr));

static_assert(sizeof(DependentScopeDeclRefExpr) == sizeof(Expr));

static_assert(sizeof(DependentCoawaitExpr) == sizeof(Expr));

static_assert(sizeof(DeclRefExpr) == sizeof(Expr));

static_assert(sizeof(CoroutineSuspendExpr) == sizeof(Expr));

static_assert(sizeof(CoawaitExpr) == sizeof(CoroutineSuspendExpr));

static_assert(sizeof(CoyieldExpr) == sizeof(CoroutineSuspendExpr));

static_assert(sizeof(ConvertVectorExpr) == sizeof(Expr));

static_assert(sizeof(ConceptSpecializationExpr) == sizeof(Expr));

static_assert(sizeof(CompoundLiteralExpr) == sizeof(Expr));

static_assert(sizeof(ChooseExpr) == sizeof(Expr));

static_assert(sizeof(CharacterLiteral) == sizeof(Expr));

static_assert(sizeof(CastExpr) == sizeof(Expr));

static_assert(sizeof(ImplicitCastExpr) == sizeof(CastExpr));

static_assert(sizeof(ExplicitCastExpr) == sizeof(CastExpr));

static_assert(sizeof(CXXNamedCastExpr) == sizeof(ExplicitCastExpr));

static_assert(sizeof(CXXDynamicCastExpr) == sizeof(CXXNamedCastExpr));

static_assert(sizeof(CXXConstCastExpr) == sizeof(CXXNamedCastExpr));

static_assert(sizeof(CXXAddrspaceCastExpr) == sizeof(CXXNamedCastExpr));

static_assert(sizeof(CXXStaticCastExpr) == sizeof(CXXNamedCastExpr));

static_assert(sizeof(CXXReinterpretCastExpr) == sizeof(CXXNamedCastExpr));

static_assert(sizeof(CXXFunctionalCastExpr) == sizeof(ExplicitCastExpr));

static_assert(sizeof(CStyleCastExpr) == sizeof(ExplicitCastExpr));

static_assert(sizeof(BuiltinBitCastExpr) == sizeof(ExplicitCastExpr));

static_assert(sizeof(ObjCBridgedCastExpr) == sizeof(ExplicitCastExpr));

static_assert(sizeof(CallExpr) == sizeof(Expr));

static_assert(sizeof(CXXOperatorCallExpr) == sizeof(CallExpr));

static_assert(sizeof(CXXMemberCallExpr) == sizeof(CallExpr));

static_assert(sizeof(CUDAKernelCallExpr) == sizeof(CallExpr));

static_assert(sizeof(UserDefinedLiteral) == sizeof(CallExpr));

static_assert(sizeof(CXXUuidofExpr) == sizeof(Expr));

static_assert(sizeof(CXXUnresolvedConstructExpr) == sizeof(Expr));

static_assert(sizeof(CXXTypeidExpr) == sizeof(Expr));

static_assert(sizeof(CXXThrowExpr) == sizeof(Expr));

static_assert(sizeof(CXXThisExpr) == sizeof(Expr));

static_assert(sizeof(CXXStdInitializerListExpr) == sizeof(Expr));

static_assert(sizeof(CXXScalarValueInitExpr) == sizeof(Expr));

static_assert(sizeof(CXXRewrittenBinaryOperator) == sizeof(Expr));

static_assert(sizeof(CXXPseudoDestructorExpr) == sizeof(Expr));

static_assert(sizeof(CXXNullPtrLiteralExpr) == sizeof(Expr));

static_assert(sizeof(CXXNoexceptExpr) == sizeof(Expr));

static_assert(sizeof(CXXNewExpr) == sizeof(Expr));

static_assert(sizeof(CXXInheritedCtorInitExpr) == sizeof(Expr));

static_assert(sizeof(CXXFoldExpr) == sizeof(Expr));

static_assert(sizeof(CXXDependentScopeMemberExpr) == sizeof(Expr));

static_assert(sizeof(CXXDeleteExpr) == sizeof(Expr));

static_assert(sizeof(CXXDefaultInitExpr) == sizeof(Expr));

static_assert(sizeof(CXXDefaultArgExpr) == sizeof(Expr));

static_assert(sizeof(CXXConstructExpr) == sizeof(Expr));

static_assert(sizeof(CXXTemporaryObjectExpr) == sizeof(CXXConstructExpr));

static_assert(sizeof(CXXBoolLiteralExpr) == sizeof(Expr));

static_assert(sizeof(CXXBindTemporaryExpr) == sizeof(Expr));

static_assert(sizeof(BlockExpr) == sizeof(Expr));

static_assert(sizeof(BinaryOperator) == sizeof(Expr));

static_assert(sizeof(CompoundAssignOperator) == sizeof(BinaryOperator));

static_assert(sizeof(AtomicExpr) == sizeof(Expr));

static_assert(sizeof(AsTypeExpr) == sizeof(Expr));

static_assert(sizeof(ArrayTypeTraitExpr) == sizeof(Expr));

static_assert(sizeof(ArraySubscriptExpr) == sizeof(Expr));

static_assert(sizeof(ArrayInitLoopExpr) == sizeof(Expr));

static_assert(sizeof(ArrayInitIndexExpr) == sizeof(Expr));

static_assert(sizeof(AddrLabelExpr) == sizeof(Expr));

static_assert(sizeof(AbstractConditionalOperator) == sizeof(Expr));

static_assert(sizeof(ConditionalOperator) == sizeof(AbstractConditionalOperator));

static_assert(sizeof(BinaryConditionalOperator) == sizeof(AbstractConditionalOperator));

static_assert(sizeof(VAArgExpr) == sizeof(Expr));

static_assert(sizeof(UnaryOperator) == sizeof(Expr));

static_assert(sizeof(UnaryExprOrTypeTraitExpr) == sizeof(Expr));

static_assert(sizeof(TypoExpr) == sizeof(Expr));

static_assert(sizeof(TypeTraitExpr) == sizeof(Expr));

static_assert(sizeof(SubstNonTypeTemplateParmPackExpr) == sizeof(Expr));

static_assert(sizeof(SubstNonTypeTemplateParmExpr) == sizeof(Expr));

static_assert(sizeof(StringLiteral) == sizeof(Expr));

static_assert(sizeof(StmtExpr) == sizeof(Expr));

static_assert(sizeof(SourceLocExpr) == sizeof(Expr));

static_assert(sizeof(SizeOfPackExpr) == sizeof(Expr));

static_assert(sizeof(ShuffleVectorExpr) == sizeof(Expr));

static_assert(sizeof(SYCLUniqueStableNameExpr) == sizeof(Expr));

static_assert(sizeof(RequiresExpr) == sizeof(Expr));

static_assert(sizeof(RecoveryExpr) == sizeof(Expr));

static_assert(sizeof(PseudoObjectExpr) == sizeof(Expr));

static_assert(sizeof(PredefinedExpr) == sizeof(Expr));

static_assert(sizeof(ParenListExpr) == sizeof(Expr));

static_assert(sizeof(ParenExpr) == sizeof(Expr));

static_assert(sizeof(PackExpansionExpr) == sizeof(Expr));

static_assert(sizeof(OverloadExpr) == sizeof(Expr));

static_assert(sizeof(UnresolvedMemberExpr) == sizeof(OverloadExpr));

static_assert(sizeof(UnresolvedLookupExpr) == sizeof(OverloadExpr));

static_assert(sizeof(OpaqueValueExpr) == sizeof(Expr));

static_assert(sizeof(OffsetOfExpr) == sizeof(Expr));

static_assert(sizeof(ObjCSubscriptRefExpr) == sizeof(Expr));

static_assert(sizeof(ObjCStringLiteral) == sizeof(Expr));

static_assert(sizeof(ObjCSelectorExpr) == sizeof(Expr));

static_assert(sizeof(ObjCProtocolExpr) == sizeof(Expr));

static_assert(sizeof(ObjCPropertyRefExpr) == sizeof(Expr));

static_assert(sizeof(ObjCMessageExpr) == sizeof(Expr));

static_assert(sizeof(ObjCIvarRefExpr) == sizeof(Expr));

static_assert(sizeof(ObjCIsaExpr) == sizeof(Expr));

static_assert(sizeof(ObjCIndirectCopyRestoreExpr) == sizeof(Expr));

static_assert(sizeof(ObjCEncodeExpr) == sizeof(Expr));

static_assert(sizeof(ObjCDictionaryLiteral) == sizeof(Expr));

static_assert(sizeof(ObjCBoxedExpr) == sizeof(Expr));

static_assert(sizeof(ObjCBoolLiteralExpr) == sizeof(Expr));

static_assert(sizeof(ObjCAvailabilityCheckExpr) == sizeof(Expr));

static_assert(sizeof(ObjCArrayLiteral) == sizeof(Expr));

static_assert(sizeof(OMPIteratorExpr) == sizeof(Expr));

static_assert(sizeof(OMPArrayShapingExpr) == sizeof(Expr));

static_assert(sizeof(OMPArraySectionExpr) == sizeof(Expr));

static_assert(sizeof(NoInitExpr) == sizeof(Expr));

static_assert(sizeof(MemberExpr) == sizeof(Expr));

static_assert(sizeof(MatrixSubscriptExpr) == sizeof(Expr));

static_assert(sizeof(MaterializeTemporaryExpr) == sizeof(Expr));

static_assert(sizeof(MSPropertySubscriptExpr) == sizeof(Expr));

static_assert(sizeof(MSPropertyRefExpr) == sizeof(Expr));

static_assert(sizeof(LambdaExpr) == sizeof(Expr));

static_assert(sizeof(IntegerLiteral) == sizeof(Expr));

static_assert(sizeof(InitListExpr) == sizeof(Expr));

static_assert(sizeof(ImplicitValueInitExpr) == sizeof(Expr));

static_assert(sizeof(ImaginaryLiteral) == sizeof(Expr));

static_assert(sizeof(GenericSelectionExpr) == sizeof(Expr));

static_assert(sizeof(GNUNullExpr) == sizeof(Expr));

static_assert(sizeof(FunctionParmPackExpr) == sizeof(Expr));

static_assert(sizeof(FullExpr) == sizeof(Expr));

static_assert(sizeof(ExprWithCleanups) == sizeof(FullExpr));

static_assert(sizeof(ConstantExpr) == sizeof(FullExpr));

static_assert(sizeof(FloatingLiteral) == sizeof(Expr));

static_assert(sizeof(FixedPointLiteral) == sizeof(Expr));

static_assert(sizeof(ExtVectorElementExpr) == sizeof(Expr));

static_assert(sizeof(ExpressionTraitExpr) == sizeof(Expr));

static_assert(sizeof(AttributedStmt) == sizeof(ValueStmt));

static_assert(sizeof(SwitchStmt) == sizeof(Stmt));

static_assert(sizeof(SwitchCase) == sizeof(Stmt));

static_assert(sizeof(DefaultStmt) == sizeof(SwitchCase));

static_assert(sizeof(CaseStmt) == sizeof(SwitchCase));

static_assert(sizeof(ClassScopeFunctionSpecializationDecl) == sizeof(Decl));

static_assert(sizeof(CapturedDecl) == sizeof(Decl));

static_assert(sizeof(BlockDecl) == sizeof(Decl));

static_assert(sizeof(AccessSpecDecl) == sizeof(Decl));

static_assert(sizeof(OMPDeclarativeDirectiveDecl) == sizeof(Decl));

static_assert(sizeof(OMPThreadPrivateDecl) == sizeof(OMPDeclarativeDirectiveDecl));

static_assert(sizeof(OMPRequiresDecl) == sizeof(OMPDeclarativeDirectiveDecl));

static_assert(sizeof(OMPAllocateDecl) == sizeof(OMPDeclarativeDirectiveDecl));

static_assert(sizeof(TranslationUnitDecl) == sizeof(Decl));

static_assert(sizeof(StaticAssertDecl) == sizeof(Decl));

static_assert(sizeof(RequiresExprBodyDecl) == sizeof(Decl));

static_assert(sizeof(PragmaDetectMismatchDecl) == sizeof(Decl));

static_assert(sizeof(PragmaCommentDecl) == sizeof(Decl));

static_assert(sizeof(ObjCPropertyImplDecl) == sizeof(Decl));

static_assert(sizeof(NamedDecl) == sizeof(Decl));

static_assert(sizeof(LabelDecl) == sizeof(NamedDecl));

static_assert(sizeof(BaseUsingDecl) == sizeof(NamedDecl));

static_assert(sizeof(UsingEnumDecl) == sizeof(BaseUsingDecl));

static_assert(sizeof(UsingDecl) == sizeof(BaseUsingDecl));

static_assert(sizeof(ValueDecl) == sizeof(NamedDecl));

static_assert(sizeof(UnresolvedUsingValueDecl) == sizeof(ValueDecl));

static_assert(sizeof(TemplateParamObjectDecl) == sizeof(ValueDecl));

static_assert(sizeof(OMPDeclareReductionDecl) == sizeof(ValueDecl));

static_assert(sizeof(MSGuidDecl) == sizeof(ValueDecl));

static_assert(sizeof(IndirectFieldDecl) == sizeof(ValueDecl));

static_assert(sizeof(EnumConstantDecl) == sizeof(ValueDecl));

static_assert(sizeof(DeclaratorDecl) == sizeof(ValueDecl));

static_assert(sizeof(VarDecl) == sizeof(DeclaratorDecl));

static_assert(sizeof(ParmVarDecl) == sizeof(VarDecl));

static_assert(sizeof(OMPCapturedExprDecl) == sizeof(VarDecl));

static_assert(sizeof(ImplicitParamDecl) == sizeof(VarDecl));

static_assert(sizeof(DecompositionDecl) == sizeof(VarDecl));

static_assert(sizeof(VarTemplateSpecializationDecl) == sizeof(VarDecl));

static_assert(sizeof(VarTemplatePartialSpecializationDecl) == sizeof(VarTemplateSpecializationDecl));

static_assert(sizeof(NonTypeTemplateParmDecl) == sizeof(DeclaratorDecl));

static_assert(sizeof(MSPropertyDecl) == sizeof(DeclaratorDecl));

static_assert(sizeof(FunctionDecl) == sizeof(DeclaratorDecl));

static_assert(sizeof(CXXMethodDecl) == sizeof(FunctionDecl));

static_assert(sizeof(CXXDestructorDecl) == sizeof(CXXMethodDecl));

static_assert(sizeof(CXXConversionDecl) == sizeof(CXXMethodDecl));

static_assert(sizeof(CXXConstructorDecl) == sizeof(CXXMethodDecl));

static_assert(sizeof(CXXDeductionGuideDecl) == sizeof(FunctionDecl));

static_assert(sizeof(FieldDecl) == sizeof(DeclaratorDecl));

static_assert(sizeof(ObjCIvarDecl) == sizeof(FieldDecl));

static_assert(sizeof(ObjCAtDefsFieldDecl) == sizeof(FieldDecl));

static_assert(sizeof(BindingDecl) == sizeof(ValueDecl));

static_assert(sizeof(OMPDeclarativeDirectiveValueDecl) == sizeof(ValueDecl));

static_assert(sizeof(OMPDeclareMapperDecl) == sizeof(OMPDeclarativeDirectiveValueDecl));

static_assert(sizeof(UsingShadowDecl) == sizeof(NamedDecl));

static_assert(sizeof(ConstructorUsingShadowDecl) == sizeof(UsingShadowDecl));

static_assert(sizeof(UsingPackDecl) == sizeof(NamedDecl));

static_assert(sizeof(UsingDirectiveDecl) == sizeof(NamedDecl));

static_assert(sizeof(UnresolvedUsingIfExistsDecl) == sizeof(NamedDecl));

static_assert(sizeof(TypeDecl) == sizeof(NamedDecl));

static_assert(sizeof(TemplateTypeParmDecl) == sizeof(TypeDecl));

static_assert(sizeof(TagDecl) == sizeof(TypeDecl));

static_assert(sizeof(RecordDecl) == sizeof(TagDecl));

static_assert(sizeof(CXXRecordDecl) == sizeof(RecordDecl));

static_assert(sizeof(ClassTemplateSpecializationDecl) == sizeof(CXXRecordDecl));

static_assert(sizeof(ClassTemplatePartialSpecializationDecl) == sizeof(ClassTemplateSpecializationDecl));

static_assert(sizeof(EnumDecl) == sizeof(TagDecl));

static_assert(sizeof(UnresolvedUsingTypenameDecl) == sizeof(TypeDecl));

static_assert(sizeof(TypedefNameDecl) == sizeof(TypeDecl));

static_assert(sizeof(TypedefDecl) == sizeof(TypedefNameDecl));

static_assert(sizeof(TypeAliasDecl) == sizeof(TypedefNameDecl));

static_assert(sizeof(ObjCTypeParamDecl) == sizeof(TypedefNameDecl));

static_assert(sizeof(TemplateDecl) == sizeof(NamedDecl));

static_assert(sizeof(RedeclarableTemplateDecl) == sizeof(TemplateDecl));

static_assert(sizeof(FunctionTemplateDecl) == sizeof(RedeclarableTemplateDecl));

static_assert(sizeof(ClassTemplateDecl) == sizeof(RedeclarableTemplateDecl));

static_assert(sizeof(VarTemplateDecl) == sizeof(RedeclarableTemplateDecl));

static_assert(sizeof(TypeAliasTemplateDecl) == sizeof(RedeclarableTemplateDecl));

static_assert(sizeof(ConceptDecl) == sizeof(TemplateDecl));

static_assert(sizeof(BuiltinTemplateDecl) == sizeof(TemplateDecl));

static_assert(sizeof(TemplateTemplateParmDecl) == sizeof(TemplateDecl));

static_assert(sizeof(ObjCPropertyDecl) == sizeof(NamedDecl));

static_assert(sizeof(ObjCMethodDecl) == sizeof(NamedDecl));

static_assert(sizeof(ObjCContainerDecl) == sizeof(NamedDecl));

static_assert(sizeof(ObjCCategoryDecl) == sizeof(ObjCContainerDecl));

static_assert(sizeof(ObjCProtocolDecl) == sizeof(ObjCContainerDecl));

static_assert(sizeof(ObjCInterfaceDecl) == sizeof(ObjCContainerDecl));

static_assert(sizeof(ObjCImplDecl) == sizeof(ObjCContainerDecl));

static_assert(sizeof(ObjCCategoryImplDecl) == sizeof(ObjCImplDecl));

static_assert(sizeof(ObjCImplementationDecl) == sizeof(ObjCImplDecl));

static_assert(sizeof(ObjCCompatibleAliasDecl) == sizeof(NamedDecl));

static_assert(sizeof(NamespaceDecl) == sizeof(NamedDecl));

static_assert(sizeof(NamespaceAliasDecl) == sizeof(NamedDecl));

static_assert(sizeof(LinkageSpecDecl) == sizeof(Decl));

static_assert(sizeof(LifetimeExtendedTemporaryDecl) == sizeof(Decl));

static_assert(sizeof(ImportDecl) == sizeof(Decl));

static_assert(sizeof(FriendTemplateDecl) == sizeof(Decl));

static_assert(sizeof(FriendDecl) == sizeof(Decl));

static_assert(sizeof(FileScopeAsmDecl) == sizeof(Decl));

static_assert(sizeof(ExternCContextDecl) == sizeof(Decl));

static_assert(sizeof(ExportDecl) == sizeof(Decl));

static_assert(sizeof(EmptyDecl) == sizeof(Decl));

#endif
}  // namespace mx
